const e="import { useEffect, useCallback, useRef } from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useSessionStore, FullVisualizationState } from '@/stores/sessionStore';\nimport { useVisualizationStateStore } from '@/stores/visualizationStateStore';\nimport { GamePhase } from '@/contexts/TimelineContext';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { SimulationResult } from '@/lib/chess/gameSimulator';\n\ninterface PiecesState {\n  showPieces: boolean;\n  pieceOpacity: number;\n}\n\ninterface VisualizationContext {\n  visualizationId?: string;\n  shareId?: string;\n  pgn?: string;\n  title?: string;\n  simulation?: SimulationResult | null;\n  piecesState?: PiecesState;\n}\n\n/**\n * Master hook for unified visualization state management\n * Handles state capture on navigation away and restoration on return\n * Works across all entry points: Index, VisualizationView, MarketplaceVisionDetail\n */\nexport function useUnifiedVisualizationState(context: VisualizationContext = {}) {\n  const location = useLocation();\n  const navigate = useNavigate();\n  \n  // Session store for cross-page state\n  const {\n    pushVisualizationState,\n    popVisualizationState,\n    getVisualizationStateForRoute,\n    setCurrentSimulation,\n    setSavedShareId,\n    setCapturedTimelineState,\n    setReturningFromOrder,\n    currentSimulation: storedSimulation,\n    currentPgn: storedPgn,\n    currentGameTitle: storedTitle,\n    savedShareId: storedShareId,\n    capturedTimelineState: storedTimelineState,\n    returningFromOrder,\n    clearSimulation,\n    navigationStack,\n    pushRoute,\n  } = useSessionStore();\n  \n  // Visualization state store for granular state\n  const visualizationState = useVisualizationStateStore();\n  const {\n    currentMove,\n    selectedPhase,\n    lockedPieces,\n    compareMode,\n    displayMode,\n    darkMode,\n    showTerritory,\n    showHeatmaps,\n    showPieces,\n    pieceOpacity,\n    setCurrentMove,\n    setSelectedPhase,\n    setLockedPieces,\n    setCompareMode,\n    setDisplayMode,\n    setDarkMode,\n    setShowTerritory,\n    setShowHeatmaps,\n    setShowPieces,\n    setPieceOpacity,\n    restoreFromState,\n  } = visualizationState;\n  \n  const hasRestoredRef = useRef(false);\n  const currentRouteRef = useRef(location.pathname + location.search);\n  \n  // Build full state snapshot\n  const captureFullState = useCallback((): FullVisualizationState => {\n    const effectivePiecesState = context.piecesState || { showPieces, pieceOpacity };\n    \n    return {\n      currentMove,\n      selectedPhase: selectedPhase as GamePhase,\n      isPlaying: false,\n      lockedPieces: lockedPieces.map(p => ({\n        pieceType: p.pieceType as PieceType,\n        pieceColor: p.pieceColor as PieceColor,\n      })),\n      compareMode,\n      highlightedPiece: null,\n      displayMode,\n      darkMode,\n      showTerritory,\n      showHeatmaps,\n      showPieces: effectivePiecesState.showPieces,\n      pieceOpacity: effectivePiecesState.pieceOpacity,\n      capturedAt: Date.now(),\n      sourceRoute: location.pathname + location.search,\n      visualizationId: context.visualizationId,\n      pgn: context.pgn,\n    };\n  }, [\n    currentMove,\n    selectedPhase,\n    lockedPieces,\n    compareMode,\n    displayMode,\n    darkMode,\n    showTerritory,\n    showHeatmaps,\n    showPieces,\n    pieceOpacity,\n    context.piecesState,\n    context.visualizationId,\n    context.pgn,\n    location.pathname,\n    location.search,\n  ]);\n  \n  // Save state before navigating away\n  const saveStateBeforeNavigation = useCallback(() => {\n    const state = captureFullState();\n    pushVisualizationState(state);\n    \n    // Also save simulation context for full restoration\n    if (context.simulation) {\n      setCurrentSimulation(context.simulation, context.pgn || '', context.title || '');\n      if (context.shareId) {\n        setSavedShareId(context.shareId);\n      }\n    }\n  }, [\n    captureFullState,\n    pushVisualizationState,\n    setCurrentSimulation,\n    setSavedShareId,\n    context.simulation,\n    context.pgn,\n    context.title,\n    context.shareId,\n  ]);\n  \n  // Restore state from session (for back navigation)\n  const restoreState = useCallback((state: FullVisualizationState) => {\n    restoreFromState({\n      currentMove: state.currentMove,\n      selectedPhase: state.selectedPhase,\n      lockedPieces: state.lockedPieces,\n      compareMode: state.compareMode,\n      displayMode: state.displayMode,\n      darkMode: state.darkMode,\n      showTerritory: state.showTerritory,\n      showHeatmaps: state.showHeatmaps,\n      showPieces: state.showPieces,\n      pieceOpacity: state.pieceOpacity,\n    });\n  }, [restoreFromState]);\n  \n  // Check for saved state on mount\n  useEffect(() => {\n    if (hasRestoredRef.current) return;\n    \n    const currentFullRoute = location.pathname + location.search;\n    const savedState = getVisualizationStateForRoute(currentFullRoute);\n    \n    if (savedState) {\n      restoreState(savedState);\n      hasRestoredRef.current = true;\n    } else if (storedTimelineState && returningFromOrder) {\n      // Legacy restoration from order flow\n      setCurrentMove(storedTimelineState.currentMove);\n      setLockedPieces(storedTimelineState.lockedPieces);\n      setCompareMode(storedTimelineState.compareMode);\n      setDarkMode(storedTimelineState.darkMode);\n      setReturningFromOrder(false);\n      setCapturedTimelineState(null);\n      hasRestoredRef.current = true;\n    }\n  }, [\n    location.pathname,\n    location.search,\n    getVisualizationStateForRoute,\n    restoreState,\n    storedTimelineState,\n    returningFromOrder,\n    setCurrentMove,\n    setLockedPieces,\n    setCompareMode,\n    setDarkMode,\n    setReturningFromOrder,\n    setCapturedTimelineState,\n  ]);\n  \n  // Save state on unmount or route change\n  useEffect(() => {\n    const handleBeforeUnload = () => {\n      saveStateBeforeNavigation();\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    \n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      \n      // Save state when navigating away (component unmount)\n      const newRoute = window.location.pathname + window.location.search;\n      if (currentRouteRef.current !== newRoute) {\n        saveStateBeforeNavigation();\n      }\n    };\n  }, [saveStateBeforeNavigation]);\n  \n  // Update route ref\n  useEffect(() => {\n    currentRouteRef.current = location.pathname + location.search;\n  }, [location.pathname, location.search]);\n  \n  // Navigate with state preservation\n  const navigateWithState = useCallback((to: string) => {\n    saveStateBeforeNavigation();\n    pushRoute(location.pathname);\n    navigate(to);\n  }, [saveStateBeforeNavigation, pushRoute, navigate, location.pathname]);\n  \n  // Navigate back with state restoration\n  const navigateBack = useCallback(() => {\n    const savedState = popVisualizationState();\n    if (savedState) {\n      navigate(savedState.sourceRoute);\n    } else {\n      navigate(-1);\n    }\n  }, [popVisualizationState, navigate]);\n  \n  return {\n    // State\n    currentMove,\n    selectedPhase,\n    lockedPieces,\n    compareMode,\n    displayMode,\n    darkMode,\n    showTerritory,\n    showHeatmaps,\n    showPieces,\n    pieceOpacity,\n    \n    // State setters\n    setCurrentMove,\n    setSelectedPhase,\n    setLockedPieces,\n    setCompareMode,\n    setDisplayMode,\n    setDarkMode,\n    setShowTerritory,\n    setShowHeatmaps,\n    setShowPieces,\n    setPieceOpacity,\n    \n    // Navigation helpers\n    navigateWithState,\n    navigateBack,\n    saveStateBeforeNavigation,\n    \n    // Capture current state\n    captureFullState,\n    \n    // Session data for restoration\n    storedSimulation,\n    storedPgn,\n    storedTitle,\n    storedShareId,\n    returningFromOrder,\n    clearSimulation,\n  };\n}\n";export{e as default};
