const e="/**\n * Prediction Disagreement Tracker\n * \n * Identifies and analyzes cases where En Pensent's hybrid prediction\n * correctly predicted outcomes that Stockfish's evaluation missed.\n * \n * These are the most valuable data points - they prove the hybrid\n * approach adds value beyond pure tactical calculation.\n */\n\nimport { supabase } from '@/integrations/supabase/client';\n\n/**\n * Extract game date from PGN [Date] tag\n */\nfunction extractGameDateFromPgn(pgn: string | null): string | null {\n  if (!pgn) return null;\n  const match = pgn.match(/\\[Date\\s+\"(\\d{4}\\.\\d{2}\\.\\d{2})\"\\]/);\n  if (match) {\n    // Convert YYYY.MM.DD to ISO date format\n    return match[1].replace(/\\./g, '-');\n  }\n  return null;\n}\n\n/**\n * Format time control for display\n * Handles various formats from Lichess API (speed field)\n * v6.18: Also tries to infer from game context when time_control is null\n */\nexport function formatTimeControl(tc: string | null | undefined, gameName?: string): { label: string; color: string; icon: string } {\n  // v6.18: If tc is null/undefined, try to infer from game name ELO ranges\n  // High ELO games (2800+) on Lichess are usually bullet/blitz\n  if (!tc && gameName) {\n    // Extract ELO from game name like \"Player1 (2950) vs Player2 (3100)\"\n    const eloMatches = gameName.match(/\\((\\d{3,4})\\)/g);\n    if (eloMatches && eloMatches.length >= 1) {\n      const elos = eloMatches.map(m => parseInt(m.replace(/[()]/g, '')));\n      const avgElo = elos.reduce((a, b) => a + b, 0) / elos.length;\n      // Very high ELO (2800+) games on Lichess are almost always Bullet/Blitz\n      // This is a reasonable inference for GM games\n      if (avgElo >= 2800) {\n        return { label: 'Bullet/Blitz', color: 'text-orange-400', icon: '‚ö°' };\n      }\n      if (avgElo >= 2500) {\n        return { label: 'Rated', color: 'text-blue-400', icon: 'üéØ' };\n      }\n    }\n    // Fallback for games with names but unknown time control\n    return { label: 'Rated', color: 'text-muted-foreground', icon: '‚ôüÔ∏è' };\n  }\n  \n  if (!tc) {\n    return { label: 'Unknown', color: 'text-muted-foreground', icon: 'üéØ' };\n  }\n  \n  const normalized = tc.toLowerCase().trim();\n  \n  switch (normalized) {\n    case 'bullet':\n    case 'ultrabullet':\n    case 'hyperbullet':\n      return { label: 'Bullet', color: 'text-red-400', icon: '‚ö°' };\n    case 'blitz':\n      return { label: 'Blitz', color: 'text-orange-400', icon: 'üî•' };\n    case 'rapid':\n      return { label: 'Rapid', color: 'text-blue-400', icon: '‚è±Ô∏è' };\n    case 'classical':\n    case 'correspondence':\n    case 'standard':\n      return { label: 'Classical', color: 'text-green-400', icon: '‚ôüÔ∏è' };\n    default:\n      // If it looks like a time control string (e.g., \"3+0\", \"10+5\")\n      if (/^\\d+\\+?\\d*$/.test(normalized)) {\n        const baseTime = parseInt(normalized.split('+')[0]);\n        if (baseTime <= 2) return { label: 'Bullet', color: 'text-red-400', icon: '‚ö°' };\n        if (baseTime <= 5) return { label: 'Blitz', color: 'text-orange-400', icon: 'üî•' };\n        if (baseTime <= 15) return { label: 'Rapid', color: 'text-blue-400', icon: '‚è±Ô∏è' };\n        return { label: 'Classical', color: 'text-green-400', icon: '‚ôüÔ∏è' };\n      }\n      return { label: tc, color: 'text-muted-foreground', icon: 'üéØ' };\n  }\n}\n\nexport interface DisagreementCase {\n  id: string;\n  fen: string;\n  gameName: string;\n  moveNumber: number;\n  stockfishEval: number;\n  stockfishPrediction: string;\n  hybridPrediction: string;\n  actualResult: string;\n  hybridCorrect: boolean;\n  stockfishCorrect: boolean;\n  hybridArchetype: string | null;\n  hybridConfidence: number | null;\n  createdAt: string; // When we analyzed it\n  significance: 'breakthrough' | 'notable' | 'minor';\n  evalMagnitude: number; // How \"confident\" Stockfish was in wrong direction\n  // Game metadata\n  timeControl: string | null; // bullet, blitz, rapid, classical\n  whiteElo: number | null;\n  blackElo: number | null;\n  pgn: string | null; // Contains original game date\n  gameDate: string | null; // Extracted from PGN [Date] tag\n}\n\nexport interface DisagreementStats {\n  totalDisagreements: number;\n  hybridWinsDisagreements: number;\n  stockfishWinsDisagreements: number;\n  breakthroughCases: number;\n  averageStockfishConfidenceWhenWrong: number;\n  topArchetypesInDisagreements: { archetype: string; count: number; winRate: number }[];\n}\n\n/**\n * Fetch cases where hybrid and Stockfish disagreed\n */\nexport async function getDisagreementCases(limit = 50): Promise<DisagreementCase[]> {\n  const { data, error } = await supabase\n    .from('chess_prediction_attempts')\n    .select('*')\n    .neq('hybrid_prediction', 'stockfish_prediction') // They disagreed\n    .neq('stockfish_prediction', 'unknown') // Exclude corrupted legacy data\n    .order('created_at', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error('Error fetching disagreement cases:', error);\n    return [];\n  }\n\n  return (data || []).map(row => {\n    const stockfishEval = row.stockfish_eval || 0;\n    const evalMagnitude = Math.abs(stockfishEval);\n    \n    // Significance based on how wrong Stockfish was\n    let significance: 'breakthrough' | 'notable' | 'minor' = 'minor';\n    if (evalMagnitude > 200 && row.hybrid_correct && !row.stockfish_correct) {\n      significance = 'breakthrough'; // Stockfish was very confident but wrong\n    } else if (evalMagnitude > 100 && row.hybrid_correct && !row.stockfish_correct) {\n      significance = 'notable';\n    }\n\n    // Extract game date from PGN [Date] tag\n    const gameDate = extractGameDateFromPgn(row.pgn);\n\n    return {\n      id: row.id,\n      fen: row.fen,\n      gameName: row.game_name,\n      moveNumber: row.move_number,\n      stockfishEval: stockfishEval,\n      stockfishPrediction: row.stockfish_prediction,\n      hybridPrediction: row.hybrid_prediction,\n      actualResult: row.actual_result,\n      hybridCorrect: row.hybrid_correct,\n      stockfishCorrect: row.stockfish_correct,\n      hybridArchetype: row.hybrid_archetype,\n      hybridConfidence: row.hybrid_confidence,\n      createdAt: row.created_at,\n      significance,\n      evalMagnitude,\n      timeControl: row.time_control,\n      whiteElo: row.white_elo,\n      blackElo: row.black_elo,\n      pgn: row.pgn,\n      gameDate,\n    };\n  });\n}\n\n/**\n * Get cases where hybrid was RIGHT and Stockfish was WRONG\n */\nexport async function getHybridBreakthroughs(limit = 20): Promise<DisagreementCase[]> {\n  const { data, error } = await supabase\n    .from('chess_prediction_attempts')\n    .select('*')\n    .eq('hybrid_correct', true)\n    .eq('stockfish_correct', false)\n    .neq('stockfish_prediction', 'unknown') // Exclude corrupted legacy data\n    .order('created_at', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    console.error('Error fetching breakthroughs:', error);\n    return [];\n  }\n\n  return (data || []).map(row => {\n    const gameDate = extractGameDateFromPgn(row.pgn);\n    return {\n      id: row.id,\n      fen: row.fen,\n      gameName: row.game_name,\n      moveNumber: row.move_number,\n      stockfishEval: row.stockfish_eval || 0,\n      stockfishPrediction: row.stockfish_prediction,\n      hybridPrediction: row.hybrid_prediction,\n      actualResult: row.actual_result,\n      hybridCorrect: row.hybrid_correct,\n      stockfishCorrect: row.stockfish_correct,\n      hybridArchetype: row.hybrid_archetype,\n      hybridConfidence: row.hybrid_confidence,\n      createdAt: row.created_at,\n      significance: Math.abs(row.stockfish_eval || 0) > 200 ? 'breakthrough' as const : 'notable' as const,\n      evalMagnitude: Math.abs(row.stockfish_eval || 0),\n      timeControl: row.time_control,\n      whiteElo: row.white_elo,\n      blackElo: row.black_elo,\n      pgn: row.pgn,\n      gameDate,\n    };\n  });\n}\n\n/**\n * Calculate disagreement statistics\n * v7.26-AUDIT-FIX: Uses count queries to bypass 1000-row limit\n */\nexport async function getDisagreementStats(): Promise<DisagreementStats> {\n  // v7.26: Use count queries based on exclusive wins (hybrid correct + SF wrong, or vice versa)\n  // This is the actual definition of \"disagreement where one was right and one was wrong\"\n  const [\n    { count: hybridWinsCount },\n    { count: stockfishWinsCount },\n  ] = await Promise.all([\n    // Hybrid wins (hybrid correct AND stockfish wrong)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true)\n      .eq('stockfish_correct', false),\n    // Stockfish wins (stockfish correct AND hybrid wrong)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('stockfish_correct', true)\n      .eq('hybrid_correct', false),\n  ]);\n\n  // Get archetype data from a limited sample (for top archetypes)\n  const { data: archetypeSample } = await supabase\n    .from('chess_prediction_attempts')\n    .select('hybrid_archetype, hybrid_correct, stockfish_correct')\n    .neq('hybrid_prediction', 'stockfish_prediction')\n    .limit(1000);\n\n  // Get average stockfish confidence when hybrid wins\n  const { data: evalData } = await supabase\n    .from('chess_prediction_attempts')\n    .select('stockfish_eval')\n    .eq('hybrid_correct', true)\n    .eq('stockfish_correct', false)\n    .not('stockfish_eval', 'is', null)\n    .limit(1000);\n\n  const stockfishWrongEvals = (evalData || [])\n    .map(d => Math.abs(d.stockfish_eval || 0))\n    .filter(e => e > 0);\n  \n  const avgConfidence = stockfishWrongEvals.length > 0\n    ? stockfishWrongEvals.reduce((a, b) => a + b, 0) / stockfishWrongEvals.length\n    : 0;\n\n  // Archetype analysis from sample\n  const archetypeCounts: Record<string, { total: number; wins: number }> = {};\n  (archetypeSample || []).forEach(d => {\n    const arch = d.hybrid_archetype || 'unknown';\n    if (!archetypeCounts[arch]) {\n      archetypeCounts[arch] = { total: 0, wins: 0 };\n    }\n    archetypeCounts[arch].total++;\n    if (d.hybrid_correct) {\n      archetypeCounts[arch].wins++;\n    }\n  });\n\n  const topArchetypes = Object.entries(archetypeCounts)\n    .map(([archetype, stats]) => ({\n      archetype,\n      count: stats.total,\n      winRate: stats.total > 0 ? (stats.wins / stats.total) * 100 : 0,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 5);\n\n  // v7.26: Calculate actual disagreement count from exclusive wins\n  const actualDisagreements = (hybridWinsCount || 0) + (stockfishWinsCount || 0);\n  \n  console.log('[v7.26-DISAGREEMENT] Stats:', {\n    totalDisagreements: actualDisagreements,\n    hybridWins: hybridWinsCount,\n    sfWins: stockfishWinsCount,\n    winRate: actualDisagreements > 0 ? ((hybridWinsCount || 0) / actualDisagreements * 100).toFixed(1) : 0\n  });\n\n  return {\n    totalDisagreements: actualDisagreements,\n    hybridWinsDisagreements: hybridWinsCount || 0,\n    stockfishWinsDisagreements: stockfishWinsCount || 0,\n    breakthroughCases: hybridWinsCount || 0, // All hybrid exclusive wins are breakthroughs\n    averageStockfishConfidenceWhenWrong: avgConfidence,\n    topArchetypesInDisagreements: topArchetypes,\n  };\n}\n\n/**\n * Format eval for display (centipawns to pawns)\n */\nexport function formatEval(cp: number): string {\n  if (Math.abs(cp) > 10000) {\n    return cp > 0 ? 'M+' : 'M-';\n  }\n  const pawns = cp / 100;\n  return pawns >= 0 ? `+${pawns.toFixed(1)}` : pawns.toFixed(1);\n}\n\n/**\n * Get insight text for a disagreement case\n */\nexport function getDisagreementInsight(case_: DisagreementCase): string {\n  if (case_.hybridCorrect && !case_.stockfishCorrect) {\n    if (case_.evalMagnitude > 200) {\n      return `BREAKTHROUGH: Stockfish saw ${formatEval(case_.stockfishEval)} but the ${case_.hybridArchetype || 'pattern'} trajectory correctly predicted ${case_.actualResult}`;\n    }\n    return `Hybrid's ${case_.hybridArchetype || 'pattern'} analysis correctly overrode Stockfish's ${formatEval(case_.stockfishEval)} evaluation`;\n  }\n  if (case_.stockfishCorrect && !case_.hybridCorrect) {\n    return `Stockfish's tactical precision was correct here; hybrid pattern was misleading`;\n  }\n  return 'Both systems made the same prediction';\n}\n";export{e as default};
