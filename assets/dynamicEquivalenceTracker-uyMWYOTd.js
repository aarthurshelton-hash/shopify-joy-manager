const n="/**\n * Dynamic Equivalence Tracker\n * \n * Embodies the insight that the relationship between temporal patterns\n * and fundamental data structure is DYNAMIC, not static.\n * \n * The \"=\" in \"pattern = structure\" changes value over time.\n * Sometimes correlation IS causation, sometimes it isn't.\n * This module tracks WHEN that relationship holds true.\n */\n\ninterface EquivalenceState {\n  correlationStrength: number; // How strongly patterns correlate with outcomes\n  causationProbability: number; // Probability that correlation = causation\n  relationshipPhase: 'strong_equivalence' | 'weak_equivalence' | 'decorrelated' | 'inverse';\n  stability: number; // How stable the relationship is\n  transitionProbability: number; // Likelihood of phase change\n}\n\ninterface EquivalenceWindow {\n  startTime: number;\n  endTime: number;\n  phase: EquivalenceState['relationshipPhase'];\n  patternAccuracy: number;\n  fundamentalAccuracy: number;\n  combinedAccuracy: number;\n}\n\ninterface DynamicEquivalenceState {\n  currentState: EquivalenceState;\n  historicalWindows: EquivalenceWindow[];\n  optimalStrategy: 'trust_patterns' | 'trust_fundamentals' | 'blend' | 'contrarian';\n  blendWeights: { pattern: number; fundamental: number };\n  confidenceModifier: number;\n  insights: string[];\n}\n\nclass DynamicEquivalenceTracker {\n  private stateHistory: Array<{ timestamp: number; state: EquivalenceState }> = [];\n  private windowHistory: EquivalenceWindow[] = [];\n  private patternOutcomes: Array<{ timestamp: number; predicted: number; actual: number; source: 'pattern' }> = [];\n  private fundamentalOutcomes: Array<{ timestamp: number; predicted: number; actual: number; source: 'fundamental' }> = [];\n  \n  private readonly windowDurationMs = 3600000; // 1 hour windows\n  private readonly maxHistory = 1000;\n  private readonly learningRate = 0.1;\n  \n  // Dynamic blend weights - the core of the system\n  private patternWeight = 0.5;\n  private fundamentalWeight = 0.5;\n  \n  /**\n   * Record a pattern-based prediction outcome\n   */\n  recordPatternPrediction(predicted: number, actual: number): void {\n    this.patternOutcomes.push({\n      timestamp: Date.now(),\n      predicted,\n      actual,\n      source: 'pattern',\n    });\n    \n    if (this.patternOutcomes.length > this.maxHistory) {\n      this.patternOutcomes.shift();\n    }\n    \n    this.updateEquivalence();\n  }\n  \n  /**\n   * Record a fundamental-based prediction outcome\n   */\n  recordFundamentalPrediction(predicted: number, actual: number): void {\n    this.fundamentalOutcomes.push({\n      timestamp: Date.now(),\n      predicted,\n      actual,\n      source: 'fundamental',\n    });\n    \n    if (this.fundamentalOutcomes.length > this.maxHistory) {\n      this.fundamentalOutcomes.shift();\n    }\n    \n    this.updateEquivalence();\n  }\n  \n  /**\n   * Update the dynamic equivalence state\n   */\n  private updateEquivalence(): void {\n    const now = Date.now();\n    const windowStart = now - this.windowDurationMs;\n    \n    // Get recent outcomes\n    const recentPatterns = this.patternOutcomes.filter(o => o.timestamp > windowStart);\n    const recentFundamentals = this.fundamentalOutcomes.filter(o => o.timestamp > windowStart);\n    \n    if (recentPatterns.length < 5 && recentFundamentals.length < 5) return;\n    \n    // Calculate accuracies\n    const patternAccuracy = this.calculateAccuracy(recentPatterns);\n    const fundamentalAccuracy = this.calculateAccuracy(recentFundamentals);\n    \n    // Calculate correlation between pattern predictions and actual outcomes\n    const correlationStrength = this.calculateCorrelation(recentPatterns);\n    \n    // Determine if correlation = causation (patterns actually drive outcomes)\n    const causationProbability = this.estimateCausation(patternAccuracy, fundamentalAccuracy, correlationStrength);\n    \n    // Determine relationship phase\n    const relationshipPhase = this.determinePhase(patternAccuracy, fundamentalAccuracy, correlationStrength);\n    \n    // Calculate stability\n    const stability = this.calculateStability();\n    \n    // Calculate transition probability\n    const transitionProbability = this.calculateTransitionProbability(relationshipPhase, stability);\n    \n    const newState: EquivalenceState = {\n      correlationStrength,\n      causationProbability,\n      relationshipPhase,\n      stability,\n      transitionProbability,\n    };\n    \n    this.stateHistory.push({ timestamp: now, state: newState });\n    if (this.stateHistory.length > this.maxHistory) {\n      this.stateHistory.shift();\n    }\n    \n    // Update weights dynamically\n    this.updateWeights(patternAccuracy, fundamentalAccuracy, correlationStrength);\n    \n    // Record window\n    this.recordWindow(windowStart, now, relationshipPhase, patternAccuracy, fundamentalAccuracy);\n  }\n  \n  /**\n   * Calculate prediction accuracy\n   */\n  private calculateAccuracy(outcomes: Array<{ predicted: number; actual: number }>): number {\n    if (outcomes.length === 0) return 0.5;\n    \n    let correct = 0;\n    for (const outcome of outcomes) {\n      // Directional accuracy\n      if (Math.sign(outcome.predicted) === Math.sign(outcome.actual)) {\n        correct++;\n      }\n    }\n    \n    return correct / outcomes.length;\n  }\n  \n  /**\n   * Calculate correlation between predictions and actuals\n   */\n  private calculateCorrelation(outcomes: Array<{ predicted: number; actual: number }>): number {\n    if (outcomes.length < 3) return 0;\n    \n    const predictions = outcomes.map(o => o.predicted);\n    const actuals = outcomes.map(o => o.actual);\n    \n    const n = predictions.length;\n    let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;\n    \n    for (let i = 0; i < n; i++) {\n      sumXY += predictions[i] * actuals[i];\n      sumX += predictions[i];\n      sumY += actuals[i];\n      sumX2 += predictions[i] * predictions[i];\n      sumY2 += actuals[i] * actuals[i];\n    }\n    \n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n    \n    if (denominator === 0) return 0;\n    return numerator / denominator;\n  }\n  \n  /**\n   * Estimate probability that correlation = causation\n   */\n  private estimateCausation(\n    patternAccuracy: number,\n    fundamentalAccuracy: number,\n    correlation: number\n  ): number {\n    // High pattern accuracy + high correlation + low fundamental accuracy\n    // suggests patterns ARE causal\n    if (patternAccuracy > 0.6 && correlation > 0.5 && fundamentalAccuracy < 0.5) {\n      return Math.min(0.8, patternAccuracy * correlation);\n    }\n    \n    // Both accurate suggests shared underlying cause\n    if (patternAccuracy > 0.6 && fundamentalAccuracy > 0.6) {\n      return 0.5; // Equal probability\n    }\n    \n    // Low pattern accuracy despite high correlation = spurious\n    if (patternAccuracy < 0.5 && correlation > 0.3) {\n      return 0.2;\n    }\n    \n    return correlation * 0.5; // Conservative default\n  }\n  \n  /**\n   * Determine the current relationship phase\n   */\n  private determinePhase(\n    patternAccuracy: number,\n    fundamentalAccuracy: number,\n    correlation: number\n  ): EquivalenceState['relationshipPhase'] {\n    if (correlation > 0.6 && patternAccuracy > 0.6) {\n      return 'strong_equivalence';\n    }\n    \n    if (correlation > 0.3 && patternAccuracy > 0.5) {\n      return 'weak_equivalence';\n    }\n    \n    if (correlation < -0.3) {\n      return 'inverse';\n    }\n    \n    return 'decorrelated';\n  }\n  \n  /**\n   * Calculate stability of current phase\n   */\n  private calculateStability(): number {\n    if (this.stateHistory.length < 10) return 0.5;\n    \n    const recent = this.stateHistory.slice(-20);\n    const currentPhase = recent[recent.length - 1]?.state.relationshipPhase;\n    \n    if (!currentPhase) return 0.5;\n    \n    const samePhaseCount = recent.filter(s => s.state.relationshipPhase === currentPhase).length;\n    return samePhaseCount / recent.length;\n  }\n  \n  /**\n   * Calculate probability of phase transition\n   */\n  private calculateTransitionProbability(\n    currentPhase: EquivalenceState['relationshipPhase'],\n    stability: number\n  ): number {\n    // Low stability = high transition probability\n    const baseProb = 1 - stability;\n    \n    // Some phases are inherently unstable\n    const phaseModifier: Record<EquivalenceState['relationshipPhase'], number> = {\n      strong_equivalence: 0.8, // Stable\n      weak_equivalence: 1.0,\n      decorrelated: 1.2, // Unstable\n      inverse: 1.3, // Very unstable\n    };\n    \n    return Math.min(0.9, baseProb * phaseModifier[currentPhase]);\n  }\n  \n  /**\n   * Dynamically update weights based on performance\n   */\n  private updateWeights(\n    patternAccuracy: number,\n    fundamentalAccuracy: number,\n    correlation: number\n  ): void {\n    const totalAccuracy = patternAccuracy + fundamentalAccuracy;\n    if (totalAccuracy === 0) return;\n    \n    // Calculate ideal weights based on relative accuracy\n    const idealPatternWeight = patternAccuracy / totalAccuracy;\n    const idealFundamentalWeight = fundamentalAccuracy / totalAccuracy;\n    \n    // Smooth update with learning rate\n    this.patternWeight += this.learningRate * (idealPatternWeight - this.patternWeight);\n    this.fundamentalWeight += this.learningRate * (idealFundamentalWeight - this.fundamentalWeight);\n    \n    // Normalize\n    const sum = this.patternWeight + this.fundamentalWeight;\n    this.patternWeight /= sum;\n    this.fundamentalWeight /= sum;\n    \n    // Apply correlation modifier - if decorrelated, trust both less equally\n    if (Math.abs(correlation) < 0.2) {\n      this.patternWeight = 0.5;\n      this.fundamentalWeight = 0.5;\n    }\n  }\n  \n  /**\n   * Record a historical window\n   */\n  private recordWindow(\n    startTime: number,\n    endTime: number,\n    phase: EquivalenceState['relationshipPhase'],\n    patternAccuracy: number,\n    fundamentalAccuracy: number\n  ): void {\n    this.windowHistory.push({\n      startTime,\n      endTime,\n      phase,\n      patternAccuracy,\n      fundamentalAccuracy,\n      combinedAccuracy: patternAccuracy * this.patternWeight + fundamentalAccuracy * this.fundamentalWeight,\n    });\n    \n    if (this.windowHistory.length > 100) {\n      this.windowHistory.shift();\n    }\n  }\n  \n  /**\n   * Get full dynamic equivalence state\n   */\n  getState(): DynamicEquivalenceState {\n    const currentState = this.stateHistory[this.stateHistory.length - 1]?.state || {\n      correlationStrength: 0,\n      causationProbability: 0.5,\n      relationshipPhase: 'decorrelated' as const,\n      stability: 0.5,\n      transitionProbability: 0.5,\n    };\n    \n    // Determine optimal strategy\n    let optimalStrategy: DynamicEquivalenceState['optimalStrategy'];\n    if (currentState.relationshipPhase === 'strong_equivalence') {\n      optimalStrategy = 'trust_patterns';\n    } else if (currentState.relationshipPhase === 'inverse') {\n      optimalStrategy = 'contrarian';\n    } else if (currentState.causationProbability < 0.3) {\n      optimalStrategy = 'trust_fundamentals';\n    } else {\n      optimalStrategy = 'blend';\n    }\n    \n    // Generate insights\n    const insights = this.generateInsights(currentState);\n    \n    // Calculate confidence modifier\n    const confidenceModifier = this.calculateConfidenceModifier(currentState);\n    \n    return {\n      currentState,\n      historicalWindows: this.windowHistory.slice(-20),\n      optimalStrategy,\n      blendWeights: { pattern: this.patternWeight, fundamental: this.fundamentalWeight },\n      confidenceModifier,\n      insights,\n    };\n  }\n  \n  /**\n   * Generate human-readable insights\n   */\n  private generateInsights(state: EquivalenceState): string[] {\n    const insights: string[] = [];\n    \n    if (state.relationshipPhase === 'strong_equivalence') {\n      insights.push('Pattern-structure equivalence is strong - temporal patterns are reliable');\n    } else if (state.relationshipPhase === 'decorrelated') {\n      insights.push('Pattern-structure relationship is weak - fundamentals may dominate');\n    } else if (state.relationshipPhase === 'inverse') {\n      insights.push('Inverse relationship detected - consider contrarian signals');\n    }\n    \n    if (state.transitionProbability > 0.6) {\n      insights.push('High transition probability - relationship may shift soon');\n    }\n    \n    if (state.causationProbability > 0.7) {\n      insights.push('Patterns appear to be CAUSING outcomes, not just correlating');\n    }\n    \n    if (this.patternWeight > 0.65) {\n      insights.push(`Pattern signals weighted ${(this.patternWeight * 100).toFixed(0)}% - proven more reliable`);\n    } else if (this.fundamentalWeight > 0.65) {\n      insights.push(`Fundamental signals weighted ${(this.fundamentalWeight * 100).toFixed(0)}% - patterns less reliable now`);\n    }\n    \n    return insights;\n  }\n  \n  /**\n   * Calculate confidence modifier based on equivalence state\n   */\n  private calculateConfidenceModifier(state: EquivalenceState): number {\n    // Strong equivalence = higher confidence\n    const phaseModifier: Record<EquivalenceState['relationshipPhase'], number> = {\n      strong_equivalence: 1.15,\n      weak_equivalence: 1.0,\n      decorrelated: 0.85,\n      inverse: 0.9, // Still useful if we know to invert\n    };\n    \n    const stabilityModifier = 0.9 + state.stability * 0.2;\n    const causationModifier = 0.9 + state.causationProbability * 0.2;\n    \n    return phaseModifier[state.relationshipPhase] * stabilityModifier * causationModifier;\n  }\n  \n  /**\n   * Get blended prediction from pattern and fundamental sources\n   */\n  blendPredictions(patternPrediction: number, fundamentalPrediction: number): number {\n    const state = this.getState();\n    \n    if (state.optimalStrategy === 'contrarian') {\n      // Invert pattern prediction\n      return -patternPrediction * this.patternWeight + fundamentalPrediction * this.fundamentalWeight;\n    }\n    \n    return patternPrediction * this.patternWeight + fundamentalPrediction * this.fundamentalWeight;\n  }\n}\n\nexport const dynamicEquivalenceTracker = new DynamicEquivalenceTracker();\nexport type { EquivalenceState, EquivalenceWindow, DynamicEquivalenceState };\n";export{n as default};
