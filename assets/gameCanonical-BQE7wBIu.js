const n="/**\n * Canonical Game Identification System\n * \n * Each unique game (PGN moves) has ONE universal link.\n * Different palettes of the same game are distinct \"visions\" within that link.\n * All interactions contribute to the game's value pool.\n */\n\n/**\n * Generate a compact, URL-safe hash of the game moves\n * This creates a canonical identifier for any game regardless of metadata\n */\nexport function generateGameHash(pgn: string | undefined | null): string {\n  if (!pgn) return 'empty';\n  \n  // Extract only the moves from PGN (strip headers, comments, variations)\n  const movesOnly = extractMovesFromPgn(pgn);\n  if (!movesOnly) return 'empty';\n  \n  // Create a compact hash of the moves\n  return compactHash(movesOnly);\n}\n\n/**\n * Extract just the moves from a PGN string\n * Strips headers [Event \"...\"], comments {}, variations ()\n */\nexport function extractMovesFromPgn(pgn: string): string {\n  // Remove headers\n  let cleaned = pgn.replace(/\\[[^\\]]*\\]/g, '');\n  \n  // Remove comments\n  cleaned = cleaned.replace(/\\{[^}]*\\}/g, '');\n  \n  // Remove variations\n  cleaned = cleaned.replace(/\\([^)]*\\)/g, '');\n  \n  // Remove move numbers\n  cleaned = cleaned.replace(/\\d+\\.\\s*/g, '');\n  \n  // Remove result markers\n  cleaned = cleaned.replace(/1-0|0-1|1\\/2-1\\/2|\\*/g, '');\n  \n  // Normalize whitespace\n  cleaned = cleaned.replace(/\\s+/g, ' ').trim();\n  \n  return cleaned;\n}\n\n/**\n * Create a compact URL-safe hash from a string\n * Uses a simple but effective hashing algorithm for short URLs\n */\nfunction compactHash(str: string): string {\n  let hash = 0;\n  let hash2 = 0;\n  \n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash + char) | 0;\n    hash2 = ((hash2 << 7) + hash2 + char) | 0;\n  }\n  \n  // Combine both hashes for better distribution\n  const combined = Math.abs(hash) ^ Math.abs(hash2);\n  \n  // Convert to base36 for compact URL-safe representation\n  return combined.toString(36);\n}\n\n/**\n * Generate the canonical URL for a game\n * This is the ONE universal link for any given set of moves\n */\nexport function getCanonicalGameUrl(pgn: string | undefined | null, baseUrl?: string): string {\n  const hash = generateGameHash(pgn);\n  const base = baseUrl || window.location.origin;\n  return `${base}/g/${hash}`;\n}\n\n/**\n * Check if two PGNs represent the same game (same moves)\n */\nexport function isSameGame(pgn1: string | undefined | null, pgn2: string | undefined | null): boolean {\n  return generateGameHash(pgn1) === generateGameHash(pgn2);\n}\n\n/**\n * Vision identification - Game + Palette combination\n */\nexport interface VisionIdentifier {\n  gameHash: string;\n  paletteId: string;\n}\n\n/**\n * Generate a unique vision identifier (Game + Palette)\n */\nexport function generateVisionId(pgn: string | undefined | null, paletteId: string): VisionIdentifier {\n  return {\n    gameHash: generateGameHash(pgn),\n    paletteId: paletteId || 'modern',\n  };\n}\n\n/**\n * Generate a URL-safe string for a specific vision (game + palette)\n */\nexport function generateVisionHash(pgn: string | undefined | null, paletteId: string): string {\n  const gameHash = generateGameHash(pgn);\n  const paletteShort = paletteId.slice(0, 3); // First 3 chars of palette\n  return `${gameHash}-${paletteShort}`;\n}\n\n/**\n * Parse a vision hash back to components\n */\nexport function parseVisionHash(hash: string): { gameHash: string; paletteHint: string } | null {\n  const parts = hash.split('-');\n  if (parts.length < 2) return null;\n  \n  return {\n    gameHash: parts.slice(0, -1).join('-'),\n    paletteHint: parts[parts.length - 1],\n  };\n}\n\n/**\n * Build a stateful share URL for a game\n * Includes both the game hash and optional state parameters\n */\nexport function buildCanonicalShareUrl(\n  pgn: string | undefined | null,\n  paletteId?: string,\n  state?: {\n    move?: number;\n    dark?: boolean;\n    pieces?: boolean;\n    opacity?: number;\n  }\n): string {\n  const gameHash = generateGameHash(pgn);\n  const url = new URL(`${window.location.origin}/g/${gameHash}`);\n  \n  // Add palette if specified\n  if (paletteId && paletteId !== 'modern') {\n    url.searchParams.set('p', paletteId);\n  }\n  \n  // Add state parameters if they differ from defaults\n  if (state) {\n    if (state.move !== undefined && state.move > 0 && state.move !== Infinity) {\n      url.searchParams.set('m', state.move.toString());\n    }\n    if (state.dark) {\n      url.searchParams.set('d', '1');\n    }\n    if (state.pieces) {\n      url.searchParams.set('sp', '1');\n    }\n    if (state.opacity !== undefined && state.opacity !== 0.7) {\n      url.searchParams.set('o', state.opacity.toFixed(1));\n    }\n  }\n  \n  return url.toString();\n}\n\n/**\n * Parse a canonical game URL to extract parameters\n */\nexport function parseCanonicalUrl(url: string): {\n  gameHash: string;\n  paletteId?: string;\n  move?: number;\n  dark?: boolean;\n  pieces?: boolean;\n  opacity?: number;\n} | null {\n  try {\n    const parsed = new URL(url);\n    const pathMatch = parsed.pathname.match(/\\/g\\/([^\\/]+)/);\n    \n    if (!pathMatch) return null;\n    \n    return {\n      gameHash: pathMatch[1],\n      paletteId: parsed.searchParams.get('p') || undefined,\n      move: parsed.searchParams.has('m') ? parseInt(parsed.searchParams.get('m')!) : undefined,\n      dark: parsed.searchParams.get('d') === '1',\n      pieces: parsed.searchParams.get('sp') === '1',\n      opacity: parsed.searchParams.has('o') ? parseFloat(parsed.searchParams.get('o')!) : undefined,\n    };\n  } catch {\n    return null;\n  }\n}\n";export{n as default};
