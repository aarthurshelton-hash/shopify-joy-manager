const e="import { Chess, Square, Move } from 'chess.js';\nimport { PieceType, PieceColor, getPieceColor } from './pieceColors';\n\nexport interface SquareVisit {\n  piece: PieceType;\n  color: PieceColor;\n  moveNumber: number;\n  hexColor: string;\n}\n\nexport interface SquareData {\n  file: number; // 0-7 (a-h)\n  rank: number; // 0-7 (1-8)\n  visits: SquareVisit[];\n  isLight: boolean;\n}\n\nexport interface GameData {\n  white: string;\n  black: string;\n  event: string;\n  date: string;\n  result: string;\n  pgn: string;\n  moves: string[];\n}\n\nexport interface SimulationResult {\n  board: SquareData[][];\n  gameData: GameData;\n  totalMoves: number;\n}\n\n// Parse PGN and extract game metadata\nfunction parseGameData(pgn: string): Partial<GameData> {\n  const headers: Partial<GameData> = {};\n  \n  const whiteMatch = pgn.match(/\\[White\\s+\"([^\"]+)\"\\]/);\n  const blackMatch = pgn.match(/\\[Black\\s+\"([^\"]+)\"\\]/);\n  const eventMatch = pgn.match(/\\[Event\\s+\"([^\"]+)\"\\]/);\n  const dateMatch = pgn.match(/\\[Date\\s+\"([^\"]+)\"\\]/);\n  const resultMatch = pgn.match(/\\[Result\\s+\"([^\"]+)\"\\]/);\n  \n  if (whiteMatch) headers.white = whiteMatch[1];\n  if (blackMatch) headers.black = blackMatch[1];\n  if (eventMatch) headers.event = eventMatch[1];\n  if (dateMatch) headers.date = dateMatch[1];\n  if (resultMatch) headers.result = resultMatch[1];\n  \n  return headers;\n}\n\n// Convert algebraic notation to file/rank indices\nfunction squareToIndices(square: Square): { file: number; rank: number } {\n  const file = square.charCodeAt(0) - 'a'.charCodeAt(0);\n  const rank = parseInt(square[1]) - 1;\n  return { file, rank };\n}\n\n// Get all squares a piece passes through during a move\nfunction getPathSquares(from: Square, to: Square, pieceType: string): Square[] {\n  const squares: Square[] = [];\n  const fromIndices = squareToIndices(from);\n  const toIndices = squareToIndices(to);\n  \n  const fileDir = Math.sign(toIndices.file - fromIndices.file);\n  const rankDir = Math.sign(toIndices.rank - fromIndices.rank);\n  \n  // Knights jump, don't pass through squares\n  if (pieceType.toLowerCase() === 'n') {\n    squares.push(to);\n    return squares;\n  }\n  \n  // For sliding pieces (rook, bishop, queen) and king, trace the path\n  let currentFile = fromIndices.file + fileDir;\n  let currentRank = fromIndices.rank + rankDir;\n  \n  while (currentFile !== toIndices.file || currentRank !== toIndices.rank) {\n    const file = String.fromCharCode('a'.charCodeAt(0) + currentFile);\n    const rank = (currentRank + 1).toString();\n    squares.push((file + rank) as Square);\n    currentFile += fileDir;\n    currentRank += rankDir;\n  }\n  \n  // Always include destination\n  squares.push(to);\n  \n  return squares;\n}\n\n// Simulate the entire game and track piece visits to each square\n// This function is PERMISSIVE - it processes whatever moves it can without strict validation\nexport function simulateGame(pgn: string): SimulationResult {\n  const chess = new Chess();\n  \n  // Initialize the board data structure\n  const board: SquareData[][] = [];\n  for (let rank = 0; rank < 8; rank++) {\n    board[rank] = [];\n    for (let file = 0; file < 8; file++) {\n      const isLight = (rank + file) % 2 === 1;\n      board[rank][file] = {\n        file,\n        rank,\n        visits: [],\n        isLight,\n      };\n    }\n  }\n  \n  // Parse game metadata first\n  const gameHeaders = parseGameData(pgn);\n  \n  // Try to load the PGN directly first\n  let history: Move[] = [];\n  \n  try {\n    chess.loadPgn(pgn);\n    history = chess.history({ verbose: true });\n  } catch (e) {\n    // If direct loading fails, try to parse moves manually\n    console.log('Direct PGN load failed, attempting manual parsing...');\n    \n    // Extract just the moves section (after headers)\n    const movesSection = pgn.replace(/\\[[^\\]]*\\]/g, '').trim();\n    \n    // Parse individual move tokens\n    const moveTokens = movesSection\n      .replace(/\\{[^}]*\\}/g, '') // Remove comments\n      .replace(/\\([^)]*\\)/g, '') // Remove variations\n      .replace(/\\$\\d+/g, '') // Remove NAG annotations\n      .replace(/1-0|0-1|1\\/2-1\\/2|\\*/g, '') // Remove results\n      .split(/\\s+/)\n      .filter(token => token && !token.match(/^\\d+\\.+$/) && token !== '...');\n    \n    chess.reset();\n    \n    for (const moveToken of moveTokens) {\n      try {\n        // Try common notation fixes\n        const fixedMove = moveToken\n          .replace(/0-0-0/gi, 'O-O-O')\n          .replace(/0-0/gi, 'O-O')\n          .replace(/[+#!?]+$/, ''); // Remove check/mate/annotation symbols for parsing\n        \n        const result = chess.move(fixedMove);\n        if (result) {\n          history.push(result);\n        }\n      } catch {\n        // Skip moves that can't be parsed - continue with what we have\n        console.log(`Skipping unparseable move: ${moveToken}`);\n      }\n    }\n  }\n  \n  // Reset and replay to track movements\n  chess.reset();\n  \n  let moveNumber = 0;\n  const moveNotations: string[] = [];\n  \n  for (const move of history) {\n    moveNumber++;\n    moveNotations.push(move.san);\n    \n    const pieceType = move.piece as PieceType;\n    const pieceColor = move.color as PieceColor;\n    const hexColor = getPieceColor(pieceType, pieceColor);\n    \n    // Get all squares the piece passes through\n    const pathSquares = getPathSquares(move.from, move.to, move.piece);\n    \n    // Record the visit for each square in the path\n    for (const square of pathSquares) {\n      const { file, rank } = squareToIndices(square);\n      board[rank][file].visits.push({\n        piece: pieceType,\n        color: pieceColor,\n        moveNumber,\n        hexColor,\n      });\n    }\n    \n    // Make the move on our tracking board\n    try {\n      chess.move(move.san);\n    } catch {\n      // If replay fails, just continue - we already have the data\n    }\n  }\n  \n  return {\n    board,\n    gameData: {\n      white: gameHeaders.white || 'Unknown',\n      black: gameHeaders.black || 'Unknown',\n      event: gameHeaders.event || 'Unknown',\n      date: gameHeaders.date || 'Unknown',\n      result: gameHeaders.result || '*',\n      pgn: pgn,\n      moves: moveNotations,\n    },\n    totalMoves: moveNumber,\n  };\n}\n\n// Format the moves for display (with move numbers)\nexport function formatMoves(moves: string[]): string {\n  let formatted = '';\n  for (let i = 0; i < moves.length; i++) {\n    if (i % 2 === 0) {\n      formatted += `${Math.floor(i / 2) + 1}. `;\n    }\n    formatted += moves[i] + ' ';\n  }\n  return formatted.trim();\n}\n";export{e as default};
