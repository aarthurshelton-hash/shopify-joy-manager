const n="/**\n * IBKR Autonomous Trading Hook\n * \n * Runs 24/7 automated trading through the local IB Gateway bridge.\n * Uses real IBKR paper account data with persistent DB tracking.\n * No simulation - all trades execute against actual IBKR paper account.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { ibGatewayClient } from '@/lib/trading/ibGatewayClient';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface AutoTradeSession {\n  id: string;\n  startedAt: string;\n  lastActivityAt: string;\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  totalPnl: number;\n  startBalance: number;\n  currentBalance: number;\n}\n\ninterface AutoPosition {\n  id: string;\n  symbol: string;\n  conid: number;\n  side: 'long' | 'short';\n  entryPrice: number;\n  quantity: number;\n  entryTime: number;\n  stopLoss: number;\n  takeProfit: number;\n  status: 'open' | 'closed' | 'pending';\n}\n\ninterface CycleResult {\n  tradesExecuted: number;\n  positionsManaged: number;\n  signalsGenerated: number;\n  pnlChange: number;\n  timestamp: string;\n}\n\n// Trading configuration - tuned for pattern recognition advantage\nconst AUTO_CONFIG = {\n  MIN_CONFIDENCE: 0.70,        // Higher threshold for auto-trades\n  MAX_RISK_PERCENT: 3,         // Conservative 3% max risk per trade\n  POSITION_SIZE_PERCENT: 5,    // 5% position sizing\n  SCALP_HORIZON_MS: 60000,     // 60-second scalps\n  CYCLE_INTERVAL_MS: 15000,    // Run cycle every 15 seconds\n  STOP_LOSS_PERCENT: 1.0,      // 1% stop loss\n  TAKE_PROFIT_PERCENT: 1.5,    // 1.5% take profit (1.5:1 R:R)\n};\n\n// Symbols to trade - focus on high liquidity\nconst AUTO_SYMBOLS = ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA', 'AMD'];\n\nexport function useIBKRAutonomousTrading(gatewayConnected: boolean, accountId: string | null) {\n  const [isRunning, setIsRunning] = useState(false);\n  const [session, setSession] = useState<AutoTradeSession | null>(null);\n  const [positions, setPositions] = useState<AutoPosition[]>([]);\n  const [cycleResults, setCycleResults] = useState<CycleResult[]>([]);\n  const [lastCycleTime, setLastCycleTime] = useState<Date | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  \n  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const sessionIdRef = useRef<string | null>(null);\n  const { toast } = useToast();\n\n  // Get prediction signal from our pattern recognition system\n  const getPatternSignal = useCallback(async (symbol: string): Promise<{\n    direction: 'up' | 'down' | 'neutral';\n    confidence: number;\n    archetype: string;\n  } | null> => {\n    try {\n      // Fetch recent predictions for this symbol\n      const { data: predictions } = await supabase\n        .from('prediction_outcomes')\n        .select('*')\n        .eq('symbol', symbol)\n        .order('created_at', { ascending: false })\n        .limit(5);\n\n      if (!predictions || predictions.length === 0) {\n        // Generate new signal via edge function\n        const { data, error } = await supabase.functions.invoke('stock-data', {\n          body: { action: 'prediction', symbol }\n        });\n\n        if (error || !data) return null;\n\n        return {\n          direction: data.direction || 'neutral',\n          confidence: data.confidence || 0.5,\n          archetype: data.archetype || 'unknown',\n        };\n      }\n\n      // Aggregate recent predictions for consensus\n      const upVotes = predictions.filter(p => p.predicted_direction === 'up').length;\n      const downVotes = predictions.filter(p => p.predicted_direction === 'down').length;\n      const avgConfidence = predictions.reduce((sum, p) => sum + (p.predicted_confidence || 0), 0) / predictions.length;\n\n      let direction: 'up' | 'down' | 'neutral' = 'neutral';\n      if (upVotes > downVotes && upVotes >= 3) direction = 'up';\n      else if (downVotes > upVotes && downVotes >= 3) direction = 'down';\n\n      // Extract archetype from market_conditions if available\n      const marketConditions = predictions[0]?.market_conditions as Record<string, unknown> | null;\n      const archetype = (marketConditions?.archetype as string) || 'consensus';\n\n      return {\n        direction,\n        confidence: avgConfidence,\n        archetype,\n      };\n    } catch (err) {\n      console.error('[AutoTrade] Signal error:', err);\n      return null;\n    }\n  }, []);\n\n  // Execute a single trading cycle\n  const runCycle = useCallback(async () => {\n    if (!gatewayConnected || !accountId || !sessionIdRef.current) {\n      console.log('[AutoTrade] Skipping cycle - not ready');\n      return;\n    }\n\n    console.log('[AutoTrade] Running cycle...');\n    setLastCycleTime(new Date());\n\n    let tradesExecuted = 0;\n    let positionsManaged = 0;\n    let signalsGenerated = 0;\n    let pnlChange = 0;\n\n    try {\n      // Get current account balance\n      const accounts = await ibGatewayClient.getAccounts();\n      const account = accounts.find(a => a.accountId === accountId);\n      if (!account) {\n        console.warn('[AutoTrade] Account not found');\n        return;\n      }\n\n      const currentBalance = account.balance;\n\n      // Get current positions from IBKR\n      const ibkrPositions = await ibGatewayClient.getPositions(accountId);\n\n      // Scan symbols for trading opportunities\n      for (const symbol of AUTO_SYMBOLS) {\n        // Skip if we already have a position in this symbol\n        const hasPosition = ibkrPositions.some(p => p.symbol === symbol && p.position !== 0);\n        const hasAutoPosition = positions.some(p => p.symbol === symbol && p.status === 'open');\n        \n        if (hasPosition || hasAutoPosition) {\n          positionsManaged++;\n          continue;\n        }\n\n        // Get pattern recognition signal\n        const signal = await getPatternSignal(symbol);\n        signalsGenerated++;\n\n        if (!signal || signal.direction === 'neutral' || signal.confidence < AUTO_CONFIG.MIN_CONFIDENCE) {\n          continue;\n        }\n\n        // Search for contract\n        const contracts = await ibGatewayClient.searchContract(symbol);\n        if (contracts.length === 0) continue;\n\n        const contract = contracts[0];\n\n        // Get current price\n        const quote = await ibGatewayClient.getQuote(contract.conid);\n        if (!quote || !quote.lastPrice) continue;\n\n        const price = quote.lastPrice;\n\n        // Calculate position size\n        const riskAmount = currentBalance * (AUTO_CONFIG.MAX_RISK_PERCENT / 100);\n        const stopLossAmount = price * (AUTO_CONFIG.STOP_LOSS_PERCENT / 100);\n        const maxShares = Math.floor(riskAmount / stopLossAmount);\n        const positionSizeShares = Math.min(maxShares, Math.floor((currentBalance * AUTO_CONFIG.POSITION_SIZE_PERCENT / 100) / price));\n\n        if (positionSizeShares < 1) continue;\n\n        // Execute order\n        const side = signal.direction === 'up' ? 'BUY' : 'SELL';\n        const result = await ibGatewayClient.placeOrder({\n          accountId,\n          conid: contract.conid,\n          symbol,\n          side,\n          quantity: positionSizeShares,\n          orderType: 'MKT',\n        });\n\n        if (result) {\n          tradesExecuted++;\n\n          // Track position locally\n          const newPosition: AutoPosition = {\n            id: result.orderId,\n            symbol,\n            conid: contract.conid,\n            side: signal.direction === 'up' ? 'long' : 'short',\n            entryPrice: price,\n            quantity: positionSizeShares,\n            entryTime: Date.now(),\n            stopLoss: signal.direction === 'up' \n              ? price * (1 - AUTO_CONFIG.STOP_LOSS_PERCENT / 100)\n              : price * (1 + AUTO_CONFIG.STOP_LOSS_PERCENT / 100),\n            takeProfit: signal.direction === 'up'\n              ? price * (1 + AUTO_CONFIG.TAKE_PROFIT_PERCENT / 100)\n              : price * (1 - AUTO_CONFIG.TAKE_PROFIT_PERCENT / 100),\n            status: 'open',\n          };\n\n          setPositions(prev => [...prev, newPosition]);\n\n          // Log trade to database\n          await supabase.from('autonomous_trades').insert({\n            symbol,\n            direction: side,\n            entry_price: price,\n            shares: positionSizeShares,\n            predicted_direction: signal.direction,\n            predicted_confidence: signal.confidence,\n            status: 'open',\n          });\n\n          console.log(`[AutoTrade] âœ“ ${side} ${positionSizeShares} ${symbol} @ $${price.toFixed(2)} | Confidence: ${(signal.confidence * 100).toFixed(1)}%`);\n        }\n      }\n\n      // Manage open positions - check for stop loss or take profit\n      for (const pos of positions.filter(p => p.status === 'open')) {\n        const quote = await ibGatewayClient.getQuote(pos.conid);\n        if (!quote || !quote.lastPrice) continue;\n\n        const currentPrice = quote.lastPrice;\n        const pnl = pos.side === 'long'\n          ? (currentPrice - pos.entryPrice) * pos.quantity\n          : (pos.entryPrice - currentPrice) * pos.quantity;\n\n        // Check exit conditions\n        const shouldClose = \n          (pos.side === 'long' && currentPrice <= pos.stopLoss) ||\n          (pos.side === 'long' && currentPrice >= pos.takeProfit) ||\n          (pos.side === 'short' && currentPrice >= pos.stopLoss) ||\n          (pos.side === 'short' && currentPrice <= pos.takeProfit) ||\n          (Date.now() - pos.entryTime > AUTO_CONFIG.SCALP_HORIZON_MS * 3);\n\n        if (shouldClose) {\n          const closeSide = pos.side === 'long' ? 'SELL' : 'BUY';\n          const closeResult = await ibGatewayClient.placeOrder({\n            accountId,\n            conid: pos.conid,\n            symbol: pos.symbol,\n            side: closeSide,\n            quantity: pos.quantity,\n            orderType: 'MKT',\n          });\n\n          if (closeResult) {\n            pnlChange += pnl;\n            \n            setPositions(prev => prev.map(p => \n              p.id === pos.id ? { ...p, status: 'closed' as const } : p\n            ));\n\n            // Update database\n            await supabase.from('autonomous_trades')\n              .update({\n                exit_price: currentPrice,\n                exit_time: new Date().toISOString(),\n                pnl,\n                pnl_percent: (pnl / (pos.entryPrice * pos.quantity)) * 100,\n                status: 'closed',\n                actual_direction: pnl > 0 ? 'correct' : 'incorrect',\n              })\n              .eq('symbol', pos.symbol)\n              .eq('status', 'open')\n              .order('created_at', { ascending: false })\n              .limit(1);\n\n            console.log(`[AutoTrade] Position closed: ${pos.symbol} | PnL: $${pnl.toFixed(2)}`);\n          }\n        }\n      }\n\n      // Update session stats\n      setSession(prev => {\n        if (!prev) return prev;\n        \n        const newWins = pnlChange > 0 ? prev.winningTrades + 1 : prev.winningTrades;\n        const newLosses = pnlChange < 0 ? prev.losingTrades + 1 : prev.losingTrades;\n        \n        return {\n          ...prev,\n          totalTrades: prev.totalTrades + tradesExecuted,\n          winningTrades: newWins,\n          losingTrades: newLosses,\n          totalPnl: prev.totalPnl + pnlChange,\n          currentBalance,\n          lastActivityAt: new Date().toISOString(),\n        };\n      });\n\n      // Record cycle result\n      const result: CycleResult = {\n        tradesExecuted,\n        positionsManaged,\n        signalsGenerated,\n        pnlChange,\n        timestamp: new Date().toISOString(),\n      };\n\n      setCycleResults(prev => [...prev.slice(-49), result]);\n\n    } catch (err) {\n      console.error('[AutoTrade] Cycle error:', err);\n      setError((err as Error).message);\n    }\n  }, [gatewayConnected, accountId, positions, getPatternSignal]);\n\n  // Start autonomous trading\n  const startAutonomous = useCallback(async () => {\n    if (!gatewayConnected || !accountId) {\n      toast({\n        title: 'Cannot Start',\n        description: 'IB Gateway must be connected first.',\n        variant: 'destructive',\n      });\n      return;\n    }\n\n    // Get current balance\n    const accounts = await ibGatewayClient.getAccounts();\n    const account = accounts.find(a => a.accountId === accountId);\n    if (!account) {\n      toast({\n        title: 'Account Error',\n        description: 'Could not find account balance.',\n        variant: 'destructive',\n      });\n      return;\n    }\n\n    // Create session\n    const sessionId = `auto-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;\n    sessionIdRef.current = sessionId;\n\n    const newSession: AutoTradeSession = {\n      id: sessionId,\n      startedAt: new Date().toISOString(),\n      lastActivityAt: new Date().toISOString(),\n      totalTrades: 0,\n      winningTrades: 0,\n      losingTrades: 0,\n      totalPnl: 0,\n      startBalance: account.balance,\n      currentBalance: account.balance,\n    };\n\n    setSession(newSession);\n    setIsRunning(true);\n    setError(null);\n    setCycleResults([]);\n    setPositions([]);\n\n    // Start loop\n    runCycle();\n    intervalRef.current = setInterval(runCycle, AUTO_CONFIG.CYCLE_INTERVAL_MS);\n\n    toast({\n      title: 'ðŸ¤– Autonomous Trading Started',\n      description: `Trading ${AUTO_SYMBOLS.join(', ')} with $${account.balance.toLocaleString()} balance`,\n    });\n\n    console.log(`[AutoTrade] Started session ${sessionId} with $${account.balance.toFixed(2)}`);\n  }, [gatewayConnected, accountId, toast, runCycle]);\n\n  // Stop autonomous trading\n  const stopAutonomous = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n    \n    setIsRunning(false);\n    sessionIdRef.current = null;\n\n    toast({\n      title: 'Autonomous Trading Stopped',\n      description: session ? `Session ended with ${session.totalTrades} trades, $${session.totalPnl.toFixed(2)} P&L` : 'Session ended',\n    });\n\n    console.log('[AutoTrade] Stopped');\n  }, [toast, session]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n\n  // Stop if gateway disconnects\n  useEffect(() => {\n    if (!gatewayConnected && isRunning) {\n      stopAutonomous();\n      setError('Gateway disconnected - autonomous trading stopped');\n    }\n  }, [gatewayConnected, isRunning, stopAutonomous]);\n\n  // Calculate stats\n  const stats = {\n    winRate: session && session.totalTrades > 0 \n      ? ((session.winningTrades / session.totalTrades) * 100).toFixed(1) + '%'\n      : 'N/A',\n    avgCycleTime: cycleResults.length > 0\n      ? `${(AUTO_CONFIG.CYCLE_INTERVAL_MS / 1000).toFixed(0)}s`\n      : 'N/A',\n    totalSignals: cycleResults.reduce((sum, r) => sum + r.signalsGenerated, 0),\n    openPositions: positions.filter(p => p.status === 'open').length,\n  };\n\n  return {\n    // State\n    isRunning,\n    session,\n    positions,\n    cycleResults,\n    lastCycleTime,\n    error,\n    stats,\n    config: AUTO_CONFIG,\n    symbols: AUTO_SYMBOLS,\n    \n    // Actions\n    startAutonomous,\n    stopAutonomous,\n  };\n}\n";export{n as default};
