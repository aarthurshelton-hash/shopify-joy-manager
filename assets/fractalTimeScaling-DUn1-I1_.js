const n="/**\n * Fractal Time Scaling - v7.53-ACCURACY\n * \n * Multi-timeframe confluence analysis.\n * When multiple timeframes agree, prediction reliability increases.\n */\n\nexport type Timeframe = '1m' | '5m' | '15m' | '1h' | '4h' | '1d' | '1w';\n\nexport interface TimeframeSignal {\n  timeframe: Timeframe;\n  direction: 'up' | 'down' | 'neutral';\n  strength: number;     // 0-1\n  trend: 'trending' | 'ranging' | 'reverting';\n  momentum: number;     // -1 to 1\n  keyLevels: { support: number; resistance: number };\n}\n\nexport interface ConfluenceResult {\n  overallDirection: 'up' | 'down' | 'neutral';\n  confluenceScore: number;      // 0-1, higher = more agreement\n  dominantTimeframe: Timeframe;\n  alignedTimeframes: Timeframe[];\n  conflictingTimeframes: Timeframe[];\n  predictionReliability: number;\n  fractalPattern: 'aligned' | 'diverging' | 'mixed';\n}\n\n/**\n * Timeframe weights - higher timeframes more weight\n */\nexport const TIMEFRAME_WEIGHTS: Record<Timeframe, number> = {\n  '1m': 0.1,\n  '5m': 0.15,\n  '15m': 0.2,\n  '1h': 0.3,\n  '4h': 0.5,\n  '1d': 0.7,\n  '1w': 1.0,\n};\n\n/**\n * Calculate confluence across multiple timeframes\n */\nexport function calculateConfluence(signals: TimeframeSignal[]): ConfluenceResult {\n  if (signals.length === 0) {\n    return {\n      overallDirection: 'neutral',\n      confluenceScore: 0,\n      dominantTimeframe: '1h',\n      alignedTimeframes: [],\n      conflictingTimeframes: [],\n      predictionReliability: 0,\n      fractalPattern: 'mixed',\n    };\n  }\n  \n  // Weight signals by timeframe\n  let upWeight = 0;\n  let downWeight = 0;\n  let totalWeight = 0;\n  \n  for (const signal of signals) {\n    const weight = TIMEFRAME_WEIGHTS[signal.timeframe] * signal.strength;\n    totalWeight += weight;\n    \n    if (signal.direction === 'up') {\n      upWeight += weight;\n    } else if (signal.direction === 'down') {\n      downWeight += weight;\n    }\n  }\n  \n  // Determine overall direction\n  const overallDirection: 'up' | 'down' | 'neutral' = \n    upWeight > downWeight * 1.2 ? 'up' :\n    downWeight > upWeight * 1.2 ? 'down' : 'neutral';\n  \n  // Find dominant timeframe (highest weight signal that matches overall)\n  const matchingSignals = signals.filter(s => s.direction === overallDirection);\n  const dominantTimeframe = matchingSignals.length > 0 ?\n    matchingSignals.reduce((max, s) => \n      TIMEFRAME_WEIGHTS[s.timeframe] > TIMEFRAME_WEIGHTS[max.timeframe] ? s : max\n    ).timeframe : signals[0].timeframe;\n  \n  // Calculate confluence score\n  const alignedTimeframes = signals\n    .filter(s => s.direction === overallDirection)\n    .map(s => s.timeframe);\n  \n  const conflictingTimeframes = signals\n    .filter(s => s.direction !== 'neutral' && s.direction !== overallDirection)\n    .map(s => s.timeframe);\n  \n  const alignmentRatio = alignedTimeframes.length / signals.length;\n  const weightedAlignment = alignedTimeframes.reduce((sum, tf) => \n    sum + TIMEFRAME_WEIGHTS[tf], 0\n  ) / signals.reduce((sum, s) => sum + TIMEFRAME_WEIGHTS[s.timeframe], 0);\n  \n  const confluenceScore = (alignmentRatio * 0.4) + (weightedAlignment * 0.6);\n  \n  // Determine fractal pattern\n  const fractalPattern: 'aligned' | 'diverging' | 'mixed' = \n    confluenceScore > 0.7 ? 'aligned' :\n    conflictingTimeframes.length >= alignedTimeframes.length ? 'diverging' : 'mixed';\n  \n  // Prediction reliability based on confluence\n  const predictionReliability = confluenceScore * (fractalPattern === 'aligned' ? 1.2 : \n    fractalPattern === 'diverging' ? 0.6 : 0.85);\n  \n  return {\n    overallDirection,\n    confluenceScore,\n    dominantTimeframe,\n    alignedTimeframes,\n    conflictingTimeframes,\n    predictionReliability: Math.min(1, predictionReliability),\n    fractalPattern,\n  };\n}\n\n/**\n * Detect fractal pattern repetition\n */\nexport function detectFractalRepetition(\n  shortTermSignals: TimeframeSignal[],\n  longTermSignals: TimeframeSignal[]\n): { isRepeating: boolean; similarity: number; scaleFactor: number } {\n  if (shortTermSignals.length === 0 || longTermSignals.length === 0) {\n    return { isRepeating: false, similarity: 0, scaleFactor: 1 };\n  }\n  \n  // Compare direction patterns\n  const shortDirections = shortTermSignals.map(s => s.direction);\n  const longDirections = longTermSignals.map(s => s.direction);\n  \n  let matches = 0;\n  const compareLength = Math.min(shortDirections.length, longDirections.length);\n  \n  for (let i = 0; i < compareLength; i++) {\n    if (shortDirections[i] === longDirections[i]) matches++;\n  }\n  \n  const similarity = matches / compareLength;\n  \n  // Calculate scale factor (how timeframes relate)\n  const shortAvgWeight = shortTermSignals.reduce((sum, s) => \n    sum + TIMEFRAME_WEIGHTS[s.timeframe], 0) / shortTermSignals.length;\n  const longAvgWeight = longTermSignals.reduce((sum, s) => \n    sum + TIMEFRAME_WEIGHTS[s.timeframe], 0) / longTermSignals.length;\n  \n  const scaleFactor = longAvgWeight / shortAvgWeight;\n  \n  return {\n    isRepeating: similarity > 0.7,\n    similarity,\n    scaleFactor,\n  };\n}\n\n/**\n * Get optimal timeframe for prediction\n */\nexport function getOptimalTimeframe(\n  signals: TimeframeSignal[],\n  tradingStyle: 'scalp' | 'swing' | 'position' = 'swing'\n): { timeframe: Timeframe; confidence: number; reason: string } {\n  const styleTimeframes: Record<typeof tradingStyle, Timeframe[]> = {\n    scalp: ['1m', '5m', '15m'],\n    swing: ['1h', '4h', '1d'],\n    position: ['1d', '1w'],\n  };\n  \n  const relevantSignals = signals.filter(s => \n    styleTimeframes[tradingStyle].includes(s.timeframe)\n  );\n  \n  if (relevantSignals.length === 0) {\n    return {\n      timeframe: styleTimeframes[tradingStyle][1] || '1h',\n      confidence: 0.3,\n      reason: 'No signals for trading style, using default',\n    };\n  }\n  \n  // Find strongest aligned signal\n  const confluence = calculateConfluence(relevantSignals);\n  const aligned = relevantSignals.filter(s => s.direction === confluence.overallDirection);\n  \n  if (aligned.length === 0) {\n    return {\n      timeframe: relevantSignals[0].timeframe,\n      confidence: 0.4,\n      reason: 'No aligned signals, using first available',\n    };\n  }\n  \n  const strongest = aligned.reduce((max, s) => \n    s.strength > max.strength ? s : max\n  );\n  \n  return {\n    timeframe: strongest.timeframe,\n    confidence: strongest.strength * confluence.confluenceScore,\n    reason: `${strongest.timeframe} shows strongest ${confluence.overallDirection} signal with ${(confluence.confluenceScore * 100).toFixed(0)}% confluence`,\n  };\n}\n\n/**\n * Integrate multi-timeframe analysis into prediction\n */\nexport function integrateMultiTimeframePrediction(\n  basePrediction: { direction: 'up' | 'down' | 'neutral'; confidence: number },\n  confluence: ConfluenceResult\n): { direction: 'up' | 'down' | 'neutral'; confidence: number; mtfAdjustment: number } {\n  let { direction, confidence } = basePrediction;\n  \n  // Confluence boost or penalty\n  const mtfAdjustment = confluence.fractalPattern === 'aligned' ? 0.3 :\n    confluence.fractalPattern === 'diverging' ? -0.3 : 0;\n  \n  // If MTF strongly disagrees, respect it\n  if (confluence.overallDirection !== direction && confluence.confluenceScore > 0.7) {\n    direction = confluence.overallDirection;\n    confidence = confluence.predictionReliability * 0.8;\n  } else if (confluence.overallDirection === direction) {\n    // Agreement boosts confidence\n    confidence = Math.min(1, confidence * (1 + confluence.confluenceScore * 0.4));\n  } else {\n    // Mild disagreement reduces confidence\n    confidence *= (1 - confluence.confluenceScore * 0.2);\n  }\n  \n  return { direction, confidence, mtfAdjustment };\n}\n";export{n as default};
