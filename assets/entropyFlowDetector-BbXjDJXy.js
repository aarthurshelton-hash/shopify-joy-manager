const n="/**\n * Entropy Flow Detector\n * \n * Tracks information entropy across domains to detect\n * order emerging from chaos and vice versa.\n * High entropy = uncertainty/chaos, Low entropy = order/predictability\n */\n\nimport type { DomainType } from '../types';\n\ninterface EntropySnapshot {\n  domain: DomainType;\n  entropy: number;\n  timestamp: number;\n}\n\ninterface EntropyFlow {\n  fromDomain: DomainType;\n  toDomain: DomainType;\n  entropyDelta: number;\n  flowDirection: 'order_emerging' | 'chaos_increasing' | 'stable';\n  confidence: number;\n}\n\ninterface SystemEntropyState {\n  totalEntropy: number;\n  entropyTrend: 'increasing' | 'decreasing' | 'stable';\n  orderEmergingDomains: DomainType[];\n  chaosIncreasingDomains: DomainType[];\n  predictionWindow: 'favorable' | 'unfavorable' | 'neutral';\n}\n\nclass EntropyFlowDetector {\n  private entropyHistory: Map<DomainType, EntropySnapshot[]> = new Map();\n  private readonly maxHistorySize = 100;\n  private readonly entropyDecayFactor = 0.95; // Prevents overfitting to recent data\n  \n  /**\n   * Calculate Shannon entropy from a distribution of values\n   */\n  private calculateEntropy(values: number[]): number {\n    if (values.length === 0) return 1; // Maximum uncertainty\n    \n    // Normalize to probabilities\n    const sum = values.reduce((a, b) => a + Math.abs(b), 0);\n    if (sum === 0) return 1;\n    \n    const probabilities = values.map(v => Math.abs(v) / sum);\n    \n    // Shannon entropy: -Î£ p(x) * log2(p(x))\n    let entropy = 0;\n    for (const p of probabilities) {\n      if (p > 0) {\n        entropy -= p * Math.log2(p);\n      }\n    }\n    \n    // Normalize to 0-1 range\n    const maxEntropy = Math.log2(values.length);\n    return maxEntropy > 0 ? entropy / maxEntropy : 0;\n  }\n  \n  /**\n   * Record entropy for a domain based on its recent signal values\n   */\n  recordDomainEntropy(domain: DomainType, signalValues: number[]): void {\n    const entropy = this.calculateEntropy(signalValues);\n    \n    if (!this.entropyHistory.has(domain)) {\n      this.entropyHistory.set(domain, []);\n    }\n    \n    const history = this.entropyHistory.get(domain)!;\n    history.push({\n      domain,\n      entropy,\n      timestamp: Date.now(),\n    });\n    \n    // Prune old entries\n    if (history.length > this.maxHistorySize) {\n      history.shift();\n    }\n  }\n  \n  /**\n   * Detect entropy flow between domains\n   */\n  detectEntropyFlows(): EntropyFlow[] {\n    const flows: EntropyFlow[] = [];\n    const domains = Array.from(this.entropyHistory.keys());\n    \n    for (let i = 0; i < domains.length; i++) {\n      for (let j = i + 1; j < domains.length; j++) {\n        const domainA = domains[i];\n        const domainB = domains[j];\n        \n        const historyA = this.entropyHistory.get(domainA) || [];\n        const historyB = this.entropyHistory.get(domainB) || [];\n        \n        if (historyA.length < 5 || historyB.length < 5) continue;\n        \n        // Calculate entropy trends\n        const recentA = historyA.slice(-10);\n        const recentB = historyB.slice(-10);\n        \n        const trendA = this.calculateTrend(recentA.map(s => s.entropy));\n        const trendB = this.calculateTrend(recentB.map(s => s.entropy));\n        \n        // Detect inverse relationships (order in one = chaos in other)\n        if (Math.sign(trendA) !== Math.sign(trendB) && Math.abs(trendA - trendB) > 0.1) {\n          const entropyDelta = trendA - trendB;\n          \n          flows.push({\n            fromDomain: trendA > 0 ? domainA : domainB,\n            toDomain: trendA > 0 ? domainB : domainA,\n            entropyDelta: Math.abs(entropyDelta),\n            flowDirection: trendA < 0 ? 'order_emerging' : 'chaos_increasing',\n            confidence: Math.min(0.9, Math.abs(entropyDelta) * this.entropyDecayFactor),\n          });\n        }\n      }\n    }\n    \n    return flows;\n  }\n  \n  /**\n   * Get overall system entropy state\n   */\n  getSystemEntropyState(): SystemEntropyState {\n    const domains = Array.from(this.entropyHistory.keys());\n    const orderEmergingDomains: DomainType[] = [];\n    const chaosIncreasingDomains: DomainType[] = [];\n    \n    let totalEntropy = 0;\n    let entropyTrendSum = 0;\n    \n    for (const domain of domains) {\n      const history = this.entropyHistory.get(domain) || [];\n      if (history.length < 3) continue;\n      \n      const recent = history.slice(-10);\n      const avgEntropy = recent.reduce((sum, s) => sum + s.entropy, 0) / recent.length;\n      const trend = this.calculateTrend(recent.map(s => s.entropy));\n      \n      totalEntropy += avgEntropy;\n      entropyTrendSum += trend;\n      \n      if (trend < -0.05) {\n        orderEmergingDomains.push(domain);\n      } else if (trend > 0.05) {\n        chaosIncreasingDomains.push(domain);\n      }\n    }\n    \n    const avgTrend = domains.length > 0 ? entropyTrendSum / domains.length : 0;\n    \n    // Determine prediction window\n    let predictionWindow: 'favorable' | 'unfavorable' | 'neutral' = 'neutral';\n    if (orderEmergingDomains.length > chaosIncreasingDomains.length * 2) {\n      predictionWindow = 'favorable'; // More order = more predictable\n    } else if (chaosIncreasingDomains.length > orderEmergingDomains.length * 2) {\n      predictionWindow = 'unfavorable'; // More chaos = less predictable\n    }\n    \n    return {\n      totalEntropy: domains.length > 0 ? totalEntropy / domains.length : 0.5,\n      entropyTrend: avgTrend < -0.02 ? 'decreasing' : avgTrend > 0.02 ? 'increasing' : 'stable',\n      orderEmergingDomains,\n      chaosIncreasingDomains,\n      predictionWindow,\n    };\n  }\n  \n  /**\n   * Calculate linear trend from values\n   */\n  private calculateTrend(values: number[]): number {\n    if (values.length < 2) return 0;\n    \n    const n = values.length;\n    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n    \n    for (let i = 0; i < n; i++) {\n      sumX += i;\n      sumY += values[i];\n      sumXY += i * values[i];\n      sumX2 += i * i;\n    }\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    return isNaN(slope) ? 0 : slope;\n  }\n  \n  /**\n   * Get confidence modifier based on entropy state\n   * Lower entropy = higher confidence in predictions\n   */\n  getConfidenceModifier(): number {\n    const state = this.getSystemEntropyState();\n    \n    // Invert entropy: low entropy = high confidence\n    const baseModifier = 1 - (state.totalEntropy * 0.3);\n    \n    // Boost if order is emerging\n    const emergenceBoost = state.predictionWindow === 'favorable' ? 1.1 : \n                           state.predictionWindow === 'unfavorable' ? 0.9 : 1.0;\n    \n    return Math.max(0.5, Math.min(1.2, baseModifier * emergenceBoost));\n  }\n}\n\nexport const entropyFlowDetector = new EntropyFlowDetector();\nexport type { EntropyFlow, SystemEntropyState };\n";export{n as default};
