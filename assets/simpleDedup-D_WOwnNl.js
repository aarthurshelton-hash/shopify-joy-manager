const n='/**\n * Simple Game Deduplication System\n * VERSION: 7.16-FAST-INIT\n * \n * PHILOSOPHY:\n * ===========\n * Fresh ID → Check if in system → Accept or Reject\n * That\'s it. No multi-layer complexity.\n * \n * v7.16 FIXES:\n * - Hard 5s timeout on init to prevent startup hangs\n * - Max 3 pages (3000 IDs) - good enough coverage\n * - Per-page timeout to prevent individual query hangs\n * \n * ONE SET. ONE CHECK. DONE.\n */\n\nimport { supabase } from \'@/integrations/supabase/client\';\n\nconst VERSION = "8.03-AGGRESSIVE";\nconsole.log(`[${VERSION}] simpleDedup.ts LOADED`);\n\n// v8.03: More aggressive loading to ensure full coverage\nconst INIT_TIMEOUT_MS = 15000; // Max 15s for entire init (was 10s)\nconst PAGE_TIMEOUT_MS = 4000;  // Max 4s per page (was 3s)\nconst MAX_PAGES = 30;          // Load up to 30,000 IDs (was 20)\nconst PAGE_SIZE = 1000;\n\n/**\n * The ONE set of known game IDs in our system.\n * Contains RAW IDs only (no prefixes).\n */\nlet knownGameIds: Set<string> = new Set();\nlet isInitialized = false;\nlet initPromise: Promise<void> | null = null;\n\n/**\n * Extract raw ID from any format\n * "li_ABC123XY" → "ABC123XY"\n * "cc_123456789" → "123456789"\n * "term_XYZ789" → "XYZ789"\n * "puz_abc123" → "abc123"\n * "ccp_def456" → "def456"\n * "ABC123XY" → "ABC123XY"\n */\nexport function toRawId(gameId: string): string {\n  return gameId.replace(/^(li_|cc_|term_|puz_|ccp_)/, \'\');\n}\n\n/**\n * Load known game IDs from database ONCE with hard timeout\n * Subsequent calls return immediately.\n */\nexport async function initKnownIds(): Promise<void> {\n  if (isInitialized) return;\n  \n  // Prevent multiple parallel init calls\n  if (initPromise) {\n    await initPromise;\n    return;\n  }\n  \n  initPromise = (async () => {\n    console.log(`[${VERSION}] Loading known IDs (max ${MAX_PAGES * PAGE_SIZE})...`);\n    const startTime = Date.now();\n    \n    // v7.16: Hard timeout on entire init\n    const timeoutId = setTimeout(() => {\n      isInitialized = true;\n      console.log(`[${VERSION}] Init timeout, loaded ${knownGameIds.size} IDs`);\n    }, INIT_TIMEOUT_MS);\n    \n    try {\n      for (let page = 0; page < MAX_PAGES; page++) {\n        if (isInitialized) break; // Timeout triggered\n        \n        const from = page * PAGE_SIZE;\n        \n        try {\n          // v7.16: Per-page timeout using AbortController pattern\n          const controller = new AbortController();\n          const pageTimeout = setTimeout(() => controller.abort(), PAGE_TIMEOUT_MS);\n          \n          const { data, error } = await supabase\n            .from(\'chess_prediction_attempts\')\n            .select(\'game_id\')\n            .range(from, from + PAGE_SIZE - 1);\n          \n          clearTimeout(pageTimeout);\n          \n          if (error || !data || data.length === 0) break;\n          \n          for (const row of data) {\n            if (row.game_id) {\n              knownGameIds.add(toRawId(row.game_id));\n            }\n          }\n          \n          // If less than full page, we\'re done\n          if (data.length < PAGE_SIZE) break;\n          \n        } catch (err) {\n          console.warn(`[${VERSION}] Page ${page} error:`, err);\n          break;\n        }\n      }\n    } finally {\n      clearTimeout(timeoutId);\n      isInitialized = true;\n    }\n    \n    console.log(`[${VERSION}] Loaded ${knownGameIds.size} IDs in ${Date.now() - startTime}ms`);\n  })();\n  \n  await initPromise;\n}\n\n/**\n * THE CORE FUNCTION\n * \n * Is this game ID already in our system?\n * YES → reject (return true)\n * NO → accept (return false)\n */\nexport function isKnown(gameId: string): boolean {\n  const rawId = toRawId(gameId);\n  return knownGameIds.has(rawId);\n}\n\n/**\n * Mark a game as known (after successful processing)\n */\nexport function markKnown(gameId: string): void {\n  const rawId = toRawId(gameId);\n  knownGameIds.add(rawId);\n}\n\n/**\n * Get count of known IDs\n */\nexport function getKnownCount(): number {\n  return knownGameIds.size;\n}\n\n/**\n * Get the set directly (for passing to fetchers)\n */\nexport function getKnownIds(): Set<string> {\n  return knownGameIds;\n}\n\n/**\n * Reset for testing\n */\nexport function resetKnownIds(): void {\n  knownGameIds = new Set();\n  isInitialized = false;\n  initPromise = null;\n  console.log(`[${VERSION}] Known IDs reset`);\n}\n\n/**\n * Filter a batch of game IDs, returning only fresh ones\n */\nexport function filterFreshGames<T extends { gameId?: string; id?: string }>(\n  games: T[]\n): T[] {\n  return games.filter(game => {\n    const gameId = game.gameId || game.id;\n    if (!gameId) return false;\n    return !isKnown(gameId);\n  });\n}\n';export{n as default};
