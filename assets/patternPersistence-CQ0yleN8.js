const e="/**\n * Pattern Persistence Layer\n * \n * Handles saving and loading Color Flow patterns to/from Supabase\n * for cross-user pattern learning and trajectory prediction.\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport { \n  ColorFlowSignature, \n  StrategicArchetype,\n  extractColorFlowSignature \n} from './colorFlowAnalysis';\nimport { GameData, simulateGame } from './gameSimulator';\nimport { generateGameHash } from '@/lib/visualizations/gameCanonical';\n\nexport interface PersistedPattern {\n  id: string;\n  fingerprint: string;\n  archetype: StrategicArchetype;\n  outcome: 'white_wins' | 'black_wins' | 'draw';\n  total_moves: number;\n  characteristics: PatternCharacteristics;\n  opening_eco?: string;\n  game_metadata?: GameMetadata;\n  pgn_hash?: string;\n  created_at: string;\n  created_by?: string;\n}\n\ninterface PatternCharacteristics {\n  flowDirection: string;\n  intensity: number;\n  volatility: number;\n  dominantSide: string;\n  centerControl: number;\n  kingsideActivity: number;\n  queensideActivity: number;\n}\n\ninterface GameMetadata {\n  event?: string;\n  white?: string;\n  black?: string;\n  date?: string;\n}\n\n/**\n * Save a pattern to the database\n */\nexport async function savePattern(\n  signature: ColorFlowSignature,\n  outcome: 'white_wins' | 'black_wins' | 'draw',\n  gameData: GameData,\n  totalMoves: number,\n  pgnHash?: string\n): Promise<{ success: boolean; patternId?: string; error?: string }> {\n  try {\n    const characteristics: PatternCharacteristics = {\n      flowDirection: signature.flowDirection,\n      intensity: signature.intensity,\n      volatility: signature.temporalFlow.volatility,\n      dominantSide: signature.dominantSide,\n      centerControl: signature.quadrantProfile.center,\n      kingsideActivity: (signature.quadrantProfile.kingsideWhite + signature.quadrantProfile.kingsideBlack) / 2,\n      queensideActivity: (signature.quadrantProfile.queensideWhite + signature.quadrantProfile.queensideBlack) / 2,\n    };\n\n    const gameMetadata: GameMetadata = {\n      event: gameData.event,\n      white: gameData.white,\n      black: gameData.black,\n      date: gameData.date,\n    };\n\n    const { data, error } = await supabase\n      .from('color_flow_patterns')\n      .insert([{\n        fingerprint: signature.fingerprint,\n        archetype: signature.archetype as string,\n        outcome: outcome as string,\n        total_moves: totalMoves,\n        characteristics: JSON.parse(JSON.stringify(characteristics)),\n        game_metadata: JSON.parse(JSON.stringify(gameMetadata)),\n        pgn_hash: pgnHash,\n      }])\n      .select('id')\n      .single();\n\n    if (error) {\n      console.error('Error saving pattern:', error);\n      return { success: false, error: error.message };\n    }\n\n    return { success: true, patternId: data.id };\n  } catch (err) {\n    console.error('Pattern save error:', err);\n    return { success: false, error: 'Failed to save pattern' };\n  }\n}\n\n/**\n * Find similar patterns in the database\n */\nexport async function findSimilarPatterns(\n  signature: ColorFlowSignature,\n  limit: number = 10\n): Promise<PersistedPattern[]> {\n  try {\n    // First, fetch patterns with the same archetype\n    const { data: sameArchetype, error: archetypeError } = await supabase\n      .from('color_flow_patterns')\n      .select('*')\n      .eq('archetype', signature.archetype)\n      .limit(limit);\n\n    if (archetypeError) {\n      console.error('Error fetching patterns:', archetypeError);\n      return [];\n    }\n\n    // Also fetch patterns with related archetypes\n    const relatedArchetypes = getRelatedArchetypes(signature.archetype);\n    let relatedPatterns: PersistedPattern[] = [];\n\n    if (relatedArchetypes.length > 0) {\n      const { data: related, error: relatedError } = await supabase\n        .from('color_flow_patterns')\n        .select('*')\n        .in('archetype', relatedArchetypes)\n        .limit(Math.floor(limit / 2));\n\n      if (!relatedError && related) {\n        relatedPatterns = related.map(row => ({\n          ...row,\n          characteristics: row.characteristics as unknown as PatternCharacteristics,\n          game_metadata: row.game_metadata as unknown as GameMetadata,\n          archetype: row.archetype as StrategicArchetype,\n          outcome: row.outcome as 'white_wins' | 'black_wins' | 'draw',\n        })) as PersistedPattern[];\n      }\n    }\n\n    // Combine and deduplicate\n    const sameArchetypeTyped = (sameArchetype || []).map(row => ({\n      ...row,\n      characteristics: row.characteristics as unknown as PatternCharacteristics,\n      game_metadata: row.game_metadata as unknown as GameMetadata,\n      archetype: row.archetype as StrategicArchetype,\n      outcome: row.outcome as 'white_wins' | 'black_wins' | 'draw',\n    })) as PersistedPattern[];\n    \n    const allPatterns = [...sameArchetypeTyped, ...relatedPatterns];\n    const uniquePatterns = allPatterns.filter(\n      (pattern, index, self) => self.findIndex(p => p.id === pattern.id) === index\n    );\n\n    // Sort by similarity (calculated client-side for now)\n    const scored = uniquePatterns.map(pattern => ({\n      pattern,\n      similarity: calculateSimilarity(signature, pattern.characteristics),\n    }));\n\n    scored.sort((a, b) => b.similarity - a.similarity);\n\n    return scored.slice(0, limit).map(s => s.pattern);\n  } catch (err) {\n    console.error('Pattern search error:', err);\n    return [];\n  }\n}\n\n/**\n * Load all patterns for local caching\n */\nexport async function loadPatternBatch(\n  archetype?: StrategicArchetype,\n  limit: number = 100\n): Promise<PersistedPattern[]> {\n  try {\n    let query = supabase\n      .from('color_flow_patterns')\n      .select('*')\n      .order('created_at', { ascending: false })\n      .limit(limit);\n\n    if (archetype) {\n      query = query.eq('archetype', archetype);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      console.error('Error loading patterns:', error);\n      return [];\n    }\n\n    return (data || []).map(row => ({\n      ...row,\n      characteristics: row.characteristics as unknown as PatternCharacteristics,\n      game_metadata: row.game_metadata as unknown as GameMetadata,\n      archetype: row.archetype as StrategicArchetype,\n      outcome: row.outcome as 'white_wins' | 'black_wins' | 'draw',\n    })) as PersistedPattern[];\n  } catch (err) {\n    console.error('Pattern load error:', err);\n    return [];\n  }\n}\n\n/**\n * Learn from a completed game and persist the pattern\n */\nexport async function learnAndPersistPattern(\n  pgn: string,\n  outcome: 'white_wins' | 'black_wins' | 'draw'\n): Promise<{ success: boolean; patternId?: string; error?: string }> {\n  try {\n    // Generate hash to avoid duplicates\n    const pgnHash = generateGameHash(pgn);\n\n    // Check if pattern already exists for this game\n    const { data: existing } = await supabase\n      .from('color_flow_patterns')\n      .select('id')\n      .eq('pgn_hash', pgnHash)\n      .single();\n\n    if (existing) {\n      return { success: true, patternId: existing.id };\n    }\n\n    // Simulate the game and extract signature\n    const simulation = simulateGame(pgn);\n    const signature = extractColorFlowSignature(\n      simulation.board,\n      simulation.gameData,\n      simulation.totalMoves\n    );\n\n    // Save to database\n    return await savePattern(\n      signature,\n      outcome,\n      simulation.gameData,\n      simulation.totalMoves,\n      pgnHash\n    );\n  } catch (err) {\n    console.error('Learn and persist error:', err);\n    return { success: false, error: 'Failed to learn pattern' };\n  }\n}\n\n/**\n * Get pattern database statistics\n */\nexport async function getPatternStats(): Promise<{\n  totalPatterns: number;\n  byArchetype: Record<string, number>;\n  byOutcome: Record<string, number>;\n}> {\n  try {\n    const { count: total } = await supabase\n      .from('color_flow_patterns')\n      .select('*', { count: 'exact', head: true });\n\n    const { data: archetypeCounts } = await supabase\n      .from('color_flow_patterns')\n      .select('archetype');\n\n    const { data: outcomeCounts } = await supabase\n      .from('color_flow_patterns')\n      .select('outcome');\n\n    const byArchetype: Record<string, number> = {};\n    const byOutcome: Record<string, number> = {};\n\n    archetypeCounts?.forEach(row => {\n      byArchetype[row.archetype] = (byArchetype[row.archetype] || 0) + 1;\n    });\n\n    outcomeCounts?.forEach(row => {\n      byOutcome[row.outcome] = (byOutcome[row.outcome] || 0) + 1;\n    });\n\n    return {\n      totalPatterns: total || 0,\n      byArchetype,\n      byOutcome,\n    };\n  } catch (err) {\n    console.error('Stats error:', err);\n    return { totalPatterns: 0, byArchetype: {}, byOutcome: {} };\n  }\n}\n\n// Helper functions\n\nfunction getRelatedArchetypes(archetype: StrategicArchetype): StrategicArchetype[] {\n  const relations: Record<StrategicArchetype, StrategicArchetype[]> = {\n    kingside_attack: ['sacrificial_attack', 'open_tactical'],\n    queenside_expansion: ['positional_squeeze', 'closed_maneuvering'],\n    central_domination: ['piece_harmony', 'positional_squeeze'],\n    prophylactic_defense: ['closed_maneuvering', 'endgame_technique'],\n    pawn_storm: ['kingside_attack', 'opposite_castling'],\n    piece_harmony: ['central_domination', 'positional_squeeze'],\n    opposite_castling: ['kingside_attack', 'pawn_storm'],\n    closed_maneuvering: ['prophylactic_defense', 'positional_squeeze'],\n    open_tactical: ['sacrificial_attack', 'kingside_attack'],\n    endgame_technique: ['prophylactic_defense', 'positional_squeeze'],\n    sacrificial_attack: ['open_tactical', 'kingside_attack'],\n    positional_squeeze: ['central_domination', 'closed_maneuvering'],\n    unknown: [],\n  };\n  return relations[archetype] || [];\n}\n\nfunction calculateSimilarity(\n  signature: ColorFlowSignature,\n  characteristics: PatternCharacteristics\n): number {\n  let score = 0;\n\n  // Flow direction match (25 points)\n  if (signature.flowDirection === characteristics.flowDirection) {\n    score += 25;\n  } else if (areFlowsRelated(signature.flowDirection, characteristics.flowDirection)) {\n    score += 12;\n  }\n\n  // Intensity similarity (20 points)\n  const intensityDiff = Math.abs(signature.intensity - characteristics.intensity);\n  score += Math.max(0, 20 - intensityDiff / 2);\n\n  // Volatility similarity (15 points)\n  const volatilityDiff = Math.abs(signature.temporalFlow.volatility - characteristics.volatility);\n  score += Math.max(0, 15 - volatilityDiff / 3);\n\n  // Dominant side match (20 points)\n  if (signature.dominantSide === characteristics.dominantSide) {\n    score += 20;\n  } else if (signature.dominantSide === 'contested' || characteristics.dominantSide === 'contested') {\n    score += 10;\n  }\n\n  // Center control similarity (10 points)\n  const centerDiff = Math.abs(signature.quadrantProfile.center - characteristics.centerControl);\n  score += Math.max(0, 10 - centerDiff / 5);\n\n  // Side activity similarity (10 points)\n  const kingsideActivity = (signature.quadrantProfile.kingsideWhite + signature.quadrantProfile.kingsideBlack) / 2;\n  const kingsideDiff = Math.abs(kingsideActivity - characteristics.kingsideActivity);\n  score += Math.max(0, 5 - kingsideDiff / 10);\n\n  const queensideActivity = (signature.quadrantProfile.queensideWhite + signature.quadrantProfile.queensideBlack) / 2;\n  const queensideDiff = Math.abs(queensideActivity - characteristics.queensideActivity);\n  score += Math.max(0, 5 - queensideDiff / 10);\n\n  return Math.round(score);\n}\n\nfunction areFlowsRelated(a: string, b: string): boolean {\n  const related: Record<string, string[]> = {\n    kingside: ['central', 'diagonal'],\n    queenside: ['central', 'diagonal'],\n    central: ['kingside', 'queenside', 'balanced'],\n    balanced: ['central'],\n    diagonal: ['kingside', 'queenside'],\n  };\n  return related[a]?.includes(b) || false;\n}\n";export{e as default};
