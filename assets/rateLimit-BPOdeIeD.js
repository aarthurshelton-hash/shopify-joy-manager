const n="import { supabase } from '@/integrations/supabase/client';\n\ninterface RateLimitResult {\n  allowed: boolean;\n  remaining?: number;\n  blocked_until?: string;\n  retry_after?: number;\n}\n\n// Local in-memory cache for rate limiting (reduces DB calls)\nconst localCache = new Map<string, { count: number; resetAt: number }>();\n\n/**\n * Check if a request should be rate limited\n * Uses local cache first, then falls back to database for persistence\n */\nexport async function checkRateLimit(\n  identifier: string,\n  endpoint: string,\n  maxRequests: number = 100,\n  windowSeconds: number = 60\n): Promise<RateLimitResult> {\n  const cacheKey = `${identifier}:${endpoint}`;\n  const now = Date.now();\n  \n  // Check local cache first (faster)\n  const cached = localCache.get(cacheKey);\n  if (cached) {\n    if (now < cached.resetAt) {\n      if (cached.count >= maxRequests) {\n        return {\n          allowed: false,\n          retry_after: Math.ceil((cached.resetAt - now) / 1000),\n        };\n      }\n      cached.count++;\n      return {\n        allowed: true,\n        remaining: maxRequests - cached.count,\n      };\n    } else {\n      // Window expired, reset\n      localCache.delete(cacheKey);\n    }\n  }\n  \n  // Initialize new window in local cache\n  localCache.set(cacheKey, {\n    count: 1,\n    resetAt: now + (windowSeconds * 1000),\n  });\n  \n  // For persistent tracking (abuse detection), also log to database\n  // This runs in background and doesn't block the request\n  logRateLimitCheck(identifier, endpoint, maxRequests, windowSeconds).catch(() => {\n    // Silently fail - rate limiting should not break the app\n  });\n  \n  return {\n    allowed: true,\n    remaining: maxRequests - 1,\n  };\n}\n\n/**\n * Log rate limit check to database for persistence and abuse tracking\n */\nasync function logRateLimitCheck(\n  identifier: string,\n  endpoint: string,\n  maxRequests: number,\n  windowSeconds: number\n): Promise<void> {\n  try {\n    await supabase.rpc('check_rate_limit', {\n      p_identifier: identifier,\n      p_endpoint: endpoint,\n      p_max_requests: maxRequests,\n      p_window_seconds: windowSeconds,\n    });\n  } catch (error) {\n    // Log but don't throw\n    console.warn('Rate limit logging failed:', error);\n  }\n}\n\n/**\n * Generate a hash for anonymous users based on available identifiers\n */\nexport function getAnonymousIdentifier(): string {\n  const fingerprint = [\n    navigator.userAgent,\n    navigator.language,\n    new Date().getTimezoneOffset(),\n    screen.width,\n    screen.height,\n    screen.colorDepth,\n  ].join('|');\n  \n  // Simple hash function\n  let hash = 0;\n  for (let i = 0; i < fingerprint.length; i++) {\n    const char = fingerprint.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  \n  return `anon_${Math.abs(hash).toString(36)}`;\n}\n\n/**\n * Higher-order function to wrap API calls with rate limiting\n */\nexport function withRateLimit<T extends (...args: unknown[]) => Promise<unknown>>(\n  fn: T,\n  endpoint: string,\n  maxRequests: number = 30,\n  windowSeconds: number = 60\n): T {\n  return (async (...args: Parameters<T>) => {\n    const identifier = getAnonymousIdentifier();\n    const result = await checkRateLimit(identifier, endpoint, maxRequests, windowSeconds);\n    \n    if (!result.allowed) {\n      throw new RateLimitError(\n        `Rate limit exceeded. Try again in ${result.retry_after} seconds.`,\n        result.retry_after || 60\n      );\n    }\n    \n    return fn(...args);\n  }) as T;\n}\n\n/**\n * Custom error class for rate limiting\n */\nexport class RateLimitError extends Error {\n  retryAfter: number;\n  \n  constructor(message: string, retryAfter: number) {\n    super(message);\n    this.name = 'RateLimitError';\n    this.retryAfter = retryAfter;\n  }\n}\n\n/**\n * Rate limit configurations for different endpoints\n */\nexport const RATE_LIMITS = {\n  // Sensitive operations\n  auth: { maxRequests: 5, windowSeconds: 60 },\n  payment: { maxRequests: 10, windowSeconds: 60 },\n  \n  // Standard operations\n  api: { maxRequests: 100, windowSeconds: 60 },\n  search: { maxRequests: 30, windowSeconds: 60 },\n  \n  // Heavy operations\n  download: { maxRequests: 20, windowSeconds: 60 },\n  upload: { maxRequests: 10, windowSeconds: 60 },\n  \n  // Public endpoints\n  publicView: { maxRequests: 200, windowSeconds: 60 },\n  \n  // Marketplace operations\n  listing: { maxRequests: 15, windowSeconds: 60 },\n  offer: { maxRequests: 20, windowSeconds: 60 },\n  \n  // Vision operations\n  save: { maxRequests: 10, windowSeconds: 60 },\n  scan: { maxRequests: 30, windowSeconds: 60 },\n  \n  // Benchmark operations (CPU-intensive, limit concurrent runs)\n  benchmark: { maxRequests: 5, windowSeconds: 300 }, // 5 runs per 5 minutes\n} as const;\n\n/**\n * Clean up expired entries from local cache (call periodically)\n */\nexport function cleanupLocalCache(): void {\n  const now = Date.now();\n  for (const [key, value] of localCache.entries()) {\n    if (now >= value.resetAt) {\n      localCache.delete(key);\n    }\n  }\n}\n\n// Auto-cleanup every 5 minutes\nif (typeof window !== 'undefined') {\n  setInterval(cleanupLocalCache, 5 * 60 * 1000);\n}";export{n as default};
