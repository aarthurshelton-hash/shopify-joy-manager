const n="/**\n * Unified Multi-Asset Data Pipeline\n * \n * Aggregates real-time data from IBKR, options flow, macro indicators,\n * and sentiment feeds into a unified stream for strategy engines.\n */\n\nimport { ASSET_CLASSES, DATA_SOURCES } from './multiAssetConfig';\n\ninterface MarketDataPoint {\n  timestamp: string;\n  symbol: string;\n  assetClass: string;\n  price: number;\n  change: number;\n  volume: number;\n  iv?: number;              // Implied volatility (options)\n  delta?: number;           // Greeks for options\n  gamma?: number;\n  theta?: number;\n  vega?: number;\n  openInterest?: number;\n  unusualFlow?: boolean;    // Options flow alert\n  sentiment?: number;       // -1 to 1 sentiment score\n  macroScore?: number;      // Macro regime indicator\n  correlationBeta?: number; // Cross-asset correlation\n}\n\ninterface MacroRegime {\n  timestamp: string;\n  vix: number;\n  vixTermStructure: number; // Contango/backwardation\n  yieldCurve: { '2Y': number; '10Y': number; slope: number };\n  creditSpread: number;     // HYG/LQD spread\n  dxy: number;              // Dollar strength\n  fedPolicy: 'hawkish' | 'dovish' | 'neutral';\n  marketRegime: 'risk_on' | 'risk_off' | 'neutral' | 'crisis';\n}\n\ninterface OptionsFlowAlert {\n  timestamp: string;\n  symbol: string;\n  type: 'sweep' | 'block' | 'unusual_volume' | 'whale';\n  strike: number;\n  expiration: string;\n  side: 'call' | 'put';\n  size: number;\n  premium: number;\n  sentiment: 'bullish' | 'bearish' | 'neutral';\n  confidence: number;\n}\n\nexport class UnifiedDataPipeline {\n  private subscribers: Map<string, ((data: MarketDataPoint) => void)[]> = new Map();\n  private macroCache: MacroRegime | null = null;\n  private optionsFlowQueue: OptionsFlowAlert[] = [];\n  private correlationMatrix: Map<string, Map<string, number>> = new Map();\n  private lastUpdate: Map<string, number> = new Map();\n  \n  private readonly UPDATE_INTERVAL_MS = 1000;\n  private readonly MACRO_UPDATE_INTERVAL_MS = 60000;\n  \n  constructor(private ibkrClient: any, private supabase: any) {}\n  \n  async start() {\n    console.log('[DataPipeline] Starting unified data pipeline...');\n    \n    // Start data streams\n    this.startPriceStream();\n    this.startOptionsFlowStream();\n    this.startMacroStream();\n    this.startSentimentStream();\n    this.startCorrelationEngine();\n    \n    console.log('[DataPipeline] All streams active');\n  }\n  \n  private async startPriceStream() {\n    const allSymbols = this.getAllSymbols();\n    \n    setInterval(async () => {\n      try {\n        // Batch quote request to IBKR\n        const quotes = await this.ibkrClient.getBatchQuotes(allSymbols.slice(0, 50));\n        \n        for (const quote of quotes) {\n          const dataPoint: MarketDataPoint = {\n            timestamp: new Date().toISOString(),\n            symbol: quote.symbol,\n            assetClass: this.classifyAsset(quote.symbol),\n            price: quote.lastPrice,\n            change: quote.change,\n            volume: quote.volume,\n          };\n          \n          // Enrich with options data if available\n          if (this.hasOptions(quote.symbol)) {\n            const optionsData = await this.getOptionsData(quote.symbol);\n            Object.assign(dataPoint, optionsData);\n          }\n          \n          this.broadcast(quote.symbol, dataPoint);\n        }\n      } catch (err) {\n        console.error('[DataPipeline] Price stream error:', err);\n      }\n    }, this.UPDATE_INTERVAL_MS);\n  }\n  \n  private async startOptionsFlowStream() {\n    // Poll options flow APIs\n    setInterval(async () => {\n      try {\n        const flowAlerts = await this.fetchOptionsFlow();\n        \n        for (const alert of flowAlerts) {\n          this.optionsFlowQueue.push(alert);\n          \n          // Trim queue to last 1000 alerts\n          if (this.optionsFlowQueue.length > 1000) {\n            this.optionsFlowQueue.shift();\n          }\n          \n          // Broadcast to subscribers\n          const dataPoint: MarketDataPoint = {\n            timestamp: alert.timestamp,\n            symbol: alert.symbol,\n            assetClass: 'OPTIONS_FLOW',\n            price: 0,\n            change: 0,\n            volume: alert.size,\n            unusualFlow: true,\n            sentiment: alert.sentiment === 'bullish' ? 1 : alert.sentiment === 'bearish' ? -1 : 0,\n          };\n          \n          this.broadcast(alert.symbol, dataPoint);\n        }\n      } catch (err) {\n        console.error('[DataPipeline] Options flow error:', err);\n      }\n    }, 5000);\n  }\n  \n  private async startMacroStream() {\n    setInterval(async () => {\n      try {\n        // Fetch VIX\n        const vixQuote = await this.ibkrClient.getQuote(27618703); // VIX futures conid\n        \n        // Fetch Treasury yields via FRED or IBKR\n        const yields = await this.fetchTreasuryYields();\n        \n        // Fetch DXY\n        const dxyQuote = await this.ibkrClient.getQuote(27823923); // UUP conid\n        \n        // Calculate credit spread (HYG - LQD proxy)\n        const hyg = await this.ibkrClient.getQuote(9775249);\n        const lqd = await this.ibkrClient.getQuote(9775248);\n        \n        this.macroCache = {\n          timestamp: new Date().toISOString(),\n          vix: vixQuote?.lastPrice || 20,\n          vixTermStructure: this.calculateVIXTermStructure(),\n          yieldCurve: yields,\n          creditSpread: (hyg?.lastPrice || 0) - (lqd?.lastPrice || 0),\n          dxy: dxyQuote?.lastPrice || 100,\n          fedPolicy: this.inferFedPolicy(yields),\n          marketRegime: this.classifyMarketRegime(vixQuote?.lastPrice || 20, yields),\n        };\n        \n        // Store in Supabase\n        await this.supabase.from('macro_regime').insert(this.macroCache);\n        \n      } catch (err) {\n        console.error('[DataPipeline] Macro stream error:', err);\n      }\n    }, this.MACRO_UPDATE_INTERVAL_MS);\n  }\n  \n  private async startSentimentStream() {\n    // Social media sentiment aggregation\n    setInterval(async () => {\n      try {\n        const symbols = ASSET_CLASSES.EQUITIES.symbols.US.slice(0, 10);\n        \n        for (const symbol of symbols) {\n          const sentiment = await this.fetchSocialSentiment(symbol);\n          \n          if (Math.abs(sentiment) > 0.3) { // Significant sentiment\n            const dataPoint: MarketDataPoint = {\n              timestamp: new Date().toISOString(),\n              symbol,\n              assetClass: 'EQUITIES',\n              price: 0,\n              change: 0,\n              volume: 0,\n              sentiment,\n            };\n            \n            this.broadcast(symbol, dataPoint);\n          }\n        }\n      } catch (err) {\n        console.error('[DataPipeline] Sentiment stream error:', err);\n      }\n    }, 30000);\n  }\n  \n  private async startCorrelationEngine() {\n    // Calculate rolling correlations every 5 minutes\n    setInterval(async () => {\n      try {\n        await this.updateCorrelationMatrix();\n      } catch (err) {\n        console.error('[DataPipeline] Correlation engine error:', err);\n      }\n    }, 300000);\n  }\n  \n  private async updateCorrelationMatrix() {\n    const symbols = this.getAllSymbols().slice(0, 20);\n    const returns: Map<string, number[]> = new Map();\n    \n    // Fetch 30-day price history for each symbol\n    for (const symbol of symbols) {\n      const history = await this.ibkrClient.getHistoricalData(symbol, '30d');\n      const dailyReturns = this.calculateReturns(history);\n      returns.set(symbol, dailyReturns);\n    }\n    \n    // Calculate correlation matrix\n    for (const sym1 of symbols) {\n      const row = new Map<string, number>();\n      for (const sym2 of symbols) {\n        if (sym1 === sym2) {\n          row.set(sym2, 1.0);\n        } else {\n          const corr = this.calculateCorrelation(\n            returns.get(sym1) || [],\n            returns.get(sym2) || []\n          );\n          row.set(sym2, corr);\n        }\n      }\n      this.correlationMatrix.set(sym1, row);\n    }\n  }\n  \n  subscribe(symbol: string, callback: (data: MarketDataPoint) => void) {\n    if (!this.subscribers.has(symbol)) {\n      this.subscribers.set(symbol, []);\n    }\n    this.subscribers.get(symbol)!.push(callback);\n  }\n  \n  unsubscribe(symbol: string, callback: (data: MarketDataPoint) => void) {\n    const callbacks = this.subscribers.get(symbol);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx > -1) callbacks.splice(idx, 1);\n    }\n  }\n  \n  private broadcast(symbol: string, data: MarketDataPoint) {\n    const callbacks = this.subscribers.get(symbol);\n    if (callbacks) {\n      callbacks.forEach(cb => {\n        try {\n          cb(data);\n        } catch (err) {\n          console.error('[DataPipeline] Subscriber error:', err);\n        }\n      });\n    }\n  }\n  \n  getMacroRegime(): MacroRegime | null {\n    return this.macroCache;\n  }\n  \n  getRecentOptionsFlow(symbol: string, minutes: number = 30): OptionsFlowAlert[] {\n    const cutoff = Date.now() - minutes * 60000;\n    return this.optionsFlowQueue.filter(\n      alert => alert.symbol === symbol && new Date(alert.timestamp).getTime() > cutoff\n    );\n  }\n  \n  getCorrelation(sym1: string, sym2: string): number {\n    return this.correlationMatrix.get(sym1)?.get(sym2) || 0;\n  }\n  \n  private getAllSymbols(): string[] {\n    return [\n      ...ASSET_CLASSES.EQUITIES.symbols.US,\n      ...ASSET_CLASSES.EQUITIES.symbols.INTL,\n      ...ASSET_CLASSES.EQUITIES.symbols.SECTORS,\n      ...ASSET_CLASSES.BONDS.symbols,\n      ...ASSET_CLASSES.FOREX.pairs,\n      ...ASSET_CLASSES.COMMODITIES.symbols,\n    ];\n  }\n  \n  private classifyAsset(symbol: string): string {\n    if (ASSET_CLASSES.EQUITIES.symbols.US.includes(symbol)) return 'EQUITIES_US';\n    if (ASSET_CLASSES.BONDS.symbols.includes(symbol)) return 'BONDS';\n    if (ASSET_CLASSES.FOREX.pairs.includes(symbol)) return 'FOREX';\n    if (ASSET_CLASSES.COMMODITIES.symbols.includes(symbol)) return 'COMMODITIES';\n    return 'UNKNOWN';\n  }\n  \n  private hasOptions(symbol: string): boolean {\n    return ASSET_CLASSES.OPTIONS.underlying.includes(symbol);\n  }\n  \n  private async getOptionsData(symbol: string): Promise<Partial<MarketDataPoint>> {\n    // Fetch ATM options chain and calculate IV\n    try {\n      const chain = await this.ibkrClient.getOptionsChain(symbol);\n      const atmOption = chain.find((o: any) => Math.abs(o.delta) > 0.45 && Math.abs(o.delta) < 0.55);\n      \n      if (atmOption) {\n        return {\n          iv: atmOption.impliedVol,\n          delta: atmOption.delta,\n          gamma: atmOption.gamma,\n          theta: atmOption.theta,\n          vega: atmOption.vega,\n          openInterest: atmOption.openInterest,\n        };\n      }\n    } catch (err) {\n      console.warn('[DataPipeline] Options data fetch failed for', symbol);\n    }\n    return {};\n  }\n  \n  private async fetchOptionsFlow(): Promise<OptionsFlowAlert[]> {\n    // Placeholder - integrate with Unusual Whales or similar\n    // For now, return empty array\n    return [];\n  }\n  \n  private async fetchTreasuryYields(): Promise<{ '2Y': number; '10Y': number; slope: number }> {\n    // Use IBKR bond data or FRED API\n    try {\n      // SHY (2Y) and TLT (20Y) as proxies\n      const shy = await this.ibkrClient.getQuote(9775242);\n      const tlt = await this.ibkrClient.getQuote(9775241);\n      \n      const yield2Y = (100 - (shy?.lastPrice || 99)) * 2; // Rough estimate\n      const yield10Y = (100 - (tlt?.lastPrice || 90)) * 1.5;\n      \n      return {\n        '2Y': Math.max(0, yield2Y),\n        '10Y': Math.max(0, yield10Y),\n        slope: yield10Y - yield2Y,\n      };\n    } catch (err) {\n      return { '2Y': 4.5, '10Y': 4.0, slope: -0.5 };\n    }\n  }\n  \n  private calculateVIXTermStructure(): number {\n    // Simplified - would use VIX futures curve\n    return 0; // 0 = flat, positive = contango, negative = backwardation\n  }\n  \n  private inferFedPolicy(yields: { slope: number }): 'hawkish' | 'dovish' | 'neutral' {\n    if (yields.slope < -0.5) return 'hawkish';\n    if (yields.slope > 1.0) return 'dovish';\n    return 'neutral';\n  }\n  \n  private classifyMarketRegime(vix: number, yields: { slope: number }): 'risk_on' | 'risk_off' | 'neutral' | 'crisis' {\n    if (vix > 35) return 'crisis';\n    if (vix > 25 || yields.slope < -1) return 'risk_off';\n    if (vix < 15 && yields.slope > 0) return 'risk_on';\n    return 'neutral';\n  }\n  \n  private async fetchSocialSentiment(symbol: string): Promise<number> {\n    // Placeholder - would integrate with Twitter/Reddit APIs\n    return 0;\n  }\n  \n  private calculateReturns(prices: number[]): number[] {\n    const returns: number[] = [];\n    for (let i = 1; i < prices.length; i++) {\n      returns.push((prices[i] - prices[i-1]) / prices[i-1]);\n    }\n    return returns;\n  }\n  \n  private calculateCorrelation(x: number[], y: number[]): number {\n    const n = Math.min(x.length, y.length);\n    if (n < 2) return 0;\n    \n    const sumX = x.slice(0, n).reduce((a, b) => a + b, 0);\n    const sumY = y.slice(0, n).reduce((a, b) => a + b, 0);\n    const sumXY = x.slice(0, n).reduce((sum, xi, i) => sum + xi * y[i], 0);\n    const sumX2 = x.slice(0, n).reduce((sum, xi) => sum + xi * xi, 0);\n    const sumY2 = y.slice(0, n).reduce((sum, yi) => sum + yi * yi, 0);\n    \n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n    \n    return denominator === 0 ? 0 : numerator / denominator;\n  }\n}\n";export{n as default};
