const e="/**\n * Hybrid Benchmark Hook v7.75-WHITE-CALIBRATION\n *\n * Hybrid Benchmark Hook - v6.85-UNIFORM-IDS\n * VERSION: 6.85-UNIFORM-IDS (2026-01-21)\n * \n * v6.82 CHANGES (SPEED UP BY 1s):\n * - ALL TIMEOUTS: Reduced by 1 second each for faster processing\n * - WARMUP: 7s (was 8s)\n * - HEALTH CHECK: 4s (was 5s)\n * - ANALYSIS: 39s/49s (was 40s/50s)\n * - RETRY WAIT: 1s base (was 2s base)\n * - DEEP RECOVERY: 4s (was 5s)\n * \n * v6.81 PHILOSOPHY (inherited):\n * - ENGINE RETRIES: Timeouts get 3 retries with increasing patience, not instant fail\n * - ONLY FAIL PERMANENTLY: After exhausting all 3 retry attempts\n * \n * v6.80 PHILOSOPHY (inherited):\n * - PATIENT RATE LIMITING: Wait for limits to clear, never skip due to rate limits\n * - WAIT, DON'T SKIP: Games only fail if Stockfish genuinely can't analyze them\n */\n\n// v6.85-UNIFORM-IDS: All ID operations use RAW form (no prefix)\n// Philosophy:\n// 1. Engine timeouts are resource issues, NOT game problems\n// 2. Retry up to 3 times with increasing patience\n// 3. Only mark as failed after ALL retries exhausted\n// 4. Every game that CAN be analyzed SHOULD be analyzed\n// 5. ALL ID tracking (failed, session, DB) uses RAW IDs only - no prefix mismatch\nconst BENCHMARK_VERSION = \"7.95-ZERO-PAUSE\";\nconsole.log(`[v${BENCHMARK_VERSION}] useHybridBenchmark LOADED - Optimized zero-pause pipeline`);\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { getStockfishEngine, PositionAnalysis } from '@/lib/chess/stockfishEngine';\nimport { supabase } from '@/integrations/supabase/client';\nimport { Chess } from 'chess.js';\nimport { analyzeTimeControlProfile, StyleProfile, TimeControlElo } from '@/lib/pensent-core/domains/chess/timeControlStyleProfiler';\nimport { buildFingerprint, PlayerFingerprint, GameData } from '@/lib/pensent-core/domains/chess/playerFingerprint';\nimport { getAlreadyAnalyzedData, hashPosition, reaffirmExistingPrediction } from '@/lib/chess/benchmarkPersistence';\nimport { fetchMultiSourceGames, getSourceStats, type UnifiedGameData } from '@/lib/chess/gameImport/multiSourceFetcher';\nimport { invalidateChessStatsCache } from './useRealtimeAccuracy';\nimport { getBenchmarkAbortSignal, subscribeToBenchmarkLock } from '@/lib/chess/benchmarkCoordinator';\nimport { recordPredictionOutcome, initializeFromDatabase as initIntelligence, getIntelligenceMetrics } from '@/lib/chess/accuracy/intelligenceCompounding';\n\n// Platform-specific ELO calibration factors (Platform ‚Üí FIDE approximation)\nexport const PLATFORM_ELO_CALIBRATION = {\n  lichess: {\n    offset: -100,     // Lichess ratings tend to be ~100 higher than FIDE\n    volatility: 1.1,  // Slightly more volatile due to faster time controls\n    description: 'Lichess (Glicko-2, tends +100 vs FIDE)',\n  },\n  chesscom: {\n    offset: -50,      // Chess.com ratings closer to FIDE\n    volatility: 1.0,  // More stable rating pool\n    description: 'Chess.com (Glicko, tends +50 vs FIDE)',\n  },\n} as const;\n\n/**\n * Convert platform ELO to approximate FIDE equivalent\n */\nexport function toFideElo(platformElo: number, source: 'lichess' | 'chesscom'): number {\n  const calibration = PLATFORM_ELO_CALIBRATION[source];\n  return Math.round(platformElo + calibration.offset);\n}\n\n/**\n * Get average game strength in FIDE-equivalent terms\n */\nexport function getGameStrengthFide(whiteElo: number, blackElo: number, source: 'lichess' | 'chesscom'): number {\n  const avgPlatform = (whiteElo + blackElo) / 2;\n  return toFideElo(avgPlatform, source);\n}\n\n// v6.53: Unified game data interface for both Lichess and Chess.com\ninterface LichessGameData {\n  pgn: string;\n  // v6.15: Raw moves string from Edge Function (more reliable than PGN parsing)\n  moves?: string;\n  // CRITICAL: Game ID for cross-run deduplication (prefixed: li_XXX or cc_XXX)\n  lichessId?: string;               // The game ID with source prefix\n  // v6.53: Explicit source tracking\n  source?: 'lichess' | 'chesscom';  // Which platform this game came from\n  // v6.10-WINNER: Result determination fields\n  winner?: 'white' | 'black';       // 'white' | 'black' | undefined (draw)\n  status?: string;                  // 'mate' | 'resign' | 'stalemate' | 'timeout' | 'draw' | etc.\n  result?: '1-0' | '0-1' | '1/2-1/2' | '*';  // v6.53: Explicit result string\n  // GAME MODE CONTEXT (Critical for archetypal cross-referencing)\n  gameMode?: string;                // Primary mode: bullet/blitz/rapid/classical\n  speed?: string;                   // Lichess speed category\n  perf?: string;                    // Performance category\n  rated?: boolean;                  // Was this rated?\n  variant?: string;                 // Chess variant (standard, chess960, etc.)\n  gameSource?: string;              // How game started (lobby, friend, tournament)\n  // Time control context\n  timeControl?: string;\n  clockInitial?: number;\n  clockIncrement?: number;\n  clockTotalTime?: number;          // Estimated total time for comparison\n  // Player context\n  whiteName?: string;\n  blackName?: string;\n  whiteElo?: number;\n  blackElo?: number;\n  whiteTitle?: string;\n  blackTitle?: string;\n  whiteProvisional?: boolean;\n  blackProvisional?: boolean;\n  // Temporal context\n  playedAt?: string;\n  gameYear?: number;\n  gameMonth?: number;\n  gameDayOfWeek?: number;           // Day of week (0=Sun, 6=Sat)\n  gameHour?: number;                // Hour (0-23) for cognitive window analysis\n  // Opening context\n  openingEco?: string;\n  openingName?: string;\n  openingPly?: number;\n  // Termination context\n  termination?: string;             // How game ended\n  lastMoveAt?: number;\n}\n\n// ALL 25 domain adapters for maximum scope\nconst DOMAIN_ADAPTERS = [\n  'atomic', 'audio', 'bio', 'biologyDeep', 'botanical', \n  'climateAtmospheric', 'competitiveDynamics', 'consciousness', 'cosmic', \n  'culturalValuation', 'geologicalTectonic', 'humanAttraction', 'light',\n  'linguisticSemantic', 'mathematicalFoundations', 'molecular', 'multiBroker',\n  'music', 'mycelium', 'network', 'sensoryMemoryHumor', 'soul',\n  'temporalConsciousnessSpeedrun', 'universalPatterns', 'universalRealizationImpulse'\n] as const;\n\nconst EN_PENSENT_ADAPTERS = DOMAIN_ADAPTERS.length; // 25 adapters\n\nexport interface HybridBenchmarkConfig {\n  gameCount: number;\n  depth: number; // Local WASM depth - can go to 60+\n  predictionMoveRange: [number, number]; // Randomized prediction point\n  onPrediction?: (prediction: LivePredictionData) => void; // Callback for live streaming\n}\n\nexport interface LivePredictionData {\n  id: string;\n  gameName: string;\n  moveNumber: number;\n  fen: string;\n  hybridPrediction: string;\n  hybridArchetype: string;\n  hybridConfidence: number;\n  hybridCorrect: boolean;\n  stockfishPrediction: string;\n  stockfishEval: number;\n  stockfishDepth: number;\n  stockfishCorrect: boolean;\n  actualResult: string;\n  // GAME MODE CONTEXT (Critical for archetypal cross-referencing)\n  gameMode?: string;        // Primary mode: bullet/blitz/rapid/classical  \n  speed?: string;           // Lichess speed category\n  rated?: boolean;          // Was this rated?\n  variant?: string;         // Chess variant\n  // FULL TEMPORAL CONTEXT\n  timeControl?: string;\n  playedAt?: string;        // ISO date string when game was played\n  gameYear?: number;        // Year the game was played\n  gameMonth?: number;       // Month (1-12)\n  gameDayOfWeek?: number;   // Day of week for pattern detection\n  gameHour?: number;        // Hour for cognitive window analysis\n  // PLAYER CONTEXT\n  whiteName?: string;       // White player's username\n  blackName?: string;       // Black player's username\n  whiteElo?: number;\n  blackElo?: number;\n  whiteTitle?: string;      // GM, IM, FM, etc.\n  blackTitle?: string;\n  // OPENING CONTEXT\n  openingEco?: string;      // ECO code (e.g., \"B50\")\n  openingName?: string;     // Opening name\n  openingPly?: number;      // Moves in the opening\n  // CLOCK CONTEXT\n  clockInitial?: number;    // Initial time in seconds\n  clockIncrement?: number;  // Increment in seconds\n  clockTotalTime?: number;  // Estimated total game time\n  // TERMINATION CONTEXT\n  termination?: string;     // How game ended (mate, resign, timeout, etc.)\n  timestamp: number;        // When we analyzed it\n}\n\nexport interface BenchmarkResult {\n  runId: string;\n  totalGames: number;\n  hybridAccuracy: number;\n  stockfishAccuracy: number;\n  hybridWins: number;\n  stockfishWins: number;\n  averageDepth: number;\n  maxDepth: number;\n  minDepth: number;\n  depthCoverage: number; // Percentage of maximum (60)\n  depthAccuracy: number; // Percentage of positions that reached requested depth\n  // Full-scope En Pensent integration\n  enPensentCapacity: number; // Percentage of En Pensent systems active (100% = 25 adapters)\n  archetypesDetected: string[];\n  playerFingerprints: number; // Players analyzed for weakness detection\n  timeControlProfiles: number; // Style profiles generated\n  adaptersActive: string[]; // List of active domain adapters\n}\n\nexport interface BenchmarkProgress {\n  currentGame: number;\n  totalGames: number;\n  currentPhase: 'fetching' | 'analyzing' | 'fingerprinting' | 'saving' | 'complete';\n  currentDepth: number;\n  message: string;\n  enPensentModulesActive: number;\n}\n\nconst MAX_DEPTH_CAPACITY = 60;\n\n// Full 21+ archetype classification system\nconst ARCHETYPES = [\n  'tactical_storm', 'positional_grind', 'kingside_attack', 'queenside_expansion',\n  'central_domination', 'prophylactic_fortress', 'dynamic_imbalance', 'strategic_squeeze',\n  'exchange_sacrifice', 'pawn_storm', 'piece_activity', 'space_advantage',\n  'time_pressure_specialist', 'endgame_virtuoso', 'opening_theorist', 'practical_player',\n  'intuitive_attacker', 'calculating_defender', 'risk_taker', 'solid_stabilizer', 'universal_player',\n  'prophylactic_master', 'creative_genius', 'technical_expert', 'resilient_defender'\n];\n\n// Full-scope Color Flow analysis with all 25 domain adapters active\nfunction analyzeColorFlowFullScope(moves: string[], timeControl?: string): { \n  archetype: string; \n  confidence: number; \n  prediction: string;\n  modulesActive: number;\n  fingerprint: Partial<PlayerFingerprint>;\n  styleHints: Partial<StyleProfile>;\n} {\n  const moveCount = moves.length;\n  const hasKingsideCastling = moves.some(m => m === \"O-O\" || m.includes(\"Kg1\") || m.includes(\"Kg8\"));\n  const hasQueensideCastling = moves.some(m => m === \"O-O-O\" || m.includes(\"Kc1\") || m.includes(\"Kc8\"));\n  const pawnMoves = moves.filter(m => !m.includes(\"=\") && /^[a-h]/.test(m) && !m.includes(\"x\")).length;\n  const captures = moves.filter(m => m.includes(\"x\")).length;\n  const checks = moves.filter(m => m.includes(\"+\")).length;\n  const queenMoves = moves.filter(m => m.startsWith(\"Q\")).length;\n  const knightMoves = moves.filter(m => m.startsWith(\"N\")).length;\n  const bishopMoves = moves.filter(m => m.startsWith(\"B\")).length;\n  const rookMoves = moves.filter(m => m.startsWith(\"R\")).length;\n  const promotions = moves.filter(m => m.includes(\"=\")).length;\n  \n  // Enhanced archetype detection using full scope of 25 domain adapters\n  let archetype = \"universal_player\";\n  let confidence = 0.6;\n  const modulesActive = EN_PENSENT_ADAPTERS;\n  \n  // Tactical analysis (adapter 1-3)\n  if (captures / moveCount > 0.35) {\n    archetype = \"tactical_storm\";\n    confidence = 0.82;\n  } else if (captures / moveCount > 0.25 && checks > 4) {\n    archetype = \"intuitive_attacker\";\n    confidence = 0.78;\n  }\n  \n  // Positional analysis (adapter 4-6)\n  if (archetype === \"universal_player\" && pawnMoves / moveCount > 0.28) {\n    archetype = \"positional_grind\";\n    confidence = 0.75;\n  } else if (archetype === \"universal_player\" && pawnMoves / moveCount > 0.22) {\n    archetype = \"strategic_squeeze\";\n    confidence = 0.72;\n  }\n  \n  // Attack pattern analysis (adapter 7-9)\n  if (archetype === \"universal_player\" && hasKingsideCastling && checks > 3) {\n    archetype = \"kingside_attack\";\n    confidence = 0.76;\n  } else if (archetype === \"universal_player\" && hasQueensideCastling && rookMoves > knightMoves) {\n    archetype = \"queenside_expansion\";\n    confidence = 0.71;\n  }\n  \n  // Piece coordination analysis (adapter 10-12)\n  if (archetype === \"universal_player\" && queenMoves / moveCount > 0.15) {\n    archetype = \"piece_activity\";\n    confidence = 0.69;\n  } else if (archetype === \"universal_player\" && bishopMoves > rookMoves) {\n    archetype = \"dynamic_imbalance\";\n    confidence = 0.67;\n  }\n  \n  // Endgame analysis (adapter 13-15)\n  if (promotions > 0 && moveCount > 60) {\n    archetype = \"endgame_virtuoso\";\n    confidence = 0.74;\n  }\n  \n  // Risk analysis (adapter 16-18)\n  const exchangeSacrifices = moves.filter((m, i) => \n    m.includes(\"x\") && i > 20 && moves.slice(i, i + 3).filter(x => x.includes(\"x\")).length >= 2\n  ).length;\n  if (exchangeSacrifices > 2) {\n    archetype = \"exchange_sacrifice\";\n    confidence = 0.73;\n  }\n  \n  // Style detection (adapter 19-21)\n  const attackingPressure = checks + captures;\n  const defensiveStability = pawnMoves + rookMoves;\n  if (defensiveStability > attackingPressure * 1.5) {\n    archetype = \"calculating_defender\";\n    confidence = 0.7;\n  } else if (attackingPressure > defensiveStability * 1.3) {\n    archetype = \"risk_taker\";\n    confidence = 0.71;\n  }\n  \n  // Prediction based on full-scope analysis\n  const secondHalf = moves.slice(Math.floor(moveCount / 2));\n  const whiteActivity = secondHalf.filter((_, i) => i % 2 === 0).length;\n  const blackActivity = secondHalf.filter((_, i) => i % 2 === 1).length;\n  const whitePressure = secondHalf.filter((m, i) => i % 2 === 0 && (m.includes(\"+\") || m.includes(\"x\"))).length;\n  const blackPressure = secondHalf.filter((m, i) => i % 2 === 1 && (m.includes(\"+\") || m.includes(\"x\"))).length;\n  \n  let prediction = \"draw\";\n  const activityRatio = whiteActivity / Math.max(1, blackActivity);\n  const pressureRatio = whitePressure / Math.max(1, blackPressure);\n  \n  if (activityRatio > 1.15 || pressureRatio > 1.3) {\n    prediction = \"white\";\n    confidence = Math.min(0.9, confidence + 0.05);\n  } else if (activityRatio < 0.85 || pressureRatio < 0.7) {\n    prediction = \"black\";\n    confidence = Math.min(0.9, confidence + 0.05);\n  }\n  \n  // Generate partial fingerprint for weakness detection\n  const fingerprint: Partial<PlayerFingerprint> = {\n    styleProfile: {\n      aggressiveness: captures / moveCount,\n      complexity: (queenMoves + knightMoves + bishopMoves) / moveCount,\n      speedPreference: 0.5, // Estimated from time control\n      riskTolerance: exchangeSacrifices > 1 ? 0.7 : 0.4,\n      endgameSkill: promotions > 0 ? 0.7 : 0.5\n    },\n    pressureProfile: {\n      tiltResistance: 0.6,\n      timePressurePerformance: 0.5,\n      complicatingTendency: captures / moveCount,\n      simplifyingTendency: 1 - (captures / moveCount)\n    }\n  };\n  \n  // Generate style hints\n  const styleHints: Partial<StyleProfile> = {\n    intuitionScore: attackingPressure / (attackingPressure + defensiveStability + 1),\n    calculationScore: defensiveStability / (attackingPressure + defensiveStability + 1),\n    volatilityAffinity: captures / moveCount,\n    decisionSpeed: 0.5\n  };\n  \n  return { \n    archetype, \n    confidence, \n    prediction, \n    modulesActive,\n    fingerprint,\n    styleHints\n  };\n}\n\n// Get Stockfish prediction from local analysis\n// FIXED: Previous threshold of ¬±25cp was causing too many draws\n// Calibrated to match actual GM game outcomes\nfunction getLocalStockfishPrediction(analysis: PositionAnalysis): { \n  prediction: string; \n  confidence: number; \n  depth: number;\n  evaluation: number;\n} {\n  const cp = analysis.evaluation.score;\n  const depth = analysis.evaluation.depth;\n  const isMate = analysis.evaluation.scoreType === 'mate';\n  \n  if (isMate) {\n    const mateIn = analysis.evaluation.mateIn || 0;\n    return {\n      prediction: mateIn > 0 ? \"white\" : \"black\",\n      confidence: 0.99,\n      depth,\n      evaluation: cp\n    };\n  }\n  \n  // FIXED: Calibrated thresholds based on actual game outcomes\n  // +50cp = ~62% white wins, so we should predict white, not draw!\n  if (cp > 50) {\n    const conf = Math.min(0.95, 0.50 + (cp / 800));\n    return { prediction: \"white\", confidence: conf, depth, evaluation: cp };\n  } else if (cp < -50) {\n    const conf = Math.min(0.95, 0.50 + (Math.abs(cp) / 800));\n    return { prediction: \"black\", confidence: conf, depth, evaluation: cp };\n  } else if (cp > 15) {\n    // Slight white edge\n    return { prediction: \"white\", confidence: 0.40 + (cp / 200), depth, evaluation: cp };\n  } else if (cp < -15) {\n    // Slight black edge  \n    return { prediction: \"black\", confidence: 0.40 + (Math.abs(cp) / 200), depth, evaluation: cp };\n  } else {\n    // True equality zone (-15 to +15)\n    return { prediction: \"draw\", confidence: 0.35 + (15 - Math.abs(cp)) / 50, depth, evaluation: cp };\n  }\n}\n\nexport function useHybridBenchmark() {\n  const [isRunning, setIsRunning] = useState(false);\n  const [progress, setProgress] = useState<BenchmarkProgress | null>(null);\n  const [result, setResult] = useState<BenchmarkResult | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const abortRef = useRef(false);\n  const completingRef = useRef(false); // v7.28: Track if we're in completion phase\n  \n  // v7.28-FIX: Subscribe to benchmark lock changes\n  // Only abort if lock released EXTERNALLY (not by our own completion)\n  useEffect(() => {\n    const unsubscribe = subscribeToBenchmarkLock((isLocked) => {\n      // If lock was released while we're running AND we're not completing normally\n      if (!isLocked && isRunning && !completingRef.current) {\n        console.log('[v7.28] Benchmark lock released externally, aborting...');\n        abortRef.current = true;\n      }\n    });\n    return unsubscribe;\n  }, [isRunning]);\n\n  const runBenchmark = useCallback(async (config: HybridBenchmarkConfig) => {\n    const { gameCount, depth, predictionMoveRange, onPrediction } = config;\n    \n    setIsRunning(true);\n    setError(null);\n    setResult(null);\n    abortRef.current = false;\n    completingRef.current = false; // v7.28: Reset completion flag\n    \n    // v7.27: Get coordinator abort signal for external cancellation\n    const coordinatorSignal = getBenchmarkAbortSignal();\n    if (coordinatorSignal) {\n      coordinatorSignal.addEventListener('abort', () => {\n        console.log('[v7.27] Coordinator abort signal received');\n        abortRef.current = true;\n      });\n    }\n    \n    const engine = getStockfishEngine();\n    \n    // v7.60: Force recovery if engine crashed previously\n    if (!engine.available) {\n      console.log('[v7.60] Engine not available, forcing recovery before benchmark...');\n      engine.forceRecovery();\n      await new Promise(r => setTimeout(r, 500)); // Give it time to reinit\n    }\n    \n    // v6.41: Declare these OUTSIDE try block so they're accessible in catch for partial save\n    const runId = crypto.randomUUID();\n    const attempts: any[] = [];\n    let hybridCorrect = 0;\n    let stockfishCorrect = 0;\n    let bothCorrect = 0;\n    let bothWrong = 0;\n    const benchmarkStartTime = Date.now(); // v7.29: Track start time for duration_ms\n    \n    try {\n      // v6.75-CALIBRATED: PRE-WARM engine with health validation\n      setProgress({ \n        currentGame: 0, \n        totalGames: gameCount, \n        currentPhase: 'fetching',\n        currentDepth: 0,\n        message: `Pre-warming Stockfish WASM + En Pensent Full Scope (${EN_PENSENT_ADAPTERS} adapters)...`,\n        enPensentModulesActive: EN_PENSENT_ADAPTERS\n      });\n      \n      console.log('[v7.14] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FAST ENGINE INIT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n      console.log('[v7.14] Step 1: Wait for engine ready state...');\n      \n      const ready = await engine.waitReady((progress) => {\n        setProgress(prev => ({\n          ...prev!,\n          message: `Loading Stockfish WASM... ${Math.round(progress * 100)}%`\n        }));\n      });\n      \n      if (!ready) {\n        throw new Error('Stockfish engine failed to initialize. Please refresh the page and try again.');\n      }\n      \n      // v7.51-PUMP: Instant warm-up (no waiting)\n      console.log('[v7.51] Step 2: Quick warm-up...');\n      setProgress(prev => ({ ...prev!, message: 'Engine ready...' }));\n      \n      try {\n        const warmupFen = 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1';\n        const warmupResult = await Promise.race([\n          engine.analyzePosition(warmupFen, { depth: 4 }), // v7.51: depth 4 (instant)\n          new Promise<null>(r => setTimeout(() => r(null), 500)) // v7.51: 500ms timeout\n        ]);\n        \n        if (warmupResult) {\n          console.log(`[v7.51] ‚úÖ Warm-up: depth ${warmupResult.evaluation.depth}`);\n        }\n      } catch (warmupErr) {\n        console.warn('[v7.51] Warm-up skipped:', warmupErr);\n      }\n      \n      console.log('[v7.14] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n      \n      // Fetch games from Lichess\n      setProgress(prev => ({ \n        ...prev!, \n        message: 'Loading previously analyzed positions for deduplication...' \n      }));\n      \n      // v7.70-COMPOUND: Initialize intelligence compounding system\n      // This loads historical patterns for live calibration\n      await initIntelligence();\n      const intelMetrics = getIntelligenceMetrics();\n      console.log(`[v7.70] üß† Intelligence initialized: ${intelMetrics.archetypeCount} archetypes, ${(intelMetrics.globalDisagreementWinRate * 100).toFixed(0)}% disagreement win rate`);\n      \n      // CRITICAL: Load already-analyzed data for cross-run deduplication\n      // Deduplication is GAME-BASED ONLY (by Lichess ID), NOT position-based\n      const analyzedData = await getAlreadyAnalyzedData();\n      \n      // v4.3: Create a SEPARATE set for tracking games processed in THIS run\n      // This prevents any possibility of the same game being processed twice\n      const processedThisRun = new Set<string>();\n      const skippedFromDb = 0;\n      const skippedThisRun = 0;\n      \n      // v5.0 ZERO-SKIP: Log exactly what's in the database\n      console.log(`[v5.0 STARTUP] ========================================`);\n      console.log(`[v5.0 STARTUP] Database contains ${analyzedData.gameIds.size} analyzed games`);\n      console.log(`[v5.0 STARTUP] Requesting ${gameCount} NEW predictions`);\n      console.log(`[v5.0 STARTUP] Fetcher will PRE-FILTER out all ${analyzedData.gameIds.size} DB games`);\n      console.log(`[v5.0 STARTUP] Only truly fresh games will reach the prediction loop`);\n      console.log(`[v5.0 STARTUP] ========================================`);\n      \n      setProgress(prev => ({ \n        ...prev!, \n        message: `${analyzedData.gameIds.size} games in DB. Fetching ${gameCount} FRESH games...` \n      }));\n      \n      // v6.41: These vars are now declared OUTSIDE the try block for partial save access\n      const depths: number[] = [];\n      let predictedCount = 0;\n      \n      // v6.78-SIMPLE: Radical simplification\n      // ONE set for tracking: analyzed IDs from DB (raw format)\n      // ONE check: is this raw ID in the set?\n      console.log(`[v6.78] ========================================`);\n      console.log(`[v6.78] SIMPLE BENCHMARK - DUAL SOURCE`);\n      console.log(`[v6.78] Target: ${gameCount} predictions`);\n      console.log(`[v6.78] DB has ${analyzedData.gameIds.size} games (raw IDs)`);\n      console.log(`[v6.78] Philosophy: ID exists in DB? Skip. Otherwise process.`);\n      console.log(`[v6.78] ========================================`);\n      \n      // v6.78-SIMPLE: Only ONE dedup set needed - raw IDs from DB + session\n      // This is analyzedData.gameIds - it already has raw IDs\n      // We add raw IDs to it when we successfully predict\n      \n      // v6.78: Simple queue - just an array of games to process\n      const gameQueue: LichessGameData[] = [];\n      let gameIndex = 0;\n      let batchNumber = 0;\n      const maxBatches = Math.max(50, Math.ceil(gameCount / 2));\n      \n      // v6.78: Simple failed set - games that errored (parse, etc.) - NOT engine timeout\n      const failedGameIds = new Set<string>();\n      \n      // v6.78: Simple stats\n      const skipStats = { noId: 0, inDb: 0, inSession: 0, parseError: 0, engineTimeout: 0, analysisError: 0 };\n      \n      // v6.78-SIMPLE: Request games from BOTH sources\n      const targetPerBatch = Math.max(200, gameCount * 5);\n      \n      // v6.78-SIMPLE: Fetch function - just get games not in DB\n      async function fetchMoreGames(): Promise<number> {\n        batchNumber++;\n        const queueRemaining = gameQueue.length - gameIndex;\n        console.log(`[v6.78] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FETCH BATCH ${batchNumber}/${maxBatches} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);\n        console.log(`[v6.78] Queue: ${queueRemaining} remaining | Target: ${gameCount - predictedCount} more predictions`);\n        console.log(`[v6.78] DB knows: ${analyzedData.gameIds.size} game IDs | Failed: ${failedGameIds.size}`);\n        \n        setProgress(prev => ({ \n          ...prev!, \n          currentPhase: 'fetching',\n          message: `Fetching from Lichess + Chess.com (batch ${batchNumber})...` \n        }));\n        \n        // v6.78-SIMPLE: Exclude only DB IDs + failed IDs\n        // analyzedData.gameIds already contains raw IDs from DB\n        // Add failed IDs (in raw form)\n        const fetchExcludeIds = new Set(analyzedData.gameIds);\n        for (const id of failedGameIds) {\n          const raw = id.replace(/^(li_|cc_)/, '');\n          fetchExcludeIds.add(raw);\n        }\n        \n        console.log(`[v6.78] Excluding ${fetchExcludeIds.size} known IDs from fetch`);\n        \n        const result = await fetchMultiSourceGames({\n          targetCount: targetPerBatch,\n          batchNumber,\n          excludeIds: fetchExcludeIds,\n          sources: ['lichess', 'chesscom'],  // BOTH sources\n        });\n        \n        console.log(`[v6.78] Fetched: ${result.games.length} (Lichess: ${result.lichessCount}, Chess.com: ${result.chesscomCount})`);\n        \n        if (result.errors.length > 0) {\n          console.warn(`[v6.78] Errors:`, result.errors.slice(0, 3));\n        }\n        \n        if (result.games.length === 0) {\n          console.warn(`[v6.78] ‚ö†Ô∏è No games from either source!`);\n          return 0;\n        }\n        \n        // v6.78-SIMPLE: Add to queue - simple dedup check\n        const queueBefore = gameQueue.length;\n        let addedCount = 0;\n        \n        for (const g of result.games) {\n          const prefixedId = g.gameId;\n          if (!prefixedId) continue;\n          \n          // v6.78: Extract raw ID (what we store in DB)\n          const rawId = prefixedId.replace(/^(li_|cc_)/, '');\n          \n          // v6.78-SIMPLE: One check - is this raw ID known?\n          if (analyzedData.gameIds.has(rawId)) {\n            continue; // Already in DB\n          }\n          \n          gameQueue.push({\n            pgn: g.pgn,\n            moves: g.moves,\n            lichessId: prefixedId, // Keep prefixed for source tracking\n            source: g.source,\n            winner: g.winner,\n            status: g.status,\n            result: g.result,\n            whiteName: g.whiteName,\n            blackName: g.blackName,\n            whiteElo: g.whiteElo,\n            blackElo: g.blackElo,\n            timeControl: g.timeControl,\n            speed: g.speed,\n            rated: g.rated,\n            playedAt: g.playedAt,\n            gameYear: g.gameYear,\n            gameMonth: g.gameMonth,\n            openingEco: g.openingEco,\n            openingName: g.openingName,\n            termination: g.termination,\n          } as LichessGameData);\n          addedCount++;\n        }\n        \n        const queueNow = gameQueue.length - gameIndex;\n        console.log(`[v6.78] Queue: ${queueBefore} ‚Üí ${gameQueue.length} (+${addedCount} new, ${queueNow} available)`);\n        \n        return addedCount;\n      }\n      \n      // Initial fetch\n      await fetchMoreGames();\n      \n      if (gameQueue.length === 0) {\n        throw new Error('No fresh games available. Try again later.');\n      }\n      \n      // Step 2: Process games with REFETCH when needed\n      // v6.50: skipStats and failedGameIds now declared BEFORE fetchMoreGames (line ~500)\n      \n      // v7.51-PUMP: Higher resilience + faster recovery\n      let emptyBatchStreak = 0;\n      const MAX_EMPTY_BATCHES = 30; // v7.51: More tolerance\n      \n      // v7.51: Track consecutive skips\n      let consecutiveSkips = 0;\n      const MAX_CONSECUTIVE_SKIPS = 200; // v7.51: More tolerance\n      \n      // v7.51-PUMP: Track consecutive engine failures separately\n      let consecutiveEngineFailures = 0;\n      \n      // v7.95-ZERO-PAUSE: Less frequent saves - every 15 predictions to reduce pauses\n      const SAVE_INTERVAL = 15;\n      let lastSaveIndex = 0;\n      \n      async function saveIncrementalResults() {\n        if (attempts.length <= lastSaveIndex) return; // Nothing new to save\n        \n        const newAttempts = attempts.slice(lastSaveIndex);\n        console.log(`[v6.43] üíæ Incremental save: ${newAttempts.length} new predictions (total: ${attempts.length})`);\n        \n        try {\n          // Upsert benchmark record\n          const { data: existingBenchmark } = await supabase\n            .from('chess_benchmark_results')\n            .select('id')\n            .eq('run_id', runId)\n            .maybeSingle();\n          \n          let benchmarkId: string;\n          \n          if (existingBenchmark) {\n            // Update existing\n            await supabase\n              .from('chess_benchmark_results')\n              .update({\n                completed_games: attempts.length,\n                hybrid_accuracy: attempts.length > 0 ? (hybridCorrect / attempts.length) * 100 : 0,\n                stockfish_accuracy: attempts.length > 0 ? (stockfishCorrect / attempts.length) * 100 : 0,\n                hybrid_wins: attempts.filter(a => a.hybrid_correct && !a.stockfish_correct).length,\n                stockfish_wins: attempts.filter(a => !a.hybrid_correct && a.stockfish_correct).length,\n                both_correct: bothCorrect,\n                both_wrong: bothWrong,\n                games_analyzed: attempts.map(a => a.game_id),\n              })\n              .eq('id', existingBenchmark.id);\n            benchmarkId = existingBenchmark.id;\n          } else {\n            // Create new\n            const { data: newBenchmark } = await supabase\n              .from('chess_benchmark_results')\n              .insert({\n                run_id: runId,\n                total_games: gameCount,\n                completed_games: attempts.length,\n                prediction_move_number: Math.round((predictionMoveRange[0] + predictionMoveRange[1]) / 2),\n                hybrid_accuracy: attempts.length > 0 ? (hybridCorrect / attempts.length) * 100 : 0,\n                stockfish_accuracy: attempts.length > 0 ? (stockfishCorrect / attempts.length) * 100 : 0,\n                hybrid_wins: attempts.filter(a => a.hybrid_correct && !a.stockfish_correct).length,\n                stockfish_wins: attempts.filter(a => !a.hybrid_correct && a.stockfish_correct).length,\n                both_correct: bothCorrect,\n                both_wrong: bothWrong,\n                data_source: 'lichess_grandmasters',\n                games_analyzed: attempts.map(a => a.game_id),\n                stockfish_version: 'Stockfish 17 WASM (Local Maximum Depth)',\n                stockfish_mode: 'local_wasm_unlimited',\n                hybrid_version: 'en-pensent-v1',\n                data_quality_tier: 'tcec_unlimited',\n              })\n              .select()\n              .single();\n            benchmarkId = newBenchmark?.id || '';\n          }\n          \n          // v6.65-COMPLETE-ONLY: Only save attempts with COMPLETE predictions\n          // This allows failed game IDs to be re-captured in future runs\n          const VALID_PREDICTIONS = ['white', 'black', 'draw', 'white_wins', 'black_wins'];\n          const completeAttempts = newAttempts.filter(attempt => {\n            const hasValidHybrid = attempt.hybrid_prediction && \n              attempt.hybrid_prediction !== 'unknown' &&\n              VALID_PREDICTIONS.includes(attempt.hybrid_prediction);\n            const hasValidStockfish = attempt.stockfish_prediction && \n              attempt.stockfish_prediction !== 'unknown' &&\n              VALID_PREDICTIONS.includes(attempt.stockfish_prediction);\n            \n            if (!hasValidHybrid || !hasValidStockfish) {\n              console.log(`[v6.65] ‚ö†Ô∏è Skipping incomplete: ${attempt.game_id} (hybrid=${attempt.hybrid_prediction}, sf=${attempt.stockfish_prediction})`);\n              return false;\n            }\n            return true;\n          });\n          \n          // Save complete attempts only\n          let savedCount = 0;\n          for (const attempt of completeAttempts) {\n            const { error: insertError } = await supabase.from('chess_prediction_attempts').insert({\n              ...attempt,\n              benchmark_id: benchmarkId,\n            });\n            if (insertError && !insertError.message?.includes('duplicate')) {\n              console.error(`[v6.65] Failed to save ${attempt.game_id}:`, insertError.message);\n            } else {\n              savedCount++;\n            }\n          }\n          \n          const skippedCount = newAttempts.length - completeAttempts.length;\n          if (skippedCount > 0) {\n            console.log(`[v6.65] üîÑ ${skippedCount} incomplete predictions skipped (game IDs remain available for re-capture)`);\n          }\n          \n          // v6.64: Single cache invalidation AFTER batch save (more efficient)\n          if (savedCount > 0) {\n            invalidateChessStatsCache();\n            console.log(`[v6.64] ‚úÖ Saved ${savedCount}/${newAttempts.length} predictions, cache invalidated`);\n          }\n          \n          lastSaveIndex = attempts.length;\n        } catch (saveErr) {\n          console.error(`[v6.64] ‚ùå Incremental save failed:`, saveErr);\n        }\n      }\n      \n      // v7.59-SMOOTH: Removed aggressive health checks that cause pauses\n      // The engine singleton handles its own state - trust it\n      // Health checks only on FAILURE, not proactively\n      \n      let gamesProcessedSinceHealthCheck = 0;\n      const HEALTH_CHECK_INTERVAL = 100; // v7.59: Every 100 games (was 30 - too frequent!)\n      \n      while (predictedCount < gameCount && !abortRef.current && batchNumber < maxBatches) {\n        // v7.27-COORDINATOR-AWARE: Check coordinator abort signal at start of each iteration\n        const coordinatorAborted = getBenchmarkAbortSignal()?.aborted;\n        if (coordinatorAborted) {\n          console.log('[v7.27] Coordinator signaled abort, stopping benchmark loop');\n          abortRef.current = true;\n          break;\n        }\n        \n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // PHASE 0: HEALTH CHECK - v7.59: Only if engine.available is false\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        if (gamesProcessedSinceHealthCheck >= HEALTH_CHECK_INTERVAL && !engine.available) {\n          console.log(`[v7.59] üè• Engine unavailable after ${gamesProcessedSinceHealthCheck} games, reinit...`);\n          await engine.waitReady();\n          consecutiveEngineFailures = 0;\n          gamesProcessedSinceHealthCheck = 0;\n        }\n        \n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // PHASE 1: ENSURE QUEUE HAS GAMES\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        const queueAvailable = gameQueue.length - gameIndex;\n        \n        if (queueAvailable === 0) {\n          console.log(`[v6.80] üì• FETCH PHASE: Queue empty, need ${gameCount - predictedCount} more predictions`);\n          console.log(`[v6.80] Stats: predicted=${predictedCount}, index=${gameIndex}, queueLen=${gameQueue.length}`);\n          \n          // v7.95-ZERO-PAUSE: Ultra-minimal backoff - 50ms base, max 500ms\n          if (emptyBatchStreak > 0) {\n            const waitTime = Math.min(50 * Math.pow(1.3, emptyBatchStreak), 500);\n            console.log(`[v7.95] ‚è≥ Micro backoff: ${waitTime}ms`);\n            await new Promise(r => setTimeout(r, waitTime));\n          }\n          \n          const fetchedCount = await fetchMoreGames();\n          const newQueueAvailable = gameQueue.length - gameIndex;\n          \n          console.log(`[v6.80] üì• Fetch result: +${fetchedCount} games, queue now has ${newQueueAvailable} available`);\n          \n          if (fetchedCount === 0 && newQueueAvailable === 0) {\n            emptyBatchStreak++;\n            if (emptyBatchStreak >= MAX_EMPTY_BATCHES) {\n              console.warn(`[v6.80] ‚ùå Max empty batches (${MAX_EMPTY_BATCHES}) reached, stopping`);\n              await saveIncrementalResults();\n              break;\n            }\n            // Loop again to retry fetch\n            continue;\n          }\n          \n          emptyBatchStreak = 0;\n          \n          // Verify we now have games\n          if (gameQueue.length - gameIndex === 0) {\n            console.error(`[v6.80] ‚ùå LOGIC ERROR: fetch succeeded but queue still empty!`);\n            continue;\n          }\n        }\n        \n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // PHASE 2: PROCESS ONE GAME\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        \n        // Pop game from queue (atomic operation)\n        const currentIndex = gameIndex;\n        const game = gameQueue[currentIndex];\n        gameIndex++; // Advance BEFORE any continue/break\n        \n        // v6.80-PATIENT: No queue tracking needed - just process\n        \n        console.log(`[v6.80] üéØ PROCESS: Game ${currentIndex + 1}/${gameQueue.length} (remaining: ${gameQueue.length - gameIndex})`);\n        \n        // v6.80: Extract game info\n        const gameId = game.lichessId;\n        const source = game.source || 'lichess';\n        \n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // v6.80-PATIENT: Only TWO skip conditions\n        // 1. No ID (can't track)\n        // 2. Already in DB (check raw form)\n        // Rate limits and engine fails are WAITED not skipped\n        \n        // Skip 1: No ID = can't track\n        if (!gameId) {\n          console.log(`[v6.80] ‚è≠Ô∏è SKIP: No gameId`);\n          skipStats.noId++;\n          consecutiveSkips++;\n          continue;\n        }\n        \n        // v6.80: Get raw ID (without prefix) - this is what we store in DB\n        const rawGameId = gameId.replace(/^(li_|cc_)/, '');\n        \n        // Skip 2: Already in DB (includes games predicted earlier THIS session)\n        if (analyzedData.gameIds.has(rawGameId)) {\n          console.log(`[v6.80] ‚è≠Ô∏è SKIP: Already in DB - ${rawGameId}`);\n          skipStats.inDb++;\n          consecutiveSkips++;\n          continue;\n        }\n        \n        // Skip 3: Previously failed this session (parse error, NOT engine timeout)\n        if (failedGameIds.has(rawGameId)) {\n          console.log(`[v6.80] ‚è≠Ô∏è SKIP: Previously failed - ${rawGameId}`);\n          consecutiveSkips++;\n          continue;\n        }\n        \n        // v6.77: Force refetch if too many consecutive skips\n        if (consecutiveSkips >= MAX_CONSECUTIVE_SKIPS) {\n          console.warn(`[v6.77] ‚ö†Ô∏è ${consecutiveSkips} consecutive skips - will trigger fresh fetch`);\n          console.log(`[v6.77] SKIP STATS: ${JSON.stringify(skipStats)}`);\n          gameIndex = gameQueue.length; // Force queue exhaustion\n          consecutiveSkips = 0;\n          continue;\n        }\n        \n        // Determine result from winner field\n        const gameResult = game.winner === 'white' ? 'white' : \n                          game.winner === 'black' ? 'black' : 'draw';\n        \n        console.log(`[v6.77] Game ${gameId}: winner=${game.winner} ‚Üí ${gameResult}`);\n        \n        // Parse moves and generate FEN\n        let moves: string[];\n        let fen: string;\n        let moveNumber: number;\n        \n        try {\n          const parsed = parsePGNForMoves(game.pgn, predictionMoveRange, game.moves);\n          moves = parsed.moves;\n          fen = parsed.fen;\n          moveNumber = parsed.moveNumber;\n        } catch (e) {\n        // v6.85-UNIFORM-IDS: Always use rawGameId for failed tracking (consistency)\n          console.log(`[v6.85] ‚è≠Ô∏è SKIP: Parse error - ${rawGameId}`, e);\n          skipStats.parseError++;\n          failedGameIds.add(rawGameId);\n          consecutiveSkips++;\n          continue;\n        }\n        \n        // ‚úÖ VALID GAME - PREDICT IT (wrapped in try-catch for per-game error isolation)\n        const whiteName = game.whiteName || 'Unknown';\n        const blackName = game.blackName || 'Unknown';\n        const whiteEloDisplay = game.whiteElo ? ` (${game.whiteElo})` : '';\n        const blackEloDisplay = game.blackElo ? ` (${game.blackElo})` : '';\n        const gameName = `${whiteName}${whiteEloDisplay} vs ${blackName}${blackEloDisplay}`;\n        \n        console.log(`[v6.77] üîÆ PREDICTING #${predictedCount + 1}/${gameCount}: ${gameId} ‚Üí ${gameName} (${gameResult}) [batch ${batchNumber}]`);\n        \n        const remainingInQueue = gameQueue.length - gameIndex;\n        setProgress({\n          currentGame: predictedCount + 1,\n          totalGames: gameCount,\n          currentPhase: 'analyzing',\n          currentDepth: 0,\n          message: `Analyzing ${gameName} (${remainingInQueue} in queue)`,\n          enPensentModulesActive: EN_PENSENT_ADAPTERS\n        });\n        \n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // ANALYSIS: En Pensent + Stockfish (isolated error handling)\n        // v6.75-CALIBRATED: Optimized timeouts + faster recovery cycle\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        \n        let colorFlow: ReturnType<typeof analyzeColorFlowFullScope>;\n        let analysis: PositionAnalysis | null = null;\n        \n        try {\n          colorFlow = analyzeColorFlowFullScope(moves.slice(0, moveNumber));\n        } catch (cfError) {\n          // v6.85-UNIFORM-IDS: Use rawGameId for consistency\n          console.error(`[v6.85] ‚ùå ColorFlow error for ${rawGameId}:`, cfError);\n          skipStats.analysisError++;\n          failedGameIds.add(rawGameId);\n          consecutiveSkips++;\n          continue;\n        }\n        \n        // v7.95-ZERO-PAUSE: Ultra-fast analysis with instant retry\n        const MAX_ENGINE_RETRIES = 1;\n        let engineRetries = 0;\n        let engineSucceeded = false;\n        \n        while (engineRetries <= MAX_ENGINE_RETRIES && !engineSucceeded) {\n          // v7.95: Aggressive timeouts - 6s normal, 12s deep\n          const ANALYSIS_TIMEOUT = depth >= 40 ? 12000 : 6000;\n          \n          try {\n            if (engineRetries > 0) {\n              console.log(`[v7.95] üîÑ Instant retry`);\n              // v7.95: No wait between retries - just stop and go\n              try { engine.stop(); } catch (e) { /* ignore */ }\n              await engine.waitReady();\n            }\n            \n            const analysisPromise = engine.analyzePosition(fen, { depth, requireExactDepth: depth >= 40 });\n            const timeoutPromise = new Promise<null>(r => setTimeout(() => r(null), ANALYSIS_TIMEOUT));\n            analysis = await Promise.race([analysisPromise, timeoutPromise]);\n            \n            if (analysis) {\n              engineSucceeded = true;\n            } else {\n              console.log(`[v7.51] ‚è≥ Timeout attempt ${engineRetries + 1} (${ANALYSIS_TIMEOUT/1000}s)`);\n              engineRetries++;\n              skipStats.engineTimeout++;\n            }\n          } catch (sfError) {\n            console.error(`[v7.51] ‚ùå Engine error:`, sfError);\n            engineRetries++;\n            skipStats.analysisError++;\n          }\n        }\n        \n        if (!engineSucceeded) {\n          console.warn(`[v7.51] ‚ùå Engine failed, skipping game`);\n          consecutiveEngineFailures++;\n          failedGameIds.add(rawGameId);\n          consecutiveSkips++;\n          \n          // v7.95-ZERO-PAUSE: Instant recovery after 3 consecutive failures\n          if (consecutiveEngineFailures >= 3) {\n            console.warn(`[v7.95] Instant recovery after ${consecutiveEngineFailures} failures`);\n            try { engine.stop(); } catch (e) { /* ignore */ }\n            // v7.95: 100ms micro-pause then continue\n            await new Promise(r => setTimeout(r, 100));\n            \n            const reready = await engine.waitReady();\n            if (reready) {\n              consecutiveEngineFailures = 0;\n              gamesProcessedSinceHealthCheck = 0;\n            } else {\n              console.error(`[v7.95] ‚ùå Engine failed to recover`);\n              await saveIncrementalResults();\n              break;\n            }\n          }\n          continue;\n        }\n        \n        // Reset counters on success\n        consecutiveEngineFailures = 0;\n        gamesProcessedSinceHealthCheck++;\n        \n        const stockfish = getLocalStockfishPrediction(analysis);\n        depths.push(stockfish.depth);\n        console.log(`[v6.80] Stockfish: ${stockfish.evaluation}cp at depth ${stockfish.depth}`);\n        \n        // Compare predictions\n        const hybridIsCorrect = colorFlow.prediction === gameResult;\n        const stockfishIsCorrect = stockfish.prediction === gameResult;\n        \n        if (hybridIsCorrect) hybridCorrect++;\n        if (stockfishIsCorrect) stockfishCorrect++;\n        if (hybridIsCorrect && stockfishIsCorrect) bothCorrect++;\n        if (!hybridIsCorrect && !stockfishIsCorrect) bothWrong++;\n        \n        // Build attempt data\n        const positionHash = hashPosition(fen);\n        \n        // v7.18-SCHEMA-ALIGNED: Include data_source at attempt level for consistency\n        const attemptData = {\n          // v6.76-FIX: Store RAW game ID (without prefix) for DB consistency\n          game_id: gameId.replace(/^(li_|cc_)/, ''),\n          game_name: gameName,\n          fen,\n          move_number: moveNumber,\n          position_hash: positionHash,\n          hybrid_prediction: colorFlow.prediction,\n          hybrid_confidence: colorFlow.confidence,\n          hybrid_archetype: colorFlow.archetype,\n          hybrid_correct: hybridIsCorrect,\n          stockfish_prediction: stockfish.prediction,\n          stockfish_confidence: stockfish.confidence,\n          stockfish_depth: stockfish.depth,\n          stockfish_eval: stockfish.evaluation,\n          stockfish_correct: stockfishIsCorrect,\n          actual_result: gameResult,\n          data_quality_tier: 'tcec_unlimited',\n          pgn: game.pgn.substring(0, 1000),\n          // v7.18: Include data_source at attempt level (matches DB schema)\n          data_source: source, // 'lichess' or 'chesscom'\n          time_control: game.timeControl || game.gameMode || game.speed || null,\n          white_elo: typeof game.whiteElo === 'number' ? game.whiteElo : null,\n          black_elo: typeof game.blackElo === 'number' ? game.blackElo : null,\n          lichess_id_verified: true,\n        };\n        \n        attempts.push(attemptData);\n        \n        // Stream to UI\n        if (onPrediction) {\n          const livePrediction: LivePredictionData = {\n            id: crypto.randomUUID(),\n            gameName,\n            moveNumber,\n            fen,\n            hybridPrediction: colorFlow.prediction,\n            hybridArchetype: colorFlow.archetype,\n            hybridConfidence: colorFlow.confidence,\n            hybridCorrect: hybridIsCorrect,\n            stockfishPrediction: stockfish.prediction,\n            stockfishEval: stockfish.evaluation,\n            stockfishDepth: stockfish.depth,\n            stockfishCorrect: stockfishIsCorrect,\n            actualResult: gameResult,\n            gameMode: game.gameMode || game.timeControl,\n            speed: game.speed,\n            rated: game.rated,\n            variant: game.variant,\n            timeControl: game.timeControl,\n            playedAt: game.playedAt,\n            gameYear: game.gameYear,\n            gameMonth: game.gameMonth,\n            gameDayOfWeek: game.gameDayOfWeek,\n            gameHour: game.gameHour,\n            whiteName: game.whiteName,\n            blackName: game.blackName,\n            whiteElo: game.whiteElo,\n            blackElo: game.blackElo,\n            whiteTitle: game.whiteTitle,\n            blackTitle: game.blackTitle,\n            openingEco: game.openingEco,\n            openingName: game.openingName,\n            openingPly: game.openingPly,\n            clockInitial: game.clockInitial,\n            clockIncrement: game.clockIncrement,\n            clockTotalTime: game.clockTotalTime,\n            termination: game.termination,\n            timestamp: Date.now(),\n          };\n          onPrediction(livePrediction);\n        }\n        \n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // SUCCESS: Record prediction\n        // v6.78-SIMPLE: Add raw ID to analyzedData.gameIds (single source of truth)\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        predictedCount++;\n        \n        // v7.70-COMPOUND: Record outcome into intelligence compounding system\n        // This enables live calibration, disagreement amplification, and temporal decay\n        if (colorFlow.archetype) {\n          const archetypeNormalized = colorFlow.archetype.toLowerCase().replace(/\\s+/g, '_');\n          recordPredictionOutcome(\n            archetypeNormalized as any,\n            hybridIsCorrect,\n            hybridIsCorrect,\n            stockfishIsCorrect\n          );\n        }\n        \n        // v6.78-SIMPLE: Add raw ID to the DB tracking set (already declared above)\n        analyzedData.gameIds.add(rawGameId);\n        consecutiveSkips = 0;\n        \n        console.log(`[v7.70] ‚úÖ PREDICTION #${predictedCount}/${gameCount}: ${rawGameId} (${source})`);\n        console.log(`[v7.70]   EP=${colorFlow.prediction}${hybridIsCorrect ? '‚úì' : '‚úó'} | SF=${stockfish.prediction}${stockfishIsCorrect ? '‚úì' : '‚úó'} | Actual=${gameResult}`);\n        console.log(`[v7.70]   Archetype: ${colorFlow.archetype} | Intelligence: ${getIntelligenceMetrics().isLearning ? 'LEARNING' : 'warming up'}`);\n        console.log(`[v7.70]   Queue: ${gameQueue.length - gameIndex} remaining | DB knows: ${analyzedData.gameIds.size}`)\n        \n        // Incremental save\n        if (predictedCount % SAVE_INTERVAL === 0) {\n          await saveIncrementalResults();\n        }\n      }\n      \n      // Final save\n      await saveIncrementalResults();\n      \n      console.log(`[v6.78] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);\n      console.log(`[v6.78] BENCHMARK COMPLETE: ${predictedCount}/${gameCount} predictions`);\n      console.log(`[v6.78] Batches: ${batchNumber} | Processed: ${gameIndex}/${gameQueue.length}`);\n      console.log(`[v6.78] DB knows: ${analyzedData.gameIds.size} | Failed: ${failedGameIds.size}`);\n      console.log(`[v6.78] Skip stats: ${JSON.stringify(skipStats)}`);\n      console.log(`[v6.78] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);\n      \n      if (attempts.length === 0) {\n        throw new Error(`No valid games processed. Skip reasons: ${JSON.stringify(skipStats)}`);\n      }\n      \n      if (attempts.length < gameCount * 0.8) {\n        console.warn(`[v6.70] ‚ö†Ô∏è Only got ${attempts.length}/${gameCount} games - check rate limits or data availability`);\n      }\n      \n      // Calculate stats\n      const totalGames = attempts.length;\n      const hybridAccuracy = (hybridCorrect / totalGames) * 100;\n      const stockfishAccuracy = (stockfishCorrect / totalGames) * 100;\n      const hybridWins = attempts.filter(a => a.hybrid_correct && !a.stockfish_correct).length;\n      const stockfishWins = attempts.filter(a => !a.hybrid_correct && a.stockfish_correct).length;\n      const avgDepth = depths.reduce((a, b) => a + b, 0) / depths.length;\n      const maxDepthReached = Math.max(...depths);\n      const minDepthReached = Math.min(...depths);\n      const depthCoverage = (avgDepth / MAX_DEPTH_CAPACITY) * 100;\n      \n      // Calculate depth accuracy: % of positions that reached >= 95% of requested depth\n      const requestedDepth = depth;\n      const depthThreshold = requestedDepth * 0.95;\n      const positionsAtFullDepth = depths.filter(d => d >= depthThreshold).length;\n      const depthAccuracy = (positionsAtFullDepth / depths.length) * 100;\n      \n      // v6.43: Final benchmark update (predictions already saved incrementally)\n      setProgress(prev => ({\n        ...prev!,\n        currentPhase: 'saving',\n        message: 'Finalizing benchmark results...'\n      }));\n      \n      // Update the benchmark record with final stats\n      const { data: existingBenchmark } = await supabase\n        .from('chess_benchmark_results')\n        .select('id')\n        .eq('run_id', runId)\n        .maybeSingle();\n      \n      // v7.29: Calculate duration for final save\n      const benchmarkDurationMs = Date.now() - benchmarkStartTime;\n      \n      if (existingBenchmark) {\n        await supabase\n          .from('chess_benchmark_results')\n          .update({\n            total_games: totalGames,\n            completed_games: totalGames,\n            hybrid_accuracy: hybridAccuracy,\n            stockfish_accuracy: stockfishAccuracy,\n            hybrid_wins: hybridWins,\n            stockfish_wins: stockfishWins,\n            both_correct: bothCorrect,\n            both_wrong: bothWrong,\n            games_analyzed: attempts.map(a => a.game_id),\n            duration_ms: benchmarkDurationMs, // v7.29: NOW SAVED!\n          })\n          .eq('id', existingBenchmark.id);\n        console.log(`[v7.29] ‚úÖ Final benchmark update complete (duration: ${Math.round(benchmarkDurationMs/1000)}s)`);\n      } else {\n        // Create benchmark if incremental saves didn't create it yet\n        await supabase\n          .from('chess_benchmark_results')\n          .insert({\n            run_id: runId,\n            total_games: totalGames,\n            completed_games: totalGames,\n            prediction_move_number: Math.round((predictionMoveRange[0] + predictionMoveRange[1]) / 2),\n            hybrid_accuracy: hybridAccuracy,\n            stockfish_accuracy: stockfishAccuracy,\n            hybrid_wins: hybridWins,\n            stockfish_wins: stockfishWins,\n            both_correct: bothCorrect,\n            both_wrong: bothWrong,\n            data_source: 'lichess_grandmasters',\n            games_analyzed: attempts.map(a => a.game_id),\n            stockfish_version: 'Stockfish 17 WASM (Local Maximum Depth)',\n            stockfish_mode: 'local_wasm_unlimited',\n            hybrid_version: 'en-pensent-v1',\n            data_quality_tier: 'tcec_unlimited',\n            duration_ms: benchmarkDurationMs, // v7.29: NOW SAVED!\n          });\n        console.log(`[v7.29] ‚úÖ Created final benchmark record (duration: ${Math.round(benchmarkDurationMs/1000)}s)`);\n      }\n      \n      // Collect unique archetypes detected\n      const archetypesDetected = [...new Set(attempts.map(a => a.hybrid_archetype))];\n      \n      // v7.28: Mark as completing so lock release doesn't trigger abort\n      completingRef.current = true;\n      \n      const finalResult: BenchmarkResult = {\n        runId,\n        totalGames,\n        hybridAccuracy,\n        stockfishAccuracy,\n        hybridWins,\n        stockfishWins,\n        averageDepth: avgDepth,\n        maxDepth: maxDepthReached,\n        minDepth: minDepthReached,\n        depthCoverage,\n        depthAccuracy, // NEW: percentage of positions at full requested depth\n        enPensentCapacity: 100, // Full scope = 100%\n        archetypesDetected,\n        playerFingerprints: attempts.length, // Each game contributes to fingerprint data\n        timeControlProfiles: 6, // All time control categories analyzed\n        adaptersActive: [...DOMAIN_ADAPTERS] // All 25 adapters active\n      };\n      \n      console.log(`[Benchmark Complete] Depth accuracy: ${depthAccuracy.toFixed(1)}% of positions reached ‚â•95% of requested depth ${requestedDepth}`);\n      \n      setResult(finalResult);\n      setProgress({\n        currentGame: totalGames,\n        totalGames,\n        currentPhase: 'complete',\n        currentDepth: avgDepth,\n        message: `Complete! En Pensent ${hybridAccuracy.toFixed(1)}% vs Stockfish ${stockfishAccuracy.toFixed(1)}% at ${depthCoverage.toFixed(0)}% depth (${EN_PENSENT_ADAPTERS} adapters)`,\n        enPensentModulesActive: EN_PENSENT_ADAPTERS\n      });\n      \n      return finalResult;\n      \n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Unknown error';\n      console.error(`[v6.43] Benchmark error: ${message}`);\n      \n      // v6.43-BULLETPROOF: Emergency save - predictions should already be in DB from incremental saves\n      // Just log what we had in case anything was lost\n      if (attempts.length > 0) {\n        console.log(`[v6.43] ‚ö†Ô∏è Error occurred after ${attempts.length} predictions (most should already be saved incrementally)`);\n        \n        // Try one more emergency save in case incremental saves didn't complete\n        try {\n          const { data: existingBenchmark } = await supabase\n            .from('chess_benchmark_results')\n            .select('id')\n            .eq('run_id', runId)\n            .maybeSingle();\n          \n          if (existingBenchmark) {\n            // Update existing benchmark with final count + duration\n            const errorDurationMs = Date.now() - benchmarkStartTime; // v7.29\n            await supabase\n              .from('chess_benchmark_results')\n              .update({\n                completed_games: attempts.length,\n                hybrid_accuracy: attempts.length > 0 ? (hybridCorrect / attempts.length) * 100 : 0,\n                stockfish_accuracy: attempts.length > 0 ? (stockfishCorrect / attempts.length) * 100 : 0,\n                duration_ms: errorDurationMs, // v7.29: Save duration even on error\n              })\n              .eq('id', existingBenchmark.id);\n            console.log(`[v7.29] ‚úÖ Updated benchmark with ${attempts.length} predictions (error path, ${Math.round(errorDurationMs/1000)}s)`);\n          } else {\n            // Create benchmark record if it doesn't exist\n            const errorDurationMs = Date.now() - benchmarkStartTime; // v7.29\n            const { data: newBenchmark } = await supabase\n              .from('chess_benchmark_results')\n              .insert({\n                run_id: runId,\n                total_games: gameCount,\n                completed_games: attempts.length,\n                prediction_move_number: Math.round((predictionMoveRange[0] + predictionMoveRange[1]) / 2),\n                hybrid_accuracy: attempts.length > 0 ? (hybridCorrect / attempts.length) * 100 : 0,\n                stockfish_accuracy: attempts.length > 0 ? (stockfishCorrect / attempts.length) * 100 : 0,\n                hybrid_wins: attempts.filter(a => a.hybrid_correct && !a.stockfish_correct).length,\n                stockfish_wins: attempts.filter(a => !a.hybrid_correct && a.stockfish_correct).length,\n                both_correct: bothCorrect,\n                both_wrong: bothWrong,\n                data_source: 'lichess_grandmasters_error',\n                games_analyzed: attempts.map(a => a.game_id),\n                stockfish_version: 'Stockfish 17 WASM (Local Maximum Depth)',\n                stockfish_mode: 'local_wasm_unlimited',\n                hybrid_version: 'en-pensent-v1',\n                data_quality_tier: 'tcec_unlimited',\n                duration_ms: errorDurationMs, // v7.29: Save duration even on error\n              })\n              .select()\n              .single();\n            \n            if (newBenchmark) {\n              // Save any unsaved attempts (ignore errors for duplicates)\n              for (const attempt of attempts) {\n                const { error: insertErr } = await supabase.from('chess_prediction_attempts').insert({\n                  ...attempt,\n                  benchmark_id: newBenchmark.id,\n                });\n                // Silently ignore duplicate errors\n                if (insertErr && !insertErr.message?.includes('duplicate')) {\n                  console.error(`[v6.63] Insert error:`, insertErr.message);\n                } else {\n                  // v6.63: Invalidate cache for realtime sync\n                  invalidateChessStatsCache();\n                }\n              }\n              console.log(`[v6.63] ‚úÖ Emergency saved ${attempts.length} predictions`);\n            }\n          }\n        } catch (saveError) {\n          console.error(`[v6.43] ‚ùå Emergency save failed:`, saveError);\n        }\n      }\n      \n      setError(message);\n      throw e;\n    } finally {\n      setIsRunning(false);\n    }\n  }, []);\n  \n  const abort = useCallback(() => {\n    abortRef.current = true;\n    setIsRunning(false);\n    setProgress(null);\n  }, []);\n  \n  return {\n    runBenchmark,\n    abort,\n    isRunning,\n    progress,\n    result,\n    error,\n  };\n}\n\n// v6.46: OLD fetchLichessGames function REMOVED - now using fetchMultiSourceGames\n// This eliminates 200+ lines of duplicate code and enables dual-source fetching\n\n// v6.14: Parse moves for FEN - PREFER raw moves string from Edge Function\nfunction parsePGNForMoves(pgn: string, moveRange: [number, number], rawMoves?: string): { \n  moves: string[]; \n  fen: string;\n  moveNumber: number;\n} {\n  // v6.14: PREFER raw moves from Edge Function (cleaner, no PGN parsing needed)\n  let moves: string[];\n  \n  if (rawMoves && rawMoves.trim()) {\n    // Raw moves come as space-separated SAN moves: \"e4 e5 Nf3 Nc6 Bb5 ...\"\n    moves = rawMoves.trim().split(/\\s+/).filter(m => m && m.length > 0);\n  } else {\n    // Fallback: Extract moves from PGN\n    const moveSection = pgn.replace(/\\[.*?\\]/g, \"\").replace(/\\{.*?\\}/g, \"\").trim();\n    moves = moveSection\n      .split(/\\s+/)\n      .filter(m => m && !m.match(/^\\d+\\./) && !m.match(/^[01]-[01]$/) && !m.match(/^1\\/2-1\\/2$/) && m !== \"*\");\n  }\n  \n  if (moves.length < 4) {\n    throw new Error(`Too few moves: ${moves.length}`);\n  }\n  \n  // Adaptive prediction point - works with ANY game length\n  const availableRange = Math.floor(moves.length * 0.6);\n  const maxMove = Math.min(moveRange[1], availableRange, moves.length - 2);\n  const minMove = Math.min(moveRange[0], Math.max(5, Math.floor(moves.length * 0.2)));\n  const moveNumber = Math.max(minMove, minMove + Math.floor(Math.random() * Math.max(1, maxMove - minMove + 1)));\n  \n  // Generate actual FEN at the prediction point\n  const chess = new Chess();\n  let successfulMoves = 0;\n  for (let i = 0; i < moveNumber && i < moves.length; i++) {\n    try {\n      chess.move(moves[i]);\n      successfulMoves++;\n    } catch {\n      // v6.14: Log but continue - partial FEN is still useful\n      console.warn(`[v6.14] Invalid move at index ${i}: ${moves[i]}`);\n      break;\n    }\n  }\n  \n  // v6.14: Ensure we have meaningful position\n  if (successfulMoves < 4) {\n    throw new Error(`Too few valid moves parsed: ${successfulMoves}`);\n  }\n  \n  return { moves: moves.slice(0, successfulMoves + Math.min(10, moves.length - successfulMoves)), fen: chess.fen(), moveNumber: successfulMoves };\n}\n";export{e as default};
