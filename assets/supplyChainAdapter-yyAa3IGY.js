const n="/**\n * Supply Chain & Logistics Adapter\n * \n * Bullwhip effect, inventory cycles, just-in-time fragility, network flows.\n * The circulatory system of global commerce.\n * \n * For Alec Arthur Shelton - The Artist\n * Supply chains are neural networks, warehouses are synapses, trucks are action potentials.\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\n// BULLWHIP EFFECT\nconst BULLWHIP_EFFECT = {\n  description: 'Demand variability amplifies upstream in supply chain',\n  causes: [\n    'ForecastUpdating: Each node adds uncertainty buffer',\n    'OrderBatching: Fixed order costs encourage bulk orders',\n    'PriceFluctuation: Promotions cause demand spikes',\n    'RationingGaming: Shortage anticipation leads to overordering'\n  ],\n  amplification: 'Variance can increase 2x-10x from retailer to manufacturer',\n  countermeasures: [\n    'InformationSharing: POS data to all levels',\n    'VendorManagedInventory: Supplier controls stock',\n    'ReducedLeadTimes: Faster response = less buffer needed',\n    'EveryDayLowPrices: Eliminate promotional spikes'\n  ],\n  marketAnalogy: 'Volatility clustering in financial markets'\n};\n\n// INVENTORY THEORIES\nconst INVENTORY_THEORIES = {\n  eoq: {\n    name: 'Economic Order Quantity',\n    formula: 'EOQ = sqrt(2DS/H)',\n    variables: {\n      D: 'Annual demand',\n      S: 'Ordering cost per order',\n      H: 'Holding cost per unit per year'\n    },\n    tradeoff: 'Ordering costs vs holding costs'\n  },\n  \n  newsboy: {\n    name: 'Newsvendor Problem',\n    question: 'How much to order when demand is uncertain?',\n    criticalRatio: 'Cu / (Cu + Co)',\n    Cu: 'Cost of underage (lost sale)',\n    Co: 'Cost of overage (excess inventory)',\n    marketAnalogy: 'Options delta hedging'\n  },\n  \n  safetyStock: {\n    formula: 'SS = Z × σL',\n    Z: 'Service level factor (1.65 for 95%)',\n    sigmaL: 'Demand std dev during lead time',\n    marketAnalogy: 'Risk buffer, position sizing'\n  },\n  \n  abcAnalysis: {\n    A_items: '20% of SKUs, 80% of value - tight control',\n    B_items: '30% of SKUs, 15% of value - moderate control',\n    C_items: '50% of SKUs, 5% of value - simple control',\n    marketAnalogy: 'Pareto principle in portfolio management'\n  }\n};\n\n// LOGISTICS NETWORKS\nconst LOGISTICS_PATTERNS = {\n  hubAndSpoke: {\n    structure: 'Central hub connected to spokes',\n    advantages: ['Economies of scale', 'Simplified routing', 'Connectivity'],\n    disadvantages: ['Single point of failure', 'Longer paths', 'Congestion'],\n    examples: ['FedEx Memphis', 'Airline networks', 'Amazon fulfillment'],\n    marketAnalogy: 'Market makers as liquidity hubs'\n  },\n  \n  pointToPoint: {\n    structure: 'Direct connections between all nodes',\n    advantages: ['Shorter transit times', 'Redundancy', 'No bottlenecks'],\n    disadvantages: ['Many connections', 'Lower utilization', 'Complex routing'],\n    marketAnalogy: 'Direct market access, bilateral trading'\n  },\n  \n  milkRuns: {\n    description: 'Single vehicle collects from multiple suppliers',\n    efficiency: 'Consolidation reduces transport costs',\n    scheduling: 'Route optimization (TSP variants)'\n  }\n};\n\n// SUPPLY CHAIN RISKS\nconst SUPPLY_RISKS = {\n  disruption: {\n    types: ['Natural disaster', 'Supplier bankruptcy', 'Geopolitical', 'Pandemic'],\n    probability: 'Low frequency, high impact',\n    mitigation: ['Dual sourcing', 'Strategic inventory', 'Flexible suppliers']\n  },\n  \n  delay: {\n    causes: ['Port congestion', 'Customs', 'Weather', 'Capacity constraints'],\n    impact: 'Stockouts, expedited shipping costs',\n    mitigation: ['Buffer stock', 'Alternative routes', 'Visibility systems']\n  },\n  \n  information: {\n    problems: ['Forecast error', 'Data latency', 'Bullwhip amplification'],\n    solution: 'Real-time visibility, collaborative planning'\n  },\n  \n  reputation: {\n    sources: ['Counterfeit products', 'Unethical suppliers', 'Quality failures'],\n    impact: 'Brand damage, regulatory action'\n  }\n};\n\n// LEAN vs AGILE\nconst SUPPLY_STRATEGIES = {\n  lean: {\n    focus: 'Eliminate waste, minimize inventory',\n    suited: 'Stable demand, low variety, cost focus',\n    risk: 'Fragile to disruptions',\n    exemplar: 'Toyota Production System',\n    marketAnalogy: 'Low-volatility carry strategies'\n  },\n  \n  agile: {\n    focus: 'Respond quickly to demand changes',\n    suited: 'Volatile demand, high variety, speed focus',\n    cost: 'Higher inventory, premium logistics',\n    exemplar: 'Zara fast fashion',\n    marketAnalogy: 'High-frequency trading'\n  },\n  \n  leagile: {\n    focus: 'Lean upstream, agile downstream',\n    decoupling: 'Strategic inventory point separates strategies',\n    exemplar: 'Dell build-to-order'\n  }\n};\n\ninterface SupplyChainEvent {\n  timestamp: number;\n  inventoryLevel: number;\n  orderQuantity: number;\n  demand: number;\n  leadTime: number; // Days\n  supplierReliability: number; // 0-1\n  transportCost: number;\n  stockoutOccurred: boolean;\n  nodePosition: number; // 0=retailer, 1=distributor, 2=manufacturer\n  visibility: number; // 0-1 information transparency\n}\n\nclass SupplyChainAdapter implements DomainAdapter<SupplyChainEvent> {\n  domain = 'market' as const;\n  name = 'Supply Chain & Logistics';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 5000;\n  \n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[SupplyChainAdapter] Initialized - Logistics network active');\n  }\n  \n  processRawData(event: SupplyChainEvent): UniversalSignal {\n    const { timestamp, inventoryLevel, demand, leadTime, supplierReliability, visibility } = event;\n    \n    // Frequency encodes inventory turns (velocity)\n    const frequency = Math.min(demand / (inventoryLevel + 1), 1);\n    \n    // Intensity = supply stress (high demand, low inventory, long lead times)\n    const inventoryStress = 1 - Math.min(inventoryLevel / (demand * leadTime), 1);\n    const intensity = inventoryStress * (1 - supplierReliability);\n    \n    // Phase encodes information flow quality\n    const phase = visibility * Math.PI;\n    \n    const harmonics = [\n      inventoryLevel / 1000,\n      demand / 100,\n      leadTime / 30,\n      supplierReliability,\n      event.transportCost / 1000,\n      event.stockoutOccurred ? 1 : 0\n    ];\n    \n    const signal: UniversalSignal = {\n      domain: 'market',\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData: [inventoryLevel, demand, leadTime, supplierReliability, visibility]\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.lastUpdate = timestamp;\n    return signal;\n  }\n  \n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n    \n    const recent = signals.slice(-100);\n    \n    const avgInventory = recent.reduce((sum, s) => sum + s.rawData[0], 0) / recent.length;\n    const avgDemand = recent.reduce((sum, s) => sum + s.rawData[1], 0) / recent.length;\n    const avgLead = recent.reduce((sum, s) => sum + s.rawData[2], 0) / recent.length;\n    const avgReliability = recent.reduce((sum, s) => sum + s.rawData[3], 0) / recent.length;\n    const avgVisibility = recent.reduce((sum, s) => sum + s.rawData[4], 0) / recent.length;\n    \n    const quadrantProfile = {\n      aggressive: avgDemand > avgInventory ? 0.8 : 0.2, // High demand pressure\n      defensive: avgInventory > avgDemand * 2 ? 0.7 : 0.2, // High safety stock\n      tactical: avgLead > 14 ? 0.6 : 0.3, // Long lead times\n      strategic: avgVisibility > 0.8 ? 0.8 : 0.3 // High visibility\n    };\n    \n    const temporalFlow = {\n      early: avgLead < 7 ? 0.8 : 0.2,\n      mid: avgLead >= 7 && avgLead < 21 ? 0.7 : 0.2,\n      late: avgLead >= 21 ? 0.8 : 0.2\n    };\n    \n    return {\n      domain: 'market',\n      quadrantProfile,\n      temporalFlow,\n      intensity: (avgDemand - avgInventory) / 100,\n      momentum: avgDemand > avgInventory ? 1 : -1,\n      volatility: 1 - avgReliability,\n      dominantFrequency: avgDemand / (avgInventory + 1),\n      harmonicResonance: avgVisibility,\n      phaseAlignment: avgReliability,\n      extractedAt: Date.now()\n    };\n  }\n  \n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'market',\n      quadrantProfile: { aggressive: 0.3, defensive: 0.3, tactical: 0.2, strategic: 0.2 },\n      temporalFlow: { early: 0.4, mid: 0.4, late: 0.2 },\n      intensity: 0.4,\n      momentum: 0,\n      volatility: 0.3,\n      dominantFrequency: 0.5,\n      harmonicResonance: 0.6,\n      phaseAlignment: 0.7,\n      extractedAt: Date.now()\n    };\n  }\n  \n  // Calculate Economic Order Quantity\n  calculateEOQ(annualDemand: number, orderCost: number, holdingCost: number): number {\n    return Math.sqrt((2 * annualDemand * orderCost) / holdingCost);\n  }\n  \n  // Calculate safety stock\n  calculateSafetyStock(serviceLevel: number, demandStdDev: number, leadTime: number): number {\n    const zScores: Record<number, number> = { 0.9: 1.28, 0.95: 1.65, 0.99: 2.33 };\n    const z = zScores[serviceLevel] || 1.65;\n    return z * demandStdDev * Math.sqrt(leadTime);\n  }\n  \n  // Simulate bullwhip effect\n  simulateBullwhip(\n    retailDemand: number[],\n    orderBatchSize: number,\n    forecastSmoothing: number\n  ): { retailer: number[]; distributor: number[]; manufacturer: number[] } {\n    const retailer = retailDemand;\n    const distributor: number[] = [];\n    const manufacturer: number[] = [];\n    \n    let distForecast = retailer[0];\n    \n    for (let i = 0; i < retailer.length; i++) {\n      // Distributor batches orders\n      const distOrder = Math.ceil(retailer[i] / orderBatchSize) * orderBatchSize;\n      distributor.push(distOrder);\n      \n      // Update forecast with smoothing\n      distForecast = forecastSmoothing * retailer[i] + (1 - forecastSmoothing) * distForecast;\n      \n      // Manufacturer sees distributor orders + forecast buffer\n      const mfgOrder = Math.ceil(distForecast * 1.2 / orderBatchSize) * orderBatchSize;\n      manufacturer.push(mfgOrder);\n    }\n    \n    return { retailer, distributor, manufacturer };\n  }\n}\n\nexport const supplyChainAdapter = new SupplyChainAdapter();\nexport { BULLWHIP_EFFECT, INVENTORY_THEORIES, LOGISTICS_PATTERNS, SUPPLY_RISKS, SUPPLY_STRATEGIES };\nexport type { SupplyChainEvent };\n";export{n as default};
