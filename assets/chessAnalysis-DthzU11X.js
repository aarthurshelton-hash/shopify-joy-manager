const e="/**\n * Deep Chess Analysis System\n * \n * Detects and categorizes chess patterns including:\n * - Openings (by ECO code and common names)\n * - Gambits (pawn/piece sacrifices for position)\n * - Tactical motifs: Forks, Pins, Skewers, Discoveries\n * - Special moves: En passant, Castling, Pawn promotion\n * - Game phases: Opening, Middlegame, Endgame\n */\n\nimport { Chess, Move, Square, PieceSymbol } from 'chess.js';\nimport { PIECE_VALUES, PIECE_POINTS, ENDGAME_PIECE_VALUES, cpToWinProbability, calculateMoveAccuracy, classifyMoves, getMoveQualitySummary, MoveQualitySummary, ClassifiedMove } from './moveQuality';\nimport { detectOpeningFromMoves } from './openingDetector';\n\n// Re-export for convenience\nexport { PIECE_VALUES, PIECE_POINTS, ENDGAME_PIECE_VALUES, cpToWinProbability, calculateMoveAccuracy };\nexport type { MoveQualitySummary, ClassifiedMove };\n\n// ===================== TYPES =====================\n\nexport interface ChessOpening {\n  eco: string;          // ECO code (A00-E99)\n  name: string;         // Opening name\n  variation?: string;   // Specific variation\n  moves: string;        // Standard move sequence\n  description: string;  // Brief description\n  category: 'open' | 'semi-open' | 'closed' | 'semi-closed' | 'flank' | 'irregular';\n}\n\nexport interface ChessGambit {\n  name: string;\n  moves: string;\n  sacrificedMaterial: string;\n  compensation: string;\n  frequency: 'common' | 'rare' | 'legendary';\n}\n\nexport interface TacticalMotif {\n  type: 'fork' | 'pin' | 'skewer' | 'discovery' | 'double_attack' | 'back_rank' | 'smothered_mate' | 'sacrifice' | 'check' | 'checkmate' | 'discovered_check' | 'double_check';\n  moveNumber: number;\n  notation: string;\n  attacker: { piece: PieceSymbol; square: Square };\n  targets: { piece: PieceSymbol; square: Square }[];\n  description: string;\n  value: number; // Material value involved\n  isAbsolute?: boolean; // For pins - piece cannot legally move\n}\n\nexport interface SpecialMove {\n  type: 'en_passant' | 'castle_kingside' | 'castle_queenside' | 'promotion' | 'underpromotion';\n  moveNumber: number;\n  notation: string;\n  description: string;\n  promotedTo?: PieceSymbol;\n}\n\nexport interface GamePhase {\n  name: 'opening' | 'middlegame' | 'endgame';\n  startMove: number;\n  endMove: number;\n  description: string;\n  keyEvents: string[];\n}\n\nexport interface GameAnalysis {\n  opening?: ChessOpening;\n  gambit?: ChessGambit;\n  tactics: TacticalMotif[];\n  specialMoves: SpecialMove[];\n  phases: GamePhase[];\n  moveQuality?: MoveQualitySummary;\n  summary: {\n    totalMoves: number;\n    captureCount: number;\n    checkCount: number;\n    brilliantCount: number;\n    blunderCount: number;\n    accuracy: number; // Percentage of good+ moves\n    materialBalance: number; // Positive = white ahead\n    longestForcingSequence: number;\n    complexity: 'simple' | 'moderate' | 'complex' | 'masterpiece';\n  };\n}\n\n// ===================== OPENING DATABASE =====================\n\nconst OPENINGS_DB: ChessOpening[] = [\n  // Italian Game family\n  { eco: 'C50', name: 'Italian Game', moves: '1.e4 e5 2.Nf3 Nc6 3.Bc4', description: 'Classic opening targeting f7', category: 'open' },\n  { eco: 'C51', name: 'Evans Gambit', moves: '1.e4 e5 2.Nf3 Nc6 3.Bc4 Bc5 4.b4', description: 'Aggressive pawn sacrifice for rapid development', category: 'open' },\n  { eco: 'C53', name: 'Giuoco Piano', moves: '1.e4 e5 2.Nf3 Nc6 3.Bc4 Bc5', description: 'The \"quiet game\" - solid and strategic', category: 'open' },\n  \n  // Spanish Game family\n  { eco: 'C60', name: 'Ruy Lopez', moves: '1.e4 e5 2.Nf3 Nc6 3.Bb5', description: 'The most thoroughly analyzed opening', category: 'open' },\n  { eco: 'C65', name: 'Berlin Defense', moves: '1.e4 e5 2.Nf3 Nc6 3.Bb5 Nf6', description: 'Solid defense, \"the Berlin Wall\"', category: 'open' },\n  { eco: 'C78', name: 'Morphy Defense', moves: '1.e4 e5 2.Nf3 Nc6 3.Bb5 a6 4.Ba4', description: 'Main line Ruy Lopez', category: 'open' },\n  \n  // Sicilian Defense family\n  { eco: 'B20', name: 'Sicilian Defense', moves: '1.e4 c5', description: 'Fighting response to 1.e4, asymmetrical play', category: 'semi-open' },\n  { eco: 'B33', name: 'Sicilian Sveshnikov', moves: '1.e4 c5 2.Nf3 Nc6 3.d4 cxd4 4.Nxd4 Nf6 5.Nc3 e5', description: 'Dynamic with weak d5 but active pieces', category: 'semi-open' },\n  { eco: 'B90', name: 'Sicilian Najdorf', moves: '1.e4 c5 2.Nf3 d6 3.d4 cxd4 4.Nxd4 Nf6 5.Nc3 a6', description: 'The most popular Sicilian, flexible and fighting', category: 'semi-open' },\n  { eco: 'B23', name: 'Grand Prix Attack', moves: '1.e4 c5 2.Nc3 Nc6 3.f4', description: 'Aggressive anti-Sicilian with f4', category: 'semi-open' },\n  { eco: 'B52', name: 'Sicilian Rossolimo', moves: '1.e4 c5 2.Nf3 Nc6 3.Bb5', description: 'Positional anti-Sicilian', category: 'semi-open' },\n  \n  // French Defense\n  { eco: 'C00', name: 'French Defense', moves: '1.e4 e6', description: 'Solid but cramped, counterattacking', category: 'semi-open' },\n  { eco: 'C11', name: 'French Classical', moves: '1.e4 e6 2.d4 d5 3.Nc3 Nf6', description: 'Main line French with Nf6', category: 'semi-open' },\n  { eco: 'C18', name: 'French Winawer', moves: '1.e4 e6 2.d4 d5 3.Nc3 Bb4', description: 'Sharp and complex French variation', category: 'semi-open' },\n  \n  // Caro-Kann Defense\n  { eco: 'B10', name: 'Caro-Kann Defense', moves: '1.e4 c6', description: 'Solid and reliable, fewer weaknesses than French', category: 'semi-open' },\n  { eco: 'B12', name: 'Caro-Kann Advance', moves: '1.e4 c6 2.d4 d5 3.e5', description: 'Space advantage for White, French-like', category: 'semi-open' },\n  \n  // Queen\\'s Gambit family\n  { eco: 'D06', name: \"Queen's Gambit\", moves: '1.d4 d5 2.c4', description: 'Classical opening, fight for the center', category: 'closed' },\n  { eco: 'D30', name: \"Queen's Gambit Declined\", moves: '1.d4 d5 2.c4 e6', description: 'Solid defense, maintaining the d5 pawn', category: 'closed' },\n  { eco: 'D20', name: \"Queen's Gambit Accepted\", moves: '1.d4 d5 2.c4 dxc4', description: 'Taking the pawn, conceding center', category: 'closed' },\n  { eco: 'D35', name: 'Exchange Variation', moves: '1.d4 d5 2.c4 e6 3.Nc3 Nf6 4.cxd5 exd5', description: 'Symmetrical structure, minority attack', category: 'closed' },\n  \n  // Indian Defenses\n  { eco: 'E00', name: \"King's Indian Defense\", moves: '1.d4 Nf6 2.c4 g6', description: 'Hypermodern, fianchetto kingside', category: 'semi-closed' },\n  { eco: 'E70', name: \"King's Indian Classical\", moves: '1.d4 Nf6 2.c4 g6 3.Nc3 Bg7 4.e4 d6 5.Nf3', description: 'Main line KID', category: 'semi-closed' },\n  { eco: 'E60', name: \"King's Indian Fianchetto\", moves: '1.d4 Nf6 2.c4 g6 3.g3', description: 'Quiet, positional approach', category: 'semi-closed' },\n  { eco: 'E20', name: 'Nimzo-Indian Defense', moves: '1.d4 Nf6 2.c4 e6 3.Nc3 Bb4', description: 'Flexible and solid, pins Nc3', category: 'semi-closed' },\n  { eco: 'A50', name: \"Queen's Indian Defense\", moves: '1.d4 Nf6 2.c4 e6 3.Nf3 b6', description: 'Control e4 with Bb7', category: 'semi-closed' },\n  { eco: 'D70', name: 'Grünfeld Defense', moves: '1.d4 Nf6 2.c4 g6 3.Nc3 d5', description: 'Hypermodern counter to d4', category: 'semi-closed' },\n  \n  // Flank Openings\n  { eco: 'A00', name: 'Hungarian Opening', moves: '1.g3', description: 'Flexible flank opening', category: 'flank' },\n  { eco: 'A02', name: \"Bird's Opening\", moves: '1.f4', description: 'Control e5 with f-pawn', category: 'flank' },\n  { eco: 'A04', name: \"Réti Opening\", moves: '1.Nf3 d5 2.c4', description: 'Hypermodern, fianchetto setup', category: 'flank' },\n  { eco: 'A10', name: 'English Opening', moves: '1.c4', description: 'Flexible flank opening, transposes often', category: 'flank' },\n  { eco: 'A16', name: 'English Anglo-Indian', moves: '1.c4 Nf6 2.Nc3', description: 'English with Indian setup', category: 'flank' },\n  \n  // Gambits\n  { eco: 'C30', name: \"King's Gambit\", moves: '1.e4 e5 2.f4', description: 'Romantic era attacking opening', category: 'open' },\n  { eco: 'D08', name: 'Albin Counter-Gambit', moves: '1.d4 d5 2.c4 e5', description: 'Aggressive counter to QG', category: 'closed' },\n  { eco: 'A45', name: 'Trompowsky Attack', moves: '1.d4 Nf6 2.Bg5', description: 'Aggressive anti-Indian', category: 'closed' },\n  { eco: 'D00', name: 'London System', moves: '1.d4 d5 2.Bf4', description: 'Solid, systematic setup for White', category: 'closed' },\n  { eco: 'A46', name: 'Torre Attack', moves: '1.d4 Nf6 2.Nf3 e6 3.Bg5', description: 'Pin knight, solid development', category: 'closed' },\n  \n  // Scandinavian\n  { eco: 'B01', name: 'Scandinavian Defense', moves: '1.e4 d5', description: 'Immediate counter in center, queen comes out early', category: 'semi-open' },\n  \n  // Pirc/Modern\n  { eco: 'B07', name: 'Pirc Defense', moves: '1.e4 d6 2.d4 Nf6 3.Nc3 g6', description: 'Hypermodern, lets White build center', category: 'semi-open' },\n  { eco: 'B06', name: 'Modern Defense', moves: '1.e4 g6', description: 'Flexible, delays d6', category: 'semi-open' },\n  \n  // Alekhine\n  { eco: 'B02', name: \"Alekhine's Defense\", moves: '1.e4 Nf6', description: 'Provoke e5, attack White center', category: 'semi-open' },\n  \n  // Dutch\n  { eco: 'A80', name: 'Dutch Defense', moves: '1.d4 f5', description: 'Aggressive response to d4', category: 'semi-closed' },\n  { eco: 'A87', name: 'Dutch Leningrad', moves: '1.d4 f5 2.c4 Nf6 3.g3 g6', description: 'Dragon-like setup against d4', category: 'semi-closed' },\n  \n  // Slav\n  { eco: 'D10', name: 'Slav Defense', moves: '1.d4 d5 2.c4 c6', description: 'Solid, supports d5 with c6', category: 'closed' },\n  { eco: 'D15', name: 'Slav Accepted', moves: '1.d4 d5 2.c4 c6 3.Nf3 Nf6 4.Nc3 dxc4', description: 'Taking on c4 with c6 support', category: 'closed' },\n  \n  // Catalan\n  { eco: 'E01', name: 'Catalan Opening', moves: '1.d4 Nf6 2.c4 e6 3.g3', description: 'Fianchetto bishop, pressure on d5', category: 'closed' },\n  \n  // Benoni\n  { eco: 'A60', name: 'Benoni Defense', moves: '1.d4 Nf6 2.c4 c5 3.d5', description: 'Asymmetrical pawn structure', category: 'semi-closed' },\n  { eco: 'A67', name: 'Benko Gambit', moves: '1.d4 Nf6 2.c4 c5 3.d5 b5', description: 'Pawn sac for queenside pressure', category: 'semi-closed' },\n];\n\nconst GAMBITS_DB: ChessGambit[] = [\n  { name: \"King's Gambit\", moves: '1.e4 e5 2.f4', sacrificedMaterial: 'f-pawn', compensation: 'Open f-file, rapid development', frequency: 'common' },\n  { name: 'Evans Gambit', moves: '1.e4 e5 2.Nf3 Nc6 3.Bc4 Bc5 4.b4', sacrificedMaterial: 'b-pawn', compensation: 'Tempo, open lines, center control', frequency: 'common' },\n  { name: 'Danish Gambit', moves: '1.e4 e5 2.d4 exd4 3.c3', sacrificedMaterial: 'd and c pawns', compensation: 'Massive lead in development', frequency: 'rare' },\n  { name: 'Smith-Morra Gambit', moves: '1.e4 c5 2.d4 cxd4 3.c3', sacrificedMaterial: 'c-pawn', compensation: 'Development and open lines', frequency: 'common' },\n  { name: 'Benko Gambit', moves: '1.d4 Nf6 2.c4 c5 3.d5 b5', sacrificedMaterial: 'b-pawn', compensation: 'Queenside pressure, a and b files', frequency: 'common' },\n  { name: 'Marshall Attack', moves: '1.e4 e5 2.Nf3 Nc6 3.Bb5 a6 4.Ba4 Nf6 5.O-O Be7 6.Re1 b5 7.Bb3 O-O 8.c3 d5', sacrificedMaterial: 'e-pawn', compensation: 'Attack on white king', frequency: 'legendary' },\n  { name: 'Muzio Gambit', moves: '1.e4 e5 2.f4 exf4 3.Nf3 g5 4.Bc4 g4 5.O-O', sacrificedMaterial: 'Knight', compensation: 'Massive attack, development lead', frequency: 'rare' },\n  { name: 'Latvian Gambit', moves: '1.e4 e5 2.Nf3 f5', sacrificedMaterial: 'f-pawn weakens king', compensation: 'Counterattack chances', frequency: 'rare' },\n  { name: 'Englund Gambit', moves: '1.d4 e5', sacrificedMaterial: 'e-pawn', compensation: 'Tricky for White', frequency: 'rare' },\n  { name: 'Budapest Gambit', moves: '1.d4 Nf6 2.c4 e5', sacrificedMaterial: 'e-pawn', compensation: 'Active pieces', frequency: 'rare' },\n  { name: 'Albin Counter-Gambit', moves: '1.d4 d5 2.c4 e5', sacrificedMaterial: 'e-pawn', compensation: 'Central initiative', frequency: 'rare' },\n  { name: \"Queen's Gambit\", moves: '1.d4 d5 2.c4', sacrificedMaterial: 'c-pawn (temporarily)', compensation: 'Center control', frequency: 'common' },\n  { name: 'Scotch Gambit', moves: '1.e4 e5 2.Nf3 Nc6 3.d4 exd4 4.Bc4', sacrificedMaterial: 'd-pawn', compensation: 'Development, attacking f7', frequency: 'common' },\n  { name: 'Wing Gambit', moves: '1.e4 c5 2.b4', sacrificedMaterial: 'b-pawn', compensation: 'Open b-file, queenside play', frequency: 'rare' },\n  { name: 'Blackmar-Diemer Gambit', moves: '1.d4 d5 2.e4 dxe4 3.Nc3 Nf6 4.f3', sacrificedMaterial: 'e-pawn', compensation: 'Development and attack', frequency: 'rare' },\n];\n\n// ===================== ANALYSIS FUNCTIONS =====================\n\n/**\n * Convert PGN moves to array of SAN notation\n */\nfunction pgnToMoves(pgn: string): string[] {\n  const movesSection = pgn.replace(/\\[[^\\]]*\\]/g, '').trim();\n  return movesSection\n    .replace(/\\{[^}]*\\}/g, '')\n    .replace(/\\([^)]*\\)/g, '')\n    .replace(/\\$\\d+/g, '')\n    .replace(/1-0|0-1|1\\/2-1\\/2|\\*/g, '')\n    .split(/\\s+/)\n    .filter(token => token && !token.match(/^\\d+\\.+$/) && token !== '...')\n    .map(m => m.replace(/[+#!?]+$/, ''));\n}\n\n/**\n * Match opening from move sequence using the comprehensive opening detector\n */\nexport function detectOpening(moves: string[]): ChessOpening | undefined {\n  // Use the comprehensive opening detector (imported at top of file)\n  try {\n    const detected = detectOpeningFromMoves(moves);\n    \n    if (!detected) return undefined;\n    \n    // Convert to legacy ChessOpening format for backwards compatibility\n    return {\n      eco: detected.eco,\n      name: detected.fullName,\n      moves: detected.moves,\n      description: detected.description,\n      category: detected.category === 'gambit' ? 'open' : detected.category,\n    };\n  } catch (e) {\n    console.warn('Opening detection failed:', e);\n    return undefined;\n  }\n}\n\n/**\n * Detect if a gambit was played\n */\nexport function detectGambit(moves: string[]): ChessGambit | undefined {\n  const moveSequence = moves.slice(0, 10).join(' ').toLowerCase();\n  \n  for (const gambit of GAMBITS_DB) {\n    const gambitMoves = pgnToMoves(gambit.moves).join(' ').toLowerCase();\n    if (moveSequence.startsWith(gambitMoves) || gambitMoves.startsWith(moveSequence)) {\n      return gambit;\n    }\n  }\n  \n  return undefined;\n}\n\n/**\n * Detect special moves in the game\n */\nexport function detectSpecialMoves(pgn: string): SpecialMove[] {\n  const specialMoves: SpecialMove[] = [];\n  const chess = new Chess();\n  \n  try {\n    chess.loadPgn(pgn);\n    const history = chess.history({ verbose: true });\n    \n    history.forEach((move, index) => {\n      const moveNumber = index + 1;\n      \n      // En passant\n      if (move.flags.includes('e')) {\n        specialMoves.push({\n          type: 'en_passant',\n          moveNumber,\n          notation: move.san,\n          description: `En passant capture: ${move.san} - a rare pawn capture where the capturing pawn moves to the square the opponent's pawn passed through`,\n        });\n      }\n      \n      // Castling\n      if (move.flags.includes('k')) {\n        specialMoves.push({\n          type: 'castle_kingside',\n          moveNumber,\n          notation: move.san,\n          description: `Kingside castling (O-O) - King moves two squares toward h-file, rook jumps to the other side`,\n        });\n      }\n      \n      if (move.flags.includes('q')) {\n        specialMoves.push({\n          type: 'castle_queenside',\n          moveNumber,\n          notation: move.san,\n          description: `Queenside castling (O-O-O) - King moves two squares toward a-file, rook jumps to the other side`,\n        });\n      }\n      \n      // Pawn promotion\n      if (move.promotion) {\n        const pieceNames: Record<string, string> = {\n          q: 'Queen',\n          r: 'Rook',\n          b: 'Bishop',\n          n: 'Knight',\n        };\n        \n        const isUnderpromotion = move.promotion !== 'q';\n        specialMoves.push({\n          type: isUnderpromotion ? 'underpromotion' : 'promotion',\n          moveNumber,\n          notation: move.san,\n          promotedTo: move.promotion as PieceSymbol,\n          description: isUnderpromotion \n            ? `Underpromotion to ${pieceNames[move.promotion]}: ${move.san} - a tactical choice, often to avoid stalemate or deliver checkmate`\n            : `Pawn promotes to ${pieceNames[move.promotion]}: ${move.san} - the most common promotion`,\n        });\n      }\n    });\n  } catch (e) {\n    // Handle malformed PGN gracefully\n  }\n  \n  return specialMoves;\n}\n\n/**\n * Detect tactical motifs (forks, pins, etc.)\n */\nexport function detectTactics(pgn: string): TacticalMotif[] {\n  const tactics: TacticalMotif[] = [];\n  const chess = new Chess();\n  \n  try {\n    chess.loadPgn(pgn);\n    const history = chess.history({ verbose: true });\n    \n    // Reset and replay to analyze each position\n    chess.reset();\n    \n    history.forEach((move, index) => {\n      const moveNumber = index + 1;\n      chess.move(move.san);\n      \n      // Check for checks\n      if (move.san.includes('+') && !move.san.includes('#')) {\n        tactics.push({\n          type: 'check',\n          moveNumber,\n          notation: move.san,\n          attacker: { piece: move.piece, square: move.to },\n          targets: [{ piece: 'k', square: findKingSquare(chess, move.color === 'w' ? 'b' : 'w') }],\n          description: `${getPieceName(move.piece)} delivers check from ${move.to}`,\n          value: 0,\n        });\n      }\n      \n      // Check for checkmate\n      if (move.san.includes('#')) {\n        tactics.push({\n          type: 'checkmate',\n          moveNumber,\n          notation: move.san,\n          attacker: { piece: move.piece, square: move.to },\n          targets: [{ piece: 'k', square: findKingSquare(chess, move.color === 'w' ? 'b' : 'w') }],\n          description: `Checkmate! ${getPieceName(move.piece)} delivers the final blow from ${move.to}`,\n          value: 100, // Game-ending value\n        });\n      }\n      \n      // Check for forks (one piece attacking multiple valuable pieces)\n      const forksFound = detectForks(chess, move, moveNumber);\n      tactics.push(...forksFound);\n      \n      // Check for pins\n      const pinsFound = detectPins(chess, move, moveNumber);\n      tactics.push(...pinsFound);\n    });\n  } catch (e) {\n    // Handle gracefully\n  }\n  \n  return tactics;\n}\n\nfunction detectForks(chess: Chess, lastMove: Move, moveNumber: number): TacticalMotif[] {\n  const forks: TacticalMotif[] = [];\n  const movedPiece = lastMove.piece;\n  const movedTo = lastMove.to;\n  const color = lastMove.color;\n  \n  // Get all squares attacked by the moved piece\n  const attackedSquares = getAttackedSquares(chess, movedTo);\n  \n  // Find valuable pieces being attacked\n  const valuablePieces: { piece: PieceSymbol; square: Square }[] = [];\n  const pieceValues: Record<string, number> = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 100 };\n  \n  for (const square of attackedSquares) {\n    const piece = chess.get(square);\n    if (piece && piece.color !== color) {\n      if (pieceValues[piece.type] >= 3 || piece.type === 'k') {\n        valuablePieces.push({ piece: piece.type, square });\n      }\n    }\n  }\n  \n  // A fork attacks 2+ valuable pieces\n  if (valuablePieces.length >= 2) {\n    const totalValue = valuablePieces.reduce((sum, p) => sum + pieceValues[p.piece], 0);\n    forks.push({\n      type: 'fork',\n      moveNumber,\n      notation: lastMove.san,\n      attacker: { piece: movedPiece, square: movedTo },\n      targets: valuablePieces,\n      description: `${getPieceName(movedPiece)} fork attacks ${valuablePieces.map(p => getPieceName(p.piece)).join(' and ')}`,\n      value: totalValue,\n    });\n  }\n  \n  return forks;\n}\n\nfunction detectPins(chess: Chess, lastMove: Move, moveNumber: number): TacticalMotif[] {\n  const pins: TacticalMotif[] = [];\n  const skewers: TacticalMotif[] = [];\n  const movedPiece = lastMove.piece;\n  const movedTo = lastMove.to;\n  const attackerColor = lastMove.color;\n  const defenderColor = attackerColor === 'w' ? 'b' : 'w';\n  \n  // Only sliding pieces can create pins/skewers\n  if (!['b', 'r', 'q'].includes(movedPiece)) {\n    return [];\n  }\n  \n  const pieceValues: Record<string, number> = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 100 };\n  \n  // Find the defender's king position\n  const kingSquare = findKingSquare(chess, defenderColor);\n  \n  // Direction vectors for sliding pieces\n  const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n  const rookDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  const queenDirs = [...bishopDirs, ...rookDirs];\n  \n  const directions = movedPiece === 'b' ? bishopDirs \n                   : movedPiece === 'r' ? rookDirs \n                   : queenDirs;\n  \n  const file = movedTo.charCodeAt(0) - 97; // 0-7\n  const rank = parseInt(movedTo[1]) - 1; // 0-7\n  \n  // Check each direction from the moved piece\n  for (const [df, dr] of directions) {\n    const piecesInLine: { piece: PieceSymbol; square: Square; color: 'w' | 'b'; value: number }[] = [];\n    \n    let f = file + df;\n    let r = rank + dr;\n    \n    // Scan along the line\n    while (f >= 0 && f <= 7 && r >= 0 && r <= 7) {\n      const square = (String.fromCharCode(97 + f) + (r + 1)) as Square;\n      const piece = chess.get(square);\n      \n      if (piece) {\n        piecesInLine.push({\n          piece: piece.type,\n          square,\n          color: piece.color,\n          value: pieceValues[piece.type]\n        });\n        \n        // Stop if we hit a same-color piece (can't pin through)\n        if (piece.color === attackerColor) break;\n        \n        // If we have 2 defender pieces in line, check for pin/skewer\n        if (piecesInLine.length === 2) break;\n      }\n      \n      f += df;\n      r += dr;\n    }\n    \n    // Need exactly 2 enemy pieces in line for pin/skewer\n    const enemyPieces = piecesInLine.filter(p => p.color === defenderColor);\n    \n    if (enemyPieces.length === 2) {\n      const first = enemyPieces[0];\n      const second = enemyPieces[1];\n      \n      // PIN: First piece is less valuable than second (or second is king)\n      // The first piece is \"pinned\" to the more valuable piece behind it\n      if (first.value < second.value || second.piece === 'k') {\n        pins.push({\n          type: 'pin',\n          moveNumber,\n          notation: lastMove.san,\n          attacker: { piece: movedPiece, square: movedTo },\n          targets: [\n            { piece: first.piece, square: first.square },\n            { piece: second.piece, square: second.square }\n          ],\n          description: `${getPieceName(movedPiece)} pins ${getPieceName(first.piece)} to ${second.piece === 'k' ? 'the King' : getPieceName(second.piece)}`,\n          value: first.value + (second.piece === 'k' ? 10 : second.value),\n        });\n      }\n      \n      // SKEWER: First piece is MORE valuable than second\n      // The more valuable piece must move, exposing the lesser piece\n      if (first.value > second.value && first.piece !== 'k') {\n        skewers.push({\n          type: 'skewer',\n          moveNumber,\n          notation: lastMove.san,\n          attacker: { piece: movedPiece, square: movedTo },\n          targets: [\n            { piece: first.piece, square: first.square },\n            { piece: second.piece, square: second.square }\n          ],\n          description: `${getPieceName(movedPiece)} skewers ${getPieceName(first.piece)}, exposing ${getPieceName(second.piece)}`,\n          value: first.value + second.value,\n        });\n      }\n      \n      // Special case: Absolute pin (pinned to king)\n      if (second.piece === 'k') {\n        // This is always a pin, the pinned piece cannot legally move\n        // Already handled above, but could add extra flag\n      }\n    }\n  }\n  \n  return [...pins, ...skewers];\n}\n\nfunction getAttackedSquares(chess: Chess, from: Square): Square[] {\n  const attacks: Square[] = [];\n  const files = 'abcdefgh';\n  const ranks = '12345678';\n  \n  for (const file of files) {\n    for (const rank of ranks) {\n      const to = (file + rank) as Square;\n      if (to !== from) {\n        // Check if move would be legal (captures or attacks)\n        const moves = chess.moves({ square: from, verbose: true });\n        if (moves.some(m => m.to === to)) {\n          attacks.push(to);\n        }\n      }\n    }\n  }\n  \n  return attacks;\n}\n\nfunction findKingSquare(chess: Chess, color: 'w' | 'b'): Square {\n  const files = 'abcdefgh';\n  const ranks = '12345678';\n  \n  for (const file of files) {\n    for (const rank of ranks) {\n      const square = (file + rank) as Square;\n      const piece = chess.get(square);\n      if (piece && piece.type === 'k' && piece.color === color) {\n        return square;\n      }\n    }\n  }\n  \n  return 'e1' as Square; // Fallback\n}\n\nfunction getPieceName(piece: PieceSymbol): string {\n  const names: Record<string, string> = {\n    p: 'Pawn',\n    n: 'Knight',\n    b: 'Bishop',\n    r: 'Rook',\n    q: 'Queen',\n    k: 'King',\n  };\n  return names[piece] || piece.toUpperCase();\n}\n\n/**\n * Detect game phases\n */\nexport function detectGamePhases(totalMoves: number, moves: string[]): GamePhase[] {\n  const phases: GamePhase[] = [];\n  \n  // Opening: first 10-15 moves (20-30 half-moves)\n  const openingEnd = Math.min(Math.floor(totalMoves * 0.25), 30);\n  \n  // Endgame: typically when few pieces remain or after move 40\n  const endgameStart = Math.max(Math.floor(totalMoves * 0.7), 60);\n  \n  // Opening phase\n  phases.push({\n    name: 'opening',\n    startMove: 1,\n    endMove: openingEnd,\n    description: 'Development phase - pieces are developed, castling, center control',\n    keyEvents: extractPhaseEvents(moves, 1, openingEnd),\n  });\n  \n  // Middlegame\n  if (openingEnd < endgameStart) {\n    phases.push({\n      name: 'middlegame',\n      startMove: openingEnd + 1,\n      endMove: endgameStart - 1,\n      description: 'Main battle - tactical combinations, attacks, strategic maneuvering',\n      keyEvents: extractPhaseEvents(moves, openingEnd + 1, endgameStart - 1),\n    });\n  }\n  \n  // Endgame\n  if (endgameStart <= totalMoves) {\n    phases.push({\n      name: 'endgame',\n      startMove: endgameStart,\n      endMove: totalMoves,\n      description: 'Endgame phase - fewer pieces, king becomes active, pawn promotion key',\n      keyEvents: extractPhaseEvents(moves, endgameStart, totalMoves),\n    });\n  }\n  \n  return phases;\n}\n\nfunction extractPhaseEvents(moves: string[], start: number, end: number): string[] {\n  const events: string[] = [];\n  const phraseMoves = moves.slice(start - 1, end);\n  \n  for (let i = 0; i < phraseMoves.length; i++) {\n    const move = phraseMoves[i];\n    const absMove = start + i;\n    \n    if (move.includes('#')) events.push(`Move ${absMove}: Checkmate! (${move})`);\n    else if (move.includes('+')) events.push(`Move ${absMove}: Check (${move})`);\n    else if (move === 'O-O') events.push(`Move ${absMove}: Kingside castle`);\n    else if (move === 'O-O-O') events.push(`Move ${absMove}: Queenside castle`);\n    else if (move.includes('=')) events.push(`Move ${absMove}: Pawn promotion (${move})`);\n    else if (move.includes('x') && move.toLowerCase().includes('q')) events.push(`Move ${absMove}: Queen capture! (${move})`);\n  }\n  \n  return events.slice(0, 5); // Limit to 5 key events per phase\n}\n\n/**\n * Main analysis function - analyzes a full game\n * Returns null if analysis fails to prevent app crashes\n */\nexport function analyzeGame(pgn: string): GameAnalysis | null {\n  try {\n    const moves = pgnToMoves(pgn);\n    const totalMoves = moves.length;\n    \n    // Return null for empty games\n    if (totalMoves === 0) {\n      return null;\n    }\n    \n    // Count captures and checks\n    let captureCount = 0;\n    let checkCount = 0;\n    \n    for (const move of moves) {\n      if (move.includes('x')) captureCount++;\n      if (move.includes('+') || move.includes('#')) checkCount++;\n    }\n    \n    // Classify move quality with error handling\n    let classifiedMoves: ClassifiedMove[] = [];\n    let moveQuality: MoveQualitySummary = {\n      totalMoves: 0,\n      brilliantCount: 0,\n      greatCount: 0,\n      bestCount: 0,\n      goodCount: 0,\n      bookCount: 0,\n      inaccuracyCount: 0,\n      mistakeCount: 0,\n      blunderCount: 0,\n      checkCount: 0,\n      checkmateCount: 0,\n      captureCount: 0,\n      castleCount: 0,\n      promotionCount: 0,\n      sacrificeCount: 0,\n      accuracy: 0,\n      whiteAccuracy: 0,\n      blackAccuracy: 0,\n      whiteMoves: [],\n      blackMoves: [],\n    };\n    \n    try {\n      classifiedMoves = classifyMoves(pgn);\n      moveQuality = getMoveQualitySummary(classifiedMoves);\n    } catch (e) {\n      console.warn('Move quality classification failed:', e);\n    }\n    \n    // Determine complexity - enhanced with brilliant/blunder data\n    let complexity: GameAnalysis['summary']['complexity'] = 'simple';\n    if (totalMoves > 40) complexity = 'moderate';\n    if (totalMoves > 60 && captureCount > 10) complexity = 'complex';\n    if (totalMoves > 80 && checkCount > 5) complexity = 'masterpiece';\n    if (moveQuality.brilliantCount >= 2) complexity = 'masterpiece';\n    \n    const analysis: GameAnalysis = {\n      opening: detectOpening(moves),\n      gambit: detectGambit(moves),\n      tactics: detectTactics(pgn),\n      specialMoves: detectSpecialMoves(pgn),\n      phases: detectGamePhases(totalMoves, moves),\n      moveQuality,\n      summary: {\n        totalMoves,\n        captureCount,\n        checkCount,\n        brilliantCount: moveQuality.brilliantCount,\n        blunderCount: moveQuality.blunderCount,\n        accuracy: moveQuality.accuracy,\n        materialBalance: 0, // Would require position analysis\n        longestForcingSequence: 0, // Would require deep analysis\n        complexity,\n      },\n    };\n    \n    return analysis;\n  } catch (e) {\n    console.error('Game analysis failed:', e);\n    return null;\n  }\n}\n\n/**\n * Get a human-readable summary of the analysis\n */\nexport function getAnalysisSummary(analysis: GameAnalysis): string {\n  const parts: string[] = [];\n  \n  if (analysis.opening) {\n    parts.push(`Opening: ${analysis.opening.name} (${analysis.opening.eco})`);\n    parts.push(`  → ${analysis.opening.description}`);\n  }\n  \n  if (analysis.gambit) {\n    parts.push(`Gambit: ${analysis.gambit.name}`);\n    parts.push(`  → Sacrificed: ${analysis.gambit.sacrificedMaterial}`);\n    parts.push(`  → Compensation: ${analysis.gambit.compensation}`);\n  }\n  \n  if (analysis.tactics.length > 0) {\n    parts.push(`Tactics detected: ${analysis.tactics.length}`);\n    analysis.tactics.slice(0, 3).forEach(t => {\n      parts.push(`  → Move ${t.moveNumber}: ${t.description}`);\n    });\n  }\n  \n  if (analysis.specialMoves.length > 0) {\n    parts.push(`Special moves: ${analysis.specialMoves.map(m => m.type).join(', ')}`);\n  }\n  \n  // Add move quality summary\n  if (analysis.moveQuality) {\n    const mq = analysis.moveQuality;\n    parts.push(`Move Quality: ${analysis.summary.accuracy}% accuracy`);\n    if (mq.brilliantCount > 0) {\n      parts.push(`  → Brilliant moves: ${mq.brilliantCount}`);\n    }\n    if (mq.blunderCount > 0) {\n      parts.push(`  → Blunders: ${mq.blunderCount}`);\n    }\n  }\n  \n  parts.push(`Game complexity: ${analysis.summary.complexity}`);\n  parts.push(`Total: ${analysis.summary.totalMoves} moves, ${analysis.summary.captureCount} captures, ${analysis.summary.checkCount} checks`);\n  \n  return parts.join('\\n');\n}\n";export{e as default};
