const n="import { Chess, Square, Move } from 'chess.js';\nimport { getStockfishEngine } from '@/lib/chess/stockfishEngine';\n\nexport type BotDifficulty = 'easy' | 'medium' | 'hard' | 'stockfish';\n\ninterface EvaluationResult {\n  score: number;\n  move: Move | null;\n}\n\n// Piece values for evaluation\nconst PIECE_VALUES: Record<string, number> = {\n  p: 100,\n  n: 320,\n  b: 330,\n  r: 500,\n  q: 900,\n  k: 20000,\n};\n\n// Position tables for piece-square evaluation\nconst PAWN_TABLE = [\n  [0, 0, 0, 0, 0, 0, 0, 0],\n  [50, 50, 50, 50, 50, 50, 50, 50],\n  [10, 10, 20, 30, 30, 20, 10, 10],\n  [5, 5, 10, 25, 25, 10, 5, 5],\n  [0, 0, 0, 20, 20, 0, 0, 0],\n  [5, -5, -10, 0, 0, -10, -5, 5],\n  [5, 10, 10, -20, -20, 10, 10, 5],\n  [0, 0, 0, 0, 0, 0, 0, 0],\n];\n\nconst KNIGHT_TABLE = [\n  [-50, -40, -30, -30, -30, -30, -40, -50],\n  [-40, -20, 0, 0, 0, 0, -20, -40],\n  [-30, 0, 10, 15, 15, 10, 0, -30],\n  [-30, 5, 15, 20, 20, 15, 5, -30],\n  [-30, 0, 15, 20, 20, 15, 0, -30],\n  [-30, 5, 10, 15, 15, 10, 5, -30],\n  [-40, -20, 0, 5, 5, 0, -20, -40],\n  [-50, -40, -30, -30, -30, -30, -40, -50],\n];\n\nconst BISHOP_TABLE = [\n  [-20, -10, -10, -10, -10, -10, -10, -20],\n  [-10, 0, 0, 0, 0, 0, 0, -10],\n  [-10, 0, 5, 10, 10, 5, 0, -10],\n  [-10, 5, 5, 10, 10, 5, 5, -10],\n  [-10, 0, 10, 10, 10, 10, 0, -10],\n  [-10, 10, 10, 10, 10, 10, 10, -10],\n  [-10, 5, 0, 0, 0, 0, 5, -10],\n  [-20, -10, -10, -10, -10, -10, -10, -20],\n];\n\nconst ROOK_TABLE = [\n  [0, 0, 0, 0, 0, 0, 0, 0],\n  [5, 10, 10, 10, 10, 10, 10, 5],\n  [-5, 0, 0, 0, 0, 0, 0, -5],\n  [-5, 0, 0, 0, 0, 0, 0, -5],\n  [-5, 0, 0, 0, 0, 0, 0, -5],\n  [-5, 0, 0, 0, 0, 0, 0, -5],\n  [-5, 0, 0, 0, 0, 0, 0, -5],\n  [0, 0, 0, 5, 5, 0, 0, 0],\n];\n\nconst QUEEN_TABLE = [\n  [-20, -10, -10, -5, -5, -10, -10, -20],\n  [-10, 0, 0, 0, 0, 0, 0, -10],\n  [-10, 0, 5, 5, 5, 5, 0, -10],\n  [-5, 0, 5, 5, 5, 5, 0, -5],\n  [0, 0, 5, 5, 5, 5, 0, -5],\n  [-10, 5, 5, 5, 5, 5, 0, -10],\n  [-10, 0, 5, 0, 0, 0, 0, -10],\n  [-20, -10, -10, -5, -5, -10, -10, -20],\n];\n\nconst KING_MIDDLE_TABLE = [\n  [-30, -40, -40, -50, -50, -40, -40, -30],\n  [-30, -40, -40, -50, -50, -40, -40, -30],\n  [-30, -40, -40, -50, -50, -40, -40, -30],\n  [-30, -40, -40, -50, -50, -40, -40, -30],\n  [-20, -30, -30, -40, -40, -30, -30, -20],\n  [-10, -20, -20, -20, -20, -20, -20, -10],\n  [20, 20, 0, 0, 0, 0, 20, 20],\n  [20, 30, 10, 0, 0, 10, 30, 20],\n];\n\nfunction getPositionTable(piece: string): number[][] {\n  switch (piece.toLowerCase()) {\n    case 'p': return PAWN_TABLE;\n    case 'n': return KNIGHT_TABLE;\n    case 'b': return BISHOP_TABLE;\n    case 'r': return ROOK_TABLE;\n    case 'q': return QUEEN_TABLE;\n    case 'k': return KING_MIDDLE_TABLE;\n    default: return [];\n  }\n}\n\n// Evaluate the board position\nfunction evaluateBoard(game: Chess): number {\n  if (game.isCheckmate()) {\n    return game.turn() === 'w' ? -Infinity : Infinity;\n  }\n  if (game.isDraw() || game.isStalemate()) {\n    return 0;\n  }\n\n  let score = 0;\n  const board = game.board();\n\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece) {\n        const pieceValue = PIECE_VALUES[piece.type] || 0;\n        const table = getPositionTable(piece.type);\n        \n        // Get position bonus (flip for black pieces)\n        let positionBonus = 0;\n        if (table.length > 0) {\n          const tableRank = piece.color === 'w' ? rank : 7 - rank;\n          positionBonus = table[tableRank][file];\n        }\n\n        const totalValue = pieceValue + positionBonus;\n        score += piece.color === 'w' ? totalValue : -totalValue;\n      }\n    }\n  }\n\n  // Mobility bonus\n  const moves = game.moves().length;\n  score += game.turn() === 'w' ? moves * 2 : -moves * 2;\n\n  return score;\n}\n\n// Minimax with alpha-beta pruning\nfunction minimax(\n  game: Chess,\n  depth: number,\n  alpha: number,\n  beta: number,\n  maximizingPlayer: boolean\n): EvaluationResult {\n  if (depth === 0 || game.isGameOver()) {\n    return { score: evaluateBoard(game), move: null };\n  }\n\n  const moves = game.moves({ verbose: true });\n  \n  // Move ordering for better pruning\n  moves.sort((a, b) => {\n    let scoreA = 0, scoreB = 0;\n    if (a.captured) scoreA += PIECE_VALUES[a.captured] || 0;\n    if (b.captured) scoreB += PIECE_VALUES[b.captured] || 0;\n    if (a.san.includes('+')) scoreA += 50;\n    if (b.san.includes('+')) scoreB += 50;\n    return scoreB - scoreA;\n  });\n\n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    let bestMove: Move | null = null;\n\n    for (const move of moves) {\n      game.move(move);\n      const evalResult = minimax(game, depth - 1, alpha, beta, false);\n      game.undo();\n\n      if (evalResult.score > maxEval) {\n        maxEval = evalResult.score;\n        bestMove = move;\n      }\n      alpha = Math.max(alpha, evalResult.score);\n      if (beta <= alpha) break;\n    }\n\n    return { score: maxEval, move: bestMove };\n  } else {\n    let minEval = Infinity;\n    let bestMove: Move | null = null;\n\n    for (const move of moves) {\n      game.move(move);\n      const evalResult = minimax(game, depth - 1, alpha, beta, true);\n      game.undo();\n\n      if (evalResult.score < minEval) {\n        minEval = evalResult.score;\n        bestMove = move;\n      }\n      beta = Math.min(beta, evalResult.score);\n      if (beta <= alpha) break;\n    }\n\n    return { score: minEval, move: bestMove };\n  }\n}\n\n// Get a random move (for easy difficulty)\nfunction getRandomMove(game: Chess): Move | null {\n  const moves = game.moves({ verbose: true });\n  if (moves.length === 0) return null;\n  \n  // 30% chance to prefer captures for some aggression\n  const captures = moves.filter(m => m.captured);\n  if (captures.length > 0 && Math.random() < 0.3) {\n    return captures[Math.floor(Math.random() * captures.length)];\n  }\n  \n  return moves[Math.floor(Math.random() * moves.length)];\n}\n\n// Get medium difficulty move (basic evaluation, depth 2)\nfunction getMediumMove(game: Chess): Move | null {\n  const moves = game.moves({ verbose: true });\n  if (moves.length === 0) return null;\n\n  let bestMove: Move | null = null;\n  let bestScore = game.turn() === 'w' ? -Infinity : Infinity;\n\n  for (const move of moves) {\n    game.move(move);\n    const score = evaluateBoard(game);\n    game.undo();\n\n    if (game.turn() === 'w') {\n      if (score > bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    } else {\n      if (score < bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    }\n  }\n\n  // Add some randomness (20% chance to pick a random good move)\n  if (Math.random() < 0.2) {\n    const sortedMoves = moves.sort((a, b) => {\n      game.move(a);\n      const scoreA = evaluateBoard(game);\n      game.undo();\n      game.move(b);\n      const scoreB = evaluateBoard(game);\n      game.undo();\n      return game.turn() === 'w' ? scoreB - scoreA : scoreA - scoreB;\n    });\n    \n    // Pick from top 3 moves\n    const topMoves = sortedMoves.slice(0, Math.min(3, sortedMoves.length));\n    return topMoves[Math.floor(Math.random() * topMoves.length)];\n  }\n\n  return bestMove;\n}\n\n// Get hard difficulty move (minimax with alpha-beta, depth 4)\nfunction getHardMove(game: Chess): Move | null {\n  const result = minimax(\n    game,\n    4, // Depth 4 for good play without being too slow\n    -Infinity,\n    Infinity,\n    game.turn() === 'w'\n  );\n  return result.move;\n}\n\n// Get Stockfish-powered move (real engine analysis)\nasync function getStockfishMove(game: Chess): Promise<Move | null> {\n  try {\n    const engine = getStockfishEngine();\n    const ready = await engine.waitReady();\n    \n    if (!ready) {\n      console.warn('Stockfish not ready, falling back to hard mode');\n      return getHardMove(game);\n    }\n    \n    const analysis = await engine.analyzePosition(game.fen(), { depth: 18, movetime: 1500 });\n    const bestMoveUci = analysis.bestMove;\n    \n    if (!bestMoveUci) {\n      return getHardMove(game);\n    }\n    \n    // Convert UCI to move object\n    const from = bestMoveUci.slice(0, 2) as Square;\n    const to = bestMoveUci.slice(2, 4) as Square;\n    const promotion = bestMoveUci.length > 4 ? bestMoveUci[4] : undefined;\n    \n    const moves = game.moves({ verbose: true });\n    const move = moves.find(m => \n      m.from === from && \n      m.to === to && \n      (!promotion || m.promotion === promotion)\n    );\n    \n    return move || getHardMove(game);\n  } catch (e) {\n    console.error('Stockfish move error:', e);\n    return getHardMove(game);\n  }\n}\n\n// Main bot move function\nexport function getBotMove(game: Chess, difficulty: BotDifficulty): Move | null {\n  switch (difficulty) {\n    case 'easy':\n      return getRandomMove(game);\n    case 'medium':\n      return getMediumMove(game);\n    case 'hard':\n      return getHardMove(game);\n    case 'stockfish':\n      // For sync API, fall back to hard - use getBotMoveAsync for Stockfish\n      return getHardMove(game);\n    default:\n      return getRandomMove(game);\n  }\n}\n\n// Async bot move function (supports Stockfish)\nexport async function getBotMoveAsync(game: Chess, difficulty: BotDifficulty): Promise<Move | null> {\n  if (difficulty === 'stockfish') {\n    return getStockfishMove(game);\n  }\n  return getBotMove(game, difficulty);\n}\n\n// Get thinking delay based on difficulty (for UX)\nexport function getBotThinkingDelay(difficulty: BotDifficulty): number {\n  switch (difficulty) {\n    case 'easy':\n      return 300 + Math.random() * 500; // 300-800ms\n    case 'medium':\n      return 500 + Math.random() * 1000; // 500-1500ms\n    case 'hard':\n      return 800 + Math.random() * 1500; // 800-2300ms\n    case 'stockfish':\n      return 100; // Minimal delay, engine takes time itself\n    default:\n      return 500;\n  }\n}\n\n// Difficulty descriptions\nexport const BOT_DIFFICULTIES: { id: BotDifficulty; label: string; description: string; rating: string; enginePowered?: boolean }[] = [\n  { id: 'easy', label: 'Beginner', description: 'Makes random moves, occasional captures', rating: '~800' },\n  { id: 'medium', label: 'Club Player', description: 'Basic tactics and material awareness', rating: '~1400' },\n  { id: 'hard', label: 'Master', description: 'Advanced evaluation, 4-ply search depth', rating: '~2000' },\n  { id: 'stockfish', label: 'Stockfish 16', description: 'Real NNUE engine, grandmaster strength', rating: '~3200', enginePowered: true },\n];\n";export{n as default};
