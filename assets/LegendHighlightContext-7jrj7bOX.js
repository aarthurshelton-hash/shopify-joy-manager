const e="import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\n\nexport interface HighlightedPiece {\n  pieceType: PieceType;\n  pieceColor: PieceColor;\n}\n\n// Locked square for persistent highlighting (similar to locked pieces)\nexport interface LockedSquare {\n  square: string; // e.g., \"e4\"\n  pieces: HighlightedPiece[]; // Pieces that visited this square\n}\n\n// For reverse highlighting: hovering a square highlights relevant pieces\nexport interface HoveredSquareInfo {\n  square: string;\n  pieces: HighlightedPiece[]; // All pieces that have visited this square\n  moveNumbers: number[]; // Move numbers associated with this square's visits\n}\n\n// Annotation types that can be highlighted\nexport type AnnotationType = \n  | 'white-player'    // The white player name\n  | 'black-player'    // The black player name\n  | 'move-notation'   // The move notation text\n  | 'result';         // The game result\n\n// For annotation highlighting: which annotation element is hovered\nexport interface HoveredAnnotation {\n  type: AnnotationType;\n  // For annotations, specify which pieces are associated\n  associatedPieces?: HighlightedPiece[];\n}\n\n// Move arrow data for visualizing piece movements\nexport interface PieceMoveArrow {\n  from: string; // e.g., \"e2\"\n  to: string;   // e.g., \"e4\"\n  moveNumber: number;\n  pieceType: PieceType;\n  pieceColor: PieceColor;\n  isCapture: boolean;\n}\n\n// Follow piece mode data\nexport interface FollowPieceData {\n  piece: HighlightedPiece;\n  moveNumbers: number[]; // All move numbers where this piece moved\n  currentIndex: number;  // Current position in the moveNumbers array\n}\n\n// For move notation hover highlighting\nexport interface HoveredMoveInfo {\n  moveNumber: number;       // 1-indexed move number in the game\n  san: string;              // The SAN notation (e.g., \"Nf3\", \"e4\")\n  piece: HighlightedPiece;  // The piece that moved\n  targetSquare: string;     // The destination square (e.g., \"f3\", \"e4\")\n  isCapture: boolean;       // Whether this move was a capture\n}\n\ninterface LegendHighlightContextValue {\n  highlightedPiece: HighlightedPiece | null;\n  lockedPieces: HighlightedPiece[];\n  lockedSquares: LockedSquare[]; // NEW: Locked squares for persistent highlighting\n  compareMode: boolean;\n  hoveredSquare: HoveredSquareInfo | null;\n  // Annotation highlighting\n  hoveredAnnotation: HoveredAnnotation | null;\n  highlightedAnnotations: AnnotationType[]; // Annotations to highlight based on piece selection\n  // Follow piece mode\n  followPieceData: FollowPieceData | null;\n  pieceArrows: PieceMoveArrow[];\n  // Move notation hover\n  hoveredMove: HoveredMoveInfo | null;\n  setHighlightedPiece: (piece: HighlightedPiece | null) => void;\n  toggleLockedPiece: (piece: HighlightedPiece) => void;\n  toggleLockedSquare: (square: string, pieces: HighlightedPiece[]) => void; // NEW\n  toggleCompareMode: () => void;\n  clearLock: () => void;\n  setHoveredSquare: (info: HoveredSquareInfo | null) => void;\n  setHoveredAnnotation: (annotation: HoveredAnnotation | null) => void;\n  setHighlightedAnnotations: (annotations: AnnotationType[]) => void;\n  // Follow piece mode functions\n  setFollowPieceData: (data: FollowPieceData | null) => void;\n  setPieceArrows: (arrows: PieceMoveArrow[]) => void;\n  nextPieceMove: () => number | null;\n  prevPieceMove: () => number | null;\n  // Move notation hover\n  setHoveredMove: (move: HoveredMoveInfo | null) => void;\n}\n\nconst LegendHighlightContext = createContext<LegendHighlightContextValue | undefined>(undefined);\n\ninterface LegendHighlightProviderProps {\n  children: ReactNode;\n  initialLockedPieces?: HighlightedPiece[];\n  initialLockedSquares?: LockedSquare[];\n  initialCompareMode?: boolean;\n}\n\nexport function LegendHighlightProvider({ \n  children, \n  initialLockedPieces,\n  initialLockedSquares, \n  initialCompareMode \n}: LegendHighlightProviderProps) {\n  const [highlightedPiece, setHighlightedPieceState] = useState<HighlightedPiece | null>(null);\n  const [lockedPieces, setLockedPieces] = useState<HighlightedPiece[]>(initialLockedPieces ?? []);\n  const [lockedSquares, setLockedSquares] = useState<LockedSquare[]>(initialLockedSquares ?? []);\n  const [compareMode, setCompareMode] = useState(initialCompareMode ?? false);\n  const [hoveredSquare, setHoveredSquareState] = useState<HoveredSquareInfo | null>(null);\n  const [hoveredAnnotation, setHoveredAnnotationState] = useState<HoveredAnnotation | null>(null);\n  const [highlightedAnnotations, setHighlightedAnnotationsState] = useState<AnnotationType[]>([]);\n  const [followPieceData, setFollowPieceDataState] = useState<FollowPieceData | null>(null);\n  const [pieceArrows, setPieceArrowsState] = useState<PieceMoveArrow[]>([]);\n  const [hoveredMove, setHoveredMoveState] = useState<HoveredMoveInfo | null>(null);\n\n  const setHighlightedPiece = useCallback((piece: HighlightedPiece | null) => {\n    setHighlightedPieceState(piece);\n  }, []);\n\n  const setHoveredSquare = useCallback((info: HoveredSquareInfo | null) => {\n    setHoveredSquareState(info);\n  }, []);\n\n  const setHoveredAnnotation = useCallback((annotation: HoveredAnnotation | null) => {\n    setHoveredAnnotationState(annotation);\n  }, []);\n\n  const setHighlightedAnnotations = useCallback((annotations: AnnotationType[]) => {\n    setHighlightedAnnotationsState(annotations);\n  }, []);\n\n  const setFollowPieceData = useCallback((data: FollowPieceData | null) => {\n    setFollowPieceDataState(data);\n  }, []);\n\n  const setPieceArrows = useCallback((arrows: PieceMoveArrow[]) => {\n    setPieceArrowsState(arrows);\n  }, []);\n\n  const setHoveredMove = useCallback((move: HoveredMoveInfo | null) => {\n    setHoveredMoveState(move);\n  }, []);\n\n  const nextPieceMove = useCallback((): number | null => {\n    if (!followPieceData) return null;\n    const newIndex = Math.min(followPieceData.currentIndex + 1, followPieceData.moveNumbers.length - 1);\n    if (newIndex !== followPieceData.currentIndex) {\n      setFollowPieceDataState({ ...followPieceData, currentIndex: newIndex });\n      return followPieceData.moveNumbers[newIndex];\n    }\n    return null;\n  }, [followPieceData]);\n\n  const prevPieceMove = useCallback((): number | null => {\n    if (!followPieceData) return null;\n    const newIndex = Math.max(followPieceData.currentIndex - 1, 0);\n    if (newIndex !== followPieceData.currentIndex) {\n      setFollowPieceDataState({ ...followPieceData, currentIndex: newIndex });\n      return followPieceData.moveNumbers[newIndex];\n    }\n    return null;\n  }, [followPieceData]);\n\n  const toggleLockedPiece = useCallback((piece: HighlightedPiece) => {\n    setLockedPieces(prev => {\n      const existingIndex = prev.findIndex(\n        p => p.pieceType === piece.pieceType && p.pieceColor === piece.pieceColor\n      );\n      \n      if (existingIndex !== -1) {\n        // Remove if already selected - also clear follow mode\n        setFollowPieceDataState(null);\n        setPieceArrowsState([]);\n        return prev.filter((_, i) => i !== existingIndex);\n      }\n      \n      if (compareMode) {\n        // In compare mode, allow up to 2 pieces\n        if (prev.length >= 2) {\n          // Replace oldest selection\n          return [prev[1], piece];\n        }\n        return [...prev, piece];\n      } else {\n        // Single selection mode\n        return [piece];\n      }\n    });\n  }, [compareMode]);\n\n  // Toggle locked square - click to lock, click again to unlock\n  const toggleLockedSquare = useCallback((square: string, pieces: HighlightedPiece[]) => {\n    setLockedSquares(prev => {\n      const existingIndex = prev.findIndex(s => s.square === square);\n      \n      if (existingIndex !== -1) {\n        // Remove if already locked\n        return prev.filter((_, i) => i !== existingIndex);\n      }\n      \n      // Add new locked square (allow multiple squares)\n      return [...prev, { square, pieces }];\n    });\n  }, []);\n\n  const toggleCompareMode = useCallback(() => {\n    setCompareMode(prev => {\n      if (prev) {\n        // Exiting compare mode - keep only first locked piece\n        setLockedPieces(current => current.slice(0, 1));\n      }\n      return !prev;\n    });\n  }, []);\n\n  const clearLock = useCallback(() => {\n    setLockedPieces([]);\n    setLockedSquares([]);\n    setHighlightedAnnotationsState([]);\n    setFollowPieceDataState(null);\n    setPieceArrowsState([]);\n  }, []);\n\n  return (\n    <LegendHighlightContext.Provider value={{ \n      highlightedPiece: lockedPieces.length > 0 ? null : highlightedPiece, \n      lockedPieces,\n      lockedSquares,\n      compareMode,\n      hoveredSquare,\n      hoveredAnnotation,\n      highlightedAnnotations,\n      followPieceData,\n      pieceArrows,\n      hoveredMove,\n      setHighlightedPiece, \n      toggleLockedPiece,\n      toggleLockedSquare,\n      toggleCompareMode,\n      clearLock,\n      setHoveredSquare,\n      setHoveredAnnotation,\n      setHighlightedAnnotations,\n      setFollowPieceData,\n      setPieceArrows,\n      nextPieceMove,\n      prevPieceMove,\n      setHoveredMove,\n    }}>\n      {children}\n    </LegendHighlightContext.Provider>\n  );\n}\n\nexport function useLegendHighlight() {\n  const context = useContext(LegendHighlightContext);\n  if (context === undefined) {\n    throw new Error('useLegendHighlight must be used within a LegendHighlightProvider');\n  }\n  return context;\n}\n\n// Helper function to parse SAN notation and extract piece type and target square\nexport function parseSanMove(san: string, isWhiteMove: boolean): { pieceType: PieceType; targetSquare: string; isCapture: boolean } | null {\n  if (!san) return null;\n  \n  // Remove check/checkmate symbols\n  const cleanSan = san.replace(/[+#!?]/g, '');\n  \n  // Handle castling\n  if (cleanSan === 'O-O' || cleanSan === 'O-O-O') {\n    return { pieceType: 'k', targetSquare: cleanSan === 'O-O' ? (isWhiteMove ? 'g1' : 'g8') : (isWhiteMove ? 'c1' : 'c8'), isCapture: false };\n  }\n  \n  const isCapture = cleanSan.includes('x');\n  \n  // Extract piece type (uppercase letter at start, or pawn if lowercase/no letter)\n  let pieceType: PieceType = 'p';\n  let remaining = cleanSan;\n  \n  if (/^[KQRBN]/.test(cleanSan)) {\n    const pieceChar = cleanSan[0].toLowerCase();\n    pieceType = pieceChar as PieceType;\n    remaining = cleanSan.slice(1);\n  }\n  \n  // Remove capture symbol and disambiguation\n  remaining = remaining.replace('x', '');\n  \n  // Extract target square (last 2 characters before promotion)\n  const promotionMatch = remaining.match(/=([QRBN])$/i);\n  if (promotionMatch) {\n    remaining = remaining.slice(0, -2);\n  }\n  \n  // Target square is the last 2 characters\n  const targetSquare = remaining.slice(-2);\n  \n  if (!/^[a-h][1-8]$/.test(targetSquare)) {\n    return null;\n  }\n  \n  return { pieceType, targetSquare, isCapture };\n}\n";export{e as default};
