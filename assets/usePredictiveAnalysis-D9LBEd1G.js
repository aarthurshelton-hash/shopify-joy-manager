const n="/**\n * React Hook for Predictive Chess Analysis\n * \n * Provides access to the Predictive Analysis Engine for analyzing\n * position potential and getting best move recommendations.\n */\n\nimport { useState, useCallback, useRef } from 'react';\nimport { \n  analyzePositionPotential, \n  getBestMoveRecommendation,\n  predictVisualPattern,\n  PositionPotential,\n  MoveRecommendation,\n  VisualPattern,\n} from '@/lib/chess/predictiveAnalysis';\nimport { Chess } from 'chess.js';\n\nexport interface UsePredictiveAnalysisReturn {\n  // State\n  isAnalyzing: boolean;\n  progress: { stage: string; percent: number } | null;\n  error: string | null;\n  \n  // Analysis results\n  positionPotential: PositionPotential | null;\n  moveRecommendation: MoveRecommendation | null;\n  visualPattern: VisualPattern | null;\n  \n  // Actions\n  analyzePosition: (fen: string, options?: AnalysisOptions) => Promise<PositionPotential | null>;\n  getBestMove: (fen: string, depth?: number) => Promise<MoveRecommendation | null>;\n  getVisualPattern: (fen: string) => VisualPattern | null;\n  clearResults: () => void;\n  cancelAnalysis: () => void;\n}\n\ninterface AnalysisOptions {\n  depth?: number;\n  lines?: number;\n  lookahead?: number;\n}\n\nexport function usePredictiveAnalysis(): UsePredictiveAnalysisReturn {\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [progress, setProgress] = useState<{ stage: string; percent: number } | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [positionPotential, setPositionPotential] = useState<PositionPotential | null>(null);\n  const [moveRecommendation, setMoveRecommendation] = useState<MoveRecommendation | null>(null);\n  const [visualPattern, setVisualPattern] = useState<VisualPattern | null>(null);\n  \n  const cancelledRef = useRef(false);\n  const mountedRef = useRef(true);\n\n  const analyzePosition = useCallback(async (\n    fen: string, \n    options: AnalysisOptions = {}\n  ): Promise<PositionPotential | null> => {\n    cancelledRef.current = false;\n    setIsAnalyzing(true);\n    setError(null);\n    setProgress({ stage: 'Starting analysis', percent: 0 });\n    \n    try {\n      const result = await analyzePositionPotential(fen, {\n        depth: options.depth || 20,\n        lines: options.lines || 3,\n        lookahead: options.lookahead || 15,\n        onProgress: (stage, percent) => {\n          if (!cancelledRef.current && mountedRef.current) {\n            setProgress({ stage, percent });\n          }\n        },\n      });\n      \n      if (!cancelledRef.current && mountedRef.current) {\n        setPositionPotential(result);\n        setIsAnalyzing(false);\n        setProgress(null);\n      }\n      \n      return result;\n    } catch (e) {\n      if (!cancelledRef.current && mountedRef.current) {\n        setError(e instanceof Error ? e.message : 'Analysis failed');\n        setIsAnalyzing(false);\n        setProgress(null);\n      }\n      return null;\n    }\n  }, []);\n\n  const getBestMove = useCallback(async (\n    fen: string, \n    depth: number = 20\n  ): Promise<MoveRecommendation | null> => {\n    setIsAnalyzing(true);\n    setError(null);\n    \n    try {\n      const result = await getBestMoveRecommendation(fen, depth);\n      \n      if (mountedRef.current) {\n        setMoveRecommendation(result);\n        setIsAnalyzing(false);\n      }\n      \n      return result;\n    } catch (e) {\n      if (mountedRef.current) {\n        setError(e instanceof Error ? e.message : 'Failed to get recommendation');\n        setIsAnalyzing(false);\n      }\n      return null;\n    }\n  }, []);\n\n  const getVisualPattern = useCallback((fen: string): VisualPattern | null => {\n    try {\n      const chess = new Chess(fen);\n      const pattern = predictVisualPattern(chess);\n      setVisualPattern(pattern);\n      return pattern;\n    } catch (e) {\n      setError('Invalid FEN position');\n      return null;\n    }\n  }, []);\n\n  const clearResults = useCallback(() => {\n    setPositionPotential(null);\n    setMoveRecommendation(null);\n    setVisualPattern(null);\n    setError(null);\n  }, []);\n\n  const cancelAnalysis = useCallback(() => {\n    cancelledRef.current = true;\n    setIsAnalyzing(false);\n    setProgress(null);\n  }, []);\n\n  return {\n    isAnalyzing,\n    progress,\n    error,\n    positionPotential,\n    moveRecommendation,\n    visualPattern,\n    analyzePosition,\n    getBestMove,\n    getVisualPattern,\n    clearResults,\n    cancelAnalysis,\n  };\n}\n";export{n as default};
