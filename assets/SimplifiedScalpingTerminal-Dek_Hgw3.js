const e='/**\n * Simplified Scalping Terminal - LIVE MARKET DATA VERSION\n * Uses REAL 24/7 market data (crypto/forex) for prediction testing\n * \n * CEO Testing Dashboard - Alec Arthur Shelton\n */\n\nimport React, { useState, useEffect, useCallback, useRef, useMemo } from \'react\';\nimport { motion, AnimatePresence } from \'framer-motion\';\nimport { \n  TrendingUp, TrendingDown, Minus, Activity, \n  Play, Pause, RotateCcw, Zap, CheckCircle, XCircle, Target, \n  Radio, Clock, Wifi, WifiOff, Globe\n} from \'lucide-react\';\nimport { Card, CardContent, CardHeader, CardTitle } from \'@/components/ui/card\';\nimport { Button } from \'@/components/ui/button\';\nimport { Badge } from \'@/components/ui/badge\';\nimport { Progress } from \'@/components/ui/progress\';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \'@/components/ui/select\';\nimport { cn } from \'@/lib/utils\';\nimport { supabase } from \'@/integrations/supabase/client\';\n\n// ============================================\n// TYPES\n// ============================================\n\ninterface Prediction {\n  id: string;\n  direction: \'up\' | \'down\' | \'flat\';\n  confidence: number;\n  priceAtPrediction: number;\n  timestamp: number;\n  expiresAt: number;\n  resolved?: boolean;\n  wasCorrect?: boolean;\n  actualPrice?: number;\n  actualDirection?: \'up\' | \'down\' | \'flat\';\n  symbol: string;\n}\n\ninterface PriceTick {\n  price: number;\n  timestamp: number;\n  symbol: string;\n  isReal: boolean;\n}\n\ninterface SessionStats {\n  totalPredictions: number;\n  correct: number;\n  accuracy: number;\n  currentStreak: number;\n  bestStreak: number;\n  upAccuracy: number;\n  downAccuracy: number;\n}\n\n// 24/7 Markets - Crypto trades around the clock\nconst MARKET_SYMBOLS = [\n  { symbol: \'BTC-USD\', name: \'Bitcoin\', is24h: true },\n  { symbol: \'ETH-USD\', name: \'Ethereum\', is24h: true },\n  { symbol: \'SPY\', name: \'S&P 500 ETF\', is24h: false },\n  { symbol: \'QQQ\', name: \'Nasdaq 100 ETF\', is24h: false },\n  { symbol: \'AAPL\', name: \'Apple\', is24h: false },\n  { symbol: \'TSLA\', name: \'Tesla\', is24h: false },\n  { symbol: \'NVDA\', name: \'NVIDIA\', is24h: false },\n];\n\n// ============================================\n// PREDICTION ENGINE\n// ============================================\n\nfunction predictDirection(ticks: PriceTick[]): { direction: \'up\' | \'down\' | \'flat\'; confidence: number } {\n  if (ticks.length < 5) {\n    return { direction: \'flat\', confidence: 50 };\n  }\n\n  const recent = ticks.slice(-20);\n  const priceChanges = recent.slice(1).map((t, i) => t.price - recent[i].price);\n  const avgChange = priceChanges.reduce((a, b) => a + b, 0) / priceChanges.length;\n  \n  // Calculate momentum\n  const shortMomentum = ticks.slice(-5).reduce((sum, t, i, arr) => \n    i === 0 ? 0 : sum + (t.price - arr[i-1].price), 0);\n  const longMomentum = ticks.slice(-15).reduce((sum, t, i, arr) => \n    i === 0 ? 0 : sum + (t.price - arr[i-1].price), 0);\n  \n  // Volatility\n  const variance = priceChanges.reduce((sum, c) => sum + Math.pow(c - avgChange, 2), 0) / priceChanges.length;\n  const volatility = Math.sqrt(variance);\n  \n  // Combined signal\n  const signal = (shortMomentum * 2 + longMomentum) / ticks[ticks.length - 1].price * 10000;\n  \n  let direction: \'up\' | \'down\' | \'flat\';\n  if (signal > 0.5) direction = \'up\';\n  else if (signal < -0.5) direction = \'down\';\n  else direction = \'flat\';\n  \n  // Confidence based on signal strength\n  const signalStrength = Math.min(Math.abs(signal) * 10, 35);\n  const baseConfidence = 50 + signalStrength;\n  const confidence = Math.min(92, Math.max(40, baseConfidence * (volatility < 50 ? 1.1 : 0.9)));\n  \n  return { direction, confidence: Math.round(confidence) };\n}\n\nfunction resolveDirection(priceChange: number): \'up\' | \'down\' | \'flat\' {\n  if (priceChange > 0.0001) return \'up\';\n  if (priceChange < -0.0001) return \'down\';\n  return \'flat\';\n}\n\n// ============================================\n// DIRECTION ICON\n// ============================================\n\nconst DirectionIcon: React.FC<{ direction: \'up\' | \'down\' | \'flat\'; size?: number }> = ({ direction, size = 20 }) => {\n  if (direction === \'up\') return <TrendingUp size={size} className="text-green-500" />;\n  if (direction === \'down\') return <TrendingDown size={size} className="text-red-500" />;\n  return <Minus size={size} className="text-muted-foreground" />;\n};\n\n// ============================================\n// MAIN COMPONENT\n// ============================================\n\nconst SimplifiedScalpingTerminal: React.FC = () => {\n  // Core state\n  const [isRunning, setIsRunning] = useState(true);\n  const [selectedSymbol, setSelectedSymbol] = useState(\'BTC-USD\');\n  const [ticks, setTicks] = useState<PriceTick[]>([]);\n  const [predictions, setPredictions] = useState<Prediction[]>([]);\n  const [currentPrice, setCurrentPrice] = useState<number | null>(null);\n  const [isLive, setIsLive] = useState(false);\n  const [lastFetch, setLastFetch] = useState<Date | null>(null);\n  const [fetchError, setFetchError] = useState<string | null>(null);\n  const [predictionIntervalMs] = useState(5000); // 5 second predictions\n  \n  // Refs\n  const fetchIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const predictionIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const mountedRef = useRef(true);\n  const lastPriceRef = useRef<number | null>(null);\n\n  // Get symbol info\n  const symbolInfo = useMemo(() => \n    MARKET_SYMBOLS.find(s => s.symbol === selectedSymbol) || MARKET_SYMBOLS[0],\n    [selectedSymbol]\n  );\n\n  // Calculate stats\n  const stats = useMemo((): SessionStats => {\n    const symbolPredictions = predictions.filter(p => p.symbol === selectedSymbol);\n    const resolved = symbolPredictions.filter(p => p.resolved);\n    const correct = resolved.filter(p => p.wasCorrect);\n    const upPreds = resolved.filter(p => p.direction === \'up\');\n    const downPreds = resolved.filter(p => p.direction === \'down\');\n    \n    let currentStreak = 0;\n    for (let i = resolved.length - 1; i >= 0; i--) {\n      if (resolved[i].wasCorrect) currentStreak++;\n      else break;\n    }\n    \n    let bestStreak = 0;\n    let tempStreak = 0;\n    for (const p of resolved) {\n      if (p.wasCorrect) {\n        tempStreak++;\n        bestStreak = Math.max(bestStreak, tempStreak);\n      } else {\n        tempStreak = 0;\n      }\n    }\n    \n    return {\n      totalPredictions: resolved.length,\n      correct: correct.length,\n      accuracy: resolved.length > 0 ? (correct.length / resolved.length) * 100 : 0,\n      currentStreak,\n      bestStreak,\n      upAccuracy: upPreds.length > 0 ? (upPreds.filter(p => p.wasCorrect).length / upPreds.length) * 100 : 0,\n      downAccuracy: downPreds.length > 0 ? (downPreds.filter(p => p.wasCorrect).length / downPreds.length) * 100 : 0\n    };\n  }, [predictions, selectedSymbol]);\n\n  // Pending and resolved predictions for current symbol\n  const pendingPredictions = useMemo(() => \n    predictions.filter(p => !p.resolved && p.symbol === selectedSymbol).slice(-5), \n    [predictions, selectedSymbol]\n  );\n  \n  const recentResolved = useMemo(() => \n    predictions.filter(p => p.resolved && p.symbol === selectedSymbol).slice(-10).reverse(), \n    [predictions, selectedSymbol]\n  );\n\n  // Fetch real market data\n  const fetchMarketData = useCallback(async () => {\n    if (!mountedRef.current) return;\n    \n    try {\n      const { data, error } = await supabase.functions.invoke(\'stock-data\', {\n        body: { action: \'quote\', symbol: selectedSymbol }\n      });\n\n      if (error) throw error;\n      \n      if (data && data.latestPrice) {\n        const price = data.latestPrice;\n        const now = Date.now();\n        \n        // Only add tick if price changed\n        if (lastPriceRef.current !== price) {\n          lastPriceRef.current = price;\n          \n          const newTick: PriceTick = {\n            price,\n            timestamp: now,\n            symbol: selectedSymbol,\n            isReal: true\n          };\n          \n          setTicks(prev => {\n            const updated = [...prev.filter(t => t.symbol === selectedSymbol), newTick].slice(-200);\n            return updated;\n          });\n          \n          setCurrentPrice(price);\n          setIsLive(true);\n          setFetchError(null);\n        }\n        \n        setLastFetch(new Date());\n      }\n    } catch (error) {\n      console.error(\'Market data fetch error:\', error);\n      setFetchError(error instanceof Error ? error.message : \'Failed to fetch\');\n      setIsLive(false);\n      \n      // Generate simulated tick as fallback\n      if (currentPrice) {\n        const change = (Math.random() - 0.5) * currentPrice * 0.0005;\n        const newPrice = currentPrice + change;\n        \n        setTicks(prev => [...prev, {\n          price: newPrice,\n          timestamp: Date.now(),\n          symbol: selectedSymbol,\n          isReal: false\n        }].slice(-200));\n        \n        setCurrentPrice(newPrice);\n      }\n    }\n  }, [selectedSymbol, currentPrice]);\n\n  // Generate prediction\n  const generatePrediction = useCallback(() => {\n    const symbolTicks = ticks.filter(t => t.symbol === selectedSymbol);\n    if (symbolTicks.length < 5 || !currentPrice) return;\n    \n    const { direction, confidence } = predictDirection(symbolTicks);\n    \n    const newPrediction: Prediction = {\n      id: `pred-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,\n      direction,\n      confidence,\n      priceAtPrediction: currentPrice,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + predictionIntervalMs,\n      symbol: selectedSymbol\n    };\n    \n    setPredictions(prev => [...prev, newPrediction].slice(-100));\n  }, [ticks, selectedSymbol, currentPrice, predictionIntervalMs]);\n\n  // Resolve predictions\n  const resolvePredictions = useCallback(() => {\n    if (!currentPrice) return;\n    const now = Date.now();\n    \n    setPredictions(prev => prev.map(pred => {\n      if (pred.resolved || pred.expiresAt > now || pred.symbol !== selectedSymbol) return pred;\n      \n      const priceChange = (currentPrice - pred.priceAtPrediction) / pred.priceAtPrediction;\n      const actualDirection = resolveDirection(priceChange);\n      const wasCorrect = pred.direction === actualDirection || \n        (pred.direction === \'flat\' && Math.abs(priceChange) < 0.0002);\n      \n      return {\n        ...pred,\n        resolved: true,\n        wasCorrect,\n        actualPrice: currentPrice,\n        actualDirection\n      };\n    }));\n  }, [currentPrice, selectedSymbol]);\n\n  // Main effect - start/stop data fetching\n  useEffect(() => {\n    mountedRef.current = true;\n    \n    if (isRunning) {\n      // Initial fetch\n      fetchMarketData();\n      \n      // Fetch every 2 seconds for real-time feel\n      fetchIntervalRef.current = setInterval(() => {\n        if (mountedRef.current) {\n          fetchMarketData();\n          resolvePredictions();\n        }\n      }, 2000);\n      \n      // Generate predictions every 5 seconds\n      predictionIntervalRef.current = setInterval(() => {\n        if (mountedRef.current) {\n          generatePrediction();\n        }\n      }, predictionIntervalMs);\n    }\n    \n    return () => {\n      mountedRef.current = false;\n      if (fetchIntervalRef.current) clearInterval(fetchIntervalRef.current);\n      if (predictionIntervalRef.current) clearInterval(predictionIntervalRef.current);\n    };\n  }, [isRunning, selectedSymbol, predictionIntervalMs]);\n\n  // Symbol change - reset ticks\n  useEffect(() => {\n    setTicks([]);\n    setCurrentPrice(null);\n    lastPriceRef.current = null;\n    if (isRunning) {\n      fetchMarketData();\n    }\n  }, [selectedSymbol]);\n\n  // Reset function\n  const handleReset = useCallback(() => {\n    setPredictions([]);\n    setTicks([]);\n    setCurrentPrice(null);\n    lastPriceRef.current = null;\n  }, []);\n\n  // Format price based on symbol\n  const formatPrice = (price: number) => {\n    if (selectedSymbol.includes(\'BTC\')) return `$${price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\n    if (selectedSymbol.includes(\'ETH\')) return `$${price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\n    return `$${price.toFixed(2)}`;\n  };\n\n  // Price change calculation\n  const symbolTicks = ticks.filter(t => t.symbol === selectedSymbol);\n  const priceChange = symbolTicks.length > 1 && currentPrice ? \n    currentPrice - symbolTicks[0].price : 0;\n  const priceChangePercent = symbolTicks.length > 1 && symbolTicks[0].price ? \n    (priceChange / symbolTicks[0].price) * 100 : 0;\n\n  return (\n    <div className="space-y-4 p-4">\n      {/* Header */}\n      <div className="flex items-center justify-between flex-wrap gap-4">\n        <div className="flex items-center gap-4">\n          <h1 className="text-2xl font-bold flex items-center gap-2">\n            <Activity className="w-6 h-6 text-primary" />\n            Live Scalping Terminal\n          </h1>\n          <Badge variant={isLive ? "default" : "destructive"} className="animate-pulse">\n            {isLive ? <Wifi className="w-3 h-3 mr-1" /> : <WifiOff className="w-3 h-3 mr-1" />}\n            {isLive ? \'LIVE DATA\' : \'SIMULATED\'}\n          </Badge>\n          {symbolInfo.is24h && (\n            <Badge variant="outline" className="text-green-500 border-green-500">\n              <Globe className="w-3 h-3 mr-1" />\n              24/7 Market\n            </Badge>\n          )}\n        </div>\n        \n        <div className="flex items-center gap-2">\n          <Select value={selectedSymbol} onValueChange={setSelectedSymbol}>\n            <SelectTrigger className="w-[180px]">\n              <SelectValue />\n            </SelectTrigger>\n            <SelectContent>\n              {MARKET_SYMBOLS.map(s => (\n                <SelectItem key={s.symbol} value={s.symbol}>\n                  {s.symbol} - {s.name}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n          \n          <Button \n            variant={isRunning ? "destructive" : "default"}\n            size="sm"\n            onClick={() => setIsRunning(!isRunning)}\n          >\n            {isRunning ? <Pause className="w-4 h-4 mr-1" /> : <Play className="w-4 h-4 mr-1" />}\n            {isRunning ? \'Pause\' : \'Start\'}\n          </Button>\n          <Button variant="outline" size="sm" onClick={handleReset}>\n            <RotateCcw className="w-4 h-4 mr-1" />\n            Reset\n          </Button>\n        </div>\n      </div>\n\n      {/* Error Banner */}\n      {fetchError && (\n        <div className="bg-destructive/10 border border-destructive/30 rounded-lg p-3 text-sm text-destructive">\n          ⚠️ {fetchError} - Using simulated data as fallback\n        </div>\n      )}\n      \n      {/* Main Price Display */}\n      <Card className="bg-gradient-to-br from-card to-card/50 border-primary/20">\n        <CardContent className="pt-6">\n          <div className="flex items-center justify-between">\n            <div>\n              <div className="text-sm text-muted-foreground mb-1 flex items-center gap-2">\n                {symbolInfo.name} ({selectedSymbol})\n                {lastFetch && (\n                  <span className="text-xs opacity-60">\n                    Updated: {lastFetch.toLocaleTimeString()}\n                  </span>\n                )}\n              </div>\n              <div className="text-5xl font-mono font-bold">\n                {currentPrice ? formatPrice(currentPrice) : \'Loading...\'}\n              </div>\n              {currentPrice && (\n                <div className={cn(\n                  "text-lg font-medium mt-1",\n                  priceChange >= 0 ? "text-green-500" : "text-red-500"\n                )}>\n                  {priceChange >= 0 ? \'+\' : \'\'}{formatPrice(Math.abs(priceChange))} ({priceChangePercent >= 0 ? \'+\' : \'\'}{priceChangePercent.toFixed(4)}%)\n                </div>\n              )}\n            </div>\n            \n            <div className="text-right">\n              <div className="text-sm text-muted-foreground">Session Accuracy</div>\n              <div className={cn(\n                "text-4xl font-bold",\n                stats.accuracy >= 60 ? "text-green-500" : \n                stats.accuracy >= 50 ? "text-yellow-500" : "text-red-500"\n              )}>\n                {stats.accuracy.toFixed(1)}%\n              </div>\n              <div className="text-sm text-muted-foreground">\n                {stats.correct}/{stats.totalPredictions} correct\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n      \n      {/* Stats Grid */}\n      <div className="grid grid-cols-2 md:grid-cols-5 gap-3">\n        <Card className="bg-card/50">\n          <CardContent className="pt-4 text-center">\n            <div className="text-2xl font-bold text-primary">{stats.totalPredictions}</div>\n            <div className="text-xs text-muted-foreground">Total Predictions</div>\n          </CardContent>\n        </Card>\n        \n        <Card className="bg-card/50">\n          <CardContent className="pt-4 text-center">\n            <div className="text-2xl font-bold text-green-500">{stats.currentStreak}</div>\n            <div className="text-xs text-muted-foreground">Current Streak</div>\n          </CardContent>\n        </Card>\n        \n        <Card className="bg-card/50">\n          <CardContent className="pt-4 text-center">\n            <div className="text-2xl font-bold text-yellow-500">{stats.bestStreak}</div>\n            <div className="text-xs text-muted-foreground">Best Streak</div>\n          </CardContent>\n        </Card>\n        \n        <Card className="bg-card/50">\n          <CardContent className="pt-4 text-center">\n            <div className="flex items-center justify-center gap-1">\n              <TrendingUp className="w-4 h-4 text-green-500" />\n              <span className="text-lg font-bold">{stats.upAccuracy.toFixed(0)}%</span>\n            </div>\n            <div className="text-xs text-muted-foreground">Up Accuracy</div>\n          </CardContent>\n        </Card>\n        \n        <Card className="bg-card/50">\n          <CardContent className="pt-4 text-center">\n            <div className="flex items-center justify-center gap-1">\n              <TrendingDown className="w-4 h-4 text-red-500" />\n              <span className="text-lg font-bold">{stats.downAccuracy.toFixed(0)}%</span>\n            </div>\n            <div className="text-xs text-muted-foreground">Down Accuracy</div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Predictions Grid */}\n      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">\n        {/* Pending Predictions */}\n        <Card>\n          <CardHeader className="pb-2">\n            <CardTitle className="text-base flex items-center gap-2">\n              <Clock className="w-4 h-4 text-yellow-500" />\n              Pending Predictions ({pendingPredictions.length})\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className="space-y-2 min-h-[200px]">\n              <AnimatePresence mode="popLayout">\n                {pendingPredictions.length === 0 ? (\n                  <div className="text-center text-muted-foreground py-8">\n                    {currentPrice ? \'Generating predictions...\' : \'Waiting for market data...\'}\n                  </div>\n                ) : (\n                  pendingPredictions.map(pred => {\n                    const timeLeft = Math.max(0, pred.expiresAt - Date.now());\n                    const progress = ((predictionIntervalMs - timeLeft) / predictionIntervalMs) * 100;\n                    \n                    return (\n                      <motion.div\n                        key={pred.id}\n                        initial={{ opacity: 0, y: -20 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        exit={{ opacity: 0, x: 100 }}\n                        className="flex items-center gap-3 p-3 rounded-lg bg-muted/30 border border-border/50"\n                      >\n                        <DirectionIcon direction={pred.direction} size={24} />\n                        <div className="flex-1">\n                          <div className="flex items-center justify-between">\n                            <span className="font-medium capitalize">{pred.direction}</span>\n                            <Badge variant="outline">{pred.confidence}%</Badge>\n                          </div>\n                          <div className="text-xs text-muted-foreground">\n                            Entry: {formatPrice(pred.priceAtPrediction)}\n                          </div>\n                          <Progress value={progress} className="h-1 mt-1" />\n                        </div>\n                        <div className="text-xs text-muted-foreground">\n                          {(timeLeft / 1000).toFixed(1)}s\n                        </div>\n                      </motion.div>\n                    );\n                  })\n                )}\n              </AnimatePresence>\n            </div>\n          </CardContent>\n        </Card>\n        \n        {/* Resolved Predictions */}\n        <Card>\n          <CardHeader className="pb-2">\n            <CardTitle className="text-base flex items-center gap-2">\n              <Target className="w-4 h-4 text-primary" />\n              Recent Results ({recentResolved.length})\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className="space-y-2 min-h-[200px] max-h-[300px] overflow-y-auto">\n              <AnimatePresence mode="popLayout">\n                {recentResolved.length === 0 ? (\n                  <div className="text-center text-muted-foreground py-8">\n                    No results yet...\n                  </div>\n                ) : (\n                  recentResolved.map(pred => (\n                    <motion.div\n                      key={pred.id}\n                      initial={{ opacity: 0, scale: 0.95 }}\n                      animate={{ opacity: 1, scale: 1 }}\n                      exit={{ opacity: 0, scale: 0.95 }}\n                      className={cn(\n                        "flex items-center gap-3 p-3 rounded-lg border",\n                        pred.wasCorrect \n                          ? "bg-green-500/10 border-green-500/30" \n                          : "bg-red-500/10 border-red-500/30"\n                      )}\n                    >\n                      {pred.wasCorrect ? (\n                        <CheckCircle className="w-5 h-5 text-green-500 shrink-0" />\n                      ) : (\n                        <XCircle className="w-5 h-5 text-red-500 shrink-0" />\n                      )}\n                      <div className="flex-1 min-w-0">\n                        <div className="flex items-center gap-2">\n                          <span className="text-sm">Predicted:</span>\n                          <DirectionIcon direction={pred.direction} size={16} />\n                          <span className="text-xs text-muted-foreground">→</span>\n                          <span className="text-sm">Actual:</span>\n                          <DirectionIcon direction={pred.actualDirection || \'flat\'} size={16} />\n                        </div>\n                        <div className="text-xs text-muted-foreground truncate">\n                          {formatPrice(pred.priceAtPrediction)} → {pred.actualPrice ? formatPrice(pred.actualPrice) : \'?\'}\n                        </div>\n                      </div>\n                      <Badge \n                        variant={pred.wasCorrect ? "default" : "destructive"}\n                        className="shrink-0"\n                      >\n                        {pred.confidence}%\n                      </Badge>\n                    </motion.div>\n                  ))\n                )}\n              </AnimatePresence>\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Live Data Indicator */}\n      <div className="flex items-center justify-center gap-2 text-xs text-muted-foreground">\n        <Radio className={cn("w-3 h-3", isLive ? "text-green-500 animate-pulse" : "text-red-500")} />\n        {isLive ? (\n          <span>Receiving live market data • {symbolTicks.length} ticks collected</span>\n        ) : (\n          <span>Using simulated data • Real data unavailable</span>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default SimplifiedScalpingTerminal;\n';export{e as default};
