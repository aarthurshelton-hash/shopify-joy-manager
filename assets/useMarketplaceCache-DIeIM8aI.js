const n="import { useCallback, useRef, useEffect } from 'react';\nimport { MarketplaceListing } from '@/lib/marketplace/marketplaceApi';\n\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  expiresAt: number;\n}\n\ninterface MarketplaceCache {\n  listings: Map<string, CacheEntry<MarketplaceListing>>;\n  listingsPage: Map<number, CacheEntry<MarketplaceListing[]>>;\n  totalCount: number | null;\n  lastUpdated: number | null;\n}\n\n// Cache TTL in milliseconds\nconst CACHE_TTL = 60000; // 1 minute for listings\nconst STALE_TTL = 300000; // 5 minutes before completely stale\n\n// Global cache instance (persists across component mounts)\nconst globalCache: MarketplaceCache = {\n  listings: new Map(),\n  listingsPage: new Map(),\n  totalCount: null,\n  lastUpdated: null,\n};\n\nexport function useMarketplaceCache() {\n  const cacheRef = useRef(globalCache);\n\n  // Get a single listing from cache\n  const getCachedListing = useCallback((id: string): MarketplaceListing | null => {\n    const entry = cacheRef.current.listings.get(id);\n    if (!entry) return null;\n    \n    const now = Date.now();\n    if (now > entry.expiresAt) {\n      cacheRef.current.listings.delete(id);\n      return null;\n    }\n    \n    return entry.data;\n  }, []);\n\n  // Cache a single listing\n  const cacheListing = useCallback((listing: MarketplaceListing) => {\n    const now = Date.now();\n    cacheRef.current.listings.set(listing.id, {\n      data: listing,\n      timestamp: now,\n      expiresAt: now + CACHE_TTL,\n    });\n  }, []);\n\n  // Cache multiple listings from a page\n  const cacheListingsPage = useCallback((page: number, listings: MarketplaceListing[]) => {\n    const now = Date.now();\n    \n    // Cache the page\n    cacheRef.current.listingsPage.set(page, {\n      data: listings,\n      timestamp: now,\n      expiresAt: now + CACHE_TTL,\n    });\n    \n    // Also cache individual listings\n    listings.forEach(listing => {\n      cacheRef.current.listings.set(listing.id, {\n        data: listing,\n        timestamp: now,\n        expiresAt: now + CACHE_TTL,\n      });\n    });\n    \n    cacheRef.current.lastUpdated = now;\n  }, []);\n\n  // Get cached page\n  const getCachedPage = useCallback((page: number): MarketplaceListing[] | null => {\n    const entry = cacheRef.current.listingsPage.get(page);\n    if (!entry) return null;\n    \n    const now = Date.now();\n    if (now > entry.expiresAt) {\n      cacheRef.current.listingsPage.delete(page);\n      return null;\n    }\n    \n    return entry.data;\n  }, []);\n\n  // Check if cache is fresh (within TTL)\n  const isCacheFresh = useCallback((): boolean => {\n    if (!cacheRef.current.lastUpdated) return false;\n    return Date.now() - cacheRef.current.lastUpdated < CACHE_TTL;\n  }, []);\n\n  // Check if cache is stale but usable (for stale-while-revalidate)\n  const isCacheStale = useCallback((): boolean => {\n    if (!cacheRef.current.lastUpdated) return true;\n    const age = Date.now() - cacheRef.current.lastUpdated;\n    return age >= CACHE_TTL && age < STALE_TTL;\n  }, []);\n\n  // Get all cached listings as array\n  const getAllCachedListings = useCallback((): MarketplaceListing[] => {\n    const allListings: MarketplaceListing[] = [];\n    const now = Date.now();\n    \n    // Collect from all pages in order\n    const pages = Array.from(cacheRef.current.listingsPage.entries())\n      .filter(([_, entry]) => now <= entry.expiresAt)\n      .sort(([a], [b]) => a - b);\n    \n    for (const [_, entry] of pages) {\n      allListings.push(...entry.data);\n    }\n    \n    return allListings;\n  }, []);\n\n  // Cache total count\n  const cacheTotalCount = useCallback((count: number) => {\n    cacheRef.current.totalCount = count;\n  }, []);\n\n  // Get cached total count\n  const getCachedTotalCount = useCallback((): number | null => {\n    return cacheRef.current.totalCount;\n  }, []);\n\n  // Invalidate cache for a specific listing\n  const invalidateListing = useCallback((id: string) => {\n    cacheRef.current.listings.delete(id);\n    \n    // Also remove from any cached pages\n    for (const [page, entry] of cacheRef.current.listingsPage.entries()) {\n      const filtered = entry.data.filter(l => l.id !== id);\n      if (filtered.length !== entry.data.length) {\n        cacheRef.current.listingsPage.set(page, {\n          ...entry,\n          data: filtered,\n        });\n      }\n    }\n  }, []);\n\n  // Clear all cache\n  const clearCache = useCallback(() => {\n    cacheRef.current.listings.clear();\n    cacheRef.current.listingsPage.clear();\n    cacheRef.current.totalCount = null;\n    cacheRef.current.lastUpdated = null;\n  }, []);\n\n  // Update a listing in cache (for real-time updates)\n  const updateCachedListing = useCallback((id: string, updates: Partial<MarketplaceListing>) => {\n    const entry = cacheRef.current.listings.get(id);\n    if (entry) {\n      const now = Date.now();\n      cacheRef.current.listings.set(id, {\n        data: { ...entry.data, ...updates },\n        timestamp: now,\n        expiresAt: now + CACHE_TTL,\n      });\n    }\n    \n    // Update in pages too\n    for (const [page, pageEntry] of cacheRef.current.listingsPage.entries()) {\n      const idx = pageEntry.data.findIndex(l => l.id === id);\n      if (idx !== -1) {\n        const updated = [...pageEntry.data];\n        updated[idx] = { ...updated[idx], ...updates };\n        cacheRef.current.listingsPage.set(page, {\n          ...pageEntry,\n          data: updated,\n        });\n      }\n    }\n  }, []);\n\n  // Cleanup expired entries periodically\n  useEffect(() => {\n    const cleanup = () => {\n      const now = Date.now();\n      \n      // Cleanup expired listings\n      for (const [id, entry] of cacheRef.current.listings.entries()) {\n        if (now > entry.expiresAt + STALE_TTL) {\n          cacheRef.current.listings.delete(id);\n        }\n      }\n      \n      // Cleanup expired pages\n      for (const [page, entry] of cacheRef.current.listingsPage.entries()) {\n        if (now > entry.expiresAt + STALE_TTL) {\n          cacheRef.current.listingsPage.delete(page);\n        }\n      }\n    };\n\n    const interval = setInterval(cleanup, 60000); // Cleanup every minute\n    return () => clearInterval(interval);\n  }, []);\n\n  return {\n    getCachedListing,\n    cacheListing,\n    cacheListingsPage,\n    getCachedPage,\n    isCacheFresh,\n    isCacheStale,\n    getAllCachedListings,\n    cacheTotalCount,\n    getCachedTotalCount,\n    invalidateListing,\n    clearCache,\n    updateCachedListing,\n  };\n}\n";export{n as default};
