const n="import { useCallback, useState } from 'react';\nimport { toast } from 'sonner';\nimport { \n  checkRateLimit, \n  getAnonymousIdentifier, \n  RateLimitError,\n  RATE_LIMITS \n} from '@/lib/rateLimit';\n\ninterface UseRateLimitOptions {\n  endpoint: string;\n  maxRequests?: number;\n  windowSeconds?: number;\n  showToast?: boolean;\n}\n\ninterface UseRateLimitReturn {\n  checkLimit: () => Promise<boolean>;\n  isLimited: boolean;\n  retryAfter: number | null;\n  remaining: number | null;\n}\n\n/**\n * React hook for rate limiting user actions\n */\nexport function useRateLimit({\n  endpoint,\n  maxRequests = 100,\n  windowSeconds = 60,\n  showToast = true,\n}: UseRateLimitOptions): UseRateLimitReturn {\n  const [isLimited, setIsLimited] = useState(false);\n  const [retryAfter, setRetryAfter] = useState<number | null>(null);\n  const [remaining, setRemaining] = useState<number | null>(null);\n\n  const checkLimit = useCallback(async (): Promise<boolean> => {\n    try {\n      const identifier = getAnonymousIdentifier();\n      const result = await checkRateLimit(identifier, endpoint, maxRequests, windowSeconds);\n\n      if (!result.allowed) {\n        setIsLimited(true);\n        setRetryAfter(result.retry_after || null);\n        setRemaining(0);\n\n        if (showToast) {\n          toast.error(`Too many requests. Please wait ${result.retry_after} seconds.`);\n        }\n\n        // Auto-reset after retry period\n        if (result.retry_after) {\n          setTimeout(() => {\n            setIsLimited(false);\n            setRetryAfter(null);\n          }, result.retry_after * 1000);\n        }\n\n        return false;\n      }\n\n      setIsLimited(false);\n      setRetryAfter(null);\n      setRemaining(result.remaining || null);\n      return true;\n    } catch (error) {\n      if (error instanceof RateLimitError) {\n        setIsLimited(true);\n        setRetryAfter(error.retryAfter);\n        \n        if (showToast) {\n          toast.error(error.message);\n        }\n        \n        return false;\n      }\n      \n      // For other errors, allow the request (fail open)\n      console.warn('Rate limit check failed:', error);\n      return true;\n    }\n  }, [endpoint, maxRequests, windowSeconds, showToast]);\n\n  return {\n    checkLimit,\n    isLimited,\n    retryAfter,\n    remaining,\n  };\n}\n\n/**\n * Pre-configured hooks for common operations\n */\nexport function useAuthRateLimit() {\n  return useRateLimit({\n    endpoint: 'auth',\n    ...RATE_LIMITS.auth,\n  });\n}\n\nexport function usePaymentRateLimit() {\n  return useRateLimit({\n    endpoint: 'payment',\n    ...RATE_LIMITS.payment,\n  });\n}\n\nexport function useSearchRateLimit() {\n  return useRateLimit({\n    endpoint: 'search',\n    ...RATE_LIMITS.search,\n    showToast: false, // Don't show toast for search\n  });\n}\n\nexport function useDownloadRateLimit() {\n  return useRateLimit({\n    endpoint: 'download',\n    ...RATE_LIMITS.download,\n  });\n}\n\nexport function useUploadRateLimit() {\n  return useRateLimit({\n    endpoint: 'upload',\n    ...RATE_LIMITS.upload,\n  });\n}\n\nexport function useListingRateLimit() {\n  return useRateLimit({\n    endpoint: 'listing',\n    ...RATE_LIMITS.listing,\n  });\n}\n\nexport function useSaveRateLimit() {\n  return useRateLimit({\n    endpoint: 'save',\n    ...RATE_LIMITS.save,\n  });\n}\n\nexport function useOfferRateLimit() {\n  return useRateLimit({\n    endpoint: 'offer',\n    ...RATE_LIMITS.offer,\n  });\n}\n\nexport function useScanRateLimit() {\n  return useRateLimit({\n    endpoint: 'scan',\n    ...RATE_LIMITS.scan,\n  });\n}\n\nexport function useBenchmarkRateLimit() {\n  return useRateLimit({\n    endpoint: 'benchmark',\n    ...RATE_LIMITS.benchmark,\n  });\n}";export{n as default};
