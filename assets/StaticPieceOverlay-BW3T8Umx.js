const e="import React, { useMemo } from 'react';\nimport { Chess } from 'chess.js';\n\n// Unicode chess piece characters\nconst PIECE_SYMBOLS: Record<string, string> = {\n  'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',\n  'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟',\n};\n\ninterface StaticPieceOverlayProps {\n  pgn: string;\n  currentMoveNumber?: number;\n  size: number;\n  pieceOpacity?: number;\n}\n\n/**\n * A simple static piece overlay that renders chess pieces without requiring\n * any React context. Used for exports, GIF generation, and print rendering.\n */\nexport const StaticPieceOverlay: React.FC<StaticPieceOverlayProps> = ({\n  pgn,\n  currentMoveNumber,\n  size,\n  pieceOpacity = 0.7,\n}) => {\n  const squareSize = size / 8;\n\n  const piecePositions = useMemo(() => {\n    if (!pgn || typeof pgn !== 'string' || pgn.trim().length < 2) {\n      return [];\n    }\n\n    try {\n      // First load PGN to get all moves\n      const fullGame = new Chess();\n      fullGame.loadPgn(pgn);\n      const allMoves = fullGame.history({ verbose: true });\n\n      // Replay to the target move number\n      const chess = new Chess();\n      const targetMove = currentMoveNumber ?? allMoves.length;\n      const movesToPlay = Math.min(targetMove, allMoves.length);\n\n      for (let i = 0; i < movesToPlay; i++) {\n        chess.move(allMoves[i].san);\n      }\n\n      const boardState = chess.board();\n      const pieces: { square: string; piece: string; color: 'w' | 'b'; row: number; col: number }[] = [];\n\n      for (let rowIndex = 0; rowIndex < 8; rowIndex++) {\n        for (let file = 0; file < 8; file++) {\n          const piece = boardState[rowIndex]?.[file];\n          if (piece) {\n            const rank = 7 - rowIndex;\n            const square = `${String.fromCharCode(97 + file)}${rank + 1}`;\n            pieces.push({\n              square,\n              piece: piece.type,\n              color: piece.color,\n              row: rowIndex,\n              col: file,\n            });\n          }\n        }\n      }\n      return pieces;\n    } catch (e) {\n      console.error('Error parsing PGN for static piece overlay:', e);\n      return [];\n    }\n  }, [pgn, currentMoveNumber]);\n\n  if (piecePositions.length === 0) {\n    return null;\n  }\n\n  return (\n    <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }}>\n      {piecePositions.map((p, idx) => {\n        const symbol = p.color === 'w' \n          ? PIECE_SYMBOLS[p.piece.toUpperCase()] \n          : PIECE_SYMBOLS[p.piece.toLowerCase()];\n        return (\n          <div\n            key={idx}\n            style={{\n              position: 'absolute',\n              left: p.col * squareSize,\n              top: p.row * squareSize,\n              width: squareSize,\n              height: squareSize,\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              fontSize: squareSize * 0.75,\n              opacity: pieceOpacity,\n              color: p.color === 'w' ? '#ffffff' : '#1a1a1a',\n              textShadow: p.color === 'w' \n                ? '0 1px 3px rgba(0,0,0,0.5), 0 0 1px rgba(0,0,0,0.8)' \n                : '0 1px 2px rgba(255,255,255,0.3)',\n              fontFamily: 'serif',\n            }}\n          >\n            {symbol}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default StaticPieceOverlay;\n";export{e as default};
