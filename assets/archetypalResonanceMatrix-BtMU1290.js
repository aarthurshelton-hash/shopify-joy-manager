const e="/**\n * Archetypal Resonance Matrix\n * \n * Maps narrative patterns (hero's journey, fall/redemption, cycles)\n * to market and temporal cycles. Detects when collective unconscious\n * archetypes manifest in price action.\n */\n\ntype Archetype = \n  | 'hero_journey'      // Challenge → Growth → Victory\n  | 'fall_redemption'   // Peak → Collapse → Recovery\n  | 'eternal_return'    // Cyclical patterns, what goes around\n  | 'death_rebirth'     // Complete transformation\n  | 'shadow_integration'// Facing darkness before light\n  | 'threshold_guardian'// Resistance before breakthrough\n  | 'sacred_marriage'   // Union of opposites (bull/bear equilibrium)\n  | 'apocalypse_renewal'// Complete destruction → new beginning\n  ;\n\ninterface ArchetypeSignature {\n  archetype: Archetype;\n  phase: number; // 0-1 where in the narrative arc\n  strength: number;\n  expectedNextPhase: string;\n  priceImplication: 'bullish' | 'bearish' | 'volatile' | 'consolidating';\n}\n\ninterface ResonanceEvent {\n  archetype: Archetype;\n  resonanceStrength: number;\n  detectedAt: number;\n  phaseTransition: string;\n  historicalAccuracy: number;\n}\n\nclass ArchetypalResonanceMatrix {\n  private archetypeHistory: ResonanceEvent[] = [];\n  private archetypeAccuracy: Map<Archetype, { correct: number; total: number }> = new Map();\n  private readonly regularizationFactor = 0.85; // Prevent overfitting to archetypes\n  \n  /**\n   * Analyze price/signal data for archetypal patterns\n   */\n  detectArchetype(\n    priceData: number[],\n    volumeData: number[],\n    sentimentScore: number\n  ): ArchetypeSignature | null {\n    if (priceData.length < 20) return null;\n    \n    // Calculate key metrics\n    const priceChange = this.calculateChange(priceData);\n    const volumeChange = this.calculateChange(volumeData);\n    const volatility = this.calculateVolatility(priceData);\n    const trend = this.detectTrend(priceData);\n    \n    // Match against archetypal patterns\n    const matches: Array<{ archetype: Archetype; score: number; phase: number }> = [];\n    \n    // Hero's Journey: Rising from adversity\n    if (trend === 'recovering' && sentimentScore > 0.3) {\n      matches.push({\n        archetype: 'hero_journey',\n        score: (0.3 + sentimentScore * 0.4 + Math.min(priceChange, 0.3)),\n        phase: this.calculateHeroPhase(priceData),\n      });\n    }\n    \n    // Fall and Redemption: Post-collapse recovery\n    if (this.detectFallRedemption(priceData)) {\n      matches.push({\n        archetype: 'fall_redemption',\n        score: 0.6 + Math.abs(priceChange) * 0.2,\n        phase: this.calculateRedemptionPhase(priceData),\n      });\n    }\n    \n    // Eternal Return: Cyclical patterns\n    const cyclicStrength = this.detectCyclicPattern(priceData);\n    if (cyclicStrength > 0.5) {\n      matches.push({\n        archetype: 'eternal_return',\n        score: cyclicStrength,\n        phase: this.calculateCyclePhase(priceData),\n      });\n    }\n    \n    // Death and Rebirth: Extreme volatility + direction change\n    if (volatility > 0.3 && Math.abs(priceChange) > 0.15) {\n      matches.push({\n        archetype: 'death_rebirth',\n        score: volatility * 0.5 + Math.abs(priceChange) * 0.5,\n        phase: priceChange > 0 ? 0.7 : 0.3, // Rebirth or death phase\n      });\n    }\n    \n    // Shadow Integration: Negative sentiment but stabilizing\n    if (sentimentScore < -0.2 && volatility < 0.1 && Math.abs(priceChange) < 0.05) {\n      matches.push({\n        archetype: 'shadow_integration',\n        score: 0.5 + Math.abs(sentimentScore) * 0.3,\n        phase: 0.6,\n      });\n    }\n    \n    // Threshold Guardian: Resistance at key levels\n    if (this.detectResistance(priceData)) {\n      matches.push({\n        archetype: 'threshold_guardian',\n        score: 0.55,\n        phase: 0.5,\n      });\n    }\n    \n    // Sacred Marriage: Bull/bear equilibrium\n    if (volatility < 0.05 && Math.abs(priceChange) < 0.02 && volumeChange < 0.1) {\n      matches.push({\n        archetype: 'sacred_marriage',\n        score: 0.5 + (1 - volatility) * 0.3,\n        phase: 0.5,\n      });\n    }\n    \n    // Apocalypse/Renewal: Extreme moves\n    if (Math.abs(priceChange) > 0.25) {\n      matches.push({\n        archetype: 'apocalypse_renewal',\n        score: Math.min(0.9, Math.abs(priceChange)),\n        phase: priceChange > 0 ? 0.8 : 0.2,\n      });\n    }\n    \n    if (matches.length === 0) return null;\n    \n    // Sort by score and apply regularization based on historical accuracy\n    const best = matches.sort((a, b) => {\n      const accuracyA = this.getArchetypeAccuracy(a.archetype);\n      const accuracyB = this.getArchetypeAccuracy(b.archetype);\n      return (b.score * accuracyB) - (a.score * accuracyA);\n    })[0];\n    \n    return {\n      archetype: best.archetype,\n      phase: best.phase,\n      strength: best.score * this.regularizationFactor,\n      expectedNextPhase: this.getNextPhase(best.archetype, best.phase),\n      priceImplication: this.getPriceImplication(best.archetype, best.phase),\n    };\n  }\n  \n  /**\n   * Record outcome for calibration\n   */\n  recordOutcome(archetype: Archetype, wasCorrect: boolean): void {\n    const current = this.archetypeAccuracy.get(archetype) || { correct: 0, total: 0 };\n    current.total++;\n    if (wasCorrect) current.correct++;\n    this.archetypeAccuracy.set(archetype, current);\n  }\n  \n  /**\n   * Get historical accuracy for an archetype\n   */\n  private getArchetypeAccuracy(archetype: Archetype): number {\n    const stats = this.archetypeAccuracy.get(archetype);\n    if (!stats || stats.total < 5) return 0.5; // Default to neutral\n    return stats.correct / stats.total;\n  }\n  \n  private calculateChange(data: number[]): number {\n    if (data.length < 2) return 0;\n    const first = data[0];\n    const last = data[data.length - 1];\n    return first !== 0 ? (last - first) / first : 0;\n  }\n  \n  private calculateVolatility(data: number[]): number {\n    if (data.length < 2) return 0;\n    const returns: number[] = [];\n    for (let i = 1; i < data.length; i++) {\n      if (data[i - 1] !== 0) {\n        returns.push((data[i] - data[i - 1]) / data[i - 1]);\n      }\n    }\n    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;\n    return Math.sqrt(variance);\n  }\n  \n  private detectTrend(data: number[]): 'rising' | 'falling' | 'recovering' | 'declining' | 'flat' {\n    if (data.length < 10) return 'flat';\n    \n    const firstHalf = data.slice(0, Math.floor(data.length / 2));\n    const secondHalf = data.slice(Math.floor(data.length / 2));\n    \n    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;\n    \n    const firstMin = Math.min(...firstHalf);\n    const secondMin = Math.min(...secondHalf);\n    \n    if (secondAvg > firstAvg * 1.05) {\n      return firstMin < firstAvg * 0.9 ? 'recovering' : 'rising';\n    } else if (secondAvg < firstAvg * 0.95) {\n      return 'declining';\n    }\n    return 'flat';\n  }\n  \n  private detectFallRedemption(data: number[]): boolean {\n    if (data.length < 15) return false;\n    const third = Math.floor(data.length / 3);\n    const peak = Math.max(...data.slice(0, third));\n    const trough = Math.min(...data.slice(third, third * 2));\n    const current = data[data.length - 1];\n    \n    return peak > trough * 1.2 && current > trough * 1.1;\n  }\n  \n  private detectCyclicPattern(data: number[]): number {\n    if (data.length < 20) return 0;\n    \n    // Simple autocorrelation for cycle detection\n    const mean = data.reduce((a, b) => a + b, 0) / data.length;\n    let maxCorrelation = 0;\n    \n    for (let lag = 5; lag < data.length / 2; lag++) {\n      let correlation = 0;\n      let count = 0;\n      \n      for (let i = 0; i < data.length - lag; i++) {\n        correlation += (data[i] - mean) * (data[i + lag] - mean);\n        count++;\n      }\n      \n      if (count > 0) {\n        correlation /= count;\n        maxCorrelation = Math.max(maxCorrelation, Math.abs(correlation));\n      }\n    }\n    \n    return Math.min(1, maxCorrelation / (this.calculateVolatility(data) + 0.1));\n  }\n  \n  private detectResistance(data: number[]): boolean {\n    if (data.length < 10) return false;\n    const recent = data.slice(-10);\n    const max = Math.max(...recent);\n    const touchCount = recent.filter(v => v > max * 0.98).length;\n    return touchCount >= 3 && recent[recent.length - 1] < max * 0.99;\n  }\n  \n  private calculateHeroPhase(data: number[]): number {\n    const change = this.calculateChange(data);\n    if (change < 0) return 0.2; // Call to adventure\n    if (change < 0.1) return 0.4; // Tests and trials\n    if (change < 0.2) return 0.6; // Approach\n    if (change < 0.3) return 0.8; // Reward\n    return 0.9; // Return\n  }\n  \n  private calculateRedemptionPhase(data: number[]): number {\n    const third = Math.floor(data.length / 3);\n    const current = data[data.length - 1];\n    const trough = Math.min(...data.slice(third, third * 2));\n    const peak = Math.max(...data.slice(0, third));\n    \n    const recovery = (current - trough) / (peak - trough);\n    return Math.max(0.3, Math.min(0.9, 0.3 + recovery * 0.6));\n  }\n  \n  private calculateCyclePhase(data: number[]): number {\n    // Use sine wave fitting to estimate phase\n    const normalized = this.normalizeData(data);\n    const last = normalized[normalized.length - 1];\n    \n    // Map -1 to 1 range to 0 to 1 phase\n    return (last + 1) / 2;\n  }\n  \n  private normalizeData(data: number[]): number[] {\n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min;\n    \n    if (range === 0) return data.map(() => 0);\n    return data.map(v => ((v - min) / range) * 2 - 1);\n  }\n  \n  private getNextPhase(archetype: Archetype, currentPhase: number): string {\n    const phases: Record<Archetype, string[]> = {\n      hero_journey: ['Call', 'Threshold', 'Tests', 'Abyss', 'Transformation', 'Return'],\n      fall_redemption: ['Peak', 'Decline', 'Bottom', 'Recognition', 'Recovery', 'Restoration'],\n      eternal_return: ['Spring', 'Summer', 'Autumn', 'Winter', 'Spring'],\n      death_rebirth: ['Life', 'Death', 'Void', 'Rebirth', 'New Life'],\n      shadow_integration: ['Denial', 'Confrontation', 'Struggle', 'Acceptance', 'Integration'],\n      threshold_guardian: ['Approach', 'Challenge', 'Battle', 'Victory', 'Crossing'],\n      sacred_marriage: ['Separation', 'Longing', 'Meeting', 'Union', 'Wholeness'],\n      apocalypse_renewal: ['Signs', 'Chaos', 'Destruction', 'Silence', 'New Dawn'],\n    };\n    \n    const phaseList = phases[archetype];\n    const currentIndex = Math.floor(currentPhase * (phaseList.length - 1));\n    const nextIndex = Math.min(currentIndex + 1, phaseList.length - 1);\n    \n    return phaseList[nextIndex];\n  }\n  \n  private getPriceImplication(archetype: Archetype, phase: number): 'bullish' | 'bearish' | 'volatile' | 'consolidating' {\n    const implications: Record<Archetype, (phase: number) => 'bullish' | 'bearish' | 'volatile' | 'consolidating'> = {\n      hero_journey: (p) => p > 0.5 ? 'bullish' : 'consolidating',\n      fall_redemption: (p) => p > 0.5 ? 'bullish' : 'bearish',\n      eternal_return: (p) => p > 0.25 && p < 0.75 ? (p < 0.5 ? 'bullish' : 'bearish') : 'consolidating',\n      death_rebirth: (p) => p > 0.5 ? 'volatile' : 'bearish',\n      shadow_integration: () => 'consolidating',\n      threshold_guardian: (p) => p > 0.6 ? 'bullish' : 'consolidating',\n      sacred_marriage: () => 'consolidating',\n      apocalypse_renewal: (p) => p > 0.7 ? 'bullish' : 'volatile',\n    };\n    \n    return implications[archetype](phase);\n  }\n  \n  /**\n   * Get confidence modifier based on archetypal clarity\n   */\n  getConfidenceModifier(signature: ArchetypeSignature | null): number {\n    if (!signature) return 1.0;\n    \n    const accuracy = this.getArchetypeAccuracy(signature.archetype);\n    return 0.9 + (signature.strength * accuracy * 0.2);\n  }\n}\n\nexport const archetypalResonanceMatrix = new ArchetypalResonanceMatrix();\nexport type { Archetype, ArchetypeSignature, ResonanceEvent };\n";export{e as default};
