const n="/**\n * Archetype Historical Win Rates\n * v7.56-SMART-FALLBACK: Use archetype history for intelligent fallbacks\n * \n * When hybrid prediction times out, use historical archetype win rates\n * instead of random 33/33/34% guess.\n */\n\nimport { StrategicArchetype } from '../colorFlowAnalysis';\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface ArchetypeStats {\n  archetype: StrategicArchetype;\n  totalGames: number;\n  whiteWins: number;\n  blackWins: number;\n  draws: number;\n  whiteWinRate: number;\n  blackWinRate: number;\n  drawRate: number;\n}\n\n// Cache for archetype stats (refreshed every 5 minutes)\nlet cachedStats: Map<StrategicArchetype, ArchetypeStats> = new Map();\nlet cacheTimestamp = 0;\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n/**\n * Default rates when no historical data available\n * Based on general chess statistics (white slight advantage)\n */\n/**\n * v8.02-CALIBRATED: Balanced default rates matching actual archetypes\n * Key fix: Use SYMMETRIC rates (equal white/black) since dominantSide handles bias\n */\nconst DEFAULT_RATES: Record<string, { white: number; black: number; draw: number }> = {\n  // Attack archetypes - decisive outcomes\n  kingside_attack: { white: 0.40, black: 0.40, draw: 0.20 },\n  queenside_expansion: { white: 0.40, black: 0.40, draw: 0.20 },\n  sacrificial_attack: { white: 0.42, black: 0.42, draw: 0.16 },\n  opposite_castling: { white: 0.42, black: 0.42, draw: 0.16 },\n  pawn_storm: { white: 0.42, black: 0.42, draw: 0.16 },\n  \n  // Central/positional archetypes\n  central_domination: { white: 0.38, black: 0.38, draw: 0.24 },\n  positional_squeeze: { white: 0.38, black: 0.38, draw: 0.24 },\n  piece_harmony: { white: 0.36, black: 0.36, draw: 0.28 },\n  \n  // Tactical archetypes\n  open_tactical: { white: 0.40, black: 0.40, draw: 0.20 },\n  \n  // Defensive/slow archetypes - higher draw rates\n  closed_maneuvering: { white: 0.32, black: 0.32, draw: 0.36 },\n  prophylactic_defense: { white: 0.30, black: 0.30, draw: 0.40 },\n  endgame_technique: { white: 0.34, black: 0.34, draw: 0.32 },\n  \n  // Fallback for any unmapped archetypes\n  default: { white: 0.36, black: 0.36, draw: 0.28 },\n};\n\n/**\n * Load archetype statistics from database\n */\nexport async function loadArchetypeStats(): Promise<Map<StrategicArchetype, ArchetypeStats>> {\n  // Return cache if still valid\n  if (Date.now() - cacheTimestamp < CACHE_TTL && cachedStats.size > 0) {\n    return cachedStats;\n  }\n\n  try {\n    // Query prediction attempts grouped by archetype\n    const { data, error } = await supabase\n      .from('chess_prediction_attempts')\n      .select('hybrid_archetype, actual_result, hybrid_correct')\n      .not('hybrid_archetype', 'eq', 'FALLBACK')\n      .not('actual_result', 'is', null);\n\n    if (error) {\n      console.warn('[v7.56] Failed to load archetype stats:', error);\n      return cachedStats;\n    }\n\n    // Aggregate by archetype\n    const statsMap = new Map<string, { white: number; black: number; draw: number; total: number }>();\n\n    for (const row of data || []) {\n      const arch = row.hybrid_archetype || 'unknown';\n      const existing = statsMap.get(arch) || { white: 0, black: 0, draw: 0, total: 0 };\n\n      existing.total++;\n      if (row.actual_result === 'white_wins') existing.white++;\n      else if (row.actual_result === 'black_wins') existing.black++;\n      else if (row.actual_result === 'draw') existing.draw++;\n\n      statsMap.set(arch, existing);\n    }\n\n    // Convert to ArchetypeStats\n    cachedStats = new Map();\n    for (const [arch, counts] of statsMap) {\n      if (counts.total >= 3) { // Only include archetypes with enough data\n        cachedStats.set(arch as StrategicArchetype, {\n          archetype: arch as StrategicArchetype,\n          totalGames: counts.total,\n          whiteWins: counts.white,\n          blackWins: counts.black,\n          draws: counts.draw,\n          whiteWinRate: counts.white / counts.total,\n          blackWinRate: counts.black / counts.total,\n          drawRate: counts.draw / counts.total,\n        });\n      }\n    }\n\n    cacheTimestamp = Date.now();\n    console.log(`[v7.56] Loaded archetype stats for ${cachedStats.size} archetypes`);\n\n    return cachedStats;\n  } catch (err) {\n    console.warn('[v7.56] Error loading archetype stats:', err);\n    return cachedStats;\n  }\n}\n\n/**\n * Get prediction based on archetype historical win rates\n * Returns the most likely outcome based on historical data\n */\nexport function getArchetypePrediction(\n  archetype: StrategicArchetype,\n  dominantSide?: 'white' | 'black' | 'contested'\n): {\n  prediction: 'white_wins' | 'black_wins' | 'draw';\n  confidence: number;\n  probabilities: { white: number; black: number; draw: number };\n  source: 'historical' | 'default';\n} {\n  // Check cached historical data first\n  const stats = cachedStats.get(archetype);\n\n  if (stats && stats.totalGames >= 5) {\n    // Use historical data\n    const probs = {\n      white: stats.whiteWinRate,\n      black: stats.blackWinRate,\n      draw: stats.drawRate,\n    };\n\n    // Adjust slightly based on dominant side if available\n    if (dominantSide === 'white') {\n      probs.white = Math.min(0.95, probs.white * 1.1);\n      probs.black = probs.black * 0.9;\n    } else if (dominantSide === 'black') {\n      probs.black = Math.min(0.95, probs.black * 1.1);\n      probs.white = probs.white * 0.9;\n    }\n\n    // Normalize\n    const total = probs.white + probs.black + probs.draw;\n    probs.white /= total;\n    probs.black /= total;\n    probs.draw /= total;\n\n    // Determine prediction\n    let prediction: 'white_wins' | 'black_wins' | 'draw';\n    let maxProb: number;\n\n    if (probs.white >= probs.black && probs.white >= probs.draw) {\n      prediction = 'white_wins';\n      maxProb = probs.white;\n    } else if (probs.black >= probs.draw) {\n      prediction = 'black_wins';\n      maxProb = probs.black;\n    } else {\n      prediction = 'draw';\n      maxProb = probs.draw;\n    }\n\n    // Confidence scales with sample size and probability margin\n    const sampleFactor = Math.min(1, stats.totalGames / 20);\n    const marginFactor = maxProb - 0.33; // How much above random\n    const confidence = Math.min(70, 35 + (marginFactor * 100) * sampleFactor);\n\n    return {\n      prediction,\n      confidence,\n      probabilities: probs,\n      source: 'historical',\n    };\n  }\n\n  // Fall back to default rates\n  const defaults = DEFAULT_RATES[archetype] || DEFAULT_RATES.default;\n  const probs = { ...defaults };\n\n  // Adjust based on dominant side\n  if (dominantSide === 'white') {\n    probs.white = Math.min(0.95, probs.white * 1.15);\n    probs.black = probs.black * 0.85;\n  } else if (dominantSide === 'black') {\n    probs.black = Math.min(0.95, probs.black * 1.15);\n    probs.white = probs.white * 0.85;\n  }\n\n  // Normalize\n  const total = probs.white + probs.black + probs.draw;\n  probs.white /= total;\n  probs.black /= total;\n  probs.draw /= total;\n\n  let prediction: 'white_wins' | 'black_wins' | 'draw';\n  if (probs.white >= probs.black && probs.white >= probs.draw) {\n    prediction = 'white_wins';\n  } else if (probs.black >= probs.draw) {\n    prediction = 'black_wins';\n  } else {\n    prediction = 'draw';\n  }\n\n  return {\n    prediction,\n    confidence: 40, // Lower confidence for default rates\n    probabilities: probs,\n    source: 'default',\n  };\n}\n\n/**\n * Invalidate the cache (call after new predictions are saved)\n */\nexport function invalidateArchetypeCache(): void {\n  cacheTimestamp = 0;\n}\n";export{n as default};
