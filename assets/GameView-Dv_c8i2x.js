const e="/**\n * GameView - Universal Visualization Menu for a Game\n * \n * This page shows ONE game with all its palette variations (visions).\n * Each game has a single canonical URL: /g/{gameHash}\n * Different palettes are selectable from within this unified experience.\n */\n\nimport { useEffect, useState, useMemo, useCallback, useRef } from 'react';\nimport { useParams, useNavigate, useSearchParams } from 'react-router-dom';\nimport { supabase } from '@/integrations/supabase/client';\nimport { Header } from '@/components/shop/Header';\nimport { Footer } from '@/components/shop/Footer';\nimport { motion } from 'framer-motion';\nimport { Crown, Loader2, ChevronLeft, Sparkles } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { toast } from 'sonner';\nimport { Link } from 'react-router-dom';\nimport { SquareData, GameData, simulateGame } from '@/lib/chess/gameSimulator';\nimport UnifiedVisionExperience, { ExportState } from '@/components/chess/UnifiedVisionExperience';\nimport { useAuth } from '@/hooks/useAuth';\nimport { useVisualizationExport } from '@/hooks/useVisualizationExport';\nimport { useSessionStore } from '@/stores/sessionStore';\nimport { useActiveVisionStore } from '@/stores/activeVisionStore';\nimport { useVisualizationStateStore } from '@/stores/visualizationStateStore';\nimport { usePrintOrderStore, PrintOrderData } from '@/stores/printOrderStore';\nimport AuthModal from '@/components/auth/AuthModal';\nimport { PremiumUpgradeModal } from '@/components/premium';\nimport { setActivePalette, PaletteId, PieceType } from '@/lib/chess/pieceColors';\nimport { recordVisionInteraction, getVisionScore, VisionScore } from '@/lib/visualizations/visionScoring';\nimport { generateGameHash, extractMovesFromPgn, buildCanonicalShareUrl } from '@/lib/visualizations/gameCanonical';\nimport { detectGameCard } from '@/lib/chess/gameCardDetection';\nimport { useRecentlyViewedStore } from '@/stores/recentlyViewedStore';\n\ninterface GameVision {\n  id: string;\n  title: string;\n  pgn: string | null;\n  image_path: string;\n  public_share_id: string | null;\n  user_id: string | null;\n  game_data: {\n    white?: string;\n    black?: string;\n    event?: string;\n    date?: string;\n    result?: string;\n    moves?: string[];\n    totalMoves?: number;\n    board?: SquareData[][];\n    pgn?: string;\n    visualizationState?: {\n      paletteId?: string;\n      darkMode?: boolean;\n    };\n  };\n  created_at: string;\n}\n\ninterface PaletteVariation {\n  id: string;\n  paletteId: string;\n  ownerId: string | null;\n  ownerName: string | null;\n  isListed: boolean;\n  price?: number;\n  visionScore?: number;\n}\n\nconst GameView = () => {\n  const { gameHash } = useParams<{ gameHash: string }>();\n  const [searchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const { user, isPremium, isCheckingSubscription } = useAuth();\n  const {\n    setCurrentSimulation,\n    setSavedShareId,\n    setCapturedTimelineState,\n    setReturningFromOrder,\n    returningFromOrder,\n    capturedTimelineState,\n    currentSimulation: sessionSimulation,\n    currentPgn: sessionPgn,\n    currentGameTitle: sessionTitle,\n    clearSimulation,\n  } = useSessionStore();\n  const { setOrderData } = usePrintOrderStore();\n  const { saveActiveVision, clearActiveVision } = useActiveVisionStore();\n  const visualizationState = useVisualizationStateStore();\n\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [primaryVision, setPrimaryVision] = useState<GameVision | null>(null);\n  const [paletteVariations, setPaletteVariations] = useState<PaletteVariation[]>([]);\n  const [activePaletteId, setActivePaletteId] = useState<string>('modern');\n  const [visionScore, setVisionScore] = useState<VisionScore | null>(null);\n  const [showAuthModal, setShowAuthModal] = useState(false);\n  const [showVisionaryModal, setShowVisionaryModal] = useState(false);\n  \n  // State for handling freshly generated (unsaved) games from session\n  const [isFromSession, setIsFromSession] = useState(false);\n  const [sessionBoard, setSessionBoard] = useState<SquareData[][] | null>(null);\n  const [sessionGameData, setSessionGameData] = useState<GameData | null>(null);\n  const [sessionTotalMoves, setSessionTotalMoves] = useState<number>(0);\n  \n  const viewRecordedRef = useRef(false);\n\n  // Get initial state from URL params\n  const initialState = useMemo(() => ({\n    paletteId: searchParams.get('p') || undefined,\n    move: searchParams.has('m') ? parseInt(searchParams.get('m')!) : undefined,\n    dark: searchParams.get('d') === '1',\n    pieces: searchParams.get('sp') === '1',\n    opacity: searchParams.has('o') ? parseFloat(searchParams.get('o')!) : undefined,\n  }), [searchParams]);\n\n  // Determine context from URL params (set by redirects)\n  const sourceContext = useMemo(() => {\n    const src = searchParams.get('src');\n    const listingId = searchParams.get('listing');\n    return {\n      source: src as 'gallery' | 'marketplace' | 'shared' | null,\n      listingId,\n    };\n  }, [searchParams]);\n\n  // Get back link based on source context\n  const backLink = useMemo(() => {\n    switch (sourceContext.source) {\n      case 'gallery':\n        return { href: '/my-vision', label: 'Return to Gallery' };\n      case 'marketplace':\n        return { href: '/marketplace', label: 'Return to Marketplace' };\n      default:\n        return { href: '/', label: 'Back to En Pensent' };\n    }\n  }, [sourceContext.source]);\n\n  // Export hook\n  const {\n    downloadTrademarkHD,\n    downloadGIF,\n  } = useVisualizationExport({\n    isPremium,\n    visualizationId: primaryVision?.id,\n    onUnauthorized: () => setShowAuthModal(true),\n    onUpgradeRequired: () => setShowVisionaryModal(true),\n  });\n\n  // Handle restoration toast when returning from order page\n  useEffect(() => {\n    if (returningFromOrder && capturedTimelineState) {\n      toast.success(`${capturedTimelineState.title || 'Visualization'} restored!`, {\n        description: capturedTimelineState.currentMove \n          ? `Move ${capturedTimelineState.currentMove} of ${capturedTimelineState.totalMoves}`\n          : 'Your visualization is ready',\n        icon: <Sparkles className=\"w-4 h-4\" />,\n      });\n      setReturningFromOrder(false);\n      setCapturedTimelineState(null);\n    }\n  }, [returningFromOrder, capturedTimelineState, setReturningFromOrder, setCapturedTimelineState]);\n\n  // Fetch game data by hash - checks session first, then database\n  // Uses retry mechanism to handle race condition with session store persistence\n  useEffect(() => {\n    let retryCount = 0;\n    const maxRetries = 8; // Increased from 3 to handle slower persistence\n    const retryDelay = 100; // ms - increased from 50ms\n    \n    const fetchGameByHash = async () => {\n      if (!gameHash) {\n        setError('Invalid game link');\n        setLoading(false);\n        return;\n      }\n\n      // Check if this is from the generator - if so, we expect session data\n      const isFromGenerator = searchParams.get('src') === 'generator';\n      \n      // First check if we have a freshly generated game in session storage\n      if (sessionSimulation && sessionPgn) {\n        const sessionGameHash = generateGameHash(sessionPgn);\n        \n        if (sessionGameHash === gameHash) {\n          // This is a freshly generated game - use session data\n          setIsFromSession(true);\n          setSessionBoard(sessionSimulation.board);\n          setSessionGameData(sessionSimulation.gameData);\n          setSessionTotalMoves(sessionSimulation.totalMoves);\n          \n          // Set palette from URL or default\n          const urlPalette = initialState.paletteId || 'modern';\n          setActivePaletteId(urlPalette);\n          if (urlPalette !== 'custom') {\n            setActivePalette(urlPalette as PaletteId);\n          }\n          \n          // Show success toast for new generation\n          if (isFromGenerator) {\n            toast.success('Visualization generated!', {\n              description: `${sessionSimulation.totalMoves} moves processed.`,\n            });\n          }\n          \n          setLoading(false);\n          return;\n        }\n      } else if (isFromGenerator && retryCount < maxRetries) {\n        // Session data not ready yet - retry after a short delay\n        // This handles the race condition where navigation happens before persist completes\n        retryCount++;\n        setTimeout(() => {\n          // Re-read from store directly to get latest persisted state\n          const store = useSessionStore.getState();\n          if (store.currentSimulation && store.currentPgn) {\n            const storeGameHash = generateGameHash(store.currentPgn);\n            if (storeGameHash === gameHash) {\n              setIsFromSession(true);\n              setSessionBoard(store.currentSimulation.board);\n              setSessionGameData(store.currentSimulation.gameData);\n              setSessionTotalMoves(store.currentSimulation.totalMoves);\n              \n              const urlPalette = initialState.paletteId || 'modern';\n              setActivePaletteId(urlPalette);\n              if (urlPalette !== 'custom') {\n                setActivePalette(urlPalette as PaletteId);\n              }\n              \n              toast.success('Visualization generated!', {\n                description: `${store.currentSimulation.totalMoves} moves processed.`,\n              });\n              \n              setLoading(false);\n              return;\n            }\n          }\n          // If still no match after retries, continue to database fetch\n          if (retryCount >= maxRetries) {\n            continueWithDatabaseFetch();\n          } else {\n            fetchGameByHash();\n          }\n        }, retryDelay);\n        return;\n      }\n\n      continueWithDatabaseFetch();\n    };\n    \n    const continueWithDatabaseFetch = async () => {\n      try {\n        // Fetch all saved visualizations and find ones matching this game hash\n        const { data: allVisions, error: fetchError } = await supabase\n          .from('saved_visualizations')\n          .select('*')\n          .order('created_at', { ascending: true });\n\n        if (fetchError) throw fetchError;\n\n        // Find visions that match this game hash\n        const matchingVisions: GameVision[] = [];\n        \n        for (const viz of allVisions || []) {\n          const vizPgn = viz.pgn || (viz.game_data as { pgn?: string })?.pgn || '';\n          const vizHash = generateGameHash(vizPgn);\n          \n          if (vizHash === gameHash || (gameHash === 'empty' && !vizPgn)) {\n            // Parse game_data to extract details\n            const parsedGameData = viz.game_data as {\n              board?: SquareData[][];\n              gameData?: GameData;\n              totalMoves?: number;\n              paletteId?: string;\n              whitePalette?: Record<string, string>;\n              blackPalette?: Record<string, string>;\n              pgn?: string;\n              white?: string;\n              black?: string;\n              event?: string;\n              date?: string;\n              result?: string;\n              moves?: string[];\n              visualizationState?: {\n                paletteId?: string;\n                darkMode?: boolean;\n              };\n            };\n            \n            matchingVisions.push({\n              id: viz.id,\n              title: viz.title,\n              pgn: viz.pgn || parsedGameData?.pgn || null,\n              image_path: viz.image_path,\n              public_share_id: viz.public_share_id,\n              user_id: viz.user_id,\n              created_at: viz.created_at,\n              game_data: {\n                white: parsedGameData?.white || parsedGameData?.gameData?.white,\n                black: parsedGameData?.black || parsedGameData?.gameData?.black,\n                event: parsedGameData?.event || parsedGameData?.gameData?.event,\n                date: parsedGameData?.date || parsedGameData?.gameData?.date,\n                result: parsedGameData?.result || parsedGameData?.gameData?.result,\n                moves: parsedGameData?.moves || parsedGameData?.gameData?.moves,\n                totalMoves: parsedGameData?.totalMoves,\n                board: parsedGameData?.board,\n                pgn: parsedGameData?.pgn,\n                visualizationState: parsedGameData?.visualizationState || {\n                  paletteId: parsedGameData?.paletteId,\n                },\n              },\n            });\n          }\n        }\n\n        if (matchingVisions.length === 0) {\n          // No saved vision found - this might be a fresh game that needs to be simulated\n          // For now, show error since we don't have the PGN to regenerate\n          setError('Game not found');\n          setLoading(false);\n          return;\n        }\n\n        // Use the first (oldest) vision as the primary one\n        const primary = matchingVisions[0];\n        setPrimaryVision(primary);\n\n        // Build palette variations from all matching visions\n        const variations: PaletteVariation[] = matchingVisions.map(v => ({\n          id: v.id,\n          paletteId: v.game_data?.visualizationState?.paletteId || 'modern',\n          ownerId: v.user_id || null,\n          ownerName: null,\n          isListed: false,\n        }));\n        setPaletteVariations(variations);\n\n        // Determine which palette to activate\n        const urlPalette = initialState.paletteId;\n        const primaryPaletteId = primary.game_data?.visualizationState?.paletteId || 'modern';\n        \n        if (urlPalette) {\n          // URL specified a palette - check if we have it\n          const hasVariation = variations.some(v => v.paletteId === urlPalette);\n          if (hasVariation) {\n            setActivePaletteId(urlPalette);\n            if (urlPalette !== 'custom') {\n              setActivePalette(urlPalette as PaletteId);\n            }\n          } else {\n            // Fall back to primary vision's palette\n            setActivePaletteId(primaryPaletteId);\n            if (primaryPaletteId !== 'custom') {\n              setActivePalette(primaryPaletteId as PaletteId);\n            }\n          }\n        } else {\n          // No URL palette - use primary's palette\n          setActivePaletteId(primaryPaletteId);\n          if (primaryPaletteId !== 'custom') {\n            setActivePalette(primaryPaletteId as PaletteId);\n          }\n        }\n\n        // Record view interaction and get score\n        if (primary.id) {\n          recordVisionInteraction(primary.id, 'view').catch(console.error);\n          getVisionScore(primary.id).then(score => {\n            if (score) setVisionScore(score);\n          }).catch(console.error);\n          \n          // Track in recently viewed\n          useRecentlyViewedStore.getState().addRecentlyViewed({\n            id: primary.id,\n            gameHash: gameHash,\n            imagePath: primary.image_path,\n            title: primary.title,\n          });\n        }\n        \n        // Check if current user owns this variation\n        if (user && activePaletteId) {\n          const ownerVariation = variations.find(v => \n            v.paletteId === activePaletteId && v.ownerId === user.id\n          );\n          if (ownerVariation) {\n            setOrderData({\n              visualizationId: ownerVariation.id,\n              title: primary.title,\n              gameHash: gameHash,\n              gameData: {\n                white: primary.game_data?.white || 'Unknown',\n                black: primary.game_data?.black || 'Unknown',\n                event: primary.game_data?.event,\n                date: primary.game_data?.date,\n                result: primary.game_data?.result,\n              },\n            });\n          }\n        }\n      } catch (err) {\n        console.error('Error fetching game:', err);\n        setError('Failed to load game');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchGameByHash();\n  }, [gameHash, initialState.paletteId, sessionSimulation, sessionPgn, searchParams]);\n\n  // Reconstruct board and game data - supports both saved and session-based games\n  const { board, gameData, totalMoves, effectivePgn } = useMemo(() => {\n    // If from session (freshly generated), use session data\n    if (isFromSession && sessionBoard && sessionGameData) {\n      return {\n        board: sessionBoard,\n        gameData: sessionGameData,\n        totalMoves: sessionTotalMoves,\n        effectivePgn: sessionPgn || sessionGameData.pgn || '',\n      };\n    }\n    \n    // Otherwise use saved visualization data\n    if (!primaryVision) {\n      return {\n        board: [] as SquareData[][],\n        gameData: {} as GameData,\n        totalMoves: 0,\n        effectivePgn: '',\n      };\n    }\n\n    const data = primaryVision.game_data;\n    const pgn = primaryVision.pgn || data.pgn || '';\n    \n    // Try to use stored board, or simulate from PGN\n    let reconstructedBoard: SquareData[][] = data.board || [];\n    \n    if (reconstructedBoard.length === 0 && pgn) {\n      // Simulate game to get board\n      try {\n        const simulation = simulateGame(pgn);\n        reconstructedBoard = simulation.board;\n      } catch (e) {\n        console.error('Failed to simulate game:', e);\n      }\n    }\n\n    if (reconstructedBoard.length === 0) {\n      reconstructedBoard = Array(8).fill(null).map((_, rank) =>\n        Array(8).fill(null).map((_, file) => ({\n          file,\n          rank,\n          visits: [],\n          isLight: (file + rank) % 2 === 1,\n        }))\n      );\n    }\n\n    const reconstructedGameData: GameData = {\n      white: data.white || 'White',\n      black: data.black || 'Black',\n      event: data.event || '',\n      date: data.date || '',\n      result: data.result || '',\n      pgn,\n      moves: data.moves || [],\n    };\n\n    return {\n      board: reconstructedBoard,\n      gameData: reconstructedGameData,\n      totalMoves: data.totalMoves || data.moves?.length || 0,\n      effectivePgn: pgn,\n    };\n  }, [primaryVision, isFromSession, sessionBoard, sessionGameData, sessionTotalMoves, sessionPgn]);\n\n  // Save active vision state for refresh persistence\n  useEffect(() => {\n    if (!gameHash || loading || !primaryVision) return;\n    \n    // Build the full route with current palette\n    const currentRoute = `/g/${gameHash}${activePaletteId ? `?p=${activePaletteId}` : ''}`;\n    \n    // Save state\n    saveActiveVision({\n      route: currentRoute,\n      gameHash,\n      paletteId: activePaletteId,\n      pgn: effectivePgn,\n      gameTitle: primaryVision?.title || '',\n      currentMove: visualizationState.currentMove,\n      selectedPhase: visualizationState.selectedPhase,\n      lockedPieces: visualizationState.lockedPieces,\n      compareMode: visualizationState.compareMode,\n      darkMode: visualizationState.darkMode,\n      showPieces: visualizationState.showPieces,\n      pieceOpacity: visualizationState.pieceOpacity,\n    });\n  }, [\n    gameHash, \n    activePaletteId, \n    loading,\n    primaryVision,\n    effectivePgn,\n    visualizationState.currentMove,\n    visualizationState.selectedPhase,\n    visualizationState.lockedPieces,\n    visualizationState.compareMode,\n    visualizationState.darkMode,\n    visualizationState.showPieces,\n    visualizationState.pieceOpacity,\n    saveActiveVision,\n  ]);\n\n  // Clear active vision when intentionally navigating away\n  const handleBackClick = useCallback(() => {\n    clearActiveVision();\n    navigate(backLink.href);\n  }, [clearActiveVision, navigate, backLink.href]);\n\n  // Handle share with stateful URL\n  const handleShare = useCallback(async (exportState?: ExportState) => {\n    const url = buildCanonicalShareUrl(effectivePgn, activePaletteId, exportState ? {\n      move: exportState.currentMove,\n      dark: exportState.darkMode,\n      pieces: exportState.showPieces,\n      opacity: exportState.pieceOpacity,\n    } : undefined);\n\n    if (navigator.share) {\n      try {\n        await navigator.share({\n          title: primaryVision?.title || 'Chess Visualization',\n          text: 'Check out this chess game visualization from En Pensent',\n          url,\n        });\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          await navigator.clipboard.writeText(url);\n          toast.success('Link copied to clipboard!');\n        }\n      }\n    } else {\n      await navigator.clipboard.writeText(url);\n      toast.success('Link copied to clipboard!');\n    }\n  }, [effectivePgn, activePaletteId, primaryVision?.title]);\n\n  // Handle exports\n  const handleExport = useCallback(async (type: 'hd' | 'gif' | 'print' | 'preview', exportState?: ExportState) => {\n    if (!primaryVision) return;\n\n    const filteredBoard = exportState && exportState.currentMove < totalMoves && exportState.currentMove > 0\n      ? board.map(row =>\n          row.map(square => ({\n            ...square,\n            visits: square.visits.filter(visit => visit.moveNumber <= exportState.currentMove),\n          }))\n        )\n      : board;\n\n    const highlightState = exportState?.lockedPieces && exportState.lockedPieces.length > 0 ? {\n      lockedPieces: exportState.lockedPieces.map(p => ({\n        pieceType: p.pieceType as PieceType,\n        pieceColor: (p.pieceColor === 'white' ? 'w' : p.pieceColor === 'black' ? 'b' : p.pieceColor) as 'w' | 'b',\n      })),\n      compareMode: exportState.compareMode,\n    } : undefined;\n\n    if (type === 'preview') {\n      try {\n        const { generateCleanPrintImage } = await import('@/lib/chess/printImageGenerator');\n        \n        // Build captured state for preview with all current settings\n        const capturedState = exportState ? {\n          currentMove: exportState.currentMove,\n          selectedPhase: 'all' as const,\n          lockedPieces: exportState.lockedPieces,\n          compareMode: exportState.compareMode,\n          displayMode: 'standard' as const,\n          darkMode: exportState.darkMode,\n          showTerritory: false,\n          showHeatmaps: false,\n          showPieces: exportState.showPieces,\n          pieceOpacity: exportState.pieceOpacity,\n          capturedAt: new Date(),\n        } : undefined;\n        \n        // Always apply watermark if not premium or still checking subscription status\n        const shouldWatermark = !isPremium || isCheckingSubscription;\n        \n        const base64Image = await generateCleanPrintImage(\n          { board: filteredBoard, gameData, totalMoves },\n          { \n            darkMode: exportState?.darkMode || false, \n            withWatermark: shouldWatermark, \n            highlightState,\n            capturedState,\n            pgn: effectivePgn,\n          }\n        );\n        const response = await fetch(base64Image);\n        const blob = await response.blob();\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = `${primaryVision.title.replace(/\\s+/g, '-').toLowerCase()}-preview.png`;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n        toast.success('Preview downloaded!');\n      } catch (err) {\n        console.error('Preview download failed:', err);\n        toast.error('Download failed');\n      }\n      return;\n    }\n\n    if (type === 'hd') {\n      downloadTrademarkHD({\n        board: filteredBoard,\n        gameData,\n        title: primaryVision.title,\n        darkMode: exportState?.darkMode || false,\n        highlightState,\n        piecesState: exportState ? {\n          showPieces: exportState.showPieces,\n          pieceOpacity: exportState.pieceOpacity,\n        } : undefined,\n        pgn: effectivePgn,\n        currentMoveNumber: exportState?.currentMove,\n      });\n      return;\n    }\n\n    if (type === 'gif') {\n      const captureElement = document.querySelector('[data-vision-board=\"true\"]') as HTMLElement;\n      if (captureElement) {\n        downloadGIF(\n          { board, gameData, totalMoves },\n          captureElement,\n          primaryVision.title,\n          undefined,\n          exportState ? { showPieces: exportState.showPieces, pieceOpacity: exportState.pieceOpacity } : undefined\n        );\n      } else {\n        toast.error('Unable to capture visualization');\n      }\n      return;\n    }\n\n    if (type === 'print') {\n      if (exportState) {\n        setCapturedTimelineState({\n          currentMove: exportState.currentMove,\n          totalMoves,\n          title: primaryVision.title,\n          lockedPieces: exportState.lockedPieces.map(p => ({\n            pieceType: p.pieceType as PieceType,\n            pieceColor: p.pieceColor as 'w' | 'b',\n          })),\n          compareMode: exportState.compareMode,\n          darkMode: exportState.darkMode,\n          showPieces: exportState.showPieces,\n          pieceOpacity: exportState.pieceOpacity,\n        });\n      }\n\n      setCurrentSimulation({ board, gameData, totalMoves }, effectivePgn, primaryVision.title);\n      setSavedShareId(primaryVision.public_share_id || '');\n      setReturningFromOrder(true);\n\n      // Detect famous game card for attribution\n      const gameCardMatch = detectGameCard(effectivePgn);\n      const detectedGameId = gameCardMatch.isMatch && gameCardMatch.matchedGame \n        ? gameCardMatch.matchedGame.id \n        : undefined;\n\n      const orderData: PrintOrderData = {\n        visualizationId: primaryVision.id,\n        title: primaryVision.title,\n        imagePath: primaryVision.image_path,\n        gameData: {\n          white: gameData.white,\n          black: gameData.black,\n          event: gameData.event,\n          date: gameData.date,\n          result: gameData.result,\n        },\n        simulation: { board, gameData, totalMoves },\n        shareId: primaryVision.public_share_id || undefined,\n        returnPath: `/g/${gameHash}`,\n        // Game metadata for cart display and navigation\n        gameHash,\n        gameId: detectedGameId, // For game card art in cart\n        paletteId: activePaletteId,\n        pgn: effectivePgn,\n        capturedState: exportState ? {\n          currentMove: exportState.currentMove,\n          selectedPhase: 'all',\n          lockedPieces: exportState.lockedPieces,\n          compareMode: exportState.compareMode,\n          displayMode: 'standard',\n          darkMode: exportState.darkMode,\n          showTerritory: false,\n          showHeatmaps: false,\n          showPieces: exportState.showPieces,\n          pieceOpacity: exportState.pieceOpacity,\n          capturedAt: new Date(),\n        } : undefined,\n      };\n      setOrderData(orderData);\n      navigate('/order-print');\n    }\n  }, [primaryVision, board, gameData, totalMoves, effectivePgn, gameHash, isPremium, downloadTrademarkHD, downloadGIF, navigate, setOrderData, setCapturedTimelineState, setCurrentSimulation, setSavedShareId, setReturningFromOrder]);\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen bg-background flex items-center justify-center\">\n        <motion.div\n          animate={{ rotate: 360 }}\n          transition={{ duration: 2, repeat: Infinity, ease: 'linear' }}\n          className=\"w-12 h-12 border-2 border-primary border-t-transparent rounded-full\"\n        />\n      </div>\n    );\n  }\n\n  // Check if we have valid data (either from DB or session)\n  const hasValidData = primaryVision || (isFromSession && sessionBoard);\n\n  if (error || !hasValidData) {\n    return (\n      <div className=\"min-h-screen bg-background\">\n        <Header />\n        <main className=\"container mx-auto px-4 py-16\">\n          <div className=\"max-w-md mx-auto text-center space-y-6\">\n            <div className=\"w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center mx-auto\">\n              <Crown className=\"h-10 w-10 text-primary/50\" />\n            </div>\n            <h1 className=\"text-2xl font-royal font-bold uppercase tracking-wide\">\n              Game Not Found\n            </h1>\n            <p className=\"text-muted-foreground font-serif\">\n              {error || 'This game may not have been saved yet.'}\n            </p>\n            <Link to=\"/\">\n              <Button variant=\"outline\" className=\"gap-2\">\n                <ChevronLeft className=\"h-4 w-4\" />\n                Create a Visualization\n              </Button>\n            </Link>\n          </div>\n        </main>\n        <Footer />\n      </div>\n    );\n  }\n\n  // Determine display title\n  const displayTitle = isFromSession \n    ? (sessionTitle || `${sessionGameData?.white || 'White'} vs ${sessionGameData?.black || 'Black'}`)\n    : primaryVision?.title || 'Visualization';\n  \n  // Determine context for UnifiedVisionExperience\n  const displayContext = isFromSession \n    ? 'generator' as const\n    : (sourceContext.source || 'shared') as 'marketplace' | 'gallery' | 'shared' | 'postgame' | 'scanner' | 'generator';\n\n  return (\n    <div className=\"min-h-screen bg-background\">\n      <Header />\n\n      <main className=\"container mx-auto px-4 py-8 md:py-16\">\n        <div className=\"max-w-4xl mx-auto\">\n          {/* Back link - clears active vision to prevent restore loop */}\n          <motion.div\n            initial={{ opacity: 0, x: -20 }}\n            animate={{ opacity: 1, x: 0 }}\n            className=\"mb-6\"\n          >\n            <button\n              onClick={handleBackClick}\n              className=\"inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n            >\n              <ChevronLeft className=\"h-4 w-4\" />\n              <span className=\"font-serif\">{backLink.label}</span>\n            </button>\n          </motion.div>\n\n          {/* Title */}\n          <motion.div\n            initial={{ opacity: 0, y: 20 }}\n            animate={{ opacity: 1, y: 0 }}\n            className=\"mb-8\"\n          >\n            <h1 className=\"text-2xl md:text-3xl font-royal font-bold uppercase tracking-wide mb-2\">\n              {displayTitle}\n            </h1>\n            <div className=\"flex items-center gap-4 text-sm text-muted-foreground\">\n              {isFromSession ? (\n                <span className=\"flex items-center gap-1.5\">\n                  <Sparkles className=\"h-4 w-4 text-primary\" />\n                  Freshly generated\n                </span>\n              ) : (\n                <span className=\"flex items-center gap-1.5\">\n                  <Sparkles className=\"h-4 w-4 text-primary\" />\n                  {paletteVariations.length} palette{paletteVariations.length !== 1 ? 's' : ''} available\n                </span>\n              )}\n              {visionScore && (\n                <span className=\"px-2 py-0.5 rounded-full bg-primary/10 text-primary text-xs font-display uppercase tracking-wider\">\n                  Score: {visionScore.totalScore.toLocaleString()}\n                </span>\n              )}\n            </div>\n          </motion.div>\n\n          {/* Unified Vision Experience */}\n          <motion.div\n            initial={{ opacity: 0, y: 20 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ delay: 0.1 }}\n            className=\"bg-card/50 rounded-xl border border-border/50 p-4 md:p-6\"\n          >\n            <UnifiedVisionExperience\n              board={board}\n              gameData={gameData}\n              totalMoves={totalMoves}\n              pgn={effectivePgn}\n              context={displayContext}\n              paletteId={activePaletteId}\n              visualizationId={primaryVision?.id}\n              isPremium={isPremium}\n              onUpgradePrompt={() => setShowVisionaryModal(true)}\n              onBack={handleBackClick}\n              isOwner={isFromSession || primaryVision?.user_id === user?.id}\n              visionScoreData={visionScore ? {\n                viewCount: visionScore.viewCount,\n                uniqueViewers: visionScore.uniqueViewers,\n                royaltyCentsEarned: visionScore.royaltyCentsEarned,\n                royaltyOrdersCount: visionScore.royaltyOrdersCount,\n                printRevenueCents: visionScore.printRevenueCents,\n                printOrderCount: visionScore.printOrderCount,\n                totalScore: visionScore.totalScore,\n                downloadHdCount: visionScore.downloadHdCount,\n                downloadGifCount: visionScore.downloadGifCount,\n                tradeCount: visionScore.tradeCount,\n              } : null}\n              onShare={handleShare}\n              onExport={handleExport}\n              initialState={{\n                move: initialState.move,\n                dark: initialState.dark,\n                pieces: initialState.pieces,\n                opacity: initialState.opacity,\n              }}\n            />\n          </motion.div>\n        </div>\n      </main>\n\n      <Footer />\n\n      {/* Modals */}\n      {showAuthModal && (\n        <AuthModal\n          isOpen={showAuthModal}\n          onClose={() => setShowAuthModal(false)}\n          defaultMode=\"signin\"\n        />\n      )}\n\n      {showVisionaryModal && (\n        <PremiumUpgradeModal\n          isOpen={showVisionaryModal}\n          onClose={() => setShowVisionaryModal(false)}\n          trigger=\"download\"\n        />\n      )}\n    </div>\n  );\n};\n\nexport default GameView;\n";export{e as default};
