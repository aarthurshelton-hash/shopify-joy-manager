const n="/**\n * En Pensent Core SDK - Trajectory Prediction\n * \n * Universal, domain-agnostic algorithms for predicting future trajectories.\n * This file re-exports from focused modules for backward compatibility.\n */\n\nimport { \n  TemporalSignature,\n  TrajectoryPrediction,\n  PatternMatch,\n  ArchetypeDefinition\n} from './types';\nimport { \n  calculateOutcomeProbabilities, \n  getMostLikelyOutcome,\n  calculateMatchConfidence \n} from './patternMatcher';\n\n// Re-export configuration\nexport { DEFAULT_PREDICTION_CONFIG } from './trajectory/config';\nexport type { PredictionConfig } from './trajectory/config';\n\n// Re-export helper functions\nexport { \n  generateMilestones, \n  formatArchetype, \n  getArchetypeRecommendation \n} from './trajectory/milestoneGenerator';\n\nexport { \n  generateStrategicGuidance, \n  formatOutcome \n} from './trajectory/guidanceGenerator';\n\nexport { \n  assessTrajectorySustainability, \n  calculateTrajectoryDivergence\n} from './trajectory/sustainabilityAssessor';\nexport type { SustainabilityAssessment } from './trajectory/sustainabilityAssessor';\n\n// Import for internal use\nimport { PredictionConfig, DEFAULT_PREDICTION_CONFIG } from './trajectory/config';\nimport { generateMilestones } from './trajectory/milestoneGenerator';\nimport { generateStrategicGuidance } from './trajectory/guidanceGenerator';\n\n/**\n * Generate trajectory prediction from pattern matches\n * \n * This function is domain-agnostic and works with any TemporalSignature.\n * It uses configurable outcome mappings to support different domains.\n */\nexport function generateTrajectoryPrediction(\n  currentSignature: TemporalSignature,\n  matches: PatternMatch[],\n  archetypeDefinition: ArchetypeDefinition | null,\n  currentPosition: number,\n  totalExpectedLength: number,\n  config: Partial<PredictionConfig> = {}\n): TrajectoryPrediction {\n  const cfg = { ...DEFAULT_PREDICTION_CONFIG, ...config };\n  \n  // Calculate outcome probabilities\n  const outcomeProbabilities = calculateOutcomeProbabilities(matches);\n  const mostLikely = getMostLikelyOutcome(matches);\n  \n  // Calculate confidence using configurable weights\n  const matchConfidence = calculateMatchConfidence(matches, cfg.minSampleSize);\n  const archetypeConfidence = archetypeDefinition?.confidence ?? 0.5;\n  const overallConfidence = \n    (matchConfidence * cfg.matchConfidenceWeight) + \n    (archetypeConfidence * cfg.archetypeConfidenceWeight);\n  \n  // Determine win probabilities using flexible outcome mapping\n  const primaryWinProb = findOutcomeProbability(\n    outcomeProbabilities, \n    cfg.outcomeMapping?.primaryWin ?? []\n  ) ?? 0.33;\n  \n  const secondaryWinProb = findOutcomeProbability(\n    outcomeProbabilities, \n    cfg.outcomeMapping?.secondaryWin ?? []\n  ) ?? 0.33;\n  \n  const drawProb = Math.max(0, 1 - primaryWinProb - secondaryWinProb);\n  \n  // Generate milestones based on signature analysis\n  const milestones = generateMilestones(\n    currentSignature,\n    matches,\n    currentPosition,\n    totalExpectedLength\n  );\n  \n  // Generate strategic guidance\n  const strategicGuidance = generateStrategicGuidance(\n    currentSignature,\n    archetypeDefinition,\n    outcomeProbabilities\n  );\n  \n  // Calculate lookahead horizon (how far we can reliably predict)\n  const remainingMoves = totalExpectedLength - currentPosition;\n  const lookaheadHorizon = Math.min(\n    remainingMoves,\n    Math.floor(cfg.maxLookahead * overallConfidence)\n  );\n  \n  return {\n    predictedOutcome: mostLikely?.outcome ?? 'uncertain',\n    confidence: overallConfidence,\n    primaryWinProbability: primaryWinProb,\n    secondaryWinProbability: secondaryWinProb,\n    drawProbability: drawProb,\n    milestones,\n    strategicGuidance,\n    lookaheadHorizon,\n    patternSampleSize: matches.length\n  };\n}\n\n/**\n * Find outcome probability from multiple possible keys\n */\nfunction findOutcomeProbability(\n  probabilities: Record<string, number>,\n  keys: string[]\n): number | null {\n  for (const key of keys) {\n    if (probabilities[key] !== undefined) {\n      return probabilities[key];\n    }\n  }\n  return null;\n}\n";export{n as default};
