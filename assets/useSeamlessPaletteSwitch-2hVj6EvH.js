const e="/**\n * Hook for seamless palette switching\n * \n * Regenerates the board visualization with a new palette without navigation\n * or full page reload. Updates the board colors in-place for instant transitions.\n */\n\nimport { useState, useCallback } from 'react';\nimport { simulateGame, SquareData, GameData, SimulationResult } from '@/lib/chess/gameSimulator';\nimport { setActivePalette, PaletteId, getPieceColor } from '@/lib/chess/pieceColors';\nimport { supabase } from '@/integrations/supabase/client';\nimport { getVisionScore, VisionScore } from '@/lib/visualizations/visionScoring';\nimport { incrementPaletteUsage } from '@/lib/analytics/financialTrends';\n\nexport interface PaletteSwitchResult {\n  board: SquareData[][];\n  gameData: GameData;\n  totalMoves: number;\n  paletteId: PaletteId;\n  visualizationId?: string;\n  visionScore?: VisionScore | null;\n  title?: string;\n  createdAt?: string;\n  imageUrl?: string;\n  shareId?: string;\n  isOwner?: boolean;\n  isListed?: boolean;\n  listingPrice?: number;\n  sellerId?: string;\n  sellerName?: string;\n}\n\ninterface UseSeamlessPaletteSwitchOptions {\n  pgn: string;\n  currentUserId?: string;\n  onSwitchStart?: () => void;\n  onSwitchComplete?: (result: PaletteSwitchResult) => void;\n  onError?: (error: Error) => void;\n}\n\nexport function useSeamlessPaletteSwitch({\n  pgn,\n  currentUserId,\n  onSwitchStart,\n  onSwitchComplete,\n  onError,\n}: UseSeamlessPaletteSwitchOptions) {\n  const [isSwitching, setIsSwitching] = useState(false);\n  const [currentPaletteId, setCurrentPaletteId] = useState<PaletteId | null>(null);\n\n  /**\n   * Switch to a new palette by regenerating the board visualization\n   * If the palette is taken, it fetches the existing visualization data\n   * If available, it regenerates from the PGN with new colors\n   */\n  const switchPalette = useCallback(async (\n    newPaletteId: PaletteId,\n    existingVisualizationId?: string\n  ): Promise<PaletteSwitchResult | null> => {\n    if (!pgn) return null;\n\n    try {\n      setIsSwitching(true);\n      onSwitchStart?.();\n\n      // Set the new palette globally\n      setActivePalette(newPaletteId);\n      setCurrentPaletteId(newPaletteId);\n\n      // Track palette interaction for value attribution\n      incrementPaletteUsage(newPaletteId).catch(err => \n        console.warn('Failed to track palette interaction:', err)\n      );\n\n      let result: PaletteSwitchResult;\n\n      if (existingVisualizationId) {\n        // Fetch existing visualization data from database\n        const { data: vizData, error } = await supabase\n          .from('saved_visualizations')\n          .select('*')\n          .eq('id', existingVisualizationId)\n          .single();\n\n        if (error) throw error;\n\n        // Parse the saved game data\n        const gameData = vizData.game_data as unknown as {\n          board?: SquareData[][];\n          gameData?: GameData;\n          totalMoves?: number;\n        };\n\n        // Check if this is listed\n        const { data: listingData } = await supabase\n          .from('visualization_listings')\n          .select('*, profiles:seller_id(display_name)')\n          .eq('visualization_id', existingVisualizationId)\n          .eq('status', 'active')\n          .maybeSingle();\n\n        // Get vision score\n        const visionScore = await getVisionScore(existingVisualizationId);\n\n        result = {\n          board: gameData.board || [],\n          gameData: gameData.gameData || {\n            white: 'Unknown',\n            black: 'Unknown',\n            event: '',\n            date: '',\n            result: '*',\n            pgn: pgn,\n            moves: [],\n          },\n          totalMoves: gameData.totalMoves || 0,\n          paletteId: newPaletteId,\n          visualizationId: existingVisualizationId,\n          visionScore,\n          title: vizData.title,\n          createdAt: vizData.created_at,\n          imageUrl: vizData.image_path,\n          shareId: vizData.public_share_id,\n          isOwner: vizData.user_id === currentUserId,\n          isListed: !!listingData,\n          listingPrice: listingData?.price_cents,\n          sellerId: listingData?.seller_id,\n          sellerName: (listingData?.profiles as { display_name?: string })?.display_name || 'Anonymous',\n        };\n      } else {\n        // Regenerate board from PGN with new palette colors\n        const simResult = simulateGame(pgn);\n\n        // Re-apply colors based on new palette\n        const updatedBoard = simResult.board.map(rank =>\n          rank.map(square => ({\n            ...square,\n            visits: square.visits.map(visit => ({\n              ...visit,\n              hexColor: getPieceColor(visit.piece, visit.color),\n            })),\n          }))\n        );\n\n        result = {\n          board: updatedBoard,\n          gameData: simResult.gameData,\n          totalMoves: simResult.totalMoves,\n          paletteId: newPaletteId,\n        };\n      }\n\n      onSwitchComplete?.(result);\n      return result;\n\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to switch palette');\n      onError?.(error);\n      return null;\n    } finally {\n      setIsSwitching(false);\n    }\n  }, [pgn, currentUserId, onSwitchStart, onSwitchComplete, onError]);\n\n  /**\n   * Regenerate board colors for current palette (useful for palette editor)\n   */\n  const regenerateColors = useCallback((board: SquareData[][]): SquareData[][] => {\n    return board.map(rank =>\n      rank.map(square => ({\n        ...square,\n        visits: square.visits.map(visit => ({\n          ...visit,\n          hexColor: getPieceColor(visit.piece, visit.color),\n        })),\n      }))\n    );\n  }, []);\n\n  return {\n    switchPalette,\n    regenerateColors,\n    isSwitching,\n    currentPaletteId,\n  };\n}\n";export{e as default};
