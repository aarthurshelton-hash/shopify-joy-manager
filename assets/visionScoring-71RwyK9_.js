const n="import { supabase } from '@/integrations/supabase/client';\n\nexport interface VisionScore {\n  visualizationId: string;\n  viewCount: number;\n  downloadHdCount: number;\n  downloadGifCount: number;\n  scanCount: number;\n  tradeCount: number;\n  printOrderCount: number;\n  printRevenueCents: number;\n  totalScore: number;\n  uniqueViewers: number;\n  updatedAt: string;\n  royaltyCentsEarned: number;\n  royaltyOrdersCount: number;\n  // Attribution tracking\n  gameId?: string;\n  paletteId?: string;\n}\n\nexport interface VisionLeaderboardEntry extends VisionScore {\n  title: string;\n  imagePath: string;\n  ownerDisplayName: string;\n  ownerId: string;\n}\n\n/**\n * Scoring weights:\n * - View: 0.01 points (passive engagement)\n * - HD Download: 0.10 points (active engagement)\n * - GIF Download: 0.25 points (animated export value)\n * - Scan: 0.50 points (real-world validation - scanned via Natural Vision Scanner)\n * - Trade: 1.00 point (marketplace activity)\n * - Print Order: 2.00 points + revenue in dollars (proven demand)\n * \n * Attribution bonuses:\n * - Game attribution: Vision linked to famous game increases gamecard pool value\n * - Palette attribution: Vision using palette increases palette pool value\n */\nexport const SCORING_WEIGHTS = {\n  view: 0.01,\n  download_hd: 0.10,\n  download_gif: 0.25,\n  scan: 0.50,             // Real-world presence validation\n  trade: 1.00,\n  print_order_base: 2.00,\n  print_dollar_multiplier: 1.00,\n};\n\n/**\n * Vision Value Appreciation Economics\n * \n * Visions appreciate in value based on real-world activity (print orders, views, trades).\n * Value is NOT paid out directly - it accrues to the vision itself.\n * To realize gains, holders must sell visions on the marketplace.\n * \n * Economics:\n * - Monthly subscription: $7/month (17% contributes to market growth)\n * - Print orders: 17% of PROFIT (not revenue) adds to vision's intrinsic value\n * - Marketplace: Seller keeps 95%, platform takes 5% transaction fee\n * - Bartering: Users can negotiate trades with counter-offers\n * \n * Value Flow:\n * 1. Activity (prints, views, downloads) → increases vision score\n * 2. Score + royalty value → determines vision's market value\n * 3. Holder lists vision for sale → sets asking price\n * 4. Buyer purchases → pays seller directly (minus 5% fee)\n */\nexport const MEMBERSHIP_ECONOMICS = {\n  monthlySubscription: 7.00,           // $7/month\n  marketContributionRate: 0.17,        // 17% goes to market appreciation\n  monthlyContributionPerMember: 1.19,  // $1.19/month per subscriber to market\n  baseMarketCap: 5000,                 // $5,000 base market cap (foundation value)\n  valuePerScorePoint: 0.50,            // Base $0.50 per score point\n  membershipMultiplierCap: 3.0,        // Max 3x multiplier from memberships\n  valueAppreciationRate: 0.17,         // 17% of PROFIT adds to vision value (not revenue)\n  platformRetentionRate: 0.83,         // 83% of profit retained by platform (covers printing, fulfillment, operations)\n  marketplaceTransactionFee: 0.05,     // 5% platform fee on marketplace sales\n  sellerRetentionRate: 0.95,           // 95% goes directly to seller\n  creatorPremiumTiers: {               // Creator premium multipliers based on engagement\n    tier1: { minInteractions: 10, multiplier: 1.2 },\n    tier2: { minInteractions: 50, multiplier: 1.5 },\n  },\n};\n\n/**\n * Generate a simple hash of the client's IP for rate limiting anonymous users\n * This is NOT a secure hash - just for basic rate limiting\n */\nasync function getIpHash(): Promise<string | null> {\n  try {\n    // Use a fingerprint based on available browser data\n    const fingerprint = [\n      navigator.userAgent,\n      navigator.language,\n      screen.width,\n      screen.height,\n      new Date().getTimezoneOffset(),\n    ].join('|');\n    \n    // Simple hash function\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return hash.toString(36);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Record a vision interaction with rate-limiting protection\n * Returns true if the interaction was recorded, false if rate-limited\n */\nexport async function recordVisionInteraction(\n  visualizationId: string,\n  interactionType: 'view' | 'download_hd' | 'download_gif' | 'scan' | 'trade' | 'print_order',\n  valueCents: number = 0\n): Promise<boolean> {\n  try {\n    const { data: { user } } = await supabase.auth.getUser();\n    const userId = user?.id || null;\n    const ipHash = userId ? null : await getIpHash();\n\n    // Call the database function that handles rate limiting\n    const { data, error } = await supabase.rpc('record_vision_interaction', {\n      p_visualization_id: visualizationId,\n      p_user_id: userId,\n      p_interaction_type: interactionType,\n      p_value_cents: valueCents,\n      p_ip_hash: ipHash,\n    });\n\n    if (error) {\n      console.error('Error recording interaction:', error);\n      return false;\n    }\n\n    return data === true;\n  } catch (error) {\n    console.error('Error in recordVisionInteraction:', error);\n    return false;\n  }\n}\n\n/**\n * Get the score for a specific vision\n */\nexport async function getVisionScore(visualizationId: string): Promise<VisionScore | null> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_scores')\n      .select('*')\n      .eq('visualization_id', visualizationId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') return null; // Not found\n      throw error;\n    }\n\n    return {\n      visualizationId: data.visualization_id,\n      viewCount: data.view_count,\n      downloadHdCount: data.download_hd_count,\n      downloadGifCount: data.download_gif_count,\n      scanCount: data.scan_count || 0,\n      tradeCount: data.trade_count,\n      printOrderCount: data.print_order_count,\n      printRevenueCents: data.print_revenue_cents,\n      totalScore: parseFloat(String(data.total_score)),\n      uniqueViewers: data.unique_viewers,\n      updatedAt: data.updated_at,\n      royaltyCentsEarned: data.royalty_cents_earned || 0,\n      royaltyOrdersCount: data.royalty_orders_count || 0,\n    };\n  } catch (error) {\n    console.error('Error getting vision score:', error);\n    return null;\n  }\n}\n\n/**\n * Get the top visions by score (leaderboard)\n */\nexport async function getVisionLeaderboard(limit: number = 10): Promise<VisionLeaderboardEntry[]> {\n  try {\n    // Get top scores\n    const { data: scores, error: scoresError } = await supabase\n      .from('vision_scores')\n      .select('*')\n      .order('total_score', { ascending: false })\n      .limit(limit);\n\n    if (scoresError) throw scoresError;\n    if (!scores || scores.length === 0) return [];\n\n    // Get visualization details\n    const vizIds = scores.map(s => s.visualization_id);\n    const { data: visualizations, error: vizError } = await supabase\n      .from('saved_visualizations')\n      .select('id, title, image_path, user_id')\n      .in('id', vizIds);\n\n    if (vizError) throw vizError;\n\n    // Get owner profiles\n    const userIds = [...new Set(visualizations?.map(v => v.user_id) || [])];\n    const { data: profiles } = await supabase\n      .from('profiles')\n      .select('user_id, display_name')\n      .in('user_id', userIds);\n\n    const profileMap = new Map(profiles?.map(p => [p.user_id, p.display_name]) || []);\n    const vizMap = new Map(visualizations?.map(v => [v.id, v]) || []);\n\n    return scores.map(score => {\n      const viz = vizMap.get(score.visualization_id);\n      return {\n        visualizationId: score.visualization_id,\n        viewCount: score.view_count,\n        downloadHdCount: score.download_hd_count,\n        downloadGifCount: score.download_gif_count,\n        scanCount: score.scan_count || 0,\n        tradeCount: score.trade_count,\n        printOrderCount: score.print_order_count,\n        printRevenueCents: score.print_revenue_cents,\n        totalScore: parseFloat(String(score.total_score)),\n        uniqueViewers: score.unique_viewers,\n        updatedAt: score.updated_at,\n        royaltyCentsEarned: score.royalty_cents_earned || 0,\n        royaltyOrdersCount: score.royalty_orders_count || 0,\n        title: viz?.title || 'Untitled',\n        imagePath: viz?.image_path || '',\n        ownerDisplayName: profileMap.get(viz?.user_id || '') || 'Anonymous',\n        ownerId: viz?.user_id || '',\n      };\n    });\n  } catch (error) {\n    console.error('Error getting vision leaderboard:', error);\n    return [];\n  }\n}\n\n/**\n * Get aggregate platform statistics for analytics\n */\nexport async function getPlatformVisionStats(): Promise<{\n  totalViews: number;\n  totalDownloads: number;\n  totalGifDownloads: number;\n  totalScans: number;\n  totalTrades: number;\n  totalPrintOrders: number;\n  totalPrintRevenue: number;\n  totalScore: number;\n  uniqueCollectors: number;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_scores')\n      .select('view_count, download_hd_count, download_gif_count, scan_count, trade_count, print_order_count, print_revenue_cents, total_score');\n\n    if (error) throw error;\n\n    const stats = (data || []).reduce((acc, score) => ({\n      totalViews: acc.totalViews + score.view_count,\n      totalDownloads: acc.totalDownloads + score.download_hd_count,\n      totalGifDownloads: acc.totalGifDownloads + score.download_gif_count,\n      totalScans: acc.totalScans + (score.scan_count || 0),\n      totalTrades: acc.totalTrades + score.trade_count,\n      totalPrintOrders: acc.totalPrintOrders + score.print_order_count,\n      totalPrintRevenue: acc.totalPrintRevenue + score.print_revenue_cents,\n      totalScore: acc.totalScore + parseFloat(String(score.total_score)),\n    }), {\n      totalViews: 0,\n      totalDownloads: 0,\n      totalGifDownloads: 0,\n      totalScans: 0,\n      totalTrades: 0,\n      totalPrintOrders: 0,\n      totalPrintRevenue: 0,\n      totalScore: 0,\n    });\n\n    // Get unique collectors (owners of scored visions)\n    const { data: visualizations } = await supabase\n      .from('saved_visualizations')\n      .select('user_id');\n    \n    const uniqueCollectors = new Set(visualizations?.map(v => v.user_id) || []).size;\n\n    return { ...stats, uniqueCollectors };\n  } catch (error) {\n    console.error('Error getting platform vision stats:', error);\n    return {\n      totalViews: 0,\n      totalDownloads: 0,\n      totalGifDownloads: 0,\n      totalScans: 0,\n      totalTrades: 0,\n      totalPrintOrders: 0,\n      totalPrintRevenue: 0,\n      totalScore: 0,\n      uniqueCollectors: 0,\n    };\n  }\n}\n\n/**\n * Calculate the estimated value of a vision based on its score and activity\n * Now includes membership-driven appreciation\n */\nexport function calculateVisionValue(\n  score: VisionScore, \n  membershipMultiplier: number = 1.0\n): number {\n  // Base value from score\n  const baseValue = score.totalScore * MEMBERSHIP_ECONOMICS.valuePerScorePoint;\n  \n  // Premium for high engagement\n  const engagementMultiplier = Math.min(1 + (score.uniqueViewers / 100), 2);\n  \n  // Premium for print orders (proven demand)\n  const printPremium = score.printOrderCount * 5;\n  \n  // Apply membership-driven appreciation (capped)\n  const effectiveMultiplier = Math.min(membershipMultiplier, MEMBERSHIP_ECONOMICS.membershipMultiplierCap);\n  \n  const rawValue = (baseValue * engagementMultiplier + printPremium) * effectiveMultiplier;\n  \n  return Math.round(rawValue * 100) / 100;\n}\n\n/**\n * Calculate the membership-driven market multiplier\n * More subscribers = higher multiplier for all vision values\n */\nexport function calculateMembershipMultiplier(subscriberCount: number): number {\n  // Logarithmic scaling to prevent runaway inflation\n  // 100 subscribers = 1.3x, 1000 = 1.6x, 10000 = 2.0x, 50000 = 2.5x\n  if (subscriberCount <= 0) return 1.0;\n  \n  const multiplier = 1 + (Math.log10(subscriberCount + 1) * 0.3);\n  return Math.min(multiplier, MEMBERSHIP_ECONOMICS.membershipMultiplierCap);\n}\n\n/**\n * Calculate the total vision market capitalization\n * Includes base value + membership contributions + organic score value\n */\nexport async function getVisionMarketCap(estimatedSubscribers: number = 100): Promise<{\n  totalMarketCap: number;\n  baseMarketCap: number;\n  membershipContribution: number;\n  organicValue: number;\n  membershipMultiplier: number;\n  totalVisions: number;\n  totalScore: number;\n}> {\n  try {\n    const platformStats = await getPlatformVisionStats();\n    \n    // Calculate membership multiplier\n    const membershipMultiplier = calculateMembershipMultiplier(estimatedSubscribers);\n    \n    // Base market cap (foundation)\n    const baseMarketCap = MEMBERSHIP_ECONOMICS.baseMarketCap;\n    \n    // Membership contribution pool (monthly injection)\n    // Assuming average 6 months of contributions per subscriber\n    const membershipContribution = estimatedSubscribers * MEMBERSHIP_ECONOMICS.monthlyContributionPerMember * 6;\n    \n    // Organic value from scores (views, downloads, trades, prints)\n    const organicValue = platformStats.totalScore * MEMBERSHIP_ECONOMICS.valuePerScorePoint * membershipMultiplier;\n    \n    // Get total vision count\n    const { count } = await supabase\n      .from('saved_visualizations')\n      .select('id', { count: 'exact', head: true });\n    \n    const totalMarketCap = baseMarketCap + membershipContribution + organicValue;\n    \n    return {\n      totalMarketCap: Math.round(totalMarketCap * 100) / 100,\n      baseMarketCap,\n      membershipContribution: Math.round(membershipContribution * 100) / 100,\n      organicValue: Math.round(organicValue * 100) / 100,\n      membershipMultiplier: Math.round(membershipMultiplier * 100) / 100,\n      totalVisions: count || 0,\n      totalScore: platformStats.totalScore,\n    };\n  } catch (error) {\n    console.error('Error calculating market cap:', error);\n    return {\n      totalMarketCap: MEMBERSHIP_ECONOMICS.baseMarketCap,\n      baseMarketCap: MEMBERSHIP_ECONOMICS.baseMarketCap,\n      membershipContribution: 0,\n      organicValue: 0,\n      membershipMultiplier: 1.0,\n      totalVisions: 0,\n      totalScore: 0,\n    };\n  }\n}\n\n/**\n * Get a user's total vision portfolio value with membership appreciation\n */\nexport async function getUserPortfolioValue(\n  userId: string,\n  estimatedSubscribers: number = 100\n): Promise<{\n  totalValue: number;\n  visionCount: number;\n  totalScore: number;\n  membershipMultiplier: number;\n  appreciationFromMemberships: number;\n}> {\n  try {\n    const { data: visualizations } = await supabase\n      .from('saved_visualizations')\n      .select('id')\n      .eq('user_id', userId);\n\n    if (!visualizations || visualizations.length === 0) {\n      return { \n        totalValue: 0, \n        visionCount: 0, \n        totalScore: 0,\n        membershipMultiplier: 1.0,\n        appreciationFromMemberships: 0,\n      };\n    }\n\n    const vizIds = visualizations.map(v => v.id);\n    const { data: scores } = await supabase\n      .from('vision_scores')\n      .select('*')\n      .in('visualization_id', vizIds);\n\n    const membershipMultiplier = calculateMembershipMultiplier(estimatedSubscribers);\n    \n    let totalValueWithMultiplier = 0;\n    let totalValueWithoutMultiplier = 0;\n    let totalScore = 0;\n\n    for (const scoreData of scores || []) {\n      const score: VisionScore = {\n        visualizationId: scoreData.visualization_id,\n        viewCount: scoreData.view_count,\n        downloadHdCount: scoreData.download_hd_count,\n        downloadGifCount: scoreData.download_gif_count,\n        scanCount: scoreData.scan_count || 0,\n        tradeCount: scoreData.trade_count,\n        printOrderCount: scoreData.print_order_count,\n        printRevenueCents: scoreData.print_revenue_cents,\n        totalScore: parseFloat(String(scoreData.total_score)),\n        uniqueViewers: scoreData.unique_viewers,\n        updatedAt: scoreData.updated_at,\n        royaltyCentsEarned: scoreData.royalty_cents_earned || 0,\n        royaltyOrdersCount: scoreData.royalty_orders_count || 0,\n      };\n      totalValueWithMultiplier += calculateVisionValue(score, membershipMultiplier);\n      totalValueWithoutMultiplier += calculateVisionValue(score, 1.0);\n      totalScore += score.totalScore;\n    }\n\n    // Add base value for visions without scores yet\n    const visionsWithoutScores = visualizations.length - (scores?.length || 0);\n    const baseVisionValue = 2.50 * membershipMultiplier; // $2.50 base value per vision\n    totalValueWithMultiplier += visionsWithoutScores * baseVisionValue;\n    totalValueWithoutMultiplier += visionsWithoutScores * 2.50;\n\n    return {\n      totalValue: Math.round(totalValueWithMultiplier * 100) / 100,\n      visionCount: visualizations.length,\n      totalScore,\n      membershipMultiplier: Math.round(membershipMultiplier * 100) / 100,\n      appreciationFromMemberships: Math.round((totalValueWithMultiplier - totalValueWithoutMultiplier) * 100) / 100,\n    };\n  } catch (error) {\n    console.error('Error getting user portfolio value:', error);\n    return { \n      totalValue: 0, \n      visionCount: 0, \n      totalScore: 0,\n      membershipMultiplier: 1.0,\n      appreciationFromMemberships: 0,\n    };\n  }\n}\n\n/**\n * Calculate projected market appreciation for investor presentation\n */\nexport function calculateProjectedMarketCap(subscriberTargets: number[]): {\n  subscribers: number;\n  marketCap: number;\n  multiplier: number;\n  monthlyContribution: number;\n}[] {\n  return subscriberTargets.map(subscribers => {\n    const multiplier = calculateMembershipMultiplier(subscribers);\n    const monthlyContribution = subscribers * MEMBERSHIP_ECONOMICS.monthlyContributionPerMember;\n    const annualContribution = monthlyContribution * 12;\n    const marketCap = MEMBERSHIP_ECONOMICS.baseMarketCap + annualContribution;\n    \n    return {\n      subscribers,\n      marketCap: Math.round(marketCap),\n      multiplier: Math.round(multiplier * 100) / 100,\n      monthlyContribution: Math.round(monthlyContribution * 100) / 100,\n    };\n  });\n}\n";export{n as default};
