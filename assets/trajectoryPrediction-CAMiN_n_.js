const e="/**\n * Trajectory Prediction Generator v7.75\n * \n * Generates game trajectory predictions from hybrid analysis\n * - Phase Specialization for improved accuracy\n * - White Win Calibration to fix systematic under-prediction of white wins\n */\n\nimport { Chess } from 'chess.js';\nimport { PositionAnalysis } from '../stockfishEngine';\nimport { ColorFlowSignature, ARCHETYPE_DEFINITIONS } from '../colorFlowAnalysis';\nimport { TrajectoryPrediction, TrajectoryMilestone } from './types';\nimport { \n  getPhaseSpecializedPrediction, \n  getPhaseOptimalHorizon,\n  isArchetypePhaseMatch \n} from '../accuracy/phaseSpecialization';\nimport { detectGamePhase } from '../accuracy/temporalPhaseWeighting';\nimport { calibrateForWhiteBias } from '../accuracy/whiteWinCalibration';\n\n/**\n * Count pieces on the board for phase detection\n */\nfunction countPieces(chess: Chess): number {\n  const board = chess.board();\n  let count = 0;\n  for (const row of board) {\n    for (const sq of row) {\n      if (sq) count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Generate trajectory prediction for the game\n * v7.61: Uses phase-specialized prediction models\n */\nexport function generateTrajectoryPrediction(\n  signature: ColorFlowSignature,\n  analysis: PositionAnalysis,\n  currentMove: number,\n  chess: Chess\n): TrajectoryPrediction {\n  const archetypeDef = ARCHETYPE_DEFINITIONS[signature.archetype];\n  const pieceCount = countPieces(chess);\n  const phase = detectGamePhase(currentMove, pieceCount);\n  \n  // v7.61: Get phase-specialized prediction\n  const phaseSpecialized = getPhaseSpecializedPrediction(\n    signature,\n    archetypeDef.historicalWinRate,\n    currentMove,\n    pieceCount\n  );\n  \n  // Determine predicted outcome using phase-adjusted win rate\n  const predictedOutcome = determinePredictedOutcome(\n    signature, \n    analysis, \n    archetypeDef,\n    phaseSpecialized.phaseAdjustedWinRate,\n    phaseSpecialized.shouldPredict\n  );\n  \n  // v7.61: Use phase-optimal horizon\n  const horizonMoves = getPhaseOptimalHorizon(phase);\n  \n  // Generate milestones\n  const milestones = generateMilestones(signature, currentMove, phase);\n  \n  // Calculate probabilities using phase-adjusted rates\n  const outcomeProbabilities = calculateOutcomeProbabilities(\n    archetypeDef, \n    analysis,\n    phaseSpecialized.phaseAdjustedWinRate\n  );\n  \n  // Trajectory breakers\n  const trajectoryBreakers = getTrajectoryBreakers(signature);\n  \n  // v7.61: Add phase info to breakers\n  if (!isArchetypePhaseMatch(signature.archetype, phase)) {\n    trajectoryBreakers.unshift(`⚠️ ${signature.archetype} archetype unreliable in ${phase} phase`);\n  }\n  \n  return {\n    predictedOutcome,\n    horizonMoves,\n    expectedMilestones: milestones,\n    outcomeProbabilities,\n    trajectoryBreakers,\n  };\n}\n\nfunction determinePredictedOutcome(\n  signature: ColorFlowSignature,\n  analysis: PositionAnalysis,\n  archetypeDef: typeof ARCHETYPE_DEFINITIONS[keyof typeof ARCHETYPE_DEFINITIONS],\n  phaseAdjustedWinRate?: number,\n  shouldPredict: boolean = true\n): 'white_wins' | 'black_wins' | 'draw' | 'unclear' {\n  // Forced outcomes: mate or decisive material\n  if (analysis.evaluation.scoreType === 'mate') {\n    return analysis.evaluation.score > 0 ? 'white_wins' : 'black_wins';\n  }\n  \n  if (Math.abs(analysis.evaluation.score) > 500) {\n    return analysis.evaluation.score > 0 ? 'white_wins' : 'black_wins';\n  }\n  \n  // v7.61: If phase reliability is too low, abstain\n  if (!shouldPredict) {\n    return 'unclear';\n  }\n  \n  // Use phase-adjusted win rate if available\n  const effectiveWinRate = phaseAdjustedWinRate ?? archetypeDef.historicalWinRate;\n  \n  // v7.61: Phase-specialized thresholds\n  let rawPrediction: 'white_wins' | 'black_wins' | 'draw' | 'unclear';\n  \n  if (signature.dominantSide !== 'contested') {\n    // Higher threshold = more confident predictions\n    if (effectiveWinRate > 0.58) {\n      rawPrediction = signature.dominantSide === 'white' ? 'white_wins' : 'black_wins';\n    } else if (effectiveWinRate < 0.42) {\n      rawPrediction = signature.dominantSide === 'white' ? 'black_wins' : 'white_wins';\n    } else if (signature.temporalFlow.volatility < 30) {\n      rawPrediction = 'draw';  // Low volatility + uncertain = draw likely\n    } else {\n      rawPrediction = 'unclear';\n    }\n  } else {\n    rawPrediction = signature.temporalFlow.volatility > 50 ? 'unclear' : 'draw';\n  }\n  \n  // v7.75: Apply white win calibration to fix systematic bias\n  // Calculate a rough confidence from effective win rate distance from 0.5\n  const rawConfidence = Math.abs(effectiveWinRate - 0.5) * 200; // 0-100 scale\n  \n  const calibrated = calibrateForWhiteBias(\n    rawPrediction,\n    signature.archetype,\n    signature.dominantSide,\n    analysis.evaluation.score,\n    rawConfidence\n  );\n  \n  // Log significant calibration adjustments\n  if (calibrated.adjustmentMagnitude !== 0) {\n    console.log(`[WhiteWinCalibration] ${rawPrediction} → ${calibrated.calibratedPrediction}: ${calibrated.adjustmentApplied}`);\n  }\n  \n  return calibrated.calibratedPrediction;\n}\n\nfunction generateMilestones(\n  signature: ColorFlowSignature,\n  currentMove: number,\n  phase?: string\n): TrajectoryMilestone[] {\n  const milestones: TrajectoryMilestone[] = [];\n  \n  milestones.push({\n    approximateMoveNumber: currentMove + 5,\n    description: `${signature.flowDirection} activity intensifies`,\n    criticalSquares: signature.criticalMoments[0]?.squaresAffected || ['d4', 'e5'],\n    expectedColorFlow: `Expect ${signature.dominantSide} territorial expansion`,\n  });\n  \n  if (currentMove < 20) {\n    milestones.push({\n      approximateMoveNumber: 25,\n      description: 'Transition to middlegame complications',\n      criticalSquares: ['c5', 'e5', 'd4'],\n      expectedColorFlow: 'Color intensity peaks as pieces engage',\n    });\n  }\n  \n  if (currentMove < 35) {\n    milestones.push({\n      approximateMoveNumber: 40,\n      description: signature.archetype === 'endgame_technique' \n        ? 'Endgame conversion phase'\n        : 'Position clarification expected',\n      criticalSquares: ['d-file', 'king position'],\n      expectedColorFlow: 'Color flow stabilizes toward conclusion',\n    });\n  }\n  \n  // v7.61: Add phase-specific milestone if in endgame\n  if (phase === 'endgame' || phase === 'deep_endgame') {\n    milestones.push({\n      approximateMoveNumber: currentMove + 15,\n      description: 'Technique conversion window',\n      criticalSquares: ['king activity', 'passed pawns'],\n      expectedColorFlow: 'High reliability phase - patterns crystallized',\n    });\n  }\n  \n  return milestones;\n}\n\nfunction calculateOutcomeProbabilities(\n  archetypeDef: typeof ARCHETYPE_DEFINITIONS[keyof typeof ARCHETYPE_DEFINITIONS],\n  analysis: PositionAnalysis,\n  phaseAdjustedWinRate?: number\n): { whiteWin: number; blackWin: number; draw: number } {\n  // v7.61: Use phase-adjusted rate if available\n  const baseWin = phaseAdjustedWinRate ?? archetypeDef.historicalWinRate;\n  const evalAdjust = Math.min(0.3, analysis.evaluation.score / 1000);\n  \n  const whiteWin = Math.min(0.95, Math.max(0.05, baseWin + evalAdjust));\n  const blackWin = Math.min(0.95, Math.max(0.05, (1 - baseWin) - evalAdjust));\n  const draw = Math.max(0, 1 - whiteWin - blackWin);\n  \n  return { whiteWin, blackWin, draw };\n}\n\nfunction getTrajectoryBreakers(signature: ColorFlowSignature): string[] {\n  const breakers: string[] = [];\n  \n  if (signature.archetype === 'kingside_attack') {\n    breakers.push('Successful defensive exchange sacrifice');\n    breakers.push('Opening of queenside counter-play');\n  } else if (signature.archetype === 'central_domination') {\n    breakers.push('Successful pawn break opening the position');\n    breakers.push('Piece sacrifice to destroy center');\n  } else {\n    breakers.push('Tactical blunder changes evaluation significantly');\n    breakers.push('Unexpected strategic pivot to opposite wing');\n  }\n  \n  return breakers;\n}\n";export{e as default};
