const e="/**\n * En Pensent Core SDK - Trajectory Predictor Tests\n * \n * Tests for outcome prediction, milestone forecasting,\n * and confidence calculations.\n */\n\nimport { describe, it, expect } from 'vitest';\nimport {\n  generateTrajectoryPrediction,\n  calculateTrajectoryDivergence,\n  assessTrajectorySustainability\n} from './trajectoryPredictor';\nimport { TemporalSignature, PatternMatch, ArchetypeDefinition } from './types';\n\n// Test fixtures\nconst createMockSignature = (overrides: Partial<TemporalSignature> = {}): TemporalSignature => ({\n  fingerprint: 'EP-TEST0001',\n  archetype: 'test_archetype',\n  dominantForce: 'balanced',\n  flowDirection: 'forward',\n  intensity: 0.5,\n  quadrantProfile: { q1: 0.25, q2: 0.25, q3: 0.25, q4: 0.25 },\n  temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 },\n  criticalMoments: [],\n  ...overrides\n});\n\nconst createMockMatch = (overrides: Partial<PatternMatch> = {}): PatternMatch => ({\n  patternId: 'pattern-1',\n  similarity: 0.8,\n  signature: createMockSignature(),\n  outcome: 'success',\n  ...overrides\n});\n\nconst createMockArchetype = (overrides: Partial<ArchetypeDefinition> = {}): ArchetypeDefinition => ({\n  id: 'test_archetype',\n  name: 'Test Archetype',\n  description: 'A test archetype',\n  successRate: 0.6,\n  predictedOutcome: 'primary_wins',\n  confidence: 0.7,\n  keywords: ['test'],\n  relatedArchetypes: [],\n  ...overrides\n});\n\ndescribe('trajectoryPredictor', () => {\n  // ============================================================================\n  // generateTrajectoryPrediction\n  // ============================================================================\n  describe('generateTrajectoryPrediction', () => {\n    it('should generate prediction with required fields', () => {\n      const signature = createMockSignature();\n      const matches = [createMockMatch()];\n      const archetype = createMockArchetype();\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, archetype, 20, 60);\n      \n      expect(prediction.predictedOutcome).toBeDefined();\n      expect(prediction.confidence).toBeGreaterThanOrEqual(0);\n      expect(prediction.confidence).toBeLessThanOrEqual(1);\n      expect(prediction.primaryWinProbability).toBeGreaterThanOrEqual(0);\n      expect(prediction.secondaryWinProbability).toBeGreaterThanOrEqual(0);\n      expect(prediction.drawProbability).toBeGreaterThanOrEqual(0);\n      expect(prediction.milestones).toBeDefined();\n      expect(prediction.strategicGuidance).toBeDefined();\n      expect(prediction.lookaheadHorizon).toBeGreaterThanOrEqual(0);\n      expect(prediction.patternSampleSize).toBe(1);\n    });\n\n    it('should handle empty matches', () => {\n      const signature = createMockSignature();\n      \n      const prediction = generateTrajectoryPrediction(signature, [], null, 10, 40);\n      \n      expect(prediction.predictedOutcome).toBeDefined();\n      expect(prediction.patternSampleSize).toBe(0);\n    });\n\n    it('should calculate win probabilities based on outcomes', () => {\n      const signature = createMockSignature();\n      const matches = [\n        createMockMatch({ outcome: 'white_wins', similarity: 0.9 }),\n        createMockMatch({ outcome: 'white_wins', similarity: 0.8 }),\n        createMockMatch({ outcome: 'black_wins', similarity: 0.5 }),\n      ];\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, null, 15, 50);\n      \n      expect(prediction.primaryWinProbability).toBeGreaterThan(prediction.secondaryWinProbability);\n    });\n\n    it('should generate milestones within remaining game', () => {\n      const signature = createMockSignature();\n      const matches = [createMockMatch()];\n      const currentPosition = 20;\n      const totalLength = 60;\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, null, currentPosition, totalLength);\n      \n      for (const milestone of prediction.milestones) {\n        expect(milestone.predictedIndex).toBeGreaterThan(currentPosition);\n        expect(milestone.predictedIndex).toBeLessThanOrEqual(totalLength);\n      }\n    });\n\n    it('should include archetype-based guidance when archetype provided', () => {\n      const signature = createMockSignature({ archetype: 'rapid_growth' });\n      const matches = [createMockMatch()];\n      const archetype = createMockArchetype({ name: 'Rapid Growth' });\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, archetype, 10, 50);\n      \n      expect(prediction.strategicGuidance).toContain('Rapid Growth');\n    });\n\n    it('should adjust confidence based on match count', () => {\n      const signature = createMockSignature();\n      const fewMatches = [createMockMatch()];\n      const manyMatches = Array.from({ length: 10 }, () => createMockMatch());\n      \n      const predFew = generateTrajectoryPrediction(signature, fewMatches, null, 10, 50);\n      const predMany = generateTrajectoryPrediction(signature, manyMatches, null, 10, 50);\n      \n      expect(predMany.confidence).toBeGreaterThan(predFew.confidence);\n    });\n\n    it('should calculate lookahead horizon based on confidence', () => {\n      const signature = createMockSignature();\n      const highConfMatches = Array.from({ length: 10 }, () => \n        createMockMatch({ similarity: 0.95 })\n      );\n      const lowConfMatches = [createMockMatch({ similarity: 0.5 })];\n      \n      const predHigh = generateTrajectoryPrediction(signature, highConfMatches, null, 10, 100);\n      const predLow = generateTrajectoryPrediction(signature, lowConfMatches, null, 10, 100);\n      \n      expect(predHigh.lookaheadHorizon).toBeGreaterThan(predLow.lookaheadHorizon);\n    });\n\n    it('should handle game near completion', () => {\n      const signature = createMockSignature();\n      const matches = [createMockMatch()];\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, null, 55, 60);\n      \n      expect(prediction.milestones.length).toBeLessThanOrEqual(5);\n    });\n\n    it('should include critical moments from signature in milestones', () => {\n      const signature = createMockSignature({\n        criticalMoments: [\n          { index: 30, type: 'surge', severity: 0.8, description: 'Major shift' },\n          { index: 40, type: 'drop', severity: 0.6, description: 'Minor decline' },\n        ]\n      });\n      const matches = [createMockMatch()];\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, null, 20, 60);\n      \n      const hasCriticalMilestone = prediction.milestones.some(m => \n        m.event.includes('shift') || m.event.includes('decline') || m.predictedIndex === 30 || m.predictedIndex === 40\n      );\n      \n      expect(prediction.milestones.length).toBeGreaterThan(0);\n    });\n\n    it('should provide trend-based strategic guidance', () => {\n      const accelerating = createMockSignature({\n        temporalFlow: { opening: 0.3, middle: 0.5, ending: 0.7, trend: 'accelerating', momentum: 0.5 }\n      });\n      const declining = createMockSignature({\n        temporalFlow: { opening: 0.7, middle: 0.5, ending: 0.3, trend: 'declining', momentum: -0.5 }\n      });\n      \n      const predAccel = generateTrajectoryPrediction(accelerating, [], null, 10, 50);\n      const predDecline = generateTrajectoryPrediction(declining, [], null, 10, 50);\n      \n      expect(predAccel.strategicGuidance.toLowerCase()).toContain('momentum');\n      expect(predDecline.strategicGuidance.toLowerCase()).toContain('declin');\n    });\n\n    it('should ensure probabilities are valid', () => {\n      const signature = createMockSignature();\n      const matches = [\n        createMockMatch({ outcome: 'win', similarity: 0.9 }),\n        createMockMatch({ outcome: 'loss', similarity: 0.7 }),\n      ];\n      \n      const prediction = generateTrajectoryPrediction(signature, matches, null, 10, 50);\n      \n      const totalProb = prediction.primaryWinProbability + \n                        prediction.secondaryWinProbability + \n                        prediction.drawProbability;\n      \n      expect(prediction.drawProbability).toBeGreaterThanOrEqual(0);\n      expect(totalProb).toBeLessThanOrEqual(1.01); // Allow small floating point error\n    });\n  });\n\n  // ============================================================================\n  // calculateTrajectoryDivergence\n  // ============================================================================\n  describe('calculateTrajectoryDivergence', () => {\n    it('should return 1 for no matches', () => {\n      const signature = createMockSignature();\n      \n      const divergence = calculateTrajectoryDivergence(signature, []);\n      \n      expect(divergence).toBe(1);\n    });\n\n    it('should return low divergence for similar signatures', () => {\n      const signature = createMockSignature({ intensity: 0.5 });\n      const matches = [\n        createMockMatch({ signature: createMockSignature({ intensity: 0.5 }) }),\n        createMockMatch({ signature: createMockSignature({ intensity: 0.5 }) }),\n      ];\n      \n      const divergence = calculateTrajectoryDivergence(signature, matches);\n      \n      expect(divergence).toBeLessThan(0.5);\n    });\n\n    it('should return high divergence for different signatures', () => {\n      const signature = createMockSignature({ \n        intensity: 0.9,\n        temporalFlow: { opening: 0.8, middle: 0.8, ending: 0.8, trend: 'accelerating', momentum: 0.8 }\n      });\n      const matches = [\n        createMockMatch({ \n          signature: createMockSignature({ \n            intensity: 0.1,\n            temporalFlow: { opening: 0.2, middle: 0.2, ending: 0.2, trend: 'declining', momentum: -0.8 }\n          }) \n        }),\n      ];\n      \n      const divergence = calculateTrajectoryDivergence(signature, matches);\n      \n      expect(divergence).toBeGreaterThan(0.3);\n    });\n\n    it('should factor in momentum differences', () => {\n      const signature = createMockSignature({\n        temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0.8 }\n      });\n      const matches = [\n        createMockMatch({\n          signature: createMockSignature({\n            temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: -0.8 }\n          })\n        }),\n      ];\n      \n      const divergence = calculateTrajectoryDivergence(signature, matches);\n      \n      expect(divergence).toBeGreaterThan(0);\n    });\n\n    it('should be between 0 and 1', () => {\n      const signature = createMockSignature();\n      const matches = [\n        createMockMatch({ signature: createMockSignature({ intensity: 0.3 }) }),\n        createMockMatch({ signature: createMockSignature({ intensity: 0.7 }) }),\n      ];\n      \n      const divergence = calculateTrajectoryDivergence(signature, matches);\n      \n      expect(divergence).toBeGreaterThanOrEqual(0);\n      expect(divergence).toBeLessThanOrEqual(1);\n    });\n  });\n\n  // ============================================================================\n  // assessTrajectorySustainability\n  // ============================================================================\n  describe('assessTrajectorySustainability', () => {\n    it('should flag high intensity accelerating as unsustainable', () => {\n      const signature = createMockSignature({\n        intensity: 0.85,\n        temporalFlow: { opening: 0.5, middle: 0.7, ending: 0.9, trend: 'accelerating', momentum: 0.6 }\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      expect(assessment.sustainable).toBe(false);\n      expect(assessment.riskLevel).toBe('high');\n      expect(assessment.reason.toLowerCase()).toContain('burnout');\n    });\n\n    it('should flag declining with negative momentum as unsustainable', () => {\n      const signature = createMockSignature({\n        temporalFlow: { opening: 0.8, middle: 0.5, ending: 0.3, trend: 'declining', momentum: -0.6 }\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      expect(assessment.sustainable).toBe(false);\n      expect(assessment.riskLevel).toBe('high');\n      expect(assessment.reason.toLowerCase()).toContain('declin');\n    });\n\n    it('should flag many critical moments as potentially unsustainable', () => {\n      const signature = createMockSignature({\n        criticalMoments: [\n          { index: 10, type: 'surge', severity: 0.8, description: 'Big' },\n          { index: 20, type: 'drop', severity: 0.75, description: 'Drop' },\n          { index: 30, type: 'surge', severity: 0.9, description: 'Another' },\n          { index: 40, type: 'drop', severity: 0.85, description: 'More' },\n        ]\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      expect(assessment.sustainable).toBe(false);\n      expect(assessment.riskLevel).toBe('medium');\n      expect(assessment.reason.toLowerCase()).toContain('critical');\n    });\n\n    it('should mark volatile trends with medium risk', () => {\n      const signature = createMockSignature({\n        temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'volatile', momentum: 0 }\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      expect(assessment.sustainable).toBe(true);\n      expect(assessment.riskLevel).toBe('medium');\n    });\n\n    it('should mark stable patterns as sustainable with low risk', () => {\n      const signature = createMockSignature({\n        intensity: 0.5,\n        temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 },\n        criticalMoments: []\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      expect(assessment.sustainable).toBe(true);\n      expect(assessment.riskLevel).toBe('low');\n      expect(assessment.reason.toLowerCase()).toContain('sustainable');\n    });\n\n    it('should handle moderate intensity accelerating as sustainable', () => {\n      const signature = createMockSignature({\n        intensity: 0.6, // Below 0.8 threshold\n        temporalFlow: { opening: 0.3, middle: 0.5, ending: 0.7, trend: 'accelerating', momentum: 0.4 }\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      expect(assessment.sustainable).toBe(true);\n    });\n\n    it('should handle edge case with boundary intensity', () => {\n      const signature = createMockSignature({\n        intensity: 0.8, // Exactly at boundary\n        temporalFlow: { opening: 0.5, middle: 0.7, ending: 0.9, trend: 'accelerating', momentum: 0.5 }\n      });\n      \n      const assessment = assessTrajectorySustainability(signature);\n      \n      // Should be sustainable as condition is > 0.8, not >=\n      expect(assessment.sustainable).toBe(true);\n    });\n\n    it('should return valid risk level', () => {\n      const signatures = [\n        createMockSignature({ intensity: 0.9, temporalFlow: { opening: 0.5, middle: 0.7, ending: 0.9, trend: 'accelerating', momentum: 0.5 } }),\n        createMockSignature({ temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'volatile', momentum: 0 } }),\n        createMockSignature({ temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 } }),\n      ];\n      \n      for (const sig of signatures) {\n        const assessment = assessTrajectorySustainability(sig);\n        expect(['low', 'medium', 'high']).toContain(assessment.riskLevel);\n      }\n    });\n  });\n});\n";export{e as default};
