const n="/**\n * Chess.com Puzzle API Integration\n * Fetches daily puzzles and puzzle rush data\n * \n * v8.1-PUZZLES: New source for temporal pattern training\n */\n\nexport interface ChessComPuzzle {\n  id: string;\n  fen: string;\n  moves: string[]; // Solution in SAN format\n  rating: number;\n  themes: string[];\n  daily?: boolean; // Is this the daily puzzle?\n  rushMode?: 'bullet' | 'blitz' | 'rapid';\n}\n\nexport interface ChessComPuzzleResult {\n  puzzles: ChessComPuzzle[];\n  totalFetched: number;\n  errors: string[];\n}\n\n// Chess.com puzzle themes mapping\nexport const CHESSCOM_PUZZLE_THEMES = [\n  'Mate',\n  'Material Advantage',\n  'Endgame Technique',\n  'Tactical Patterns',\n  'Defense',\n  'Attack',\n  'Fork',\n  'Pin',\n  'Skewer',\n  'Discovered Attack',\n  'Sacrifice',\n  'Clearance',\n  'Blocking',\n  'Interference',\n  'Attraction',\n  'Deflection',\n  'Decoy',\n  'Desperado',\n  'Passed Pawns',\n  'Promotion',\n  'Stalemate',\n  'Perpetual Check',\n  'Zugzwang',\n  'Kingside Attack',\n  'Queenside Attack',\n  'Center Control',\n  'Piece Coordination',\n  'Prophylaxis',\n  'Space Advantage',\n  'Time Trouble'\n] as const;\n\n/**\n * Fetch daily puzzle from Chess.com\n * Returns today's featured puzzle\n */\nexport async function fetchChessComDailyPuzzle(): Promise<ChessComPuzzle | null> {\n  try {\n    const response = await fetch('https://api.chess.com/pub/puzzle');\n    \n    if (!response.ok) {\n      console.warn(`[Chess.com Puzzles] Daily puzzle fetch failed: ${response.status}`);\n      return null;\n    }\n    \n    const data = await response.json();\n    \n    return {\n      id: `ccp_${data.id}`,\n      fen: data.fen,\n      moves: data.pgn ? parsePgnToMoves(data.pgn) : [],\n      rating: data.rating || 1500,\n      themes: data.themes || [],\n      daily: true\n    };\n  } catch (error) {\n    console.error('[Chess.com Puzzles] Daily puzzle error:', error);\n    return null;\n  }\n}\n\n/**\n * Fetch random puzzles from Chess.com\n * Note: Chess.com has limited public puzzle API\n * Uses daily puzzle + archive approach\n */\nexport async function fetchChessComPuzzles(\n  options: {\n    max?: number;\n    minRating?: number;\n    maxRating?: number;\n  } = {}\n): Promise<ChessComPuzzleResult> {\n  const { max = 50, minRating = 800, maxRating = 2800 } = options;\n  \n  const puzzles: ChessComPuzzle[] = [];\n  const errors: string[] = [];\n  \n  try {\n    // Fetch daily puzzle first\n    const dailyPuzzle = await fetchChessComDailyPuzzle();\n    if (dailyPuzzle && \n        dailyPuzzle.rating >= minRating && \n        dailyPuzzle.rating <= maxRating) {\n      puzzles.push(dailyPuzzle);\n    }\n    \n    // Fetch from archive if available\n    // Chess.com doesn't have a direct \"random puzzle\" API\n    // So we fetch from their daily archive\n    const archiveResponse = await fetch('https://api.chess.com/pub/puzzle/history');\n    \n    if (archiveResponse.ok) {\n      const archive = await archiveResponse.json();\n      const puzzleIds = Object.keys(archive.puzzles || {}).slice(0, max - puzzles.length);\n      \n      for (const puzzleId of puzzleIds) {\n        if (puzzles.length >= max) break;\n        \n        try {\n          const puzzleData = archive.puzzles[puzzleId];\n          \n          if (puzzleData.rating >= minRating && puzzleData.rating <= maxRating) {\n            puzzles.push({\n              id: `ccp_${puzzleId}`,\n              fen: puzzleData.fen,\n              moves: puzzleData.solution || [],\n              rating: puzzleData.rating,\n              themes: puzzleData.themes || [],\n              daily: false\n            });\n          }\n        } catch (err) {\n          errors.push(`Puzzle ${puzzleId}: ${err instanceof Error ? err.message : 'Parse error'}`);\n        }\n      }\n    }\n    \n    console.log(`[Chess.com Puzzles v8.1] âœ“ Fetched ${puzzles.length} puzzles (daily: ${puzzles.filter(p => p.daily).length})`);\n    \n    return {\n      puzzles,\n      totalFetched: puzzles.length,\n      errors\n    };\n    \n  } catch (error) {\n    console.error('[Chess.com Puzzles] Fetch error:', error);\n    return {\n      puzzles,\n      totalFetched: puzzles.length,\n      errors: [error instanceof Error ? error.message : 'Unknown error', ...errors]\n    };\n  }\n}\n\n/**\n * Parse PGN moves to array\n */\nfunction parsePgnToMoves(pgn: string): string[] {\n  // Remove headers\n  const moveSection = pgn.replace(/\\[.*?\\]/g, '').trim();\n  \n  // Extract moves (simplified parsing)\n  const moves: string[] = [];\n  const tokens = moveSection.split(/\\s+/);\n  \n  for (const token of tokens) {\n    // Skip move numbers and results\n    if (token.match(/^\\d+\\.$/) || token.match(/^(1-0|0-1|1\\/2-1\\/2|\\*)$/)) {\n      continue;\n    }\n    // Keep actual moves\n    if (token.length > 0 && !token.includes('{') && !token.includes('}')) {\n      moves.push(token);\n    }\n  }\n  \n  return moves;\n}\n\n/**\n * Convert Chess.com puzzle to unified format\n */\nexport function chessComPuzzleToUnified(\n  puzzle: ChessComPuzzle\n): {\n  pgn: string;\n  fen: string;\n  gameId: string;\n  source: 'puzzle_cc';\n  themes: string[];\n  rating: number;\n  solution: string[];\n  daily: boolean;\n} {\n  const moves = puzzle.moves.map((move, i) => \n    i % 2 === 0 ? `${Math.floor(i / 2) + 1}. ${move}` : move\n  ).join(' ');\n  \n  const pgn = `[Event \"Chess.com Puzzle ${puzzle.id}\"]\\n` +\n              `[FEN \"${puzzle.fen}\"]\\n` +\n              `[PuzzleRating \"${puzzle.rating}\"]\\n` +\n              `[PuzzleThemes \"${puzzle.themes.join(', ')}\"]\\n` +\n              `[Daily \"${puzzle.daily ? 'Yes' : 'No'}\"]\\n\\n` +\n              `${moves} *`;\n  \n  return {\n    pgn,\n    fen: puzzle.fen,\n    gameId: `ccp_${puzzle.id.replace('ccp_', '')}`,\n    source: 'puzzle_cc' as const,\n    themes: puzzle.themes,\n    rating: puzzle.rating,\n    solution: puzzle.moves,\n    daily: puzzle.daily || false\n  };\n}\n";export{n as default};
