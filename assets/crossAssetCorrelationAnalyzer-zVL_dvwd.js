const n="/**\n * Cross-Asset Correlation Analyzer\n * \n * Detects lead-lag relationships, cointegration, and regime changes\n * across asset classes for pairs trading and risk management.\n */\n\nimport { ASSET_CLASSES } from './multiAssetConfig';\n\ninterface CorrelationMatrix {\n  timestamp: string;\n  correlations: Map<string, Map<string, number>>;\n  rollingWindow: number;\n}\n\ninterface CointegrationPair {\n  asset1: string;\n  asset2: string;\n  beta: number;\n  zScore: number;\n  halfLife: number;\n  pValue: number;\n  isCointegrated: boolean;\n  signal: 'long_spread' | 'short_spread' | 'none';\n  confidence: number;\n}\n\ninterface LeadLag {\n  leader: string;\n  lagger: string;\n  lagMinutes: number;\n  correlation: number;\n  grangerPValue: number;\n  confidence: number;\n}\n\ninterface RegimeChange {\n  timestamp: string;\n  asset: string;\n  fromRegime: string;\n  toRegime: string;\n  confidence: number;\n  meanShift: number;\n  volShift: number;\n}\n\nexport class CrossAssetCorrelationAnalyzer {\n  private priceHistory: Map<string, number[]> = new Map();\n  private returnsHistory: Map<string, number[]> = new Map();\n  private correlationMatrix: CorrelationMatrix | null = null;\n  private cointegrationPairs: CointegrationPair[] = [];\n  private leadLags: LeadLag[] = [];\n  private regimeChanges: RegimeChange[] = [];\n  \n  private readonly MAX_HISTORY = 252; // 1 year of daily data\n  private readonly ROLLING_WINDOW = 60; // 60-day rolling correlation\n  private readonly COINTEGRATION_THRESHOLD = 0.05;\n  \n  constructor(private supabase: any) {}\n  \n  async initialize() {\n    console.log('[CorrelationAnalyzer] Initializing...');\n    \n    // Load historical prices\n    await this.loadPriceHistory();\n    \n    // Start analysis loops\n    this.startCorrelationUpdates();\n    this.startCointegrationScan();\n    this.startLeadLagDetection();\n    this.startRegimeMonitoring();\n    \n    console.log('[CorrelationAnalyzer] Initialized');\n  }\n  \n  async addPricePoint(symbol: string, price: number, timestamp: string) {\n    if (!this.priceHistory.has(symbol)) {\n      this.priceHistory.set(symbol, []);\n    }\n    \n    const history = this.priceHistory.get(symbol)!;\n    history.push(price);\n    \n    // Trim to max history\n    if (history.length > this.MAX_HISTORY) {\n      history.shift();\n    }\n    \n    // Calculate return\n    if (history.length > 1) {\n      const ret = (price - history[history.length - 2]) / history[history.length - 2];\n      \n      if (!this.returnsHistory.has(symbol)) {\n        this.returnsHistory.set(symbol, []);\n      }\n      \n      const returns = this.returnsHistory.get(symbol)!;\n      returns.push(ret);\n      \n      if (returns.length > this.MAX_HISTORY) {\n        returns.shift();\n      }\n    }\n  }\n  \n  private startCorrelationUpdates() {\n    // Update correlations every 5 minutes\n    setInterval(() => {\n      this.updateCorrelationMatrix();\n    }, 300000);\n  }\n  \n  private updateCorrelationMatrix() {\n    const symbols = Array.from(this.returnsHistory.keys());\n    const correlations = new Map<string, Map<string, number>>();\n    \n    for (const sym1 of symbols) {\n      const row = new Map<string, number>();\n      const returns1 = this.returnsHistory.get(sym1)?.slice(-this.ROLLING_WINDOW) || [];\n      \n      for (const sym2 of symbols) {\n        if (sym1 === sym2) {\n          row.set(sym2, 1.0);\n        } else {\n          const returns2 = this.returnsHistory.get(sym2)?.slice(-this.ROLLING_WINDOW) || [];\n          const corr = this.calculateCorrelation(returns1, returns2);\n          row.set(sym2, corr);\n        }\n      }\n      \n      correlations.set(sym1, row);\n    }\n    \n    this.correlationMatrix = {\n      timestamp: new Date().toISOString(),\n      correlations,\n      rollingWindow: this.ROLLING_WINDOW,\n    };\n  }\n  \n  private startCointegrationScan() {\n    // Scan for cointegration every hour\n    setInterval(() => {\n      this.scanCointegration();\n    }, 3600000);\n  }\n  \n  private scanCointegration() {\n    this.cointegrationPairs = [];\n    const symbols = Array.from(this.priceHistory.keys());\n    \n    // Focus on known relationships\n    const pairsToCheck = [\n      ['SPY', 'QQQ'],\n      ['SPY', 'IWM'],\n      ['TLT', 'SPY'],\n      ['GLD', 'SLV'],\n      ['UUP', 'SPY'],\n      ['VIX', 'SPY'],\n      ['XLE', 'CL'],\n      ['XLF', 'TLT'],\n    ];\n    \n    for (const [sym1, sym2] of pairsToCheck) {\n      if (!this.priceHistory.has(sym1) || !this.priceHistory.has(sym2)) continue;\n      \n      const prices1 = this.priceHistory.get(sym1)!;\n      const prices2 = this.priceHistory.get(sym2)!;\n      \n      if (prices1.length < 60 || prices2.length < 60) continue;\n      \n      const result = this.testCointegration(prices1, prices2);\n      \n      if (result.isCointegrated) {\n        this.cointegrationPairs.push({\n          asset1: sym1,\n          asset2: sym2,\n          ...result,\n        });\n      }\n    }\n    \n    // Sort by confidence\n    this.cointegrationPairs.sort((a, b) => b.confidence - a.confidence);\n  }\n  \n  private testCointegration(prices1: number[], prices2: number[]): Partial<CointegrationPair> {\n    // Simplified Engle-Granger test\n    const n = Math.min(prices1.length, prices2.length);\n    const p1 = prices1.slice(-n);\n    const p2 = prices2.slice(-n);\n    \n    // OLS regression: p1 = alpha + beta * p2 + epsilon\n    const { beta, alpha } = this.olsRegression(p2, p1);\n    \n    // Calculate spread\n    const spread = p1.map((p1i, i) => p1i - alpha - beta * p2[i]);\n    \n    // Test spread for stationarity (ADF-like)\n    const { isStationary, pValue } = this.testStationarity(spread);\n    \n    // Calculate z-score of current spread\n    const mean = spread.reduce((a, b) => a + b, 0) / spread.length;\n    const variance = spread.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / spread.length;\n    const std = Math.sqrt(variance);\n    const currentSpread = spread[spread.length - 1];\n    const zScore = (currentSpread - mean) / std;\n    \n    // Calculate half-life (mean reversion speed)\n    const halfLife = this.calculateHalfLife(spread);\n    \n    // Generate signal\n    let signal: 'long_spread' | 'short_spread' | 'none' = 'none';\n    if (zScore < -2) signal = 'long_spread';\n    else if (zScore > 2) signal = 'short_spread';\n    \n    return {\n      beta,\n      zScore,\n      halfLife,\n      pValue,\n      isCointegrated: isStationary && pValue < this.COINTEGRATION_THRESHOLD,\n      signal,\n      confidence: Math.abs(zScore) / 3, // Normalize to 0-1\n    };\n  }\n  \n  private startLeadLagDetection() {\n    // Detect lead-lag every 2 hours\n    setInterval(() => {\n      this.detectLeadLag();\n    }, 7200000);\n  }\n  \n  private detectLeadLag() {\n    this.leadLags = [];\n    const symbols = Array.from(this.returnsHistory.keys());\n    \n    for (let i = 0; i < symbols.length; i++) {\n      for (let j = i + 1; j < symbols.length; j++) {\n        const sym1 = symbols[i];\n        const sym2 = symbols[j];\n        \n        const returns1 = this.returnsHistory.get(sym1) || [];\n        const returns2 = this.returnsHistory.get(sym2) || [];\n        \n        if (returns1.length < 30 || returns2.length < 30) continue;\n        \n        // Test both directions\n        const test12 = this.testGrangerCausality(returns1, returns2);\n        const test21 = this.testGrangerCausality(returns2, returns1);\n        \n        if (test12.pValue < 0.05 && test12.correlation > 0.5) {\n          this.leadLags.push({\n            leader: sym1,\n            lagger: sym2,\n            lagMinutes: test12.optimalLag,\n            correlation: test12.correlation,\n            grangerPValue: test12.pValue,\n            confidence: 1 - test12.pValue,\n          });\n        }\n        \n        if (test21.pValue < 0.05 && test21.correlation > 0.5) {\n          this.leadLags.push({\n            leader: sym2,\n            lagger: sym1,\n            lagMinutes: test21.optimalLag,\n            correlation: test21.correlation,\n            grangerPValue: test21.pValue,\n            confidence: 1 - test21.pValue,\n          });\n        }\n      }\n    }\n    \n    // Sort by confidence\n    this.leadLags.sort((a, b) => b.confidence - a.confidence);\n  }\n  \n  private startRegimeMonitoring() {\n    // Monitor for regime changes every 30 minutes\n    setInterval(() => {\n      this.detectRegimeChanges();\n    }, 1800000);\n  }\n  \n  private detectRegimeChanges() {\n    for (const [symbol, prices] of this.priceHistory) {\n      if (prices.length < 60) continue;\n      \n      // Split into two regimes\n      const midpoint = Math.floor(prices.length / 2);\n      const regime1 = prices.slice(0, midpoint);\n      const regime2 = prices.slice(midpoint);\n      \n      const mean1 = regime1.reduce((a, b) => a + b, 0) / regime1.length;\n      const mean2 = regime2.reduce((a, b) => a + b, 0) / regime2.length;\n      const vol1 = Math.sqrt(regime1.reduce((sum, p) => sum + Math.pow(p - mean1, 2), 0) / regime1.length);\n      const vol2 = Math.sqrt(regime2.reduce((sum, p) => sum + Math.pow(p - mean2, 2), 0) / regime2.length);\n      \n      // Check for significant shift\n      const meanShift = Math.abs(mean2 - mean1) / mean1;\n      const volShift = Math.abs(vol2 - vol1) / vol1;\n      \n      if (meanShift > 0.05 || volShift > 0.2) {\n        const fromRegime = vol1 > 0.2 ? 'high_vol' : 'low_vol';\n        const toRegime = vol2 > 0.2 ? 'high_vol' : 'low_vol';\n        \n        if (fromRegime !== toRegime) {\n          this.regimeChanges.push({\n            timestamp: new Date().toISOString(),\n            asset: symbol,\n            fromRegime,\n            toRegime,\n            confidence: Math.max(meanShift, volShift),\n            meanShift,\n            volShift,\n          });\n          \n          // Keep only last 100 changes\n          if (this.regimeChanges.length > 100) {\n            this.regimeChanges.shift();\n          }\n        }\n      }\n    }\n  }\n  \n  // Helper methods\n  private calculateCorrelation(x: number[], y: number[]): number {\n    const n = Math.min(x.length, y.length);\n    if (n < 2) return 0;\n    \n    const sumX = x.slice(0, n).reduce((a, b) => a + b, 0);\n    const sumY = y.slice(0, n).reduce((a, b) => a + b, 0);\n    const sumXY = x.slice(0, n).reduce((sum, xi, i) => sum + xi * y[i], 0);\n    const sumX2 = x.slice(0, n).reduce((sum, xi) => sum + xi * xi, 0);\n    const sumY2 = y.slice(0, n).reduce((sum, yi) => sum + yi * yi, 0);\n    \n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n    \n    return denominator === 0 ? 0 : numerator / denominator;\n  }\n  \n  private olsRegression(x: number[], y: number[]): { beta: number; alpha: number } {\n    const n = x.length;\n    const sumX = x.reduce((a, b) => a + b, 0);\n    const sumY = y.reduce((a, b) => a + b, 0);\n    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);\n    \n    const beta = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    const alpha = (sumY - beta * sumX) / n;\n    \n    return { beta, alpha };\n  }\n  \n  private testStationarity(series: number[]): { isStationary: boolean; pValue: number } {\n    // Simplified ADF test proxy\n    const returns = series.slice(1).map((v, i) => v - series[i]);\n    const autocorr = this.calculateCorrelation(returns.slice(0, -1), returns.slice(1));\n    \n    return {\n      isStationary: Math.abs(autocorr) < 0.9,\n      pValue: 1 - Math.abs(autocorr),\n    };\n  }\n  \n  private calculateHalfLife(spread: number[]): number {\n    // Ornstein-Uhlenbeck half-life\n    const lagSpread = spread.slice(0, -1);\n    const deltaSpread = spread.slice(1).map((s, i) => s - lagSpread[i]);\n    \n    const { beta } = this.olsRegression(lagSpread, deltaSpread);\n    const theta = -Math.log(2) / beta;\n    \n    return Math.max(1, theta);\n  }\n  \n  private testGrangerCausality(cause: number[], effect: number[]): { pValue: number; correlation: number; optimalLag: number } {\n    // Simplified Granger causality test\n    let bestCorr = 0;\n    let bestLag = 1;\n    \n    for (let lag = 1; lag <= 5; lag++) {\n      const causeLagged = cause.slice(0, -lag);\n      const effectCurrent = effect.slice(lag);\n      \n      if (causeLagged.length < 10) continue;\n      \n      const corr = Math.abs(this.calculateCorrelation(causeLagged, effectCurrent));\n      \n      if (corr > bestCorr) {\n        bestCorr = corr;\n        bestLag = lag;\n      }\n    }\n    \n    return {\n      pValue: 1 - bestCorr,\n      correlation: bestCorr,\n      optimalLag: bestLag * 5, // Convert to minutes (assuming 5-min bars)\n    };\n  }\n  \n  private async loadPriceHistory() {\n    try {\n      const { data } = await this.supabase\n        .from('price_history')\n        .select('*')\n        .order('timestamp', { ascending: true })\n        .limit(10000);\n      \n      if (data) {\n        for (const row of data) {\n          this.addPricePoint(row.symbol, row.price, row.timestamp);\n        }\n      }\n    } catch (err) {\n      console.warn('[CorrelationAnalyzer] Failed to load price history:', err);\n    }\n  }\n  \n  // Public getters\n  getCorrelation(sym1: string, sym2: string): number {\n    return this.correlationMatrix?.correlations.get(sym1)?.get(sym2) || 0;\n  }\n  \n  getCorrelationMatrix(): CorrelationMatrix | null {\n    return this.correlationMatrix;\n  }\n  \n  getCointegrationPairs(): CointegrationPair[] {\n    return this.cointegrationPairs;\n  }\n  \n  getLeadLags(): LeadLag[] {\n    return this.leadLags;\n  }\n  \n  getRecentRegimeChanges(): RegimeChange[] {\n    return this.regimeChanges.slice(-10);\n  }\n  \n  getDiversificationScore(symbol: string): number {\n    // Calculate diversification based on average correlation\n    let totalCorr = 0;\n    let count = 0;\n    \n    for (const [other, corr] of this.correlationMatrix?.correlations.get(symbol) || []) {\n      if (other !== symbol) {\n        totalCorr += Math.abs(corr);\n        count++;\n      }\n    }\n    \n    return count > 0 ? 1 - (totalCorr / count) : 1;\n  }\n}\n";export{n as default};
