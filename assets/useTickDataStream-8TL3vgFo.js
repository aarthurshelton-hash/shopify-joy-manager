const e="/**\n * Tick Data Stream Hook\n * v7.51-REAL: REAL DATA ONLY - No simulation fallbacks\n * Connects to multi-broker aggregator for authentic market data\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface Tick {\n  price: number;\n  volume: number;\n  timestamp: number;\n  bid?: number;\n  ask?: number;\n  source?: string; // Track data source for authenticity\n  isReal: boolean; // v7.51: Must be true for valid data\n}\n\nexport interface TickStreamConfig {\n  symbol: string;\n  mode: 'real' | 'websocket'; // v7.51: Removed 'demo' mode\n  wsUrl?: string;\n  apiKey?: string;\n  pollInterval?: number; // How often to fetch real data (ms)\n}\n\nexport interface TickStreamState {\n  connected: boolean;\n  ticks: Tick[];\n  latestTick: Tick | null;\n  ticksPerSecond: number;\n  error: string | null;\n  dataQuality: 'real' | 'stale' | 'disconnected';\n  lastRealUpdate: number;\n  sources: string[];\n}\n\nconst DEFAULT_CONFIG: Partial<TickStreamConfig> = {\n  pollInterval: 1500, // 1.5s default poll interval\n  mode: 'real'\n};\n\ntype TickListener = (tick: Tick) => void;\n\nexport function useTickDataStream(config: TickStreamConfig) {\n  const mergedConfig = { ...DEFAULT_CONFIG, ...config };\n  \n  const [state, setState] = useState<TickStreamState>({\n    connected: false,\n    ticks: [],\n    latestTick: null,\n    ticksPerSecond: 0,\n    error: null,\n    dataQuality: 'disconnected',\n    lastRealUpdate: 0,\n    sources: []\n  });\n  \n  const listenersRef = useRef<Set<TickListener>>(new Set());\n  const wsRef = useRef<WebSocket | null>(null);\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const tickCountRef = useRef(0);\n  const tpsIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const priceRef = useRef<number>(100);\n  const isStartedRef = useRef(false);\n  const mountedRef = useRef(true);\n  \n  // Add tick listener\n  const addTickListener = useCallback((callback: TickListener) => {\n    listenersRef.current.add(callback);\n    return () => {\n      listenersRef.current.delete(callback);\n    };\n  }, []);\n  \n  // Process a new tick\n  const processTick = useCallback((tick: Tick) => {\n    if (!mountedRef.current) return;\n    \n    tickCountRef.current++;\n    \n    setState(prev => {\n      const newTicks = [...prev.ticks, tick].slice(-200);\n      return {\n        ...prev,\n        ticks: newTicks,\n        latestTick: tick,\n        connected: true,\n        error: null\n      };\n    });\n    \n    // Notify all listeners\n    listenersRef.current.forEach(listener => {\n      try {\n        listener(tick);\n      } catch (e) {\n        console.error('[TickStream] Listener error:', e);\n      }\n    });\n  }, []);\n  \n  // Fetch real data from multi-broker edge function\n  const fetchRealData = useCallback(async (): Promise<Tick | null> => {\n    try {\n      const { data, error } = await supabase.functions.invoke('multi-broker-data', {\n        body: { \n          symbol: mergedConfig.symbol, \n          assetType: 'stock',\n          action: 'aggregate' \n        },\n      });\n\n      if (error) {\n        console.error('[TickStream] Edge function error:', error);\n        setState(prev => ({ ...prev, error: error.message }));\n        return null;\n      }\n\n      if (data?.success && data.data) {\n        const aggregated = data.data;\n        \n        if (!aggregated.consensus?.price || aggregated.sources?.length === 0) {\n          console.warn('[TickStream] No real data available for', mergedConfig.symbol);\n          return null;\n        }\n\n        priceRef.current = aggregated.consensus.price;\n\n        const tick: Tick = {\n          price: aggregated.consensus.price,\n          volume: aggregated.ticks?.reduce((sum: number, t: any) => sum + (t.volume || 0), 0) || 0,\n          timestamp: aggregated.timestamp || Date.now(),\n          bid: aggregated.ticks?.[0]?.bid,\n          ask: aggregated.ticks?.[0]?.ask,\n          source: aggregated.sources?.join(',') || 'unknown',\n          isReal: true\n        };\n\n        setState(prev => ({\n          ...prev,\n          sources: aggregated.sources || [],\n          dataQuality: 'real',\n          lastRealUpdate: Date.now()\n        }));\n\n        return tick;\n      }\n\n      return null;\n    } catch (err) {\n      console.error('[TickStream] Fetch error:', err);\n      setState(prev => ({ ...prev, error: String(err) }));\n      return null;\n    }\n  }, [mergedConfig.symbol]);\n  \n  // Start real data polling mode\n  const startRealMode = useCallback(() => {\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current);\n    }\n    \n    console.log('[TickStream] Starting REAL data mode for', mergedConfig.symbol);\n    \n    // Initialize price based on symbol\n    const symbolPrices: Record<string, number> = {\n      'SPY': 580, 'QQQ': 500, 'AAPL': 230, 'NVDA': 140,\n      'TSLA': 380, 'MSFT': 450, 'AMD': 125, 'GOOGL': 195\n    };\n    priceRef.current = symbolPrices[mergedConfig.symbol] || 100;\n    \n    // Fetch first tick immediately\n    const fetchFirst = async () => {\n      const tick = await fetchRealData();\n      if (tick && mountedRef.current) {\n        processTick(tick);\n        setState(prev => ({ ...prev, connected: true, error: null }));\n      }\n    };\n    fetchFirst();\n    \n    // Continue polling for real data\n    const interval = mergedConfig.pollInterval || 1500;\n    pollIntervalRef.current = setInterval(async () => {\n      if (mountedRef.current) {\n        const tick = await fetchRealData();\n        if (tick) {\n          processTick(tick);\n        }\n      }\n    }, interval);\n    \n    isStartedRef.current = true;\n    console.log('[TickStream] Real data mode started with poll interval:', interval, 'ms');\n  }, [mergedConfig.symbol, mergedConfig.pollInterval, fetchRealData, processTick]);\n  \n  // Connect WebSocket (with real data fallback, not demo)\n  const connectWebSocket = useCallback(() => {\n    if (!mergedConfig.wsUrl) {\n      console.warn('[TickStream] No WebSocket URL provided, using real data polling');\n      startRealMode();\n      return;\n    }\n    \n    try {\n      wsRef.current = new WebSocket(mergedConfig.wsUrl);\n      \n      wsRef.current.onopen = () => {\n        console.log('[TickStream] WebSocket connected');\n        setState(prev => ({ ...prev, connected: true, error: null, dataQuality: 'real' }));\n        \n        // Subscribe to symbol\n        if (wsRef.current && mergedConfig.apiKey) {\n          wsRef.current.send(JSON.stringify({\n            type: 'subscribe',\n            symbol: mergedConfig.symbol,\n            apiKey: mergedConfig.apiKey\n          }));\n        }\n      };\n      \n      wsRef.current.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          if (data.price) {\n            processTick({\n              price: data.price,\n              volume: data.volume || 1000,\n              timestamp: data.timestamp || Date.now(),\n              bid: data.bid,\n              ask: data.ask,\n              source: 'websocket',\n              isReal: true\n            });\n          }\n        } catch (e) {\n          console.error('[TickStream] Parse error:', e);\n        }\n      };\n      \n      wsRef.current.onerror = (error) => {\n        console.error('[TickStream] WebSocket error, falling back to real data polling:', error);\n        setState(prev => ({ ...prev, error: 'WebSocket error, using real data polling' }));\n        startRealMode();\n      };\n      \n      wsRef.current.onclose = () => {\n        console.log('[TickStream] WebSocket closed');\n        if (mountedRef.current && !pollIntervalRef.current) {\n          // Fallback to real data polling (not demo)\n          startRealMode();\n        }\n      };\n    } catch (error) {\n      console.error('[TickStream] Failed to create WebSocket:', error);\n      startRealMode();\n    }\n  }, [mergedConfig.wsUrl, mergedConfig.symbol, mergedConfig.apiKey, processTick, startRealMode]);\n  \n  // Disconnect\n  const disconnect = useCallback(() => {\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current);\n      pollIntervalRef.current = null;\n    }\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    isStartedRef.current = false;\n    setState(prev => ({ ...prev, connected: false, dataQuality: 'disconnected' }));\n  }, []);\n  \n  // Reconnect\n  const reconnect = useCallback(() => {\n    disconnect();\n    setTimeout(() => {\n      if (mergedConfig.mode === 'websocket') {\n        connectWebSocket();\n      } else {\n        startRealMode();\n      }\n    }, 100);\n  }, [disconnect, mergedConfig.mode, connectWebSocket, startRealMode]);\n  \n  // Track TPS\n  useEffect(() => {\n    tpsIntervalRef.current = setInterval(() => {\n      if (mountedRef.current) {\n        setState(prev => ({\n          ...prev,\n          ticksPerSecond: tickCountRef.current\n        }));\n        tickCountRef.current = 0;\n      }\n    }, 1000);\n    \n    return () => {\n      if (tpsIntervalRef.current) {\n        clearInterval(tpsIntervalRef.current);\n      }\n    };\n  }, []);\n  \n  // Start stream on mount\n  useEffect(() => {\n    mountedRef.current = true;\n    \n    // Small delay to ensure component is fully mounted\n    const startTimer = setTimeout(() => {\n      if (mergedConfig.mode === 'websocket') {\n        connectWebSocket();\n      } else {\n        startRealMode(); // v7.51: Always real data, never demo\n      }\n    }, 50);\n    \n    return () => {\n      mountedRef.current = false;\n      clearTimeout(startTimer);\n      disconnect();\n    };\n  }, [mergedConfig.mode, connectWebSocket, startRealMode, disconnect]);\n  \n  return {\n    ...state,\n    addTickListener,\n    disconnect,\n    reconnect,\n    isRealData: state.dataQuality === 'real' && state.sources.length > 0\n  };\n}\n";export{e as default};
