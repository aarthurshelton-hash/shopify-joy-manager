const n="import { useState, useCallback, useRef, TouchEvent, MouseEvent } from 'react';\n\ninterface SwipeConfig {\n  threshold?: number; // Minimum distance to trigger swipe\n  allowMouse?: boolean; // Allow mouse drag on desktop\n  onSwipeLeft?: () => void;\n  onSwipeRight?: () => void;\n  onSwipeUp?: () => void;\n  onSwipeDown?: () => void;\n}\n\ninterface SwipeState {\n  startX: number;\n  startY: number;\n  currentX: number;\n  currentY: number;\n  isSwiping: boolean;\n}\n\nexport const useSwipeNavigation = (config: SwipeConfig = {}) => {\n  const {\n    threshold = 50,\n    allowMouse = true,\n    onSwipeLeft,\n    onSwipeRight,\n    onSwipeUp,\n    onSwipeDown,\n  } = config;\n\n  const [swipeOffset, setSwipeOffset] = useState({ x: 0, y: 0 });\n  const [isSwiping, setIsSwiping] = useState(false);\n  const stateRef = useRef<SwipeState>({\n    startX: 0,\n    startY: 0,\n    currentX: 0,\n    currentY: 0,\n    isSwiping: false,\n  });\n\n  const handleStart = useCallback((clientX: number, clientY: number) => {\n    stateRef.current = {\n      startX: clientX,\n      startY: clientY,\n      currentX: clientX,\n      currentY: clientY,\n      isSwiping: true,\n    };\n    setIsSwiping(true);\n  }, []);\n\n  const handleMove = useCallback((clientX: number, clientY: number) => {\n    if (!stateRef.current.isSwiping) return;\n\n    stateRef.current.currentX = clientX;\n    stateRef.current.currentY = clientY;\n\n    const deltaX = clientX - stateRef.current.startX;\n    const deltaY = clientY - stateRef.current.startY;\n\n    setSwipeOffset({ x: deltaX, y: deltaY });\n  }, []);\n\n  const handleEnd = useCallback(() => {\n    if (!stateRef.current.isSwiping) return;\n\n    const deltaX = stateRef.current.currentX - stateRef.current.startX;\n    const deltaY = stateRef.current.currentY - stateRef.current.startY;\n    const absX = Math.abs(deltaX);\n    const absY = Math.abs(deltaY);\n\n    // Determine if swipe was horizontal or vertical\n    if (absX > absY && absX > threshold) {\n      if (deltaX > 0) {\n        onSwipeRight?.();\n      } else {\n        onSwipeLeft?.();\n      }\n    } else if (absY > absX && absY > threshold) {\n      if (deltaY > 0) {\n        onSwipeDown?.();\n      } else {\n        onSwipeUp?.();\n      }\n    }\n\n    stateRef.current.isSwiping = false;\n    setIsSwiping(false);\n    setSwipeOffset({ x: 0, y: 0 });\n  }, [threshold, onSwipeLeft, onSwipeRight, onSwipeUp, onSwipeDown]);\n\n  // Touch handlers\n  const onTouchStart = useCallback((e: TouchEvent) => {\n    const touch = e.touches[0];\n    handleStart(touch.clientX, touch.clientY);\n  }, [handleStart]);\n\n  const onTouchMove = useCallback((e: TouchEvent) => {\n    const touch = e.touches[0];\n    handleMove(touch.clientX, touch.clientY);\n  }, [handleMove]);\n\n  const onTouchEnd = useCallback(() => {\n    handleEnd();\n  }, [handleEnd]);\n\n  // Mouse handlers (for desktop testing)\n  const onMouseDown = useCallback((e: MouseEvent) => {\n    if (!allowMouse) return;\n    handleStart(e.clientX, e.clientY);\n  }, [allowMouse, handleStart]);\n\n  const onMouseMove = useCallback((e: MouseEvent) => {\n    if (!allowMouse) return;\n    handleMove(e.clientX, e.clientY);\n  }, [allowMouse, handleMove]);\n\n  const onMouseUp = useCallback(() => {\n    if (!allowMouse) return;\n    handleEnd();\n  }, [allowMouse, handleEnd]);\n\n  const onMouseLeave = useCallback(() => {\n    if (!allowMouse) return;\n    if (stateRef.current.isSwiping) {\n      handleEnd();\n    }\n  }, [allowMouse, handleEnd]);\n\n  return {\n    swipeOffset,\n    isSwiping,\n    handlers: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n      onMouseDown,\n      onMouseMove,\n      onMouseUp,\n      onMouseLeave,\n    },\n  };\n};\n\nexport default useSwipeNavigation;\n";export{n as default};
