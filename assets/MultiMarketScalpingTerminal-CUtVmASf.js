const e='/**\n * Multi-Market Scalping Terminal with Real-Time Predictions\n * \n * Real world market data: Stocks, Bonds, Futures, Commodities, Crypto, Forex\n * Simulated $1000 capital that grows based on prediction accuracy\n * \n * CEO Testing Dashboard - Alec Arthur Shelton\n * Patent-Pending Technology\n */\n\nimport React, { useState, useEffect, useCallback, useRef, useMemo } from \'react\';\nimport { motion, AnimatePresence } from \'framer-motion\';\nimport { \n  TrendingUp, TrendingDown, Minus, Activity, Play, Pause, RotateCcw, \n  Zap, CheckCircle, XCircle, Target, Wifi, WifiOff, Globe, DollarSign,\n  BarChart3, Clock, Award, Flame, Percent, ChevronDown, ChevronUp, Brain\n} from \'lucide-react\';\nimport { Card, CardContent, CardHeader, CardTitle } from \'@/components/ui/card\';\nimport { Button } from \'@/components/ui/button\';\nimport { Badge } from \'@/components/ui/badge\';\nimport { Progress } from \'@/components/ui/progress\';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \'@/components/ui/tabs\';\nimport { cn } from \'@/lib/utils\';\nimport { supabase } from \'@/integrations/supabase/client\';\nimport { selfEvolvingSystem } from \'@/lib/pensent-core/domains/finance/selfEvolvingSystem\';\n\n// ============================================\n// TYPES\n// ============================================\n\ninterface MarketSymbol {\n  symbol: string;\n  name: string;\n  category: string;\n  is24h: boolean;\n}\n\ninterface QuoteData {\n  symbol: string;\n  name: string;\n  category: string;\n  price: number;\n  change: number;\n  changePercent: number;\n  is24h: boolean;\n  lastUpdated: number;\n}\n\ninterface Prediction {\n  id: string;\n  symbol: string;\n  category: string;\n  direction: \'up\' | \'down\' | \'flat\';\n  confidence: number;\n  priceAtPrediction: number;\n  timestamp: number;\n  expiresAt: number;\n  betAmount: number;\n  resolved?: boolean;\n  wasCorrect?: boolean;\n  actualPrice?: number;\n  actualDirection?: \'up\' | \'down\' | \'flat\';\n  pnl?: number;\n}\n\ninterface PortfolioState {\n  balance: number;\n  startingBalance: number;\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  totalPnL: number;\n  bestTrade: number;\n  worstTrade: number;\n  currentStreak: number;\n  bestStreak: number;\n  peakBalance: number;\n  troughBalance: number;\n}\n\n// ============================================\n// CONSTANTS\n// ============================================\n\nconst CATEGORIES = {\n  crypto: { name: \'Crypto\', icon: \'‚Çø\', color: \'text-orange-500\' },\n  stocks: { name: \'Stocks\', icon: \'üìà\', color: \'text-blue-500\' },\n  etfs: { name: \'ETFs\', icon: \'üìä\', color: \'text-purple-500\' },\n  futures: { name: \'Futures\', icon: \'üìâ\', color: \'text-cyan-500\' },\n  commodities: { name: \'Commodities\', icon: \'üõ¢Ô∏è\', color: \'text-amber-500\' },\n  bonds: { name: \'Bonds\', icon: \'üè¶\', color: \'text-green-500\' },\n  forex: { name: \'Forex\', icon: \'üí±\', color: \'text-pink-500\' },\n};\n\nconst STARTING_BALANCE = 1000;\nconst PREDICTION_INTERVAL = 15000; // 15 seconds between predictions (more realistic)\nconst POSITION_SIZE = 100; // Fixed $100 position size per trade\nconst PROFIT_TARGET_PERCENT = 0.5; // 0.5% profit target\nconst STOP_LOSS_PERCENT = 0.3; // 0.3% stop loss\n\n// ============================================\n// PREDICTION ENGINE\n// ============================================\n\ninterface PriceHistory {\n  price: number;\n  timestamp: number;\n}\n\nconst priceHistories: Record<string, PriceHistory[]> = {};\n\nfunction updatePriceHistory(symbol: string, price: number) {\n  if (!priceHistories[symbol]) {\n    priceHistories[symbol] = [];\n  }\n  priceHistories[symbol].push({ price, timestamp: Date.now() });\n  // Keep last 100 prices\n  if (priceHistories[symbol].length > 100) {\n    priceHistories[symbol] = priceHistories[symbol].slice(-100);\n  }\n}\n\nfunction predictDirection(symbol: string): { direction: \'up\' | \'down\' | \'flat\'; confidence: number } {\n  const history = priceHistories[symbol] || [];\n  \n  if (history.length < 5) {\n    return { direction: Math.random() > 0.5 ? \'up\' : \'down\', confidence: 52 };\n  }\n  \n  const recent = history.slice(-20);\n  const prices = recent.map(h => h.price);\n  \n  // Calculate momentum\n  const shortMA = prices.slice(-5).reduce((a, b) => a + b, 0) / 5;\n  const longMA = prices.slice(-15).reduce((a, b) => a + b, 0) / Math.min(15, prices.length);\n  \n  // Calculate trend strength\n  const priceChanges = prices.slice(1).map((p, i) => (p - prices[i]) / prices[i]);\n  const avgChange = priceChanges.reduce((a, b) => a + b, 0) / priceChanges.length;\n  \n  // Volatility\n  const variance = priceChanges.reduce((sum, c) => sum + Math.pow(c - avgChange, 2), 0) / priceChanges.length;\n  const volatility = Math.sqrt(variance);\n  \n  // RSI-like calculation\n  const gains = priceChanges.filter(c => c > 0).reduce((a, b) => a + b, 0);\n  const losses = Math.abs(priceChanges.filter(c => c < 0).reduce((a, b) => a + b, 0));\n  const rs = losses === 0 ? 100 : gains / losses;\n  const rsi = 100 - (100 / (1 + rs));\n  \n  // Combined signal\n  let signal = 0;\n  signal += (shortMA > longMA ? 1 : -1) * 0.4;\n  signal += avgChange * 5000;\n  signal += (rsi > 60 ? -0.3 : rsi < 40 ? 0.3 : 0); // Mean reversion component\n  \n  let direction: \'up\' | \'down\' | \'flat\';\n  if (signal > 0.15) direction = \'up\';\n  else if (signal < -0.15) direction = \'down\';\n  else direction = Math.random() > 0.5 ? \'up\' : \'down\';\n  \n  // Confidence based on signal clarity and volatility\n  const signalStrength = Math.min(Math.abs(signal) * 25, 30);\n  const volatilityFactor = volatility < 0.01 ? 1.1 : volatility > 0.03 ? 0.85 : 1;\n  const confidence = Math.min(88, Math.max(52, 55 + signalStrength) * volatilityFactor);\n  \n  return { direction, confidence: Math.round(confidence) };\n}\n\nfunction resolveDirection(priceChange: number, symbol: string): \'up\' | \'down\' | \'flat\' {\n  // Threshold varies by asset class volatility\n  const threshold = symbol.includes(\'BTC\') || symbol.includes(\'ETH\') ? 0.0003 : 0.0001;\n  if (priceChange > threshold) return \'up\';\n  if (priceChange < -threshold) return \'down\';\n  return \'flat\';\n}\n\n// ============================================\n// DIRECTION ICON\n// ============================================\n\nconst DirectionIcon: React.FC<{ direction: \'up\' | \'down\' | \'flat\'; size?: number }> = ({ direction, size = 16 }) => {\n  if (direction === \'up\') return <TrendingUp size={size} className="text-green-500" />;\n  if (direction === \'down\') return <TrendingDown size={size} className="text-red-500" />;\n  return <Minus size={size} className="text-muted-foreground" />;\n};\n\n// ============================================\n// MAIN COMPONENT\n// ============================================\n\nconst MultiMarketScalpingTerminal: React.FC = () => {\n  // Core state\n  const [isRunning, setIsRunning] = useState(true);\n  const [activeCategory, setActiveCategory] = useState(\'crypto\');\n  const [availableSymbols, setAvailableSymbols] = useState<MarketSymbol[]>([]);\n  const [quotes, setQuotes] = useState<Record<string, QuoteData>>({});\n  const [predictions, setPredictions] = useState<Prediction[]>([]);\n  const [isLive, setIsLive] = useState(false);\n  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);\n  const [expandedCategory, setExpandedCategory] = useState<string | null>(\'crypto\');\n  const [selectedSymbol, setSelectedSymbol] = useState<MarketSymbol | null>(null);\n  const [customBetAmount, setCustomBetAmount] = useState<number>(20); // $20 default bet\n  const [isLoadingPortfolio, setIsLoadingPortfolio] = useState(true);\n  \n  // Portfolio state - synced from database, starts as null until loaded\n  const [portfolio, setPortfolio] = useState<PortfolioState | null>(null);\n  \n  // Default portfolio for initial render only\n  const currentPortfolio: PortfolioState = portfolio ?? {\n    balance: STARTING_BALANCE,\n    startingBalance: STARTING_BALANCE,\n    totalTrades: 0,\n    winningTrades: 0,\n    losingTrades: 0,\n    totalPnL: 0,\n    bestTrade: 0,\n    worstTrade: 0,\n    currentStreak: 0,\n    bestStreak: 0,\n    peakBalance: STARTING_BALANCE,\n    troughBalance: STARTING_BALANCE,\n  };\n  \n  // Evolution state from selfEvolvingSystem\n  const [evolutionSummary, setEvolutionSummary] = useState(selfEvolvingSystem.getEvolutionSummary());\n  \n  // Refs\n  const mountedRef = useRef(true);\n  const fetchIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const predictionIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Load portfolio from database on mount\n  useEffect(() => {\n    const loadPortfolioFromDB = async () => {\n      try {\n        // Load portfolio balance\n        const { data: portfolioData, error: portfolioError } = await supabase\n          .from(\'portfolio_balance\')\n          .select(\'*\')\n          .order(\'updated_at\', { ascending: false })\n          .limit(1)\n          .single();\n        \n        if (portfolioError && portfolioError.code !== \'PGRST116\') {\n          console.error(\'Failed to load portfolio:\', portfolioError);\n        }\n        \n        // Load trade history for stats\n        const { data: tradesData, error: tradesError } = await supabase\n          .from(\'autonomous_trades\')\n          .select(\'*\')\n          .order(\'created_at\', { ascending: false })\n          .limit(100);\n        \n        if (tradesError) {\n          console.error(\'Failed to load trades:\', tradesError);\n        }\n        \n        // Load evolution state from database\n        const { data: evolutionData, error: evolutionError } = await supabase\n          .from(\'evolution_state\')\n          .select(\'*\')\n          .eq(\'state_type\', \'global\')\n          .order(\'updated_at\', { ascending: false })\n          .limit(1)\n          .single();\n        \n        if (evolutionError && evolutionError.code !== \'PGRST116\') {\n          console.error(\'Failed to load evolution state:\', evolutionError);\n        }\n        \n        // Calculate stats from trades\n        const closedTrades = tradesData?.filter(t => t.status === \'closed\') || [];\n        const winningTrades = closedTrades.filter(t => (t.pnl || 0) > 0).length;\n        const losingTrades = closedTrades.filter(t => (t.pnl || 0) <= 0).length;\n        const totalPnL = closedTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);\n        const bestTrade = closedTrades.reduce((max, t) => Math.max(max, t.pnl || 0), 0);\n        const worstTrade = closedTrades.reduce((min, t) => Math.min(min, t.pnl || 0), 0);\n        \n        // Update portfolio with real data from database\n        // CRITICAL: Always load from DB - this is the source of truth\n        const dbBalance = portfolioData?.balance ?? STARTING_BALANCE;\n        const dbPeakBalance = portfolioData?.peak_balance ?? dbBalance;\n        const dbTroughBalance = portfolioData?.trough_balance ?? dbBalance;\n        \n        console.log(`[Portfolio] Loaded from DB: $${dbBalance.toFixed(2)} (peak: $${dbPeakBalance.toFixed(2)})`);\n        \n        setPortfolio({\n          balance: dbBalance,\n          startingBalance: STARTING_BALANCE,\n          totalTrades: portfolioData?.total_trades || closedTrades.length,\n          winningTrades: portfolioData?.winning_trades || winningTrades,\n          losingTrades: losingTrades,\n          totalPnL: dbBalance - STARTING_BALANCE,\n          bestTrade: bestTrade,\n          worstTrade: worstTrade,\n          currentStreak: 0,\n          bestStreak: 0,\n          peakBalance: dbPeakBalance,\n          troughBalance: dbTroughBalance,\n        });\n        \n        // Update evolution state if available\n        if (evolutionData) {\n          const genes = evolutionData.genes as Record<string, number>;\n          setEvolutionSummary({\n            generation: evolutionData.generation || 0,\n            fitness: evolutionData.fitness_score || 0,\n            velocity: 0,\n            topGenes: Object.entries(genes || {})\n              .sort((a, b) => (b[1] as number) - (a[1] as number))\n              .slice(0, 5)\n              .map(([name, value]) => ({ name, value: value as number, impact: (value as number) * 0.1 })),\n            patternCount: (evolutionData.learned_patterns as Array<unknown> || []).length,\n            bestPatternAccuracy: evolutionData.fitness_score || 0,\n            anomalyHarvest: { totalAnomalies: 0, topPatterns: [], recentInsights: [] }\n          });\n        }\n        \n      } catch (err) {\n        console.error(\'Error loading portfolio from database:\', err);\n      } finally {\n        setIsLoadingPortfolio(false);\n      }\n    };\n    \n    loadPortfolioFromDB();\n    \n    // Subscribe to real-time updates for evolution and portfolio\n    const evolutionChannel = supabase\n      .channel(\'evolution-updates\')\n      .on(\n        \'postgres_changes\',\n        { event: \'*\', schema: \'public\', table: \'evolution_state\' },\n        (payload) => {\n          const data = payload.new as { \n            generation?: number; \n            fitness_score?: number; \n            genes?: Record<string, number>;\n            total_predictions?: number;\n            learned_patterns?: unknown[];\n          };\n          if (data && data.generation) {\n            setEvolutionSummary({\n              generation: data.generation || 0,\n              fitness: data.fitness_score || 0,\n              velocity: 0,\n              topGenes: Object.entries(data.genes || {})\n                .sort((a, b) => (b[1] as number) - (a[1] as number))\n                .slice(0, 5)\n                .map(([name, value]) => ({ name, value: value as number, impact: (value as number) * 0.1 })),\n              patternCount: (data.learned_patterns as Array<unknown> || []).length,\n              bestPatternAccuracy: data.fitness_score || 0,\n              anomalyHarvest: { totalAnomalies: 0, topPatterns: [], recentInsights: [] }\n            });\n          }\n        }\n      )\n      .on(\n        \'postgres_changes\',\n        { event: \'*\', schema: \'public\', table: \'portfolio_balance\' },\n        (payload) => {\n          const data = payload.new as {\n            balance?: number;\n            peak_balance?: number;\n            trough_balance?: number;\n            total_trades?: number;\n            winning_trades?: number;\n          };\n          if (data && data.balance !== undefined) {\n            setPortfolio(prev => ({\n              ...prev,\n              balance: data.balance || prev.balance,\n              peakBalance: data.peak_balance || prev.peakBalance,\n              troughBalance: data.trough_balance || prev.troughBalance,\n              totalTrades: data.total_trades || prev.totalTrades,\n              winningTrades: data.winning_trades || prev.winningTrades,\n            }));\n          }\n        }\n      )\n      .subscribe();\n    \n    return () => {\n      supabase.removeChannel(evolutionChannel);\n    };\n  }, []);\n  \n  // Sync portfolio changes to database\n  const syncPortfolioToDB = useCallback(async (newPortfolio: PortfolioState) => {\n    try {\n      await supabase\n        .from(\'portfolio_balance\')\n        .upsert({\n          id: \'a72170ff-70ad-4da2-b54d-dd2c315a2fa6\', // Use existing ID\n          balance: newPortfolio.balance,\n          peak_balance: newPortfolio.peakBalance,\n          trough_balance: newPortfolio.troughBalance,\n          total_trades: newPortfolio.totalTrades,\n          winning_trades: newPortfolio.winningTrades,\n          target_balance: 10000,\n          updated_at: new Date().toISOString()\n        }, { onConflict: \'id\' });\n    } catch (err) {\n      console.error(\'Failed to sync portfolio to DB:\', err);\n    }\n  }, []);\n  \n  // Computed values - use currentPortfolio for null-safety\n  const growthPercent = useMemo(() => \n    ((currentPortfolio.balance - currentPortfolio.startingBalance) / currentPortfolio.startingBalance) * 100,\n    [currentPortfolio.balance, currentPortfolio.startingBalance]\n  );\n  \n  const winRate = useMemo(() => \n    currentPortfolio.totalTrades > 0 ? (currentPortfolio.winningTrades / currentPortfolio.totalTrades) * 100 : 0,\n    [currentPortfolio.winningTrades, currentPortfolio.totalTrades]\n  );\n  \n  const pendingPredictions = useMemo(() => \n    predictions.filter(p => !p.resolved).slice(-10),\n    [predictions]\n  );\n  \n  const recentResolved = useMemo(() => \n    predictions.filter(p => p.resolved).slice(-15).reverse(),\n    [predictions]\n  );\n  \n  // Category stats\n  const categoryStats = useMemo(() => {\n    const stats: Record<string, { total: number; correct: number; pnl: number }> = {};\n    \n    for (const pred of predictions.filter(p => p.resolved)) {\n      if (!stats[pred.category]) {\n        stats[pred.category] = { total: 0, correct: 0, pnl: 0 };\n      }\n      stats[pred.category].total++;\n      if (pred.wasCorrect) stats[pred.category].correct++;\n      stats[pred.category].pnl += pred.pnl || 0;\n    }\n    \n    return stats;\n  }, [predictions]);\n  \n  // Symbol-specific stats\n  const symbolStats = useMemo(() => {\n    const stats: Record<string, { total: number; correct: number; pnl: number; history: Prediction[] }> = {};\n    \n    for (const pred of predictions.filter(p => p.resolved)) {\n      if (!stats[pred.symbol]) {\n        stats[pred.symbol] = { total: 0, correct: 0, pnl: 0, history: [] };\n      }\n      stats[pred.symbol].total++;\n      if (pred.wasCorrect) stats[pred.symbol].correct++;\n      stats[pred.symbol].pnl += pred.pnl || 0;\n      stats[pred.symbol].history.push(pred);\n    }\n    \n    return stats;\n  }, [predictions]);\n  \n  // Manual trade on selected symbol\n  const executeManualTrade = useCallback((direction: \'up\' | \'down\') => {\n    if (!selectedSymbol || currentPortfolio.balance <= 0 || customBetAmount <= 0) return;\n    \n    const quote = quotes[selectedSymbol.symbol];\n    if (!quote) return;\n    \n    const betAmount = Math.min(customBetAmount, currentPortfolio.balance);\n    const { confidence } = predictDirection(selectedSymbol.symbol);\n    \n    const prediction: Prediction = {\n      id: `manual-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,\n      symbol: selectedSymbol.symbol,\n      category: selectedSymbol.category,\n      direction,\n      confidence,\n      priceAtPrediction: quote.price,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + PREDICTION_INTERVAL,\n      betAmount,\n    };\n    \n    setPredictions(prev => [...prev, prediction].slice(-200));\n  }, [selectedSymbol, quotes, currentPortfolio.balance, customBetAmount]);\n\n  // Fetch available symbols\n  useEffect(() => {\n    const fetchSymbols = async () => {\n      try {\n        const { data, error } = await supabase.functions.invoke(\'stock-data\', {\n          body: { action: \'list\' }\n        });\n        \n        if (error) throw error;\n        if (data?.symbols) {\n          setAvailableSymbols(data.symbols);\n        }\n      } catch (err) {\n        console.error(\'Failed to fetch symbols:\', err);\n      }\n    };\n    \n    fetchSymbols();\n  }, []);\n  \n  // Fetch market data\n  const fetchMarketData = useCallback(async () => {\n    if (!mountedRef.current) return;\n    \n    try {\n      // Get symbols for current category plus all 24/7 markets\n      const categorySymbols = availableSymbols.filter(s => s.category === activeCategory);\n      const allSymbols = [...new Set([\n        ...categorySymbols.map(s => s.symbol),\n        ...availableSymbols.filter(s => s.is24h).slice(0, 10).map(s => s.symbol)\n      ])];\n      \n      if (allSymbols.length === 0) return;\n      \n      const { data, error } = await supabase.functions.invoke(\'stock-data\', {\n        body: { action: \'batch\', symbols: allSymbols }\n      });\n      \n      if (error) throw error;\n      \n      if (data?.quotes) {\n        const newQuotes: Record<string, QuoteData> = {};\n        for (const quote of data.quotes) {\n          newQuotes[quote.symbol] = quote;\n          updatePriceHistory(quote.symbol, quote.price);\n        }\n        setQuotes(prev => ({ ...prev, ...newQuotes }));\n        setIsLive(true);\n        setLastUpdate(new Date());\n      }\n    } catch (err) {\n      console.error(\'Failed to fetch market data:\', err);\n      setIsLive(false);\n    }\n  }, [availableSymbols, activeCategory]);\n  \n  // Generate prediction\n  const generatePrediction = useCallback(() => {\n    if (!mountedRef.current || currentPortfolio.balance <= 0) return;\n    \n    // Select a random symbol from 24/7 markets for continuous predictions\n    const tradableSymbols = availableSymbols.filter(s => s.is24h && quotes[s.symbol]);\n    if (tradableSymbols.length === 0) return;\n    \n    const randomSymbol = tradableSymbols[Math.floor(Math.random() * tradableSymbols.length)];\n    const quote = quotes[randomSymbol.symbol];\n    if (!quote) return;\n    \n    const { direction, confidence } = predictDirection(randomSymbol.symbol);\n    const betAmount = Math.min(POSITION_SIZE, currentPortfolio.balance);\n    \n    const prediction: Prediction = {\n      id: `pred-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,\n      symbol: randomSymbol.symbol,\n      category: randomSymbol.category,\n      direction,\n      confidence,\n      priceAtPrediction: quote.price,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + PREDICTION_INTERVAL,\n      betAmount,\n    };\n    \n    setPredictions(prev => [...prev, prediction].slice(-200));\n  }, [availableSymbols, quotes, currentPortfolio.balance]);\n  \n  // Resolve predictions\n  const resolvePredictions = useCallback(() => {\n    if (!mountedRef.current || !portfolio) return;\n    \n    const now = Date.now();\n    const portfolioUpdates = { ...currentPortfolio };\n    let hasUpdates = false;\n    \n    setPredictions(prev => prev.map(pred => {\n      if (pred.resolved || pred.expiresAt > now) return pred;\n      \n      const currentQuote = quotes[pred.symbol];\n      if (!currentQuote) return pred;\n      \n      hasUpdates = true;\n      const priceChange = (currentQuote.price - pred.priceAtPrediction) / pred.priceAtPrediction;\n      const actualDirection = resolveDirection(priceChange, pred.symbol);\n      \n      // Determine if prediction was correct\n      const wasCorrect = pred.direction === actualDirection || \n        (pred.direction === \'flat\' && Math.abs(priceChange) < 0.0002);\n      \n      // ========================================\n      // FEED OUTCOME TO SELF-EVOLVING SYSTEM\n      // ========================================\n      const mapDirection = (dir: \'up\' | \'down\' | \'flat\'): \'up\' | \'down\' | \'neutral\' => \n        dir === \'flat\' ? \'neutral\' : dir;\n      \n      selfEvolvingSystem.processOutcome({\n        predicted: mapDirection(pred.direction),\n        actual: mapDirection(actualDirection),\n        confidence: pred.confidence / 100,\n        marketConditions: {\n          correlationStrength: Math.abs(priceChange) * 100,\n          volatility: Math.abs(priceChange),\n          momentum: priceChange > 0 ? 1 : priceChange < 0 ? -1 : 0,\n          leadingSignals: pred.confidence / 100\n        }\n      });\n      \n      setEvolutionSummary(selfEvolvingSystem.getEvolutionSummary());\n      \n      if (pred.category) {\n        selfEvolvingSystem.updateCorrelationMemory(pred.symbol, pred.category, priceChange);\n      }\n      \n      // Calculate P&L based on actual price movement (realistic paper trading)\n      const priceMovePct = Math.abs(priceChange) * 100;\n      let pnl = 0;\n      \n      if (wasCorrect) {\n        // Win: earn based on price movement, capped at profit target\n        pnl = pred.betAmount * Math.min(priceMovePct, PROFIT_TARGET_PERCENT) / 100;\n        pnl = Math.max(pnl, pred.betAmount * 0.001); // Minimum $0.10 on $100\n        portfolioUpdates.balance += pnl;\n        portfolioUpdates.winningTrades++;\n        portfolioUpdates.currentStreak++;\n        portfolioUpdates.bestStreak = Math.max(portfolioUpdates.bestStreak, portfolioUpdates.currentStreak);\n        portfolioUpdates.bestTrade = Math.max(portfolioUpdates.bestTrade, pnl);\n      } else {\n        // Lose: lose based on price movement, capped at stop loss\n        pnl = -pred.betAmount * Math.min(priceMovePct, STOP_LOSS_PERCENT) / 100;\n        pnl = Math.min(pnl, -pred.betAmount * 0.001); // Minimum -$0.10 on $100\n        portfolioUpdates.balance += pnl;\n        portfolioUpdates.losingTrades++;\n        portfolioUpdates.currentStreak = 0;\n        portfolioUpdates.worstTrade = Math.min(portfolioUpdates.worstTrade, pnl);\n      }\n      \n      portfolioUpdates.totalTrades++;\n      portfolioUpdates.totalPnL = portfolioUpdates.balance - STARTING_BALANCE;\n      portfolioUpdates.peakBalance = Math.max(portfolioUpdates.peakBalance, portfolioUpdates.balance);\n      portfolioUpdates.troughBalance = Math.min(portfolioUpdates.troughBalance, portfolioUpdates.balance);\n      \n      console.log(`[Trade] ${pred.symbol} ${wasCorrect ? \'‚úì\' : \'‚úó\'} | P&L: $${pnl.toFixed(2)} | Balance: $${portfolioUpdates.balance.toFixed(2)}`);\n      \n      return {\n        ...pred,\n        resolved: true,\n        wasCorrect,\n        actualPrice: currentQuote.price,\n        actualDirection,\n        pnl,\n      };\n    }));\n    \n    if (hasUpdates) {\n      setPortfolio(portfolioUpdates);\n      syncPortfolioToDB(portfolioUpdates);\n    }\n  }, [quotes, portfolio, currentPortfolio, syncPortfolioToDB]);\n  \n  // Main effect - data fetching and prediction loop\n  useEffect(() => {\n    mountedRef.current = true;\n    \n    if (isRunning && availableSymbols.length > 0) {\n      fetchMarketData();\n      \n      fetchIntervalRef.current = setInterval(() => {\n        if (mountedRef.current) {\n          fetchMarketData();\n          resolvePredictions();\n        }\n      }, 2000);\n      \n      predictionIntervalRef.current = setInterval(() => {\n        if (mountedRef.current) {\n          generatePrediction();\n        }\n      }, PREDICTION_INTERVAL);\n    }\n    \n    return () => {\n      mountedRef.current = false;\n      if (fetchIntervalRef.current) clearInterval(fetchIntervalRef.current);\n      if (predictionIntervalRef.current) clearInterval(predictionIntervalRef.current);\n    };\n  }, [isRunning, availableSymbols.length, activeCategory]);\n  \n  // Clear predictions only - never reset the balance!\n  const handleClearPredictions = useCallback(() => {\n    setPredictions([]);\n    // Clear price histories to get fresh analysis\n    for (const key in priceHistories) {\n      delete priceHistories[key];\n    }\n  }, []);\n  \n  // Format helpers\n  const formatPrice = (price: number, symbol: string) => {\n    if (symbol.includes(\'JPY\') || symbol.includes(\'=X\')) {\n      return price.toFixed(4);\n    }\n    if (symbol.includes(\'BTC\')) {\n      return `$${price.toLocaleString(undefined, { maximumFractionDigits: 2 })}`;\n    }\n    if (price < 1) return `$${price.toFixed(4)}`;\n    return `$${price.toFixed(2)}`;\n  };\n  \n  const formatMoney = (amount: number) => {\n    const sign = amount >= 0 ? \'+\' : \'\';\n    return `${sign}$${Math.abs(amount).toFixed(2)}`;\n  };\n\n  return (\n    <div className="space-y-4 p-4">\n      {/* Header */}\n      <div className="flex items-center justify-between flex-wrap gap-4">\n        <div className="flex items-center gap-3">\n          <Activity className="w-8 h-8 text-primary" />\n          <div>\n            <h1 className="text-2xl font-bold">Paper Trading Terminal</h1>\n            <p className="text-sm text-muted-foreground">\n              $1000 ‚Üí $10,000 Challenge ‚Ä¢ Real Market Data ‚Ä¢ En Pensent AI Predictions\n            </p>\n          </div>\n          <Badge variant={isLive ? "default" : "destructive"} className="ml-2">\n            {isLive ? <Wifi className="w-3 h-3 mr-1" /> : <WifiOff className="w-3 h-3 mr-1" />}\n            {isLive ? \'LIVE\' : \'OFFLINE\'}\n          </Badge>\n        </div>\n        \n        <div className="flex items-center gap-2">\n          <Button \n            variant={isRunning ? "destructive" : "default"}\n            size="sm"\n            onClick={() => setIsRunning(!isRunning)}\n          >\n            {isRunning ? <Pause className="w-4 h-4 mr-1" /> : <Play className="w-4 h-4 mr-1" />}\n            {isRunning ? \'Pause\' : \'Start\'}\n          </Button>\n          <Button variant="outline" size="sm" onClick={handleClearPredictions}>\n            <RotateCcw className="w-4 h-4 mr-1" />\n            Clear History\n          </Button>\n        </div>\n      </div>\n      \n      {/* Portfolio Overview */}\n      <Card className="bg-gradient-to-br from-card via-card to-primary/5 border-primary/20">\n        <CardContent className="pt-6">\n          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">\n            {/* Balance */}\n            <div className="col-span-2">\n              <div className="text-sm text-muted-foreground mb-1 flex items-center gap-2">\n                <DollarSign className="w-4 h-4" />\n                Paper Trading Balance\n              </div>\n              <div className="text-4xl font-mono font-bold">\n                ${currentPortfolio.balance.toFixed(2)}\n              </div>\n              <div className={cn(\n                "text-lg font-semibold flex items-center gap-1",\n                growthPercent >= 0 ? "text-green-500" : "text-red-500"\n              )}>\n                {growthPercent >= 0 ? <TrendingUp className="w-4 h-4" /> : <TrendingDown className="w-4 h-4" />}\n                {growthPercent >= 0 ? \'+\' : \'\'}{growthPercent.toFixed(2)}%\n                <span className="text-sm text-muted-foreground ml-1">\n                  ({formatMoney(currentPortfolio.totalPnL)})\n                </span>\n              </div>\n            </div>\n            \n            {/* Win Rate */}\n            <div>\n              <div className="text-sm text-muted-foreground mb-1 flex items-center gap-1">\n                <Target className="w-3 h-3" />\n                Win Rate\n              </div>\n              <div className={cn(\n                "text-2xl font-bold",\n                winRate >= 55 ? "text-green-500" : winRate >= 45 ? "text-yellow-500" : "text-red-500"\n              )}>\n                {winRate.toFixed(1)}%\n              </div>\n              <div className="text-xs text-muted-foreground">\n                {currentPortfolio.winningTrades}W / {currentPortfolio.losingTrades}L\n              </div>\n            </div>\n            \n            {/* Total Trades */}\n            <div>\n              <div className="text-sm text-muted-foreground mb-1 flex items-center gap-1">\n                <BarChart3 className="w-3 h-3" />\n                Trades\n              </div>\n              <div className="text-2xl font-bold text-primary">\n                {currentPortfolio.totalTrades}\n              </div>\n              <div className="text-xs text-muted-foreground">\n                2% per trade\n              </div>\n            </div>\n            \n            {/* Streak */}\n            <div>\n              <div className="text-sm text-muted-foreground mb-1 flex items-center gap-1">\n                <Flame className="w-3 h-3" />\n                Streak\n              </div>\n              <div className="text-2xl font-bold text-orange-500">\n                {currentPortfolio.currentStreak}\n              </div>\n              <div className="text-xs text-muted-foreground">\n                Best: {currentPortfolio.bestStreak}\n              </div>\n            </div>\n            \n            {/* Peak/Trough */}\n            <div>\n              <div className="text-sm text-muted-foreground mb-1">\n                Peak / Trough\n              </div>\n              <div className="text-lg font-semibold text-green-500">\n                ${currentPortfolio.peakBalance.toFixed(0)}\n              </div>\n              <div className="text-sm font-medium text-red-500">\n                ${currentPortfolio.troughBalance.toFixed(0)}\n              </div>\n            </div>\n          </div>\n          \n          {/* Growth Progress Bar - Target $10,000 */}\n          <div className="mt-4">\n            <div className="flex justify-between text-xs text-muted-foreground mb-1">\n              <span>Starting: $1,000</span>\n              <span>Target: $10,000 (900% growth)</span>\n            </div>\n            <Progress \n              value={Math.min(100, Math.max(0, (currentPortfolio.balance / 10000) * 100))} \n              className="h-2"\n            />\n          </div>\n        </CardContent>\n      </Card>\n      \n      {/* Self-Evolving AI Status */}\n      <Card className="border-cyan-500/30 bg-gradient-to-r from-cyan-950/20 to-purple-950/20">\n        <CardHeader className="pb-2">\n          <CardTitle className="text-sm flex items-center gap-2">\n            <Brain className="w-4 h-4 text-cyan-400" />\n            En Pensent Self-Evolving AI\n            <Badge variant="outline" className="ml-auto text-xs">\n              Gen {evolutionSummary.generation}\n            </Badge>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-sm">\n            <div>\n              <div className="text-xs text-muted-foreground">Fitness</div>\n              <div className="text-lg font-bold text-cyan-400">\n                {(evolutionSummary.fitness * 100).toFixed(1)}%\n              </div>\n            </div>\n            <div>\n              <div className="text-xs text-muted-foreground">Learning Velocity</div>\n              <div className={cn(\n                "text-lg font-bold",\n                evolutionSummary.velocity > 0 ? "text-green-400" : "text-red-400"\n              )}>\n                {evolutionSummary.velocity > 0 ? \'+\' : \'\'}{(evolutionSummary.velocity * 100).toFixed(2)}\n              </div>\n            </div>\n            <div>\n              <div className="text-xs text-muted-foreground">Learned Patterns</div>\n              <div className="text-lg font-bold text-purple-400">\n                {evolutionSummary.patternCount}\n              </div>\n            </div>\n            <div>\n              <div className="text-xs text-muted-foreground">Best Pattern Accuracy</div>\n              <div className="text-lg font-bold text-amber-400">\n                {(evolutionSummary.bestPatternAccuracy * 100).toFixed(1)}%\n              </div>\n            </div>\n            <div>\n              <div className="text-xs text-muted-foreground">Top Gene</div>\n              {evolutionSummary.topGenes[0] && (\n                <div className="text-sm font-medium text-muted-foreground">\n                  {evolutionSummary.topGenes[0].name}: {evolutionSummary.topGenes[0].value.toFixed(2)}\n                </div>\n              )}\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n      \n      {/* Category Tabs */}\n      <Tabs value={activeCategory} onValueChange={setActiveCategory}>\n        <TabsList className="grid grid-cols-7 w-full">\n          {Object.entries(CATEGORIES).map(([key, cat]) => (\n            <TabsTrigger key={key} value={key} className="text-xs">\n              <span className="mr-1">{cat.icon}</span>\n              {cat.name}\n            </TabsTrigger>\n          ))}\n        </TabsList>\n        \n        {Object.keys(CATEGORIES).map(category => (\n          <TabsContent key={category} value={category} className="mt-4">\n            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">\n              {availableSymbols\n                .filter(s => s.category === category)\n                .map(symbol => {\n                  const quote = quotes[symbol.symbol];\n                  const stats = symbolStats[symbol.symbol];\n                  const isSelected = selectedSymbol?.symbol === symbol.symbol;\n                  const accuracy = stats && stats.total > 0 ? (stats.correct / stats.total) * 100 : null;\n                  \n                  return (\n                    <Card \n                      key={symbol.symbol} \n                      className={cn(\n                        "bg-card/50 cursor-pointer transition-all hover:scale-[1.02] hover:border-primary/50",\n                        isSelected && "ring-2 ring-primary border-primary"\n                      )}\n                      onClick={() => setSelectedSymbol(isSelected ? null : symbol)}\n                    >\n                      <CardContent className="pt-4">\n                        <div className="flex items-center justify-between mb-2">\n                          <span className="font-mono font-medium text-sm">{symbol.symbol}</span>\n                          {symbol.is24h && (\n                            <Badge variant="outline" className="text-xs">\n                              <Globe className="w-2 h-2 mr-1" />\n                              24/7\n                            </Badge>\n                          )}\n                        </div>\n                        <div className="text-lg font-bold">\n                          {quote ? formatPrice(quote.price, symbol.symbol) : \'‚Äî\'}\n                        </div>\n                        {quote && (\n                          <div className={cn(\n                            "text-xs",\n                            quote.changePercent >= 0 ? "text-green-500" : "text-red-500"\n                          )}>\n                            {quote.changePercent >= 0 ? \'+\' : \'\'}{quote.changePercent.toFixed(2)}%\n                          </div>\n                        )}\n                        <div className="text-xs text-muted-foreground truncate mt-1">\n                          {symbol.name}\n                        </div>\n                        {/* Show accuracy if we have trades */}\n                        {accuracy !== null && (\n                          <div className={cn(\n                            "text-xs font-semibold mt-2 pt-2 border-t border-border/50",\n                            accuracy >= 55 ? "text-green-500" : accuracy >= 45 ? "text-yellow-500" : "text-red-500"\n                          )}>\n                            {accuracy.toFixed(0)}% accuracy ‚Ä¢ {stats.total} trades\n                          </div>\n                        )}\n                      </CardContent>\n                    </Card>\n                  );\n                })}\n            </div>\n          </TabsContent>\n        ))}\n      </Tabs>\n      \n      {/* Selected Symbol Trading Panel */}\n      <AnimatePresence>\n        {selectedSymbol && quotes[selectedSymbol.symbol] && (\n          <motion.div\n            initial={{ opacity: 0, height: 0 }}\n            animate={{ opacity: 1, height: \'auto\' }}\n            exit={{ opacity: 0, height: 0 }}\n          >\n            <Card className="border-primary/50 bg-gradient-to-br from-primary/5 to-card">\n              <CardHeader className="pb-3">\n                <div className="flex items-center justify-between">\n                  <CardTitle className="flex items-center gap-3">\n                    <Zap className="w-5 h-5 text-primary" />\n                    Trade {selectedSymbol.symbol}\n                    <Badge>{selectedSymbol.name}</Badge>\n                  </CardTitle>\n                  <Button variant="ghost" size="sm" onClick={() => setSelectedSymbol(null)}>\n                    ‚úï\n                  </Button>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">\n                  {/* Live Price & Prediction */}\n                  <div className="space-y-4">\n                    <div>\n                      <div className="text-sm text-muted-foreground mb-1">Live Price</div>\n                      <div className="text-3xl font-mono font-bold">\n                        {formatPrice(quotes[selectedSymbol.symbol].price, selectedSymbol.symbol)}\n                      </div>\n                      <div className={cn(\n                        "text-sm font-medium",\n                        quotes[selectedSymbol.symbol].changePercent >= 0 ? "text-green-500" : "text-red-500"\n                      )}>\n                        {quotes[selectedSymbol.symbol].changePercent >= 0 ? \'+\' : \'\'}\n                        {quotes[selectedSymbol.symbol].changePercent.toFixed(3)}%\n                      </div>\n                    </div>\n                    \n                    {/* AI Prediction */}\n                    {(() => {\n                      const pred = predictDirection(selectedSymbol.symbol);\n                      return (\n                        <div className="p-3 rounded-lg bg-card border">\n                          <div className="text-xs text-muted-foreground mb-1 flex items-center gap-1">\n                            <Brain className="w-3 h-3" />\n                            AI Prediction\n                          </div>\n                          <div className="flex items-center gap-2">\n                            <DirectionIcon direction={pred.direction} size={24} />\n                            <span className="text-xl font-bold capitalize">{pred.direction}</span>\n                            <Badge variant="outline" className="ml-auto">\n                              {pred.confidence}% confidence\n                            </Badge>\n                          </div>\n                        </div>\n                      );\n                    })()}\n                  </div>\n                  \n                  {/* Trade Controls */}\n                  <div className="space-y-4">\n                    <div>\n                      <div className="text-sm text-muted-foreground mb-2">Bet Amount ($)</div>\n                      <div className="flex gap-2">\n                        {[10, 20, 50, 100].map(amount => (\n                          <Button\n                            key={amount}\n                            variant={customBetAmount === amount ? "default" : "outline"}\n                            size="sm"\n                            onClick={() => setCustomBetAmount(amount)}\n                            disabled={amount > currentPortfolio.balance}\n                          >\n                            ${amount}\n                          </Button>\n                        ))}\n                      </div>\n                      <div className="text-xs text-muted-foreground mt-1">\n                        Available: ${currentPortfolio.balance.toFixed(2)}\n                      </div>\n                    </div>\n                    \n                    <div className="grid grid-cols-2 gap-3">\n                      <Button\n                        size="lg"\n                        className="bg-green-600 hover:bg-green-700 text-white"\n                        onClick={() => executeManualTrade(\'up\')}\n                        disabled={currentPortfolio.balance < customBetAmount}\n                      >\n                        <TrendingUp className="w-5 h-5 mr-2" />\n                        LONG\n                      </Button>\n                      <Button\n                        size="lg"\n                        className="bg-red-600 hover:bg-red-700 text-white"\n                        onClick={() => executeManualTrade(\'down\')}\n                        disabled={currentPortfolio.balance < customBetAmount}\n                      >\n                        <TrendingDown className="w-5 h-5 mr-2" />\n                        SHORT\n                      </Button>\n                    </div>\n                    \n                    <div className="text-xs text-center text-muted-foreground">\n                      Target: +{PROFIT_TARGET_PERCENT}% ‚Ä¢ Stop: -{STOP_LOSS_PERCENT}% ‚Ä¢ Resolves in {PREDICTION_INTERVAL / 1000}s\n                    </div>\n                  </div>\n                  \n                  {/* Symbol Stats */}\n                  <div className="space-y-3">\n                    <div className="text-sm text-muted-foreground">Your {selectedSymbol.symbol} History</div>\n                    {symbolStats[selectedSymbol.symbol] ? (\n                      <>\n                        <div className="grid grid-cols-3 gap-2 text-center">\n                          <div className="p-2 rounded bg-card border">\n                            <div className="text-lg font-bold">\n                              {symbolStats[selectedSymbol.symbol].total}\n                            </div>\n                            <div className="text-xs text-muted-foreground">Trades</div>\n                          </div>\n                          <div className="p-2 rounded bg-card border">\n                            <div className={cn(\n                              "text-lg font-bold",\n                              (symbolStats[selectedSymbol.symbol].correct / symbolStats[selectedSymbol.symbol].total) >= 0.55 \n                                ? "text-green-500" : "text-red-500"\n                            )}>\n                              {((symbolStats[selectedSymbol.symbol].correct / symbolStats[selectedSymbol.symbol].total) * 100).toFixed(0)}%\n                            </div>\n                            <div className="text-xs text-muted-foreground">Accuracy</div>\n                          </div>\n                          <div className="p-2 rounded bg-card border">\n                            <div className={cn(\n                              "text-lg font-bold",\n                              symbolStats[selectedSymbol.symbol].pnl >= 0 ? "text-green-500" : "text-red-500"\n                            )}>\n                              {formatMoney(symbolStats[selectedSymbol.symbol].pnl)}\n                            </div>\n                            <div className="text-xs text-muted-foreground">P&L</div>\n                          </div>\n                        </div>\n                        \n                        {/* Recent trades for this symbol */}\n                        <div className="space-y-1 max-h-32 overflow-y-auto">\n                          {symbolStats[selectedSymbol.symbol].history.slice(-5).reverse().map(trade => (\n                            <div key={trade.id} className="flex items-center justify-between text-xs p-1 rounded bg-card/50">\n                              <div className="flex items-center gap-1">\n                                {trade.wasCorrect ? (\n                                  <CheckCircle className="w-3 h-3 text-green-500" />\n                                ) : (\n                                  <XCircle className="w-3 h-3 text-red-500" />\n                                )}\n                                <DirectionIcon direction={trade.direction} size={12} />\n                              </div>\n                              <span className={cn(\n                                "font-mono",\n                                (trade.pnl || 0) >= 0 ? "text-green-500" : "text-red-500"\n                              )}>\n                                {formatMoney(trade.pnl || 0)}\n                              </span>\n                            </div>\n                          ))}\n                        </div>\n                      </>\n                    ) : (\n                      <div className="text-center text-muted-foreground py-4">\n                        No trades yet on {selectedSymbol.symbol}\n                      </div>\n                    )}\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </motion.div>\n        )}\n      </AnimatePresence>\n      \n      {/* Category Performance */}\n      <Card>\n        <CardHeader className="pb-3">\n          <CardTitle className="text-lg flex items-center gap-2">\n            <Award className="w-5 h-5" />\n            Category Performance\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-3">\n            {Object.entries(CATEGORIES).map(([key, cat]) => {\n              const stats = categoryStats[key] || { total: 0, correct: 0, pnl: 0 };\n              const accuracy = stats.total > 0 ? (stats.correct / stats.total) * 100 : 0;\n              return (\n                <div key={key} className="text-center p-3 rounded-lg bg-card/50 border">\n                  <div className={cn("text-lg mb-1", cat.color)}>{cat.icon}</div>\n                  <div className="text-xs font-medium mb-2">{cat.name}</div>\n                  <div className={cn(\n                    "text-xl font-bold",\n                    accuracy >= 55 ? "text-green-500" : accuracy >= 45 ? "text-yellow-500" : stats.total === 0 ? "text-muted-foreground" : "text-red-500"\n                  )}>\n                    {stats.total > 0 ? `${accuracy.toFixed(0)}%` : \'‚Äî\'}\n                  </div>\n                  <div className="text-xs text-muted-foreground">\n                    {stats.total} trades\n                  </div>\n                  <div className={cn(\n                    "text-xs font-medium",\n                    stats.pnl >= 0 ? "text-green-500" : "text-red-500"\n                  )}>\n                    {stats.total > 0 ? formatMoney(stats.pnl) : \'‚Äî\'}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </CardContent>\n      </Card>\n      \n      {/* Predictions Grid */}\n      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">\n        {/* Pending Predictions */}\n        <Card>\n          <CardHeader className="pb-3">\n            <CardTitle className="text-lg flex items-center gap-2">\n              <Clock className="w-5 h-5 text-yellow-500" />\n              Pending Predictions ({pendingPredictions.length})\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className="space-y-2">\n              <AnimatePresence mode="popLayout">\n                {pendingPredictions.map(pred => {\n                  const timeLeft = Math.max(0, pred.expiresAt - Date.now());\n                  const progress = ((PREDICTION_INTERVAL - timeLeft) / PREDICTION_INTERVAL) * 100;\n                  const currentQuote = quotes[pred.symbol];\n                  const currentChange = currentQuote \n                    ? ((currentQuote.price - pred.priceAtPrediction) / pred.priceAtPrediction) * 100 \n                    : 0;\n                  \n                  return (\n                    <motion.div\n                      key={pred.id}\n                      initial={{ opacity: 0, x: -20 }}\n                      animate={{ opacity: 1, x: 0 }}\n                      exit={{ opacity: 0, x: 20 }}\n                      className="p-3 rounded-lg bg-card/50 border border-yellow-500/20"\n                    >\n                      <div className="flex items-center justify-between mb-2">\n                        <div className="flex items-center gap-2">\n                          <span className="font-mono font-medium">{pred.symbol}</span>\n                          <DirectionIcon direction={pred.direction} />\n                          <Badge variant="outline" className="text-xs">\n                            {pred.confidence}%\n                          </Badge>\n                        </div>\n                        <div className="text-xs text-muted-foreground">\n                          ${pred.betAmount.toFixed(2)} bet\n                        </div>\n                      </div>\n                      <div className="flex items-center justify-between text-xs">\n                        <span className="text-muted-foreground">\n                          Entry: {formatPrice(pred.priceAtPrediction, pred.symbol)}\n                        </span>\n                        <span className={cn(\n                          "font-medium",\n                          currentChange >= 0 ? "text-green-500" : "text-red-500"\n                        )}>\n                          {currentChange >= 0 ? \'+\' : \'\'}{currentChange.toFixed(3)}%\n                        </span>\n                      </div>\n                      <Progress value={progress} className="h-1 mt-2" />\n                    </motion.div>\n                  );\n                })}\n              </AnimatePresence>\n              \n              {pendingPredictions.length === 0 && (\n                <div className="text-center text-muted-foreground py-8">\n                  <Zap className="w-8 h-8 mx-auto mb-2 opacity-50" />\n                  <p>Generating predictions...</p>\n                </div>\n              )}\n            </div>\n          </CardContent>\n        </Card>\n        \n        {/* Resolved Predictions */}\n        <Card>\n          <CardHeader className="pb-3">\n            <CardTitle className="text-lg flex items-center gap-2">\n              <CheckCircle className="w-5 h-5 text-green-500" />\n              Recent Results\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className="space-y-2 max-h-[400px] overflow-y-auto">\n              <AnimatePresence mode="popLayout">\n                {recentResolved.map(pred => (\n                  <motion.div\n                    key={pred.id}\n                    initial={{ opacity: 0, scale: 0.95 }}\n                    animate={{ opacity: 1, scale: 1 }}\n                    className={cn(\n                      "p-3 rounded-lg border",\n                      pred.wasCorrect \n                        ? "bg-green-500/5 border-green-500/30" \n                        : "bg-red-500/5 border-red-500/30"\n                    )}\n                  >\n                    <div className="flex items-center justify-between">\n                      <div className="flex items-center gap-2">\n                        {pred.wasCorrect ? (\n                          <CheckCircle className="w-4 h-4 text-green-500" />\n                        ) : (\n                          <XCircle className="w-4 h-4 text-red-500" />\n                        )}\n                        <span className="font-mono text-sm">{pred.symbol}</span>\n                        <DirectionIcon direction={pred.direction} size={14} />\n                        <span className="text-xs text-muted-foreground">‚Üí</span>\n                        <DirectionIcon direction={pred.actualDirection || \'flat\'} size={14} />\n                      </div>\n                      <div className={cn(\n                        "font-mono font-medium text-sm",\n                        (pred.pnl || 0) >= 0 ? "text-green-500" : "text-red-500"\n                      )}>\n                        {formatMoney(pred.pnl || 0)}\n                      </div>\n                    </div>\n                    <div className="flex items-center justify-between mt-1 text-xs text-muted-foreground">\n                      <span>\n                        {formatPrice(pred.priceAtPrediction, pred.symbol)} ‚Üí {formatPrice(pred.actualPrice || 0, pred.symbol)}\n                      </span>\n                      <span>{pred.confidence}% conf</span>\n                    </div>\n                  </motion.div>\n                ))}\n              </AnimatePresence>\n              \n              {recentResolved.length === 0 && (\n                <div className="text-center text-muted-foreground py-8">\n                  <Activity className="w-8 h-8 mx-auto mb-2 opacity-50" />\n                  <p>No resolved predictions yet</p>\n                </div>\n              )}\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n      \n      {/* Footer */}\n      <div className="text-center text-xs text-muted-foreground pt-4 border-t">\n        <p>Multi-Market Prediction Engine ‚Ä¢ Patent-Pending Technology</p>\n        <p className="mt-1">Invented by Alec Arthur Shelton "The Artist" ‚Ä¢ CEO</p>\n        {lastUpdate && (\n          <p className="mt-1">Last updated: {lastUpdate.toLocaleTimeString()}</p>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default MultiMarketScalpingTerminal;\n';export{e as default};
