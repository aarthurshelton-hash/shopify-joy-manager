const n="/**\n * Emotional Contagion Mapper\n * \n * Models the viral spread of emotions (fear, greed, euphoria, panic)\n * through markets using epidemiological concepts (R0, infection curves).\n * Emotions are treated as \"contagious\" information patterns.\n */\n\ntype EmotionalState = 'fear' | 'greed' | 'euphoria' | 'panic' | 'neutral' | 'despair' | 'hope';\n\ninterface EmotionMetrics {\n  state: EmotionalState;\n  intensity: number; // 0-1\n  r0: number; // Reproduction number (how contagious)\n  infectedPercent: number; // What % of market is \"infected\"\n  peakPredicted: boolean;\n  daysSincePeak: number;\n}\n\ninterface ContagionEvent {\n  emotion: EmotionalState;\n  startedAt: number;\n  peakedAt: number | null;\n  currentIntensity: number;\n  maxIntensity: number;\n  spreadRate: number;\n  isActive: boolean;\n}\n\ninterface ContagionState {\n  dominantEmotion: EmotionalState;\n  emotionMix: Record<EmotionalState, number>;\n  contagionR0: number;\n  isViral: boolean;\n  peakPhase: 'pre_peak' | 'at_peak' | 'post_peak' | 'dormant';\n  herdImmunity: number; // How resistant the market is to this emotion\n  predictedFlip: EmotionalState | null;\n  flipConfidence: number;\n}\n\nclass EmotionalContagionMapper {\n  private activeContagions: Map<EmotionalState, ContagionEvent> = new Map();\n  private emotionHistory: Array<{ timestamp: number; state: EmotionalState; intensity: number }> = [];\n  private outcomeHistory: Array<{ emotion: EmotionalState; predictedDirection: string; wasCorrect: boolean }> = [];\n  private readonly maxHistory = 1000;\n  private readonly regularization = 0.85; // Prevent overfitting\n  \n  // Emotion transition probabilities (what typically follows what)\n  private readonly transitionMatrix: Record<EmotionalState, Partial<Record<EmotionalState, number>>> = {\n    fear: { panic: 0.3, despair: 0.25, neutral: 0.3, hope: 0.15 },\n    greed: { euphoria: 0.35, fear: 0.25, neutral: 0.3, despair: 0.1 },\n    euphoria: { greed: 0.2, fear: 0.35, panic: 0.25, neutral: 0.2 },\n    panic: { despair: 0.3, fear: 0.25, hope: 0.2, neutral: 0.25 },\n    neutral: { greed: 0.25, fear: 0.25, hope: 0.25, despair: 0.25 },\n    despair: { hope: 0.35, neutral: 0.3, panic: 0.2, fear: 0.15 },\n    hope: { greed: 0.35, neutral: 0.3, fear: 0.2, euphoria: 0.15 },\n  };\n  \n  /**\n   * Detect current emotional state from market signals\n   */\n  detectEmotion(\n    priceChange: number,\n    volatility: number,\n    volume: number,\n    sentiment: number\n  ): EmotionMetrics {\n    const state = this.classifyEmotion(priceChange, volatility, volume, sentiment);\n    const intensity = this.calculateIntensity(priceChange, volatility, sentiment);\n    \n    // Track in history\n    this.emotionHistory.push({ timestamp: Date.now(), state, intensity });\n    if (this.emotionHistory.length > this.maxHistory) {\n      this.emotionHistory.shift();\n    }\n    \n    // Update or create contagion event\n    this.updateContagion(state, intensity);\n    \n    const contagion = this.activeContagions.get(state);\n    const r0 = this.calculateR0(state);\n    const infectedPercent = this.calculateInfectedPercent(state);\n    \n    return {\n      state,\n      intensity,\n      r0,\n      infectedPercent,\n      peakPredicted: contagion?.peakedAt != null || infectedPercent > 0.7,\n      daysSincePeak: contagion?.peakedAt \n        ? (Date.now() - contagion.peakedAt) / 86400000 \n        : 0,\n    };\n  }\n  \n  /**\n   * Classify emotion from market signals\n   */\n  private classifyEmotion(\n    priceChange: number,\n    volatility: number,\n    volume: number,\n    sentiment: number\n  ): EmotionalState {\n    // High volatility + negative change = fear/panic\n    if (volatility > 0.3 && priceChange < -0.05) {\n      return priceChange < -0.1 ? 'panic' : 'fear';\n    }\n    \n    // High volatility + positive change = euphoria/greed\n    if (volatility > 0.3 && priceChange > 0.05) {\n      return priceChange > 0.1 ? 'euphoria' : 'greed';\n    }\n    \n    // Low volatility, very negative sentiment = despair\n    if (volatility < 0.1 && sentiment < -0.5) {\n      return 'despair';\n    }\n    \n    // Low volatility, positive sentiment = hope\n    if (volatility < 0.15 && sentiment > 0.3) {\n      return 'hope';\n    }\n    \n    // Strong sentiment without volatility\n    if (sentiment > 0.5) return 'greed';\n    if (sentiment < -0.5) return 'fear';\n    \n    return 'neutral';\n  }\n  \n  /**\n   * Calculate emotional intensity\n   */\n  private calculateIntensity(priceChange: number, volatility: number, sentiment: number): number {\n    const priceComponent = Math.min(1, Math.abs(priceChange) * 5);\n    const volatilityComponent = Math.min(1, volatility * 3);\n    const sentimentComponent = Math.abs(sentiment);\n    \n    return Math.min(1, (priceComponent * 0.4 + volatilityComponent * 0.3 + sentimentComponent * 0.3));\n  }\n  \n  /**\n   * Update or create contagion tracking for an emotion\n   */\n  private updateContagion(state: EmotionalState, intensity: number): void {\n    const existing = this.activeContagions.get(state);\n    \n    if (existing && existing.isActive) {\n      existing.currentIntensity = intensity;\n      if (intensity > existing.maxIntensity) {\n        existing.maxIntensity = intensity;\n      } else if (intensity < existing.maxIntensity * 0.7 && !existing.peakedAt) {\n        existing.peakedAt = Date.now();\n      }\n      existing.spreadRate = this.calculateSpreadRate(state);\n    } else if (intensity > 0.3) {\n      // New contagion starting\n      this.activeContagions.set(state, {\n        emotion: state,\n        startedAt: Date.now(),\n        peakedAt: null,\n        currentIntensity: intensity,\n        maxIntensity: intensity,\n        spreadRate: 0,\n        isActive: true,\n      });\n    }\n    \n    // Deactivate old contagions\n    for (const [emotionState, contagion] of this.activeContagions) {\n      if (emotionState !== state && contagion.currentIntensity < 0.1) {\n        contagion.isActive = false;\n      }\n    }\n  }\n  \n  /**\n   * Calculate R0 (basic reproduction number) for an emotion\n   */\n  private calculateR0(state: EmotionalState): number {\n    const recent = this.emotionHistory.slice(-50);\n    const stateCount = recent.filter(e => e.state === state).length;\n    \n    if (recent.length < 10) return 1.0;\n    \n    // R0 > 1 means spreading, < 1 means dying out\n    const prevalence = stateCount / recent.length;\n    const previousPrevalence = this.emotionHistory.slice(-100, -50)\n      .filter(e => e.state === state).length / 50;\n    \n    if (previousPrevalence === 0) return prevalence > 0.1 ? 2.0 : 1.0;\n    \n    return Math.min(4, Math.max(0.1, prevalence / previousPrevalence));\n  }\n  \n  /**\n   * Calculate what % of market is \"infected\" with this emotion\n   */\n  private calculateInfectedPercent(state: EmotionalState): number {\n    const recent = this.emotionHistory.slice(-100);\n    if (recent.length === 0) return 0;\n    \n    const stateEntries = recent.filter(e => e.state === state);\n    const avgIntensity = stateEntries.length > 0\n      ? stateEntries.reduce((sum, e) => sum + e.intensity, 0) / stateEntries.length\n      : 0;\n    \n    return (stateEntries.length / recent.length) * avgIntensity;\n  }\n  \n  /**\n   * Calculate how fast the emotion is spreading\n   */\n  private calculateSpreadRate(state: EmotionalState): number {\n    const firstHalf = this.emotionHistory.slice(-100, -50);\n    const secondHalf = this.emotionHistory.slice(-50);\n    \n    const firstCount = firstHalf.filter(e => e.state === state).length;\n    const secondCount = secondHalf.filter(e => e.state === state).length;\n    \n    if (firstHalf.length === 0 || secondHalf.length === 0) return 0;\n    \n    return (secondCount / secondHalf.length) - (firstCount / firstHalf.length);\n  }\n  \n  /**\n   * Get full contagion state analysis\n   */\n  getContagionState(): ContagionState {\n    const recentEmotions = this.emotionHistory.slice(-100);\n    const emotionMix: Record<EmotionalState, number> = {\n      fear: 0, greed: 0, euphoria: 0, panic: 0, neutral: 0, despair: 0, hope: 0\n    };\n    \n    for (const entry of recentEmotions) {\n      emotionMix[entry.state] += entry.intensity;\n    }\n    \n    // Normalize\n    const total = Object.values(emotionMix).reduce((a, b) => a + b, 0);\n    if (total > 0) {\n      for (const key of Object.keys(emotionMix) as EmotionalState[]) {\n        emotionMix[key] /= total;\n      }\n    }\n    \n    // Find dominant emotion\n    const dominantEmotion = (Object.entries(emotionMix) as [EmotionalState, number][])\n      .reduce((a, b) => a[1] > b[1] ? a : b)[0];\n    \n    const activeContagion = this.activeContagions.get(dominantEmotion);\n    const r0 = this.calculateR0(dominantEmotion);\n    \n    // Determine peak phase\n    let peakPhase: 'pre_peak' | 'at_peak' | 'post_peak' | 'dormant' = 'dormant';\n    if (activeContagion?.isActive) {\n      if (!activeContagion.peakedAt) {\n        peakPhase = r0 > 1.5 ? 'pre_peak' : 'at_peak';\n      } else {\n        peakPhase = 'post_peak';\n      }\n    }\n    \n    // Predict emotional flip based on transition matrix\n    const transitions = this.transitionMatrix[dominantEmotion];\n    let predictedFlip: EmotionalState | null = null;\n    let maxProb = 0;\n    \n    for (const [nextEmotion, prob] of Object.entries(transitions) as [EmotionalState, number][]) {\n      if (prob > maxProb) {\n        maxProb = prob;\n        predictedFlip = nextEmotion;\n      }\n    }\n    \n    // Herd immunity: how \"tired\" the market is of this emotion\n    const herdImmunity = peakPhase === 'post_peak' ? 0.7 :\n                         peakPhase === 'at_peak' ? 0.3 : 0.1;\n    \n    return {\n      dominantEmotion,\n      emotionMix,\n      contagionR0: r0,\n      isViral: r0 > 1.5,\n      peakPhase,\n      herdImmunity,\n      predictedFlip: peakPhase !== 'pre_peak' ? predictedFlip : null,\n      flipConfidence: maxProb * this.regularization * (peakPhase === 'post_peak' ? 1.2 : 0.8),\n    };\n  }\n  \n  /**\n   * Get direction prediction based on emotional contagion\n   */\n  getPrediction(): { direction: 'up' | 'down' | 'neutral'; confidence: number } {\n    const state = this.getContagionState();\n    \n    const bullishEmotions: EmotionalState[] = ['greed', 'euphoria', 'hope'];\n    const bearishEmotions: EmotionalState[] = ['fear', 'panic', 'despair'];\n    \n    let bullishScore = 0;\n    let bearishScore = 0;\n    \n    for (const emotion of bullishEmotions) {\n      bullishScore += state.emotionMix[emotion];\n    }\n    for (const emotion of bearishEmotions) {\n      bearishScore += state.emotionMix[emotion];\n    }\n    \n    // Factor in peak phase (post-peak often means reversal)\n    if (state.peakPhase === 'post_peak') {\n      if (bullishEmotions.includes(state.dominantEmotion)) {\n        bearishScore *= 1.3;\n      } else if (bearishEmotions.includes(state.dominantEmotion)) {\n        bullishScore *= 1.3;\n      }\n    }\n    \n    const diff = Math.abs(bullishScore - bearishScore);\n    const confidence = Math.min(0.85, diff * this.regularization);\n    \n    if (diff < 0.1) {\n      return { direction: 'neutral', confidence: 0.3 };\n    }\n    \n    return {\n      direction: bullishScore > bearishScore ? 'up' : 'down',\n      confidence,\n    };\n  }\n  \n  /**\n   * Record outcome for learning\n   */\n  recordOutcome(emotion: EmotionalState, predictedDirection: string, actualDirection: string): void {\n    this.outcomeHistory.push({\n      emotion,\n      predictedDirection,\n      wasCorrect: predictedDirection === actualDirection,\n    });\n    \n    if (this.outcomeHistory.length > this.maxHistory) {\n      this.outcomeHistory.shift();\n    }\n  }\n  \n  /**\n   * Get accuracy by emotion type\n   */\n  getAccuracyByEmotion(): Record<EmotionalState, number> {\n    const accuracy: Record<EmotionalState, { correct: number; total: number }> = {\n      fear: { correct: 0, total: 0 },\n      greed: { correct: 0, total: 0 },\n      euphoria: { correct: 0, total: 0 },\n      panic: { correct: 0, total: 0 },\n      neutral: { correct: 0, total: 0 },\n      despair: { correct: 0, total: 0 },\n      hope: { correct: 0, total: 0 },\n    };\n    \n    for (const outcome of this.outcomeHistory) {\n      accuracy[outcome.emotion].total++;\n      if (outcome.wasCorrect) accuracy[outcome.emotion].correct++;\n    }\n    \n    const result: Record<EmotionalState, number> = {} as Record<EmotionalState, number>;\n    for (const [emotion, stats] of Object.entries(accuracy)) {\n      result[emotion as EmotionalState] = stats.total > 5 ? stats.correct / stats.total : 0.5;\n    }\n    \n    return result;\n  }\n}\n\nexport const emotionalContagionMapper = new EmotionalContagionMapper();\nexport type { EmotionalState, EmotionMetrics, ContagionState };\n";export{n as default};
