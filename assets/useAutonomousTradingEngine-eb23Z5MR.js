const n="/**\n * Universal En Pensent Autonomous Trading Engine Hook\n * \n * Provides interface to the 24/7 autonomous trading system\n * that integrates all En Pensent domains\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface TradingSession {\n  id: string;\n  startBalance: number;\n  currentBalance: number;\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  totalPnl: number;\n  isLive: boolean;\n  startedAt: string;\n  lastActivityAt: string;\n}\n\ninterface EngineStatus {\n  paperMode: boolean;\n  preferredBroker: 'alpaca' | 'ibkr';\n  // Alpaca broker status\n  alpacaConnected: boolean;\n  alpacaBalance: number;\n  alpacaPositions: number;\n  // IBKR broker status (Canadian-friendly)\n  ibkrConnected: boolean;\n  ibkrBalance: number;\n  ibkrPositions: number;\n  // Evolution\n  evolutionGeneration: number;\n  systemFitness: number;\n  overallAccuracy: number;\n  // Instruments (expanded with IBKR support)\n  instruments: {\n    CRYPTO: string[];\n    FUTURES: string[];\n    STOCKS: string[];\n    FOREX: string[];\n    TSX: string[];\n  };\n  topPerformers: Array<{ symbol: string; accuracy: string }>;\n  recentSessions: Array<{\n    id: string;\n    pnl: number;\n    trades: number;\n    winRate: string;\n  }>;\n  config: {\n    MAX_RISK_PERCENT: number;\n    MIN_CONFIDENCE: number;\n    MAX_POSITION_SIZE_PERCENT: number;\n    SCALP_HORIZON_MS: number;\n    PAPER_MODE: boolean;\n    PREFERRED_BROKER: 'alpaca' | 'ibkr';\n  };\n}\n\ninterface CycleResult {\n  tradesExecuted: number;\n  pnlChange: number;\n  signalsGenerated: number;\n  evolutionUpdated: boolean;\n}\n\nexport function useAutonomousTradingEngine() {\n  const [status, setStatus] = useState<EngineStatus | null>(null);\n  const [session, setSession] = useState<TradingSession | null>(null);\n  const [isRunning, setIsRunning] = useState(false);\n  const [cycleResults, setCycleResults] = useState<CycleResult[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const { toast } = useToast();\n\n  // Fetch engine status\n  const fetchStatus = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('autonomous-trading-engine', {\n        body: { action: 'status' },\n      });\n\n      if (error) throw error;\n      if (data?.status) {\n        setStatus(data.status);\n      }\n    } catch (err) {\n      console.error('[AutonomousEngine] Status fetch error:', err);\n      setError((err as Error).message);\n    }\n  }, []);\n\n  // Start new trading session\n  const startSession = useCallback(async (initialBalance: number = 10000, isLive: boolean = false) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const sessionId = `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n      \n      const { data, error } = await supabase.functions.invoke('autonomous-trading-engine', {\n        body: { \n          action: 'start', \n          sessionId,\n          initialBalance,\n          isLive,\n        },\n      });\n\n      if (error) throw error;\n\n      if (data?.session) {\n        setSession(data.session);\n        toast({\n          title: \"Trading Session Started\",\n          description: data.message,\n        });\n        return data.session;\n      }\n    } catch (err) {\n      const message = (err as Error).message;\n      setError(message);\n      toast({\n        title: \"Failed to Start Session\",\n        description: message,\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [toast]);\n\n  // Run single trading cycle\n  const runCycle = useCallback(async () => {\n    if (!session?.id) return null;\n\n    try {\n      const { data, error } = await supabase.functions.invoke('autonomous-trading-engine', {\n        body: { \n          action: 'cycle',\n          sessionId: session.id,\n        },\n      });\n\n      if (error) throw error;\n\n      if (data?.result) {\n        setCycleResults(prev => [...prev.slice(-99), data.result]);\n        \n        // Update session balance from response\n        if (data.session) {\n          setSession(prev => prev ? {\n            ...prev,\n            currentBalance: data.session.balance,\n            totalPnl: data.session.pnl,\n            totalTrades: data.session.trades,\n          } : prev);\n        }\n        \n        return data.result;\n      }\n    } catch (err) {\n      console.error('[AutonomousEngine] Cycle error:', err);\n    }\n    return null;\n  }, [session?.id]);\n\n  // Start autonomous loop\n  const startAutonomousLoop = useCallback((intervalMs: number = 5000) => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n    }\n\n    setIsRunning(true);\n    \n    // Run immediately\n    runCycle();\n    \n    // Then run on interval\n    intervalRef.current = setInterval(() => {\n      runCycle();\n    }, intervalMs);\n\n    toast({\n      title: \"Autonomous Trading Active\",\n      description: `Running trading cycles every ${intervalMs / 1000}s`,\n    });\n  }, [runCycle, toast]);\n\n  // Stop autonomous loop\n  const stopAutonomousLoop = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n    setIsRunning(false);\n    \n    toast({\n      title: \"Autonomous Trading Paused\",\n      description: \"Trading loop has been stopped\",\n    });\n  }, [toast]);\n\n  // Toggle live mode\n  const toggleLiveMode = useCallback(async (enable: boolean) => {\n    if (enable) {\n      // Confirm before enabling live mode\n      const brokerName = status?.preferredBroker === 'ibkr' ? 'IBKR' : 'Alpaca';\n      const confirmed = window.confirm(\n        `⚠️ WARNING: You are about to enable LIVE TRADING.\\n\\n` +\n        `This will use REAL MONEY from your connected ${brokerName} account.\\n\\n` +\n        `Are you absolutely sure you want to proceed?`\n      );\n      if (!confirmed) return false;\n    }\n\n    try {\n      const { data, error } = await supabase.functions.invoke('autonomous-trading-engine', {\n        body: { action: 'toggle-live', enable },\n      });\n\n      if (error) throw error;\n\n      toast({\n        title: enable ? \"⚠️ LIVE MODE ENABLED\" : \"Paper Mode Active\",\n        description: data?.message,\n        variant: enable ? \"destructive\" : \"default\",\n      });\n\n      await fetchStatus();\n      return true;\n    } catch (err) {\n      toast({\n        title: \"Mode Toggle Failed\",\n        description: (err as Error).message,\n        variant: \"destructive\",\n      });\n      return false;\n    }\n  }, [toast, fetchStatus]);\n\n  // Calculate statistics\n  const stats = {\n    totalSignals: cycleResults.reduce((sum, r) => sum + r.signalsGenerated, 0),\n    totalTrades: cycleResults.reduce((sum, r) => sum + r.tradesExecuted, 0),\n    totalPnlChange: cycleResults.reduce((sum, r) => sum + r.pnlChange, 0),\n    evolutionUpdates: cycleResults.filter(r => r.evolutionUpdated).length,\n    winRate: session ? \n      session.totalTrades > 0 \n        ? ((session.winningTrades / session.totalTrades) * 100).toFixed(1) + '%'\n        : 'N/A'\n      : 'N/A',\n  };\n\n  // Fetch status on mount\n  useEffect(() => {\n    fetchStatus();\n    const interval = setInterval(fetchStatus, 30000); // Refresh every 30s\n    return () => clearInterval(interval);\n  }, [fetchStatus]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    // State\n    status,\n    session,\n    isRunning,\n    cycleResults,\n    stats,\n    loading,\n    error,\n\n    // Actions\n    fetchStatus,\n    startSession,\n    runCycle,\n    startAutonomousLoop,\n    stopAutonomousLoop,\n    toggleLiveMode,\n  };\n}\n";export{n as default};
