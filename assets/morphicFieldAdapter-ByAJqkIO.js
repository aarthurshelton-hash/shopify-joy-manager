const n="/**\n * Morphic Field Adapter\n * \n * Inspired by Rupert Sheldrake's morphic resonance theory.\n * Tracks how patterns propagate across geographically and temporally\n * separate markets/systems as if influenced by a shared \"field.\"\n */\n\ninterface MorphicPattern {\n  id: string;\n  signature: number[]; // Pattern fingerprint\n  firstObserved: number;\n  locations: string[]; // Markets/domains where observed\n  propagationSpeed: number; // How fast it spread\n  strength: number;\n  isActive: boolean;\n}\n\ninterface FieldResonance {\n  patternId: string;\n  currentStrength: number;\n  propagatingTo: string[];\n  expectedArrivalMs: number;\n  confidence: number;\n}\n\ninterface MorphicFieldState {\n  activePatterns: MorphicPattern[];\n  resonances: FieldResonance[];\n  fieldCoherence: number; // 0-1, how aligned the field is\n  dominantPattern: MorphicPattern | null;\n}\n\nclass MorphicFieldAdapter {\n  private patterns: Map<string, MorphicPattern> = new Map();\n  private observations: Map<string, Array<{ location: string; timestamp: number; signature: number[] }>> = new Map();\n  private readonly patternSimilarityThreshold = 0.75;\n  private readonly patternDecayRate = 0.99; // Per hour\n  private readonly regularizationFactor = 0.8; // Prevent overfitting to morphic patterns\n  \n  /**\n   * Record an observation that might form or match a morphic pattern\n   */\n  recordObservation(location: string, signature: number[]): MorphicPattern | null {\n    const now = Date.now();\n    const signatureHash = this.hashSignature(signature);\n    \n    // Check for matching existing patterns\n    for (const [id, pattern] of this.patterns) {\n      if (this.calculateSimilarity(pattern.signature, signature) > this.patternSimilarityThreshold) {\n        // Pattern resonance detected\n        if (!pattern.locations.includes(location)) {\n          pattern.locations.push(location);\n          pattern.propagationSpeed = this.calculatePropagationSpeed(pattern, now);\n        }\n        pattern.strength = Math.min(1, pattern.strength + 0.1);\n        pattern.isActive = true;\n        return pattern;\n      }\n    }\n    \n    // Store observation for potential new pattern formation\n    if (!this.observations.has(signatureHash)) {\n      this.observations.set(signatureHash, []);\n    }\n    \n    const obs = this.observations.get(signatureHash)!;\n    obs.push({ location, timestamp: now, signature });\n    \n    // Check if we have enough observations across different locations to form a pattern\n    const uniqueLocations = new Set(obs.map(o => o.location));\n    if (uniqueLocations.size >= 3) {\n      const newPattern = this.createPattern(signatureHash, obs);\n      this.patterns.set(newPattern.id, newPattern);\n      this.observations.delete(signatureHash);\n      return newPattern;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Calculate similarity between two signatures using cosine similarity\n   */\n  private calculateSimilarity(sig1: number[], sig2: number[]): number {\n    const minLength = Math.min(sig1.length, sig2.length);\n    if (minLength === 0) return 0;\n    \n    let dotProduct = 0;\n    let norm1 = 0;\n    let norm2 = 0;\n    \n    for (let i = 0; i < minLength; i++) {\n      dotProduct += sig1[i] * sig2[i];\n      norm1 += sig1[i] * sig1[i];\n      norm2 += sig2[i] * sig2[i];\n    }\n    \n    const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);\n    return denominator > 0 ? dotProduct / denominator : 0;\n  }\n  \n  /**\n   * Create a unique hash for a signature\n   */\n  private hashSignature(signature: number[]): string {\n    // Quantize and hash\n    const quantized = signature.map(v => Math.round(v * 10) / 10);\n    return quantized.join(',');\n  }\n  \n  /**\n   * Calculate how fast a pattern is propagating\n   */\n  private calculatePropagationSpeed(pattern: MorphicPattern, now: number): number {\n    const timeSinceFirst = now - pattern.firstObserved;\n    if (timeSinceFirst === 0) return 0;\n    \n    // Locations per hour\n    return (pattern.locations.length * 3600000) / timeSinceFirst;\n  }\n  \n  /**\n   * Create a new morphic pattern from observations\n   */\n  private createPattern(\n    id: string, \n    observations: Array<{ location: string; timestamp: number; signature: number[] }>\n  ): MorphicPattern {\n    // Average the signatures\n    const avgSignature = this.averageSignatures(observations.map(o => o.signature));\n    \n    return {\n      id: `morphic_${id.substring(0, 8)}_${Date.now()}`,\n      signature: avgSignature,\n      firstObserved: Math.min(...observations.map(o => o.timestamp)),\n      locations: [...new Set(observations.map(o => o.location))],\n      propagationSpeed: 0,\n      strength: 0.5,\n      isActive: true,\n    };\n  }\n  \n  /**\n   * Average multiple signatures\n   */\n  private averageSignatures(signatures: number[][]): number[] {\n    if (signatures.length === 0) return [];\n    \n    const maxLength = Math.max(...signatures.map(s => s.length));\n    const result: number[] = new Array(maxLength).fill(0);\n    \n    for (let i = 0; i < maxLength; i++) {\n      let sum = 0;\n      let count = 0;\n      for (const sig of signatures) {\n        if (i < sig.length) {\n          sum += sig[i];\n          count++;\n        }\n      }\n      result[i] = count > 0 ? sum / count : 0;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Detect resonances (patterns likely to appear in new locations)\n   */\n  detectResonances(targetLocation: string): FieldResonance[] {\n    const resonances: FieldResonance[] = [];\n    \n    for (const [id, pattern] of this.patterns) {\n      if (!pattern.isActive) continue;\n      if (pattern.locations.includes(targetLocation)) continue;\n      \n      // Patterns with high strength and fast propagation are likely to resonate\n      if (pattern.strength > 0.4 && pattern.locations.length >= 2) {\n        const avgPropagationTime = pattern.propagationSpeed > 0 \n          ? 3600000 / pattern.propagationSpeed \n          : 86400000; // Default 24 hours\n        \n        resonances.push({\n          patternId: pattern.id,\n          currentStrength: pattern.strength * this.regularizationFactor,\n          propagatingTo: [targetLocation],\n          expectedArrivalMs: avgPropagationTime,\n          confidence: Math.min(0.8, pattern.strength * (pattern.locations.length / 10)),\n        });\n      }\n    }\n    \n    return resonances.sort((a, b) => b.confidence - a.confidence).slice(0, 5);\n  }\n  \n  /**\n   * Get the current state of the morphic field\n   */\n  getFieldState(): MorphicFieldState {\n    this.decayPatterns();\n    \n    const activePatterns = Array.from(this.patterns.values()).filter(p => p.isActive);\n    \n    // Calculate field coherence (how aligned patterns are)\n    let coherence = 0;\n    if (activePatterns.length >= 2) {\n      let totalSimilarity = 0;\n      let comparisons = 0;\n      \n      for (let i = 0; i < activePatterns.length; i++) {\n        for (let j = i + 1; j < activePatterns.length; j++) {\n          totalSimilarity += this.calculateSimilarity(\n            activePatterns[i].signature,\n            activePatterns[j].signature\n          );\n          comparisons++;\n        }\n      }\n      \n      coherence = comparisons > 0 ? totalSimilarity / comparisons : 0;\n    }\n    \n    const dominantPattern = activePatterns.length > 0\n      ? activePatterns.reduce((a, b) => a.strength > b.strength ? a : b)\n      : null;\n    \n    const resonances: FieldResonance[] = [];\n    for (const pattern of activePatterns) {\n      if (pattern.propagationSpeed > 0.5) {\n        resonances.push({\n          patternId: pattern.id,\n          currentStrength: pattern.strength,\n          propagatingTo: [], // Would need target location context\n          expectedArrivalMs: 3600000 / pattern.propagationSpeed,\n          confidence: pattern.strength * 0.8,\n        });\n      }\n    }\n    \n    return {\n      activePatterns,\n      resonances,\n      fieldCoherence: coherence,\n      dominantPattern,\n    };\n  }\n  \n  /**\n   * Decay inactive patterns over time\n   */\n  private decayPatterns(): void {\n    const now = Date.now();\n    \n    for (const [id, pattern] of this.patterns) {\n      const hoursSinceUpdate = (now - pattern.firstObserved) / 3600000;\n      pattern.strength *= Math.pow(this.patternDecayRate, hoursSinceUpdate / 24);\n      \n      if (pattern.strength < 0.1) {\n        pattern.isActive = false;\n      }\n      \n      // Remove very old inactive patterns\n      if (pattern.strength < 0.01 && hoursSinceUpdate > 168) { // 1 week\n        this.patterns.delete(id);\n      }\n    }\n  }\n  \n  /**\n   * Get confidence modifier based on morphic field state\n   */\n  getConfidenceModifier(): number {\n    const state = this.getFieldState();\n    \n    // Higher coherence = more confidence\n    const coherenceBoost = 1 + (state.fieldCoherence * 0.15);\n    \n    // Active resonances boost confidence\n    const resonanceBoost = state.resonances.length > 0 \n      ? 1 + Math.min(0.1, state.resonances.length * 0.02)\n      : 1;\n    \n    // Apply regularization to prevent overfitting\n    return (coherenceBoost * resonanceBoost) * this.regularizationFactor;\n  }\n  \n  /**\n   * Record outcome for pattern accuracy tracking\n   */\n  recordOutcome(patternId: string, wasAccurate: boolean): void {\n    const pattern = this.patterns.get(patternId);\n    if (pattern) {\n      if (wasAccurate) {\n        pattern.strength = Math.min(1, pattern.strength * 1.05);\n      } else {\n        pattern.strength *= 0.9;\n      }\n    }\n  }\n}\n\nexport const morphicFieldAdapter = new MorphicFieldAdapter();\nexport type { MorphicPattern, FieldResonance, MorphicFieldState };\n";export{n as default};
