const e="/**\n * Marketplace Resilience Utilities\n * \n * Provides inventory locking, rate limiting, and queue management\n * for heavy business load scenarios\n */\n\nimport { supabase } from '@/integrations/supabase/client';\n\n// Inventory Lock Types\nexport interface InventoryLock {\n  resourceType: 'listing' | 'print_variant' | 'book_slot';\n  resourceId: string;\n  userId: string;\n  expiresAt: Date;\n}\n\n// Rate Limit Tracking\ninterface RateLimitEntry {\n  count: number;\n  resetAt: number;\n}\n\nconst rateLimitStore = new Map<string, RateLimitEntry>();\n\n/**\n * Acquire inventory lock to prevent overselling\n * Uses database-level locking for consistency\n */\nexport async function acquireInventoryLock(\n  resourceType: string,\n  resourceId: string,\n  userId: string,\n  ttlSeconds: number = 300\n): Promise<{ success: boolean; lockId?: string; error?: string }> {\n  try {\n    const expiresAt = new Date(Date.now() + ttlSeconds * 1000);\n    \n    const { data, error } = await supabase\n      .from('inventory_locks')\n      .insert({\n        resource_type: resourceType,\n        resource_id: resourceId,\n        user_id: userId,\n        expires_at: expiresAt.toISOString(),\n      })\n      .select('id')\n      .single();\n    \n    if (error) {\n      // Check if it's a unique constraint violation (already locked)\n      if (error.code === '23505') {\n        // Check if existing lock has expired\n        const { data: existingLock } = await supabase\n          .from('inventory_locks')\n          .select('expires_at, user_id')\n          .eq('resource_type', resourceType)\n          .eq('resource_id', resourceId)\n          .single();\n        \n        if (existingLock && new Date(existingLock.expires_at) < new Date()) {\n          // Lock expired, delete it and retry\n          await supabase\n            .from('inventory_locks')\n            .delete()\n            .eq('resource_type', resourceType)\n            .eq('resource_id', resourceId);\n          \n          // Retry once\n          return acquireInventoryLock(resourceType, resourceId, userId, ttlSeconds);\n        }\n        \n        return { success: false, error: 'Resource temporarily unavailable' };\n      }\n      throw error;\n    }\n    \n    return { success: true, lockId: data.id };\n  } catch (error) {\n    console.error('[InventoryLock] Failed to acquire lock:', error);\n    return { success: false, error: 'Failed to lock resource' };\n  }\n}\n\n/**\n * Release inventory lock\n */\nexport async function releaseInventoryLock(lockId: string): Promise<void> {\n  try {\n    await supabase\n      .from('inventory_locks')\n      .delete()\n      .eq('id', lockId);\n  } catch (error) {\n    console.error('[InventoryLock] Failed to release lock:', error);\n  }\n}\n\n/**\n * Check rate limit for an action\n * Implements sliding window rate limiting\n */\nexport function checkRateLimit(\n  key: string,\n  maxRequests: number,\n  windowMs: number\n): { allowed: boolean; remaining: number; resetAt: number } {\n  const now = Date.now();\n  const entry = rateLimitStore.get(key);\n  \n  if (!entry || now > entry.resetAt) {\n    // New window\n    const resetAt = now + windowMs;\n    rateLimitStore.set(key, { count: 1, resetAt });\n    return { allowed: true, remaining: maxRequests - 1, resetAt };\n  }\n  \n  if (entry.count >= maxRequests) {\n    return { allowed: false, remaining: 0, resetAt: entry.resetAt };\n  }\n  \n  entry.count++;\n  return { allowed: true, remaining: maxRequests - entry.count, resetAt: entry.resetAt };\n}\n\n/**\n * Clean up expired rate limit entries\n */\nexport function cleanupRateLimits(): void {\n  const now = Date.now();\n  for (const [key, entry] of rateLimitStore) {\n    if (now > entry.resetAt) {\n      rateLimitStore.delete(key);\n    }\n  }\n}\n\n// Clean up every 5 minutes\nsetInterval(cleanupRateLimits, 5 * 60 * 1000);\n\n/**\n * Execute with automatic inventory lock\n * Automatically releases lock when done\n */\nexport async function withInventoryLock<T>(\n  resourceType: string,\n  resourceId: string,\n  userId: string,\n  fn: () => Promise<T>,\n  ttlSeconds: number = 300\n): Promise<{ success: boolean; result?: T; error?: string }> {\n  const lock = await acquireInventoryLock(resourceType, resourceId, userId, ttlSeconds);\n  \n  if (!lock.success) {\n    return { success: false, error: lock.error };\n  }\n  \n  try {\n    const result = await fn();\n    return { success: true, result };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Operation failed';\n    return { success: false, error: message };\n  } finally {\n    if (lock.lockId) {\n      await releaseInventoryLock(lock.lockId);\n    }\n  }\n}\n\n/**\n * Queue item for async processing\n * Used for book generation and other heavy operations\n */\nexport async function queueForProcessing(\n  queueName: string,\n  payload: Record<string, unknown>,\n  priority: number = 0\n): Promise<{ success: boolean; jobId?: string; error?: string }> {\n  try {\n    const { data, error } = await supabase\n      .from('processing_queue')\n      .insert({\n        queue_name: queueName,\n        payload,\n        priority,\n        status: 'pending',\n        attempts: 0,\n        max_attempts: 3,\n      })\n      .select('id')\n      .single();\n    \n    if (error) throw error;\n    \n    return { success: true, jobId: data.id };\n  } catch (error) {\n    console.error('[Queue] Failed to queue item:', error);\n    return { success: false, error: 'Failed to queue item' };\n  }\n}\n\n/**\n * Get queue status\n */\nexport async function getQueueStatus(\n  queueName: string\n): Promise<{ pending: number; processing: number; failed: number }> {\n  try {\n    const { data, error } = await supabase\n      .from('processing_queue')\n      .select('status')\n      .eq('queue_name', queueName);\n    \n    if (error) throw error;\n    \n    const counts = { pending: 0, processing: 0, failed: 0 };\n    for (const item of data || []) {\n      counts[item.status as keyof typeof counts]++;\n    }\n    \n    return counts;\n  } catch (error) {\n    console.error('[Queue] Failed to get status:', error);\n    return { pending: 0, processing: 0, failed: 0 };\n  }\n}\n\n/**\n * Distributed lock using database\n * For critical sections that need cluster-wide locking\n */\nexport async function withDistributedLock<T>(\n  lockName: string,\n  ttlSeconds: number,\n  fn: () => Promise<T>\n): Promise<{ success: boolean; result?: T; error?: string }> {\n  const lockKey = `distributed:${lockName}`;\n  const acquired = await acquireInventoryLock('distributed', lockKey, 'system', ttlSeconds);\n  \n  if (!acquired.success) {\n    return { success: false, error: 'Could not acquire distributed lock' };\n  }\n  \n  try {\n    const result = await fn();\n    return { success: true, result };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Operation failed';\n    return { success: false, error: message };\n  } finally {\n    if (acquired.lockId) {\n      await releaseInventoryLock(acquired.lockId);\n    }\n  }\n}\n";export{e as default};
