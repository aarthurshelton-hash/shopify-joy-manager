const n="/**\n * En Pensent Core SDK - Visualization Primitives\n * \n * Universal visualization data structures and utilities that can be used\n * by any domain to render pattern analysis results.\n */\n\nimport { \n  TemporalSignature, \n  QuadrantProfile, \n  TemporalFlow,\n  CriticalMoment \n} from './types';\n\n// ===================== VISUALIZATION DATA TYPES =====================\n\n/**\n * Normalized data point for any time-series visualization\n */\nexport interface TimeSeriesPoint {\n  /** Position in sequence (0-1 normalized or absolute index) */\n  position: number;\n  /** Value at this position (typically 0-1 normalized) */\n  value: number;\n  /** Optional label for the point */\n  label?: string;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Data for radar/spider chart visualizations\n */\nexport interface RadarChartData {\n  axes: Array<{\n    id: string;\n    label: string;\n    value: number; // 0-1 normalized\n    maxValue?: number;\n  }>;\n  /** Optional comparison dataset */\n  comparison?: Array<{\n    id: string;\n    value: number;\n  }>;\n}\n\n/**\n * Data for heat map visualizations\n */\nexport interface HeatMapData {\n  rows: number;\n  cols: number;\n  cells: Array<{\n    row: number;\n    col: number;\n    value: number; // 0-1 intensity\n    label?: string;\n  }>;\n  /** Row labels */\n  rowLabels?: string[];\n  /** Column labels */\n  colLabels?: string[];\n}\n\n/**\n * Data for flow/timeline visualizations\n */\nexport interface FlowChartData {\n  phases: Array<{\n    id: string;\n    label: string;\n    value: number;\n    startPosition: number;\n    endPosition: number;\n  }>;\n  transitions: Array<{\n    from: string;\n    to: string;\n    magnitude: number;\n  }>;\n  trend: 'accelerating' | 'declining' | 'stable' | 'volatile';\n}\n\n/**\n * Data for gauge/meter visualizations\n */\nexport interface GaugeData {\n  value: number; // 0-1 or 0-100\n  min: number;\n  max: number;\n  thresholds?: Array<{\n    value: number;\n    color: string;\n    label: string;\n  }>;\n  label: string;\n  unit?: string;\n}\n\n/**\n * Complete visualization bundle for a signature\n */\nexport interface SignatureVisualizationData {\n  quadrantRadar: RadarChartData;\n  temporalFlow: FlowChartData;\n  intensityGauge: GaugeData;\n  confidenceGauge: GaugeData;\n  criticalMomentTimeline: TimeSeriesPoint[];\n  heatMap?: HeatMapData;\n}\n\n// ===================== TRANSFORMATION FUNCTIONS =====================\n\n/**\n * Transform quadrant profile to radar chart data\n */\nexport function quadrantToRadarData(\n  profile: QuadrantProfile,\n  labels?: { q1?: string; q2?: string; q3?: string; q4?: string }\n): RadarChartData {\n  return {\n    axes: [\n      {\n        id: 'q1',\n        label: labels?.q1 ?? 'Quadrant 1',\n        value: profile.q1,\n        maxValue: 1\n      },\n      {\n        id: 'q2',\n        label: labels?.q2 ?? 'Quadrant 2',\n        value: profile.q2,\n        maxValue: 1\n      },\n      {\n        id: 'q3',\n        label: labels?.q3 ?? 'Quadrant 3',\n        value: profile.q3,\n        maxValue: 1\n      },\n      {\n        id: 'q4',\n        label: labels?.q4 ?? 'Quadrant 4',\n        value: profile.q4,\n        maxValue: 1\n      }\n    ]\n  };\n}\n\n/**\n * Transform temporal flow to flow chart data\n */\nexport function temporalFlowToChartData(\n  flow: TemporalFlow,\n  phaseLabels?: { opening?: string; middle?: string; ending?: string }\n): FlowChartData {\n  return {\n    phases: [\n      {\n        id: 'opening',\n        label: phaseLabels?.opening ?? 'Opening Phase',\n        value: flow.opening,\n        startPosition: 0,\n        endPosition: 0.33\n      },\n      {\n        id: 'middle',\n        label: phaseLabels?.middle ?? 'Middle Phase',\n        value: flow.middle,\n        startPosition: 0.33,\n        endPosition: 0.66\n      },\n      {\n        id: 'ending',\n        label: phaseLabels?.ending ?? 'Ending Phase',\n        value: flow.ending,\n        startPosition: 0.66,\n        endPosition: 1\n      }\n    ],\n    transitions: [\n      {\n        from: 'opening',\n        to: 'middle',\n        magnitude: Math.abs(flow.middle - flow.opening)\n      },\n      {\n        from: 'middle',\n        to: 'ending',\n        magnitude: Math.abs(flow.ending - flow.middle)\n      }\n    ],\n    trend: flow.trend\n  };\n}\n\n/**\n * Transform critical moments to timeline points\n */\nexport function criticalMomentsToTimeline(\n  moments: CriticalMoment[],\n  totalLength?: number\n): TimeSeriesPoint[] {\n  const normalizer = totalLength ?? Math.max(...moments.map(m => m.index), 1);\n  \n  return moments.map(moment => ({\n    position: moment.index / normalizer,\n    value: moment.severity,\n    label: moment.description,\n    metadata: {\n      type: moment.type,\n      index: moment.index\n    }\n  }));\n}\n\n/**\n * Create intensity gauge data from signature\n */\nexport function createIntensityGauge(\n  intensity: number,\n  label?: string\n): GaugeData {\n  return {\n    value: intensity * 100,\n    min: 0,\n    max: 100,\n    thresholds: [\n      { value: 30, color: 'hsl(var(--success))', label: 'Low' },\n      { value: 60, color: 'hsl(var(--warning))', label: 'Moderate' },\n      { value: 100, color: 'hsl(var(--destructive))', label: 'High' }\n    ],\n    label: label ?? 'Intensity',\n    unit: '%'\n  };\n}\n\n/**\n * Create confidence gauge data\n */\nexport function createConfidenceGauge(\n  confidence: number,\n  label?: string\n): GaugeData {\n  return {\n    value: confidence * 100,\n    min: 0,\n    max: 100,\n    thresholds: [\n      { value: 40, color: 'hsl(var(--destructive))', label: 'Low' },\n      { value: 70, color: 'hsl(var(--warning))', label: 'Moderate' },\n      { value: 100, color: 'hsl(var(--success))', label: 'High' }\n    ],\n    label: label ?? 'Confidence',\n    unit: '%'\n  };\n}\n\n/**\n * Generate complete visualization data from a signature\n */\nexport function signatureToVisualizationData(\n  signature: TemporalSignature,\n  options?: {\n    quadrantLabels?: { q1?: string; q2?: string; q3?: string; q4?: string };\n    phaseLabels?: { opening?: string; middle?: string; ending?: string };\n    totalSequenceLength?: number;\n  }\n): SignatureVisualizationData {\n  return {\n    quadrantRadar: quadrantToRadarData(signature.quadrantProfile, options?.quadrantLabels),\n    temporalFlow: temporalFlowToChartData(signature.temporalFlow, options?.phaseLabels),\n    intensityGauge: createIntensityGauge(signature.intensity),\n    confidenceGauge: createConfidenceGauge(signature.temporalFlow.momentum > 0 ? 0.7 : 0.5),\n    criticalMomentTimeline: criticalMomentsToTimeline(\n      signature.criticalMoments,\n      options?.totalSequenceLength\n    )\n  };\n}\n\n// ===================== COLOR UTILITIES =====================\n\n/**\n * Color scale configuration for visualizations\n */\nexport interface ColorScale {\n  min: string;\n  mid: string;\n  max: string;\n  neutral?: string;\n}\n\nexport const DEFAULT_COLOR_SCALE: ColorScale = {\n  min: 'hsl(var(--destructive))',\n  mid: 'hsl(var(--warning))',\n  max: 'hsl(var(--success))',\n  neutral: 'hsl(var(--muted))'\n};\n\n/**\n * Get color for a value based on a color scale\n */\nexport function getColorForValue(\n  value: number,\n  scale: ColorScale = DEFAULT_COLOR_SCALE\n): string {\n  if (value < 0.33) return scale.min;\n  if (value < 0.66) return scale.mid;\n  return scale.max;\n}\n\n/**\n * Get semantic color for confidence level\n */\nexport function getConfidenceColor(confidence: number): string {\n  if (confidence >= 0.7) return 'hsl(var(--success))';\n  if (confidence >= 0.4) return 'hsl(var(--warning))';\n  return 'hsl(var(--destructive))';\n}\n\n/**\n * Get semantic color for intensity level\n */\nexport function getIntensityColor(intensity: number): string {\n  if (intensity >= 0.7) return 'hsl(var(--destructive))';\n  if (intensity >= 0.4) return 'hsl(var(--warning))';\n  return 'hsl(var(--success))';\n}\n\n// ===================== FORMATTING UTILITIES =====================\n\n/**\n * Format a decimal value as a percentage string\n */\nexport function formatPercentage(value: number, decimals: number = 0): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\n/**\n * Format trend for display\n */\nexport function formatTrend(trend: TemporalFlow['trend']): string {\n  const trendLabels: Record<TemporalFlow['trend'], string> = {\n    accelerating: '↑ Accelerating',\n    declining: '↓ Declining',\n    stable: '→ Stable',\n    volatile: '↕ Volatile'\n  };\n  return trendLabels[trend] ?? trend;\n}\n\n/**\n * Format archetype for display (convert snake_case to Title Case)\n */\nexport function formatArchetype(archetype: string): string {\n  return archetype\n    .split('_')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(' ');\n}\n\n/**\n * Format flow direction for display\n */\nexport function formatFlowDirection(direction: string): string {\n  const directionLabels: Record<string, string> = {\n    ascending: '↗ Ascending',\n    descending: '↘ Descending',\n    lateral: '→ Lateral',\n    chaotic: '⟳ Chaotic',\n    balanced: '⟷ Balanced',\n    kingside: '→ Kingside',\n    queenside: '← Queenside',\n    central: '◎ Central'\n  };\n  return directionLabels[direction] ?? direction;\n}\n\n/**\n * Format dominant force for display\n */\nexport function formatDominantForce(force: string): string {\n  const forceLabels: Record<string, string> = {\n    primary: '● Primary',\n    secondary: '○ Secondary',\n    balanced: '◐ Balanced',\n    white: '○ White',\n    black: '● Black'\n  };\n  return forceLabels[force] ?? force;\n}\n\n// ===================== ANIMATION UTILITIES =====================\n\n/**\n * Animation configuration for visualizations\n */\nexport interface AnimationConfig {\n  duration: number;\n  delay: number;\n  easing: string;\n  stagger?: number;\n}\n\nexport const DEFAULT_ANIMATION_CONFIG: AnimationConfig = {\n  duration: 0.5,\n  delay: 0,\n  easing: 'easeOut',\n  stagger: 0.1\n};\n\n/**\n * Create staggered animation delays for a list of items\n */\nexport function createStaggeredDelays(\n  count: number,\n  baseDelay: number = 0,\n  stagger: number = 0.1\n): number[] {\n  return Array.from({ length: count }, (_, i) => baseDelay + (i * stagger));\n}\n";export{n as default};
