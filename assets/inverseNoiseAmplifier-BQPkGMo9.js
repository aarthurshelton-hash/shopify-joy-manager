const e="/**\n * Inverse Noise Amplifier\n * \n * Counter-intuitive module: Instead of filtering noise, it analyzes noise itself.\n * Noise patterns can predict order (calm before storm, storm before calm).\n * High entropy periods often precede directional moves.\n */\n\ninterface NoiseProfile {\n  level: number; // 0-1, current noise level\n  trend: 'increasing' | 'decreasing' | 'stable';\n  frequency: number; // Dominant noise frequency\n  structure: 'random' | 'patterned' | 'chaotic';\n  signalToNoise: number;\n}\n\ninterface NoiseAnomaly {\n  type: 'noise_spike' | 'noise_collapse' | 'frequency_shift' | 'structure_change';\n  magnitude: number;\n  timestamp: number;\n  predictiveValue: number;\n}\n\ninterface InverseNoiseState {\n  currentProfile: NoiseProfile;\n  recentAnomalies: NoiseAnomaly[];\n  predictionFromNoise: {\n    direction: 'up' | 'down' | 'neutral';\n    confidence: number;\n    reasoning: string;\n  };\n  noiseOrderCycle: 'order_to_chaos' | 'chaos_to_order' | 'stable_chaos' | 'stable_order';\n}\n\nclass InverseNoiseAmplifier {\n  private noiseHistory: NoiseProfile[] = [];\n  private anomalyHistory: NoiseAnomaly[] = [];\n  private outcomeHistory: Array<{ noiseLevel: number; predictedDirection: string; wasCorrect: boolean }> = [];\n  private readonly maxHistory = 500;\n  private readonly regularization = 0.85;\n  \n  /**\n   * Analyze noise characteristics from price data\n   */\n  analyzeNoise(priceData: number[], volumeData: number[]): NoiseProfile {\n    const level = this.calculateNoiseLevel(priceData);\n    const trend = this.calculateNoiseTrend();\n    const frequency = this.calculateDominantFrequency(priceData);\n    const structure = this.classifyNoiseStructure(priceData);\n    const signalToNoise = this.calculateSNR(priceData);\n    \n    const profile: NoiseProfile = { level, trend, frequency, structure, signalToNoise };\n    \n    this.noiseHistory.push(profile);\n    if (this.noiseHistory.length > this.maxHistory) {\n      this.noiseHistory.shift();\n    }\n    \n    // Detect anomalies\n    this.detectAnomalies(profile);\n    \n    return profile;\n  }\n  \n  /**\n   * Calculate noise level using high-frequency variations\n   */\n  private calculateNoiseLevel(data: number[]): number {\n    if (data.length < 3) return 0.5;\n    \n    // Calculate second-order differences (acceleration of price)\n    const secondDiffs: number[] = [];\n    for (let i = 2; i < data.length; i++) {\n      const d1 = data[i - 1] - data[i - 2];\n      const d2 = data[i] - data[i - 1];\n      secondDiffs.push(d2 - d1);\n    }\n    \n    // Noise is high when second derivatives are erratic\n    const mean = secondDiffs.reduce((a, b) => a + b, 0) / secondDiffs.length;\n    const variance = secondDiffs.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / secondDiffs.length;\n    const normalizedVariance = Math.sqrt(variance) / (Math.abs(mean) + 0.001);\n    \n    return Math.min(1, normalizedVariance);\n  }\n  \n  /**\n   * Calculate noise trend from history\n   */\n  private calculateNoiseTrend(): 'increasing' | 'decreasing' | 'stable' {\n    if (this.noiseHistory.length < 10) return 'stable';\n    \n    const recent = this.noiseHistory.slice(-10);\n    const older = this.noiseHistory.slice(-20, -10);\n    \n    if (older.length === 0) return 'stable';\n    \n    const recentAvg = recent.reduce((sum, p) => sum + p.level, 0) / recent.length;\n    const olderAvg = older.reduce((sum, p) => sum + p.level, 0) / older.length;\n    \n    const diff = recentAvg - olderAvg;\n    if (diff > 0.1) return 'increasing';\n    if (diff < -0.1) return 'decreasing';\n    return 'stable';\n  }\n  \n  /**\n   * Calculate dominant frequency in the noise using autocorrelation\n   */\n  private calculateDominantFrequency(data: number[]): number {\n    if (data.length < 20) return 0;\n    \n    // Detrend the data\n    const trend = this.linearDetrend(data);\n    const detrended = data.map((v, i) => v - trend[i]);\n    \n    // Simple autocorrelation to find periodicity\n    let maxCorr = 0;\n    let dominantPeriod = 0;\n    \n    for (let lag = 2; lag < Math.min(50, data.length / 2); lag++) {\n      let correlation = 0;\n      for (let i = 0; i < data.length - lag; i++) {\n        correlation += detrended[i] * detrended[i + lag];\n      }\n      correlation /= (data.length - lag);\n      \n      if (correlation > maxCorr) {\n        maxCorr = correlation;\n        dominantPeriod = lag;\n      }\n    }\n    \n    // Convert period to frequency (normalized 0-1)\n    return dominantPeriod > 0 ? 1 / dominantPeriod : 0;\n  }\n  \n  /**\n   * Linear detrending\n   */\n  private linearDetrend(data: number[]): number[] {\n    const n = data.length;\n    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n    \n    for (let i = 0; i < n; i++) {\n      sumX += i;\n      sumY += data[i];\n      sumXY += i * data[i];\n      sumX2 += i * i;\n    }\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n    \n    return data.map((_, i) => intercept + slope * i);\n  }\n  \n  /**\n   * Classify the structure of noise\n   */\n  private classifyNoiseStructure(data: number[]): 'random' | 'patterned' | 'chaotic' {\n    if (data.length < 10) return 'random';\n    \n    const noiseLevel = this.calculateNoiseLevel(data);\n    const frequency = this.calculateDominantFrequency(data);\n    \n    // Chaotic: high noise, no clear frequency\n    if (noiseLevel > 0.7 && frequency < 0.1) return 'chaotic';\n    \n    // Patterned: moderate noise, clear frequency\n    if (frequency > 0.2 && noiseLevel < 0.5) return 'patterned';\n    \n    // Random: low-medium noise, some frequency\n    return 'random';\n  }\n  \n  /**\n   * Calculate signal-to-noise ratio\n   */\n  private calculateSNR(data: number[]): number {\n    if (data.length < 5) return 1;\n    \n    // Signal: overall trend\n    const first = data[0];\n    const last = data[data.length - 1];\n    const signalPower = Math.pow(last - first, 2);\n    \n    // Noise: sum of squared deviations from trend\n    const trend = this.linearDetrend(data);\n    const noisePower = data.reduce((sum, v, i) => sum + Math.pow(v - trend[i], 2), 0) / data.length;\n    \n    if (noisePower === 0) return 10; // Very clean signal\n    return Math.min(10, signalPower / noisePower);\n  }\n  \n  /**\n   * Detect noise anomalies that might predict order\n   */\n  private detectAnomalies(current: NoiseProfile): void {\n    if (this.noiseHistory.length < 5) return;\n    \n    const recent = this.noiseHistory.slice(-5, -1);\n    const avgLevel = recent.reduce((sum, p) => sum + p.level, 0) / recent.length;\n    const avgFreq = recent.reduce((sum, p) => sum + p.frequency, 0) / recent.length;\n    \n    // Noise spike\n    if (current.level > avgLevel * 1.5 && current.level > 0.6) {\n      this.anomalyHistory.push({\n        type: 'noise_spike',\n        magnitude: current.level - avgLevel,\n        timestamp: Date.now(),\n        predictiveValue: 0.7, // Spikes often precede reversals\n      });\n    }\n    \n    // Noise collapse\n    if (current.level < avgLevel * 0.5 && current.level < 0.3) {\n      this.anomalyHistory.push({\n        type: 'noise_collapse',\n        magnitude: avgLevel - current.level,\n        timestamp: Date.now(),\n        predictiveValue: 0.8, // Calm before storm\n      });\n    }\n    \n    // Frequency shift\n    if (Math.abs(current.frequency - avgFreq) > 0.2) {\n      this.anomalyHistory.push({\n        type: 'frequency_shift',\n        magnitude: Math.abs(current.frequency - avgFreq),\n        timestamp: Date.now(),\n        predictiveValue: 0.6,\n      });\n    }\n    \n    // Structure change\n    const recentStructures = recent.map(p => p.structure);\n    const mostCommon = this.mode(recentStructures);\n    if (current.structure !== mostCommon) {\n      this.anomalyHistory.push({\n        type: 'structure_change',\n        magnitude: 0.5,\n        timestamp: Date.now(),\n        predictiveValue: 0.65,\n      });\n    }\n    \n    // Prune old anomalies\n    const hourAgo = Date.now() - 3600000;\n    this.anomalyHistory = this.anomalyHistory.filter(a => a.timestamp > hourAgo);\n  }\n  \n  /**\n   * Get mode of an array\n   */\n  private mode<T>(arr: T[]): T {\n    const counts = new Map<T, number>();\n    for (const item of arr) {\n      counts.set(item, (counts.get(item) || 0) + 1);\n    }\n    let maxCount = 0;\n    let modeValue = arr[0];\n    for (const [value, count] of counts) {\n      if (count > maxCount) {\n        maxCount = count;\n        modeValue = value;\n      }\n    }\n    return modeValue;\n  }\n  \n  /**\n   * Get full inverse noise analysis\n   */\n  getInverseNoiseState(priceData: number[], volumeData: number[]): InverseNoiseState {\n    const currentProfile = this.analyzeNoise(priceData, volumeData);\n    const recentAnomalies = this.anomalyHistory.slice(-10);\n    \n    // Determine noise-order cycle\n    let noiseOrderCycle: InverseNoiseState['noiseOrderCycle'] = 'stable_order';\n    if (currentProfile.level > 0.6 && currentProfile.trend === 'increasing') {\n      noiseOrderCycle = 'order_to_chaos';\n    } else if (currentProfile.level > 0.6 && currentProfile.trend === 'stable') {\n      noiseOrderCycle = 'stable_chaos';\n    } else if (currentProfile.level < 0.4 && currentProfile.trend === 'decreasing') {\n      noiseOrderCycle = 'chaos_to_order';\n    }\n    \n    // Generate prediction from noise analysis\n    const prediction = this.predictFromNoise(currentProfile, recentAnomalies);\n    \n    return {\n      currentProfile,\n      recentAnomalies,\n      predictionFromNoise: {\n        ...prediction,\n        confidence: prediction.confidence * this.regularization,\n      },\n      noiseOrderCycle,\n    };\n  }\n  \n  /**\n   * Generate prediction based on noise patterns\n   */\n  private predictFromNoise(\n    profile: NoiseProfile,\n    anomalies: NoiseAnomaly[]\n  ): { direction: 'up' | 'down' | 'neutral'; confidence: number; reasoning: string } {\n    // Key insight: noise collapse often precedes big moves\n    const noiseCollapse = anomalies.find(a => a.type === 'noise_collapse');\n    if (noiseCollapse && noiseCollapse.timestamp > Date.now() - 3600000) {\n      return {\n        direction: 'neutral', // Don't know direction, but expect big move\n        confidence: 0.7,\n        reasoning: 'Noise collapse detected - calm before storm pattern',\n      };\n    }\n    \n    // Noise spike often precedes reversal\n    const noiseSpike = anomalies.find(a => a.type === 'noise_spike');\n    if (noiseSpike && noiseSpike.timestamp > Date.now() - 1800000) {\n      // Check current structure for reversal direction hint\n      if (profile.structure === 'chaotic') {\n        return {\n          direction: 'neutral',\n          confidence: 0.5,\n          reasoning: 'Noise spike in chaos - reversal likely but direction unclear',\n        };\n      }\n    }\n    \n    // Structure change predicts trend change\n    const structureChange = anomalies.find(a => a.type === 'structure_change');\n    if (structureChange) {\n      if (profile.structure === 'patterned') {\n        return {\n          direction: 'up', // Patterns emerging often bullish\n          confidence: 0.55,\n          reasoning: 'Noise structure becoming ordered - trend formation likely',\n        };\n      }\n    }\n    \n    // Default: high noise = uncertain, low noise = continue trend\n    if (profile.level < 0.3 && profile.signalToNoise > 2) {\n      return {\n        direction: 'up', // Low noise + high SNR = trend continuation\n        confidence: 0.5,\n        reasoning: 'Low noise environment - trend likely to continue',\n      };\n    }\n    \n    return {\n      direction: 'neutral',\n      confidence: 0.4,\n      reasoning: 'No clear signal from noise analysis',\n    };\n  }\n  \n  /**\n   * Record outcome for learning\n   */\n  recordOutcome(noiseLevel: number, predictedDirection: string, actualDirection: string): void {\n    this.outcomeHistory.push({\n      noiseLevel,\n      predictedDirection,\n      wasCorrect: predictedDirection === actualDirection,\n    });\n    \n    if (this.outcomeHistory.length > this.maxHistory) {\n      this.outcomeHistory.shift();\n    }\n  }\n  \n  /**\n   * Get accuracy statistics\n   */\n  getAccuracyStats(): { overall: number; byNoiseLevel: Record<string, number> } {\n    if (this.outcomeHistory.length < 10) {\n      return { overall: 0.5, byNoiseLevel: { low: 0.5, medium: 0.5, high: 0.5 } };\n    }\n    \n    const correct = this.outcomeHistory.filter(o => o.wasCorrect).length;\n    \n    const byLevel: Record<string, { correct: number; total: number }> = {\n      low: { correct: 0, total: 0 },\n      medium: { correct: 0, total: 0 },\n      high: { correct: 0, total: 0 },\n    };\n    \n    for (const outcome of this.outcomeHistory) {\n      const level = outcome.noiseLevel < 0.33 ? 'low' : outcome.noiseLevel < 0.66 ? 'medium' : 'high';\n      byLevel[level].total++;\n      if (outcome.wasCorrect) byLevel[level].correct++;\n    }\n    \n    return {\n      overall: correct / this.outcomeHistory.length,\n      byNoiseLevel: {\n        low: byLevel.low.total > 0 ? byLevel.low.correct / byLevel.low.total : 0.5,\n        medium: byLevel.medium.total > 0 ? byLevel.medium.correct / byLevel.medium.total : 0.5,\n        high: byLevel.high.total > 0 ? byLevel.high.correct / byLevel.high.total : 0.5,\n      },\n    };\n  }\n}\n\nexport const inverseNoiseAmplifier = new InverseNoiseAmplifier();\nexport type { NoiseProfile, NoiseAnomaly, InverseNoiseState };\n";export{e as default};
