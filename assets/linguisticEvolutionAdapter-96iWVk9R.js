const n="/**\n * Linguistic Evolution Adapter\n * \n * Language change over time, semantic shift, etymology, neologism emergence.\n * How meaning flows and morphs through human communication networks.\n * \n * For Alec Arthur Shelton - The Artist\n * Words are living things that grow, evolve, and die like organisms.\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\n// SEMANTIC SHIFT PATTERNS\nconst SEMANTIC_SHIFTS = {\n  // Types of meaning change\n  amelioration: {\n    description: 'Word takes on more positive meaning',\n    examples: [\n      { word: 'knight', from: 'servant/boy', to: 'noble warrior' },\n      { word: 'nice', from: 'foolish/ignorant', to: 'pleasant/kind' }\n    ],\n    driver: 'Social elevation of referent',\n    marketAnalogy: 'Rebranding, value appreciation'\n  },\n  \n  pejoration: {\n    description: 'Word takes on more negative meaning',\n    examples: [\n      { word: 'silly', from: 'happy/blessed', to: 'foolish' },\n      { word: 'notorious', from: 'widely known', to: 'infamous' }\n    ],\n    driver: 'Contempt for referent',\n    marketAnalogy: 'Reputation damage, scandal'\n  },\n  \n  generalization: {\n    description: 'Meaning broadens',\n    examples: [\n      { word: 'dog', from: 'specific breed', to: 'all canines' },\n      { word: 'bird', from: 'young fowl', to: 'all avians' }\n    ],\n    driver: 'Category expansion',\n    marketAnalogy: 'Market expansion, TAM growth'\n  },\n  \n  specialization: {\n    description: 'Meaning narrows',\n    examples: [\n      { word: 'meat', from: 'any food', to: 'animal flesh' },\n      { word: 'deer', from: 'any animal', to: 'specific species' }\n    ],\n    driver: 'Category differentiation',\n    marketAnalogy: 'Niche specialization'\n  },\n  \n  metaphoricalExtension: {\n    description: 'Literal meaning gains figurative use',\n    examples: [\n      { word: 'broadband', literal: 'wide frequency range', metaphorical: 'high-speed internet' },\n      { word: 'cloud', literal: 'atmospheric', metaphorical: 'distributed computing' }\n    ],\n    driver: 'Conceptual mapping',\n    marketAnalogy: 'Technology adoption curve'\n  }\n};\n\n// LANGUAGE CHANGE MECHANISMS\nconst CHANGE_MECHANISMS = {\n  soundChange: {\n    grimmLaw: 'Systematic consonant shifts in Germanic languages',\n    greatVowelShift: 'English vowel pronunciation changes 1400-1700',\n    regularity: 'Sound changes apply systematically',\n    marketAnalogy: 'Systematic factor rotations'\n  },\n  \n  analogy: {\n    description: 'Regularizing irregular forms',\n    examples: ['childs → children (by analogy)', 'oxen → oxes (leveling)'],\n    driver: 'System simplification',\n    marketAnalogy: 'Convergence to standard practices'\n  },\n  \n  borrowing: {\n    description: 'Words imported from other languages',\n    englishExamples: {\n      french: ['beef', 'pork', 'government', 'justice'],\n      latin: ['data', 'index', 'formula'],\n      german: ['kindergarten', 'angst', 'waltz'],\n      hindi: ['shampoo', 'bungalow', 'jungle'],\n      arabic: ['algebra', 'algorithm', 'alcohol', 'coffee']\n    },\n    driver: 'Contact, prestige, need',\n    marketAnalogy: 'M&A, technology transfer'\n  },\n  \n  neologism: {\n    types: {\n      coinage: 'brand names becoming generic (xerox, google)',\n      eponym: 'names becoming words (sandwich, boycott)',\n      acronym: 'initialisms becoming words (laser, radar, scuba)',\n      blending: 'portmanteaux (brunch, motel, spork)',\n      clipping: 'shortenings (lab, phone, flu)',\n      derivation: 'affixation (unfriend, bitcoin)'\n    },\n    driver: 'New concept, efficiency, play',\n    marketAnalogy: 'Innovation, IPOs, new asset classes'\n  }\n};\n\n// ETYMOLOGICAL NETWORKS\nconst ETYMOLOGY_PATTERNS = {\n  // Proto-Indo-European roots\n  pieRoots: {\n    mother: {\n      root: '*méh₂tēr',\n      descendants: ['English: mother', 'Latin: mater', 'Greek: meter', 'Sanskrit: matr']\n    },\n    father: {\n      root: '*ph₂tḗr', \n      descendants: ['English: father', 'Latin: pater', 'Greek: pater', 'Sanskrit: pitar']\n    },\n    water: {\n      root: '*wódr̥',\n      descendants: ['English: water', 'Russian: voda', 'Greek: hydor', 'Sanskrit: udan']\n    }\n  },\n  \n  // Cognate distributions\n  cognatePatterns: {\n    description: 'Related words across languages from common ancestor',\n    detection: 'Systematic sound correspondences',\n    marketAnalogy: 'Correlated assets with common factor exposure'\n  }\n};\n\n// SOCIOLINGUISTIC DYNAMICS\nconst SOCIOLINGUISTICS = {\n  prestige: {\n    description: 'Higher-status varieties spread',\n    example: 'Standard English from upper-class London',\n    mechanism: 'Accommodation to power',\n    marketAnalogy: 'Flow to quality, flight to safety'\n  },\n  \n  languageDeath: {\n    stages: [\n      'stable_bilingualism',\n      'language_shift_underway', \n      'semi_speaker_community',\n      'terminal_speakers_only',\n      'extinction'\n    ],\n    rate: 'One language dies every 2 weeks',\n    marketAnalogy: 'Asset delisting, market closure'\n  },\n  \n  creolization: {\n    description: 'Contact language becomes native',\n    process: 'Pidgin → expanded pidgin → creole',\n    examples: ['Haitian Creole', 'Jamaican Patois', 'Tok Pisin'],\n    marketAnalogy: 'Emerging market maturation'\n  }\n};\n\n// COMPUTATIONAL LINGUISTICS\nconst COMPUTATIONAL_METHODS = {\n  word2vec: {\n    description: 'Vector space embeddings capture semantic relationships',\n    analogy: 'king - man + woman ≈ queen',\n    temporalApplication: 'Track semantic drift over time'\n  },\n  \n  diachronicEmbeddings: {\n    description: 'Align embeddings across time periods',\n    detection: 'Words changing vector position = semantic shift',\n    examples: ['gay: happy → homosexual', 'awful: full of awe → terrible']\n  },\n  \n  burstDetection: {\n    description: 'Sudden frequency increases signal neologisms',\n    mechanism: 'Kleinberg burst detection algorithm',\n    marketAnalogy: 'Volume spikes, breakout detection'\n  }\n};\n\ninterface LinguisticEvent {\n  timestamp: number;\n  word: string;\n  frequency: number; // Occurrences per million words\n  semanticVector: number[]; // Word embedding (simplified to magnitude)\n  etymologicalDepth: number; // Years since first attestation\n  borrowings: number; // Number of languages borrowed into\n  semanticShiftRate: number; // 0-1 how fast meaning changing\n  isNeologism: boolean;\n  socialPrestige: number; // 0-1 association with power\n}\n\nclass LinguisticEvolutionAdapter implements DomainAdapter<LinguisticEvent> {\n  domain = 'soul' as const;\n  name = 'Linguistic Evolution & Semantic Shift';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 50000; // Language needs massive corpora\n  \n  // Track word histories\n  private wordHistory: Map<string, {\n    firstSeen: number;\n    frequencyHistory: number[];\n    meaningEvolution: number[];\n  }> = new Map();\n  \n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[LinguisticEvolutionAdapter] Initialized - Language evolution tracking');\n  }\n  \n  processRawData(event: LinguisticEvent): UniversalSignal {\n    const { timestamp, frequency, semanticVector, semanticShiftRate, etymologicalDepth } = event;\n    \n    // Frequency encodes current usage rate\n    const freq = Math.min(frequency / 1000, 1); // Cap at 1000 per million\n    \n    // Intensity = semantic activity (change + neologism status)\n    const intensity = (semanticShiftRate + (event.isNeologism ? 0.5 : 0)) / 1.5;\n    \n    // Phase encodes etymological depth (ancient = stable)\n    const phase = Math.max(0, 1 - (etymologicalDepth / 2000)); // 2000 years = full cycle\n    \n    const vectorMagnitude = Math.sqrt(semanticVector.reduce((sum, v) => sum + v * v, 0));\n    \n    const harmonics = [\n      freq,\n      semanticShiftRate,\n      event.borrowings / 10,\n      event.socialPrestige,\n      vectorMagnitude / 10,\n      event.isNeologism ? 1 : 0\n    ];\n    \n    const signal: UniversalSignal = {\n      domain: 'soul',\n      timestamp,\n      intensity,\n      frequency: freq,\n      phase,\n      harmonics,\n      rawData: [frequency, semanticShiftRate, etymologicalDepth, event.borrowings]\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.updateWordHistory(event);\n    this.lastUpdate = timestamp;\n    return signal;\n  }\n  \n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n    \n    const recent = signals.slice(-10000); // Large sample for language\n    \n    const avgFreq = recent.reduce((sum, s) => sum + s.rawData[0], 0) / recent.length;\n    const avgShift = recent.reduce((sum, s) => sum + s.rawData[1], 0) / recent.length;\n    const avgDepth = recent.reduce((sum, s) => sum + s.rawData[2], 0) / recent.length;\n    const avgBorrow = recent.reduce((sum, s) => sum + s.rawData[3], 0) / recent.length;\n    \n    const quadrantProfile = {\n      aggressive: avgShift > 0.5 ? 0.8 : 0.2, // High semantic shift\n      defensive: avgDepth > 1000 ? 0.7 : 0.3, // Ancient words\n      tactical: avgBorrow > 5 ? 0.6 : 0.3, // Widespread borrowing\n      strategic: avgFreq > 100 ? 0.7 : 0.3 // High frequency words\n    };\n    \n    const temporalFlow = {\n      early: avgDepth < 100 ? 0.8 : 0.1, // New words\n      mid: avgDepth >= 100 && avgDepth < 500 ? 0.7 : 0.2,\n      late: avgDepth >= 500 ? 0.8 : 0.2 // Ancient words\n    };\n    \n    return {\n      domain: 'soul',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgShift,\n      momentum: avgFreq > 50 ? 1 : -1,\n      volatility: avgShift,\n      dominantFrequency: Math.min(avgFreq / 1000, 1),\n      harmonicResonance: 1 - avgShift,\n      phaseAlignment: avgDepth / 2000,\n      extractedAt: Date.now()\n    };\n  }\n  \n  private updateWordHistory(event: LinguisticEvent): void {\n    const existing = this.wordHistory.get(event.word);\n    if (existing) {\n      existing.frequencyHistory.push(event.frequency);\n      existing.meaningEvolution.push(event.semanticVector[0] || 0);\n    } else {\n      this.wordHistory.set(event.word, {\n        firstSeen: event.timestamp,\n        frequencyHistory: [event.frequency],\n        meaningEvolution: [event.semanticVector[0] || 0]\n      });\n    }\n  }\n  \n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'soul',\n      quadrantProfile: { aggressive: 0.2, defensive: 0.4, tactical: 0.2, strategic: 0.2 },\n      temporalFlow: { early: 0.2, mid: 0.3, late: 0.5 },\n      intensity: 0.3,\n      momentum: 0,\n      volatility: 0.3,\n      dominantFrequency: 0.2,\n      harmonicResonance: 0.7,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now()\n    };\n  }\n  \n  // Detect semantic shift type\n  detectShiftType(word: string, oldMeaning: number, newMeaning: number): keyof typeof SEMANTIC_SHIFTS | 'unknown' {\n    const delta = newMeaning - oldMeaning;\n    \n    if (delta > 0.3) return 'amelioration';\n    if (delta < -0.3) return 'pejoration';\n    if (Math.abs(delta) < 0.1) return 'generalization'; // Broadening\n    \n    return 'unknown';\n  }\n  \n  // Predict next neologism hotspot\n  predictNeologismDomain(currentTrends: string[]): string[] {\n    // Based on current tech/social trends\n    const techPrefixes = ['meta', 'crypto', 'neuro', 'quantum', 'bio'];\n    const socialSuffixes = ['-verse', '-conomy', '-ology', '-ification'];\n    \n    const predictions: string[] = [];\n    for (const prefix of techPrefixes) {\n      for (const suffix of socialSuffixes) {\n        predictions.push(prefix + suffix);\n      }\n    }\n    \n    return predictions;\n  }\n}\n\nexport const linguisticEvolutionAdapter = new LinguisticEvolutionAdapter();\nexport { SEMANTIC_SHIFTS, CHANGE_MECHANISMS, ETYMOLOGY_PATTERNS, SOCIOLINGUISTICS, COMPUTATIONAL_METHODS };\nexport type { LinguisticEvent };\n";export{n as default};
