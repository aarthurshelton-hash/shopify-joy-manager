const n='/**\n * Photonic Coherence Panel\n * \n * Visualizes the photonic computing architecture\'s state,\n * including channel coherence, entanglement, and glitch detection.\n */\n\nimport React, { useEffect, useState, useCallback } from \'react\';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \'@/components/ui/card\';\nimport { Badge } from \'@/components/ui/badge\';\nimport { Progress } from \'@/components/ui/progress\';\nimport { motion } from \'framer-motion\';\nimport { Sparkles, Radio, Waves, Zap, Eye, Activity } from \'lucide-react\';\nimport {\n  photonicEngine,\n  DOMAIN_WAVELENGTHS,\n  PhotonicDomain\n} from \'@/lib/pensent-core/architecture/photonicComputing\';\n\ninterface PhotonicSummary {\n  globalCoherence: number;\n  entanglementStrength: number;\n  totalEnergy: number;\n  dominantWavelength: number;\n  dominantDomain: string;\n  channelStates: Array<{\n    domain: string;\n    wavelength: number;\n    amplitude: number;\n    phase: number;\n    coherence: number;\n    color: string;\n  }>;\n  glitch: {\n    detected: boolean;\n    type: string | null;\n    confidence: number;\n    description: string;\n  };\n}\n\n// Convert wavelength to visible color (HSL)\nfunction wavelengthToColor(wavelength: number): string {\n  // Map 380-850nm to hue 270-0 (violet to red to infrared)\n  const normalized = Math.max(0, Math.min(1, (wavelength - 380) / 470));\n  const hue = 270 - normalized * 300; // Wraps around through red\n  return `hsl(${hue < 0 ? hue + 360 : hue}, 80%, 50%)`;\n}\n\nexport function PhotonicCoherencePanel() {\n  const [summary, setSummary] = useState<PhotonicSummary | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  const refreshData = useCallback(() => {\n    // Inject some random signals to simulate activity\n    const domains = Object.keys(DOMAIN_WAVELENGTHS) as PhotonicDomain[];\n    domains.forEach(domain => {\n      photonicEngine.injectSignal(domain, {\n        amplitude: 0.3 + Math.random() * 0.7,\n        phase: Math.random() * 2 * Math.PI,\n        coherence: 0.5 + Math.random() * 0.5\n      });\n    });\n\n    const state = photonicEngine.getUnifiedState();\n    const glitch = photonicEngine.detectGlitchInMatrix();\n\n    // Find dominant domain by wavelength\n    let dominantDomain = \'unknown\';\n    let minDiff = Infinity;\n    Object.entries(DOMAIN_WAVELENGTHS).forEach(([domain, wavelength]) => {\n      const diff = Math.abs(wavelength - state.dominantWavelength);\n      if (diff < minDiff) {\n        minDiff = diff;\n        dominantDomain = domain;\n      }\n    });\n\n    const channelStates = Array.from(state.channels.values()).map(channel => ({\n      domain: channel.domain,\n      wavelength: channel.state.wavelength,\n      amplitude: channel.state.amplitude,\n      phase: channel.state.phase,\n      coherence: channel.state.coherence,\n      color: wavelengthToColor(channel.state.wavelength)\n    })).sort((a, b) => a.wavelength - b.wavelength);\n\n    setSummary({\n      globalCoherence: state.globalCoherence,\n      entanglementStrength: state.entanglementStrength,\n      totalEnergy: state.totalEnergy,\n      dominantWavelength: state.dominantWavelength,\n      dominantDomain,\n      channelStates,\n      glitch: {\n        detected: glitch.detected,\n        type: glitch.type,\n        confidence: glitch.confidence,\n        description: glitch.description\n      }\n    });\n    setLoading(false);\n  }, []);\n\n  useEffect(() => {\n    refreshData();\n    const interval = setInterval(refreshData, 2000); // Update every 2 seconds\n    return () => clearInterval(interval);\n  }, [refreshData]);\n\n  if (loading || !summary) {\n    return (\n      <Card className="bg-card/50 backdrop-blur border-primary/20">\n        <CardContent className="p-8 text-center">\n          <Sparkles className="w-8 h-8 mx-auto animate-pulse text-primary" />\n          <p className="mt-4 text-muted-foreground">Calibrating photonic channels...</p>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return (\n    <Card className="bg-card/80 backdrop-blur border-primary/20 overflow-hidden relative">\n      {/* Glitch overlay when detected */}\n      {summary.glitch.detected && (\n        <motion.div\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          className="absolute inset-0 bg-gradient-to-r from-purple-500/10 via-pink-500/10 to-purple-500/10 pointer-events-none z-10"\n        />\n      )}\n      \n      <CardHeader>\n        <CardTitle className="flex items-center gap-2">\n          <Radio className="w-5 h-5 text-primary" />\n          Photonic Coherence\n        </CardTitle>\n        <CardDescription>\n          Light-speed domain synchronization & quantum entanglement\n        </CardDescription>\n      </CardHeader>\n      <CardContent className="space-y-4">\n        {/* Core Metrics */}\n        <div className="grid grid-cols-2 gap-3">\n          <div className="p-3 bg-primary/5 rounded-lg">\n            <div className="flex items-center gap-2 mb-1">\n              <Waves className="w-3 h-3 text-primary" />\n              <p className="text-xs text-muted-foreground">Global Coherence</p>\n            </div>\n            <p className="text-2xl font-bold">{(summary.globalCoherence * 100).toFixed(1)}%</p>\n            <Progress value={summary.globalCoherence * 100} className="h-1.5 mt-1" />\n          </div>\n          <div className="p-3 bg-primary/5 rounded-lg">\n            <div className="flex items-center gap-2 mb-1">\n              <Zap className="w-3 h-3 text-purple-400" />\n              <p className="text-xs text-muted-foreground">Entanglement</p>\n            </div>\n            <p className="text-2xl font-bold">{(summary.entanglementStrength * 100).toFixed(1)}%</p>\n            <Progress value={summary.entanglementStrength * 100} className="h-1.5 mt-1" />\n          </div>\n        </div>\n\n        {/* Dominant Domain */}\n        <div className="flex items-center justify-between p-2 bg-muted/30 rounded">\n          <span className="text-xs text-muted-foreground">Dominant Domain</span>\n          <Badge \n            variant="outline" \n            style={{ borderColor: wavelengthToColor(summary.dominantWavelength) }}\n          >\n            {summary.dominantDomain.toUpperCase()}\n            <span className="ml-1 text-[10px] opacity-70">{summary.dominantWavelength}nm</span>\n          </Badge>\n        </div>\n\n        {/* Spectrum Visualization */}\n        <div className="space-y-1">\n          <p className="text-xs text-muted-foreground mb-2">Channel Spectrum</p>\n          <div className="flex gap-0.5 h-8 rounded overflow-hidden">\n            {summary.channelStates.map(channel => (\n              <motion.div\n                key={channel.domain}\n                className="relative group"\n                style={{ \n                  flex: channel.amplitude,\n                  backgroundColor: channel.color,\n                  opacity: 0.3 + channel.coherence * 0.7\n                }}\n                animate={{ \n                  opacity: [0.3 + channel.coherence * 0.7, 0.5 + channel.coherence * 0.5, 0.3 + channel.coherence * 0.7]\n                }}\n                transition={{ duration: 2, repeat: Infinity }}\n                title={`${channel.domain}: ${channel.wavelength}nm`}\n              >\n                <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1 opacity-0 group-hover:opacity-100 transition-opacity">\n                  <Badge variant="outline" className="text-[10px] whitespace-nowrap">\n                    {channel.domain}\n                  </Badge>\n                </div>\n              </motion.div>\n            ))}\n          </div>\n          <div className="flex justify-between text-[10px] text-muted-foreground">\n            <span>UV (380nm)</span>\n            <span>IR (850nm)</span>\n          </div>\n        </div>\n\n        {/* Glitch Detection */}\n        <motion.div\n          className={`p-3 rounded-lg ${\n            summary.glitch.detected \n              ? \'bg-gradient-to-r from-purple-500/20 to-pink-500/20 border border-purple-500/30\'\n              : \'bg-muted/30\'\n          }`}\n          animate={summary.glitch.detected ? { scale: [1, 1.02, 1] } : {}}\n          transition={{ duration: 1, repeat: Infinity }}\n        >\n          <div className="flex items-center gap-2 mb-1">\n            <Eye className={`w-4 h-4 ${summary.glitch.detected ? \'text-purple-400\' : \'text-muted-foreground\'}`} />\n            <span className="text-sm font-medium">Matrix Glitch Detector</span>\n            {summary.glitch.detected && (\n              <Badge className="ml-auto bg-purple-500/20 text-purple-300 border-purple-500/30">\n                {summary.glitch.type}\n              </Badge>\n            )}\n          </div>\n          <p className="text-xs text-muted-foreground">\n            {summary.glitch.description}\n          </p>\n          {summary.glitch.detected && (\n            <div className="flex items-center gap-2 mt-2">\n              <Activity className="w-3 h-3 text-purple-400" />\n              <Progress value={summary.glitch.confidence * 100} className="h-1 flex-1" />\n              <span className="text-xs">{(summary.glitch.confidence * 100).toFixed(0)}%</span>\n            </div>\n          )}\n        </motion.div>\n      </CardContent>\n    </Card>\n  );\n}\n';export{n as default};
