const e="/**\n * Learning State Manager - Manages prediction learning state updates\n */\n\nimport { LearningState, MultiLevelAccuracy, TickPrediction, EngineConfig, MultiLevelPerformance } from './types';\n\nexport function createInitialLearningState(): LearningState {\n  return {\n    totalPredictions: 0,\n    correctPredictions: 0,\n    accuracy: 0,\n    streak: 0,\n    bestStreak: 0,\n    recentAccuracy: 0,\n    confidenceMultiplier: 1.0,\n    adaptiveHorizonMs: 5000,\n    volatilityState: 'medium',\n    momentumBias: 0,\n    lastUpdate: Date.now(),\n    multiLevel: createInitialMultiLevel()\n  };\n}\n\nfunction createInitialMultiLevel(): MultiLevelPerformance {\n  return {\n    direction: { correct: 0, total: 0, accuracy: 0 },\n    magnitude: { avgScore: 0, samples: 0 },\n    timing: { avgScore: 0, samples: 0 },\n    confidenceCalibration: { predicted: 0, actual: 0, calibrationError: 0 },\n    composite: { avgScore: 0, trend: 0 }\n  };\n}\n\nexport function updateLearningState(\n  state: LearningState,\n  wasCorrect: boolean,\n  prediction: TickPrediction,\n  accuracyLevels: MultiLevelAccuracy | undefined,\n  recentResults: boolean[],\n  config: EngineConfig\n): LearningState {\n  const newState = { ...state };\n  \n  newState.totalPredictions++;\n  if (wasCorrect) {\n    newState.correctPredictions++;\n    newState.streak++;\n    newState.bestStreak = Math.max(newState.bestStreak, newState.streak);\n  } else {\n    newState.streak = 0;\n  }\n  \n  newState.accuracy = (newState.correctPredictions / newState.totalPredictions) * 100;\n  newState.recentAccuracy = (recentResults.filter(r => r).length / Math.max(recentResults.length, 1)) * 100;\n  \n  if (accuracyLevels) {\n    updateMultiLevel(newState, accuracyLevels, prediction);\n  }\n  \n  // Adapt confidence multiplier\n  if (newState.recentAccuracy > 70) {\n    newState.confidenceMultiplier = Math.min(1.5, newState.confidenceMultiplier + config.learningRate * 0.1);\n  } else if (newState.recentAccuracy < 45) {\n    newState.confidenceMultiplier = Math.max(0.6, newState.confidenceMultiplier - config.learningRate * 0.1);\n  }\n  \n  // Adapt prediction horizon\n  const compositeScore = newState.multiLevel.composite.avgScore;\n  if (compositeScore > 65 && newState.adaptiveHorizonMs > config.minHorizonMs) {\n    newState.adaptiveHorizonMs = Math.max(config.minHorizonMs, newState.adaptiveHorizonMs - 500);\n  } else if (compositeScore < 45 && newState.adaptiveHorizonMs < config.maxHorizonMs) {\n    newState.adaptiveHorizonMs = Math.min(config.maxHorizonMs, newState.adaptiveHorizonMs + 500);\n  }\n  \n  // Update momentum bias\n  if (wasCorrect && prediction.predictedDirection === 'up') {\n    newState.momentumBias = Math.min(1, newState.momentumBias + config.learningRate);\n  } else if (wasCorrect && prediction.predictedDirection === 'down') {\n    newState.momentumBias = Math.max(-1, newState.momentumBias - config.learningRate);\n  } else {\n    newState.momentumBias *= 0.9;\n  }\n  \n  newState.lastUpdate = Date.now();\n  return newState;\n}\n\nfunction updateMultiLevel(state: LearningState, accuracyLevels: MultiLevelAccuracy, prediction: TickPrediction): void {\n  const ml = state.multiLevel;\n  \n  // Direction tracking\n  ml.direction.total++;\n  if (accuracyLevels.direction === 100) ml.direction.correct++;\n  ml.direction.accuracy = (ml.direction.correct / ml.direction.total) * 100;\n  \n  // Magnitude tracking\n  ml.magnitude.samples++;\n  ml.magnitude.avgScore = (\n    (ml.magnitude.avgScore * (ml.magnitude.samples - 1) + accuracyLevels.magnitude) / ml.magnitude.samples\n  );\n  \n  // Timing tracking\n  ml.timing.samples++;\n  ml.timing.avgScore = (\n    (ml.timing.avgScore * (ml.timing.samples - 1) + accuracyLevels.timing) / ml.timing.samples\n  );\n  \n  // Confidence calibration\n  ml.confidenceCalibration.predicted = (\n    (ml.confidenceCalibration.predicted * (state.totalPredictions - 1) + prediction.confidence) / state.totalPredictions\n  );\n  ml.confidenceCalibration.actual = (state.correctPredictions / state.totalPredictions) * 100;\n  ml.confidenceCalibration.calibrationError = Math.abs(\n    ml.confidenceCalibration.predicted - ml.confidenceCalibration.actual\n  );\n  \n  // Composite tracking\n  const prevComposite = ml.composite.avgScore;\n  ml.composite.avgScore = (\n    (ml.composite.avgScore * (state.totalPredictions - 1) + accuracyLevels.composite) / state.totalPredictions\n  );\n  ml.composite.trend = ml.composite.avgScore - prevComposite;\n}\n";export{e as default};
