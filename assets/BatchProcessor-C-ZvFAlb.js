const n="/**\n * En Pensent Core SDK - Batch Processor\n */\n\nimport { TemporalSignature, DomainAdapter } from '../types';\nimport { AnalysisPipeline, createPipeline } from '../pipeline';\nimport { PensentEventBus, createEventBus } from '../eventBus';\nimport {\n  BatchInput,\n  BatchResult,\n  BatchProgress,\n  BatchConfig,\n  BatchAggregation,\n  DEFAULT_BATCH_CONFIG\n} from './types';\n\n/**\n * Batch processor for analyzing multiple inputs\n */\nexport class BatchProcessor<TInput, TState> {\n  private adapter: DomainAdapter<TInput, TState>;\n  private pipeline: AnalysisPipeline<TInput, TState>;\n  private eventBus: PensentEventBus;\n  private config: BatchConfig;\n\n  constructor(\n    adapter: DomainAdapter<TInput, TState>,\n    config: Partial<BatchConfig> = {}\n  ) {\n    this.adapter = adapter;\n    this.pipeline = createPipeline(adapter);\n    this.eventBus = createEventBus(`${adapter.domain}_batch`);\n    this.config = { ...DEFAULT_BATCH_CONFIG, ...config };\n  }\n\n  /**\n   * Process a batch of inputs\n   */\n  async processBatch(\n    inputs: BatchInput<TInput>[]\n  ): Promise<BatchResult<TemporalSignature>[]> {\n    const results: BatchResult<TemporalSignature>[] = [];\n    const startTime = performance.now();\n    let completedCount = 0;\n    let failedCount = 0;\n    const processingTimes: number[] = [];\n\n    // Sort by priority if specified\n    const sortedInputs = [...inputs].sort((a, b) => \n      (b.priority ?? 0) - (a.priority ?? 0)\n    );\n\n    this.eventBus.emit('batch:started', {\n      total: inputs.length,\n      concurrency: this.config.concurrency\n    });\n\n    // Process in chunks based on concurrency\n    for (let i = 0; i < sortedInputs.length; i += this.config.concurrency) {\n      const chunk = sortedInputs.slice(i, i + this.config.concurrency);\n      \n      const chunkResults = await Promise.all(\n        chunk.map(input => this.processItem(input))\n      );\n\n      for (const result of chunkResults) {\n        results.push(result);\n        processingTimes.push(result.processingTimeMs);\n        \n        if (result.success) {\n          completedCount++;\n        } else {\n          failedCount++;\n          if (!this.config.continueOnError) {\n            throw result.error ?? new Error('Batch processing failed');\n          }\n        }\n      }\n\n      // Report progress\n      const progress = this.calculateProgress(\n        sortedInputs.length,\n        completedCount,\n        failedCount,\n        processingTimes,\n        startTime,\n        chunk[chunk.length - 1]?.id\n      );\n\n      this.eventBus.emit('batch:progress', progress);\n      this.config.onProgress?.(progress);\n\n      // Apply delay between chunks if configured\n      if (this.config.itemDelayMs && i + this.config.concurrency < sortedInputs.length) {\n        await new Promise(resolve => setTimeout(resolve, this.config.itemDelayMs));\n      }\n    }\n\n    this.eventBus.emit('batch:completed', {\n      total: inputs.length,\n      succeeded: completedCount,\n      failed: failedCount,\n      totalTimeMs: performance.now() - startTime\n    });\n\n    return results;\n  }\n\n  /**\n   * Process a single item\n   */\n  private async processItem(\n    input: BatchInput<TInput>\n  ): Promise<BatchResult<TemporalSignature>> {\n    const startTime = performance.now();\n\n    try {\n      const context = await this.pipeline.execute(input.data);\n      \n      if (context.error) {\n        throw context.error;\n      }\n\n      return {\n        id: input.id,\n        success: true,\n        result: context.signature,\n        processingTimeMs: performance.now() - startTime\n      };\n    } catch (error) {\n      return {\n        id: input.id,\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        processingTimeMs: performance.now() - startTime\n      };\n    }\n  }\n\n  /**\n   * Calculate progress metrics\n   */\n  private calculateProgress(\n    total: number,\n    completed: number,\n    failed: number,\n    processingTimes: number[],\n    startTime: number,\n    currentItem?: string\n  ): BatchProgress {\n    const avgTime = processingTimes.length > 0\n      ? processingTimes.reduce((a, b) => a + b, 0) / processingTimes.length\n      : 0;\n    \n    const remaining = total - completed - failed;\n    const estimatedRemainingMs = remaining * avgTime;\n\n    return {\n      total,\n      completed,\n      failed,\n      percentage: ((completed + failed) / total) * 100,\n      estimatedRemainingMs,\n      currentItem\n    };\n  }\n\n  /**\n   * Aggregate results for analysis\n   */\n  aggregateResults(\n    results: BatchResult<TemporalSignature>[]\n  ): BatchAggregation {\n    const successfulResults = results.filter(r => r.success && r.result);\n    const signatures = successfulResults.map(r => r.result!);\n\n    const archetypeDistribution: Record<string, number> = {};\n    let totalIntensity = 0;\n\n    for (const sig of signatures) {\n      archetypeDistribution[sig.archetype] = \n        (archetypeDistribution[sig.archetype] ?? 0) + 1;\n      totalIntensity += sig.intensity;\n    }\n\n    const totalTime = results.reduce((sum, r) => sum + r.processingTimeMs, 0);\n\n    return {\n      totalItems: results.length,\n      successCount: successfulResults.length,\n      failureCount: results.length - successfulResults.length,\n      totalProcessingTimeMs: totalTime,\n      averageProcessingTimeMs: totalTime / results.length,\n      archetypeDistribution,\n      outcomeDistribution: {},\n      averageIntensity: signatures.length > 0 ? totalIntensity / signatures.length : 0,\n      averageConfidence: 0\n    };\n  }\n\n  /**\n   * Get the event bus for subscribing to batch events\n   */\n  getEventBus(): PensentEventBus {\n    return this.eventBus;\n  }\n\n  /**\n   * Configure the underlying pipeline\n   */\n  configurePipeline(): AnalysisPipeline<TInput, TState> {\n    return this.pipeline;\n  }\n}\n";export{n as default};
