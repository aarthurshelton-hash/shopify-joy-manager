const n="/**\n * En Pensentâ„¢ Tick Prediction Engine\n * Real-time scalping predictions with adaptive learning\n * \n * Refactored: Modular architecture with separated concerns\n */\n\nimport {\n  Tick,\n  TickPrediction,\n  LearningState,\n  EngineConfig,\n  DEFAULT_ENGINE_CONFIG\n} from './prediction/types';\nimport {\n  calculateMomentum,\n  calculateVolatility,\n  detectMicroTrend,\n  analyzeVolumePattern,\n  getVolatilityState\n} from './prediction/marketAnalysis';\nimport { calculateMultiLevelAccuracy } from './prediction/accuracyCalculator';\nimport { createInitialLearningState, updateLearningState } from './prediction/learningStateManager';\n\n// Re-export types for backwards compatibility\nexport * from './prediction/types';\n\nexport class TickPredictionEngine {\n  private ticks: Tick[] = [];\n  private predictions: Map<string, TickPrediction> = new Map();\n  private learningState: LearningState;\n  private config: EngineConfig;\n  private recentResults: boolean[] = [];\n  \n  constructor(config: Partial<EngineConfig> = {}) {\n    this.config = { ...DEFAULT_ENGINE_CONFIG, ...config };\n    this.learningState = createInitialLearningState();\n  }\n  \n  processTick(tick: Tick): void {\n    this.ticks.push(tick);\n    if (this.ticks.length > 500) {\n      this.ticks.shift();\n    }\n    this.updateMarketState();\n    this.resolveExpiredPredictions(tick);\n  }\n  \n  generatePrediction(horizonMs?: number): TickPrediction | null {\n    if (this.ticks.length < this.config.minTicksForPrediction) {\n      return null;\n    }\n    \n    const effectiveHorizon = horizonMs || this.learningState.adaptiveHorizonMs;\n    const currentTick = this.ticks[this.ticks.length - 1];\n    \n    const momentum = calculateMomentum(this.ticks, this.config.momentumWindow);\n    const volatility = calculateVolatility(this.ticks, this.config.volatilityWindow);\n    const microTrend = detectMicroTrend(this.ticks);\n    const volumeSignal = analyzeVolumePattern(this.ticks);\n    \n    const signalSum = momentum * 0.35 + microTrend * 0.30 + volumeSignal * 0.20 + this.learningState.momentumBias * 0.15;\n    \n    let direction: 'up' | 'down' | 'flat';\n    if (signalSum > 0.15) direction = 'up';\n    else if (signalSum < -0.15) direction = 'down';\n    else direction = 'flat';\n    \n    const confidence = this.calculateConfidence(signalSum, volatility);\n    \n    const avgMove = volatility * (effectiveHorizon / 1000);\n    const targetPrice = direction === 'up' \n      ? currentTick.price * (1 + avgMove)\n      : direction === 'down' ? currentTick.price * (1 - avgMove) : currentTick.price;\n    \n    const prediction: TickPrediction = {\n      id: `pred-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n      timestamp: Date.now(),\n      predictedDirection: direction,\n      confidence: Math.round(confidence),\n      horizonMs: effectiveHorizon,\n      priceAtPrediction: currentTick.price,\n      targetPrice,\n      expiresAt: Date.now() + effectiveHorizon\n    };\n    \n    this.predictions.set(prediction.id, prediction);\n    return prediction;\n  }\n  \n  private calculateConfidence(signalStrength: number, volatility: number): number {\n    const absSignal = Math.abs(signalStrength);\n    let confidence = this.config.baseConfidence + (absSignal * 40);\n    confidence *= this.learningState.confidenceMultiplier;\n    \n    if (this.learningState.volatilityState === 'extreme') confidence *= 0.7;\n    else if (this.learningState.volatilityState === 'low') confidence *= 1.1;\n    \n    if (this.learningState.streak >= 5) {\n      confidence *= 1 + (this.learningState.streak * 0.02);\n    }\n    \n    return Math.min(95, Math.max(25, confidence));\n  }\n  \n  private resolveExpiredPredictions(currentTick: Tick): void {\n    const now = Date.now();\n    \n    for (const [id, pred] of this.predictions) {\n      if (pred.resolved || pred.expiresAt > now) continue;\n      \n      const priceDiff = currentTick.price - pred.priceAtPrediction;\n      const percentChange = (priceDiff / pred.priceAtPrediction) * 100;\n      const actualMagnitude = Math.abs(percentChange);\n      \n      let actualDirection: 'up' | 'down' | 'flat';\n      const flatThreshold = 0.01;\n      \n      if (percentChange > flatThreshold) actualDirection = 'up';\n      else if (percentChange < -flatThreshold) actualDirection = 'down';\n      else actualDirection = 'flat';\n      \n      const wasCorrect = pred.predictedDirection === actualDirection;\n      const accuracyLevels = calculateMultiLevelAccuracy(pred, actualDirection, actualMagnitude);\n      \n      pred.resolved = true;\n      pred.wasCorrect = wasCorrect;\n      pred.actualDirection = actualDirection;\n      pred.actualPrice = currentTick.price;\n      pred.accuracyLevels = accuracyLevels;\n      \n      this.recentResults.push(wasCorrect);\n      if (this.recentResults.length > 20) this.recentResults.shift();\n      \n      this.learningState = updateLearningState(\n        this.learningState,\n        wasCorrect,\n        pred,\n        accuracyLevels,\n        this.recentResults,\n        this.config\n      );\n    }\n    \n    this.cleanupOldPredictions();\n  }\n  \n  private cleanupOldPredictions(): void {\n    const resolved = Array.from(this.predictions.values())\n      .filter(p => p.resolved)\n      .sort((a, b) => b.timestamp - a.timestamp);\n    \n    if (resolved.length > 100) {\n      for (const old of resolved.slice(100)) {\n        this.predictions.delete(old.id);\n      }\n    }\n  }\n  \n  private updateMarketState(): void {\n    const volatility = calculateVolatility(this.ticks, this.config.volatilityWindow);\n    this.learningState.volatilityState = getVolatilityState(volatility);\n  }\n  \n  getState(): LearningState { return { ...this.learningState }; }\n  getPendingPredictions(): TickPrediction[] {\n    return Array.from(this.predictions.values()).filter(p => !p.resolved).sort((a, b) => a.expiresAt - b.expiresAt);\n  }\n  getRecentPredictions(count: number = 20): TickPrediction[] {\n    return Array.from(this.predictions.values()).filter(p => p.resolved).sort((a, b) => b.timestamp - a.timestamp).slice(0, count);\n  }\n  getStats() {\n    const resolved = Array.from(this.predictions.values()).filter(p => p.resolved);\n    const calcStats = (preds: TickPrediction[]) => ({\n      total: preds.length,\n      correct: preds.filter(p => p.wasCorrect).length,\n      accuracy: preds.length > 0 ? (preds.filter(p => p.wasCorrect).length / preds.length) * 100 : 0\n    });\n    return {\n      totalPredictions: this.learningState.totalPredictions,\n      accuracy: this.learningState.accuracy,\n      recentAccuracy: this.learningState.recentAccuracy,\n      currentStreak: this.learningState.streak,\n      bestStreak: this.learningState.bestStreak,\n      upPredictions: calcStats(resolved.filter(p => p.predictedDirection === 'up')),\n      downPredictions: calcStats(resolved.filter(p => p.predictedDirection === 'down')),\n      flatPredictions: calcStats(resolved.filter(p => p.predictedDirection === 'flat'))\n    };\n  }\n  reset(): void {\n    this.ticks = [];\n    this.predictions.clear();\n    this.recentResults = [];\n    this.learningState = createInitialLearningState();\n  }\n  getTickCount(): number { return this.ticks.length; }\n  getLatestTick(): Tick | null { return this.ticks.length > 0 ? this.ticks[this.ticks.length - 1] : null; }\n}\n\nlet engineInstance: TickPredictionEngine | null = null;\n\nexport function getTickPredictionEngine(config?: Partial<EngineConfig>): TickPredictionEngine {\n  if (!engineInstance) engineInstance = new TickPredictionEngine(config);\n  return engineInstance;\n}\n\nexport function resetTickPredictionEngine(): void {\n  if (engineInstance) engineInstance.reset();\n  engineInstance = null;\n}\n";export{n as default};
