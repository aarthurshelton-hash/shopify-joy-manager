const e="/**\n * En Pensent Core SDK - Pattern Matcher Tests\n * \n * Tests for similarity scoring, pattern matching accuracy, \n * and archetype fuzzy matching.\n */\n\nimport { describe, it, expect } from 'vitest';\nimport {\n  quadrantSimilarity,\n  temporalFlowSimilarity,\n  calculateSignatureSimilarity,\n  findSimilarPatterns,\n  calculateOutcomeProbabilities,\n  getMostLikelyOutcome,\n  calculatePatternDiversity,\n  calculateMatchConfidence\n} from './patternMatcher';\nimport { TemporalSignature, QuadrantProfile, TemporalFlow, PatternMatch } from './types';\n\n// Test fixtures\nconst createMockSignature = (overrides: Partial<TemporalSignature> = {}): TemporalSignature => ({\n  fingerprint: 'EP-TEST0001',\n  archetype: 'test_archetype',\n  dominantForce: 'balanced',\n  flowDirection: 'forward',\n  intensity: 0.5,\n  quadrantProfile: { q1: 0.25, q2: 0.25, q3: 0.25, q4: 0.25 },\n  temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 },\n  criticalMoments: [],\n  ...overrides\n});\n\nconst createMockMatch = (overrides: Partial<PatternMatch> = {}): PatternMatch => ({\n  patternId: 'pattern-1',\n  similarity: 0.8,\n  signature: createMockSignature(),\n  outcome: 'success',\n  ...overrides\n});\n\ndescribe('patternMatcher', () => {\n  // ============================================================================\n  // quadrantSimilarity\n  // ============================================================================\n  describe('quadrantSimilarity', () => {\n    it('should return 1 for identical profiles', () => {\n      const profile: QuadrantProfile = { q1: 0.25, q2: 0.25, q3: 0.25, q4: 0.25 };\n      \n      const similarity = quadrantSimilarity(profile, profile);\n      \n      expect(similarity).toBe(1);\n    });\n\n    it('should return 0 for completely opposite profiles', () => {\n      const profileA: QuadrantProfile = { q1: 1, q2: 0, q3: 0, q4: 0 };\n      const profileB: QuadrantProfile = { q1: 0, q2: 0, q3: 0, q4: 1 };\n      \n      const similarity = quadrantSimilarity(profileA, profileB);\n      \n      expect(similarity).toBe(0.5); // Diff is 2, so 1 - 2/4 = 0.5\n    });\n\n    it('should return value between 0 and 1', () => {\n      const profileA: QuadrantProfile = { q1: 0.4, q2: 0.3, q3: 0.2, q4: 0.1 };\n      const profileB: QuadrantProfile = { q1: 0.1, q2: 0.2, q3: 0.3, q4: 0.4 };\n      \n      const similarity = quadrantSimilarity(profileA, profileB);\n      \n      expect(similarity).toBeGreaterThanOrEqual(0);\n      expect(similarity).toBeLessThanOrEqual(1);\n    });\n\n    it('should be symmetric', () => {\n      const profileA: QuadrantProfile = { q1: 0.5, q2: 0.2, q3: 0.2, q4: 0.1 };\n      const profileB: QuadrantProfile = { q1: 0.3, q2: 0.3, q3: 0.2, q4: 0.2 };\n      \n      const simAB = quadrantSimilarity(profileA, profileB);\n      const simBA = quadrantSimilarity(profileB, profileA);\n      \n      expect(simAB).toBeCloseTo(simBA);\n    });\n\n    it('should handle edge case with all zeros', () => {\n      const profile: QuadrantProfile = { q1: 0, q2: 0, q3: 0, q4: 0 };\n      \n      const similarity = quadrantSimilarity(profile, profile);\n      \n      expect(similarity).toBe(1);\n    });\n  });\n\n  // ============================================================================\n  // temporalFlowSimilarity\n  // ============================================================================\n  describe('temporalFlowSimilarity', () => {\n    it('should return high value for identical flows', () => {\n      const flow: TemporalFlow = { opening: 0.5, middle: 0.6, ending: 0.7, trend: 'accelerating', momentum: 0.3 };\n      \n      const similarity = temporalFlowSimilarity(flow, flow);\n      \n      expect(similarity).toBeGreaterThan(0.9);\n    });\n\n    it('should give trend matching bonus', () => {\n      const flowA: TemporalFlow = { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 };\n      const flowB: TemporalFlow = { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'accelerating', momentum: 0 };\n      \n      const sameTrend = temporalFlowSimilarity(flowA, flowA);\n      const diffTrend = temporalFlowSimilarity(flowA, flowB);\n      \n      expect(sameTrend).toBeGreaterThan(diffTrend);\n    });\n\n    it('should factor in momentum similarity', () => {\n      const flowA: TemporalFlow = { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0.8 };\n      const flowB: TemporalFlow = { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: -0.8 };\n      \n      const similarity = temporalFlowSimilarity(flowA, flowB);\n      \n      expect(similarity).toBeLessThan(1);\n    });\n\n    it('should handle extreme phase differences', () => {\n      const flowA: TemporalFlow = { opening: 0, middle: 0, ending: 0, trend: 'stable', momentum: 0 };\n      const flowB: TemporalFlow = { opening: 1, middle: 1, ending: 1, trend: 'stable', momentum: 0 };\n      \n      const similarity = temporalFlowSimilarity(flowA, flowB);\n      \n      expect(similarity).toBeGreaterThanOrEqual(0);\n      expect(similarity).toBeLessThanOrEqual(1);\n    });\n\n    it('should be symmetric', () => {\n      const flowA: TemporalFlow = { opening: 0.3, middle: 0.6, ending: 0.9, trend: 'accelerating', momentum: 0.5 };\n      const flowB: TemporalFlow = { opening: 0.7, middle: 0.4, ending: 0.3, trend: 'declining', momentum: -0.3 };\n      \n      const simAB = temporalFlowSimilarity(flowA, flowB);\n      const simBA = temporalFlowSimilarity(flowB, flowA);\n      \n      expect(simAB).toBeCloseTo(simBA);\n    });\n  });\n\n  // ============================================================================\n  // calculateSignatureSimilarity\n  // ============================================================================\n  describe('calculateSignatureSimilarity', () => {\n    it('should return 1 for identical signatures', () => {\n      const signature = createMockSignature();\n      \n      const similarity = calculateSignatureSimilarity(signature, signature);\n      \n      expect(similarity).toBeCloseTo(1);\n    });\n\n    it('should give bonus for matching archetype', () => {\n      const sigA = createMockSignature({ archetype: 'same_archetype' });\n      const sigB = createMockSignature({ archetype: 'same_archetype' });\n      const sigC = createMockSignature({ archetype: 'different_archetype' });\n      \n      const sameArchetype = calculateSignatureSimilarity(sigA, sigB);\n      const diffArchetype = calculateSignatureSimilarity(sigA, sigC);\n      \n      expect(sameArchetype).toBeGreaterThan(diffArchetype);\n    });\n\n    it('should consider intensity similarity', () => {\n      const sigA = createMockSignature({ intensity: 0.9 });\n      const sigB = createMockSignature({ intensity: 0.9 });\n      const sigC = createMockSignature({ intensity: 0.1 });\n      \n      const sameIntensity = calculateSignatureSimilarity(sigA, sigB);\n      const diffIntensity = calculateSignatureSimilarity(sigA, sigC);\n      \n      expect(sameIntensity).toBeGreaterThan(diffIntensity);\n    });\n\n    it('should consider flow direction similarity', () => {\n      const sigA = createMockSignature({ flowDirection: 'forward' });\n      const sigB = createMockSignature({ flowDirection: 'forward' });\n      const sigC = createMockSignature({ flowDirection: 'chaotic' });\n      \n      const sameFlow = calculateSignatureSimilarity(sigA, sigB);\n      const diffFlow = calculateSignatureSimilarity(sigA, sigC);\n      \n      expect(sameFlow).toBeGreaterThan(diffFlow);\n    });\n\n    it('should respect custom weights', () => {\n      const sigA = createMockSignature({ archetype: 'archetype_a' });\n      const sigB = createMockSignature({ archetype: 'archetype_b' });\n      \n      const highArchetypeWeight = calculateSignatureSimilarity(sigA, sigB, { archetype: 0.8, quadrant: 0.1, temporal: 0.1 });\n      const lowArchetypeWeight = calculateSignatureSimilarity(sigA, sigB, { archetype: 0.1, quadrant: 0.45, temporal: 0.45 });\n      \n      expect(highArchetypeWeight).toBeLessThan(lowArchetypeWeight);\n    });\n\n    it('should clamp result between 0 and 1', () => {\n      const sigA = createMockSignature();\n      const sigB = createMockSignature({\n        archetype: 'different',\n        intensity: 0,\n        flowDirection: 'chaotic',\n        quadrantProfile: { q1: 0, q2: 0, q3: 1, q4: 0 },\n        temporalFlow: { opening: 1, middle: 0, ending: 1, trend: 'volatile', momentum: -1 }\n      });\n      \n      const similarity = calculateSignatureSimilarity(sigA, sigB);\n      \n      expect(similarity).toBeGreaterThanOrEqual(0);\n      expect(similarity).toBeLessThanOrEqual(1);\n    });\n  });\n\n  // ============================================================================\n  // findSimilarPatterns\n  // ============================================================================\n  describe('findSimilarPatterns', () => {\n    const targetSignature = createMockSignature();\n    \n    it('should return empty array when no patterns exist', () => {\n      const matches = findSimilarPatterns(targetSignature, []);\n      \n      expect(matches).toHaveLength(0);\n    });\n\n    it('should filter by minimum similarity', () => {\n      const patterns = [\n        { id: 'p1', signature: createMockSignature(), outcome: 'success' },\n        { id: 'p2', signature: createMockSignature({ intensity: 0.1 }), outcome: 'failure' },\n      ];\n      \n      const matchesLow = findSimilarPatterns(targetSignature, patterns, { minSimilarity: 0.5 });\n      const matchesHigh = findSimilarPatterns(targetSignature, patterns, { minSimilarity: 0.99 });\n      \n      expect(matchesLow.length).toBeGreaterThanOrEqual(matchesHigh.length);\n    });\n\n    it('should respect limit parameter', () => {\n      const patterns = Array.from({ length: 20 }, (_, i) => ({\n        id: `p${i}`,\n        signature: createMockSignature(),\n        outcome: 'success'\n      }));\n      \n      const matches = findSimilarPatterns(targetSignature, patterns, { limit: 5 });\n      \n      expect(matches.length).toBeLessThanOrEqual(5);\n    });\n\n    it('should filter by archetype', () => {\n      const patterns = [\n        { id: 'p1', signature: createMockSignature({ archetype: 'type_a' }), outcome: 'success' },\n        { id: 'p2', signature: createMockSignature({ archetype: 'type_b' }), outcome: 'success' },\n      ];\n      \n      const matches = findSimilarPatterns(targetSignature, patterns, { \n        minSimilarity: 0,\n        archetypeFilter: ['type_a'] \n      });\n      \n      expect(matches.every(m => m.signature.archetype === 'type_a')).toBe(true);\n    });\n\n    it('should filter by outcome', () => {\n      const patterns = [\n        { id: 'p1', signature: createMockSignature(), outcome: 'win' },\n        { id: 'p2', signature: createMockSignature(), outcome: 'loss' },\n        { id: 'p3', signature: createMockSignature(), outcome: 'draw' },\n      ];\n      \n      const matches = findSimilarPatterns(targetSignature, patterns, { \n        minSimilarity: 0,\n        outcomeFilter: ['win', 'draw'] \n      });\n      \n      expect(matches.every(m => m.outcome === 'win' || m.outcome === 'draw')).toBe(true);\n    });\n\n    it('should sort by similarity descending', () => {\n      const patterns = [\n        { id: 'p1', signature: createMockSignature({ intensity: 0.1 }), outcome: 'a' },\n        { id: 'p2', signature: createMockSignature({ intensity: 0.5 }), outcome: 'b' },\n        { id: 'p3', signature: createMockSignature({ intensity: 0.49 }), outcome: 'c' },\n      ];\n      \n      const matches = findSimilarPatterns(createMockSignature({ intensity: 0.5 }), patterns, { minSimilarity: 0 });\n      \n      for (let i = 1; i < matches.length; i++) {\n        expect(matches[i].similarity).toBeLessThanOrEqual(matches[i - 1].similarity);\n      }\n    });\n\n    it('should include metadata from patterns', () => {\n      const patterns = [\n        { id: 'p1', signature: createMockSignature(), outcome: 'success', metadata: { source: 'test' } },\n      ];\n      \n      const matches = findSimilarPatterns(targetSignature, patterns, { minSimilarity: 0 });\n      \n      expect(matches[0].sourceMetadata).toEqual({ source: 'test' });\n    });\n  });\n\n  // ============================================================================\n  // calculateOutcomeProbabilities\n  // ============================================================================\n  describe('calculateOutcomeProbabilities', () => {\n    it('should return empty object for no matches', () => {\n      const probabilities = calculateOutcomeProbabilities([]);\n      \n      expect(Object.keys(probabilities)).toHaveLength(0);\n    });\n\n    it('should calculate weighted probabilities', () => {\n      const matches = [\n        createMockMatch({ outcome: 'win', similarity: 0.9 }),\n        createMockMatch({ outcome: 'win', similarity: 0.8 }),\n        createMockMatch({ outcome: 'loss', similarity: 0.7 }),\n      ];\n      \n      const probabilities = calculateOutcomeProbabilities(matches);\n      \n      expect(probabilities['win']).toBeGreaterThan(probabilities['loss']);\n    });\n\n    it('should sum probabilities to 1', () => {\n      const matches = [\n        createMockMatch({ outcome: 'win', similarity: 0.8 }),\n        createMockMatch({ outcome: 'loss', similarity: 0.6 }),\n        createMockMatch({ outcome: 'draw', similarity: 0.5 }),\n      ];\n      \n      const probabilities = calculateOutcomeProbabilities(matches);\n      const sum = Object.values(probabilities).reduce((a, b) => a + b, 0);\n      \n      expect(sum).toBeCloseTo(1);\n    });\n\n    it('should handle single outcome', () => {\n      const matches = [\n        createMockMatch({ outcome: 'win', similarity: 0.8 }),\n        createMockMatch({ outcome: 'win', similarity: 0.7 }),\n      ];\n      \n      const probabilities = calculateOutcomeProbabilities(matches);\n      \n      expect(probabilities['win']).toBe(1);\n    });\n\n    it('should weight by similarity correctly', () => {\n      const matches = [\n        createMockMatch({ outcome: 'win', similarity: 1.0 }),\n        createMockMatch({ outcome: 'loss', similarity: 0.0 }),\n      ];\n      \n      const probabilities = calculateOutcomeProbabilities(matches);\n      \n      expect(probabilities['win']).toBe(1);\n      expect(probabilities['loss']).toBe(0);\n    });\n  });\n\n  // ============================================================================\n  // getMostLikelyOutcome\n  // ============================================================================\n  describe('getMostLikelyOutcome', () => {\n    it('should return null for no matches', () => {\n      const result = getMostLikelyOutcome([]);\n      \n      expect(result).toBeNull();\n    });\n\n    it('should return highest probability outcome', () => {\n      const matches = [\n        createMockMatch({ outcome: 'win', similarity: 0.9 }),\n        createMockMatch({ outcome: 'win', similarity: 0.8 }),\n        createMockMatch({ outcome: 'loss', similarity: 0.5 }),\n      ];\n      \n      const result = getMostLikelyOutcome(matches);\n      \n      expect(result?.outcome).toBe('win');\n    });\n\n    it('should include probability in result', () => {\n      const matches = [\n        createMockMatch({ outcome: 'success', similarity: 0.8 }),\n      ];\n      \n      const result = getMostLikelyOutcome(matches);\n      \n      expect(result?.probability).toBe(1);\n    });\n\n    it('should handle ties by returning first encountered', () => {\n      const matches = [\n        createMockMatch({ outcome: 'a', similarity: 0.5 }),\n        createMockMatch({ outcome: 'b', similarity: 0.5 }),\n      ];\n      \n      const result = getMostLikelyOutcome(matches);\n      \n      expect(result).not.toBeNull();\n      expect(['a', 'b']).toContain(result?.outcome);\n    });\n  });\n\n  // ============================================================================\n  // calculatePatternDiversity\n  // ============================================================================\n  describe('calculatePatternDiversity', () => {\n    it('should return 0 for single match', () => {\n      const diversity = calculatePatternDiversity([createMockMatch()]);\n      \n      expect(diversity).toBe(0);\n    });\n\n    it('should return 0 for empty matches', () => {\n      const diversity = calculatePatternDiversity([]);\n      \n      expect(diversity).toBe(0);\n    });\n\n    it('should return high value for diverse patterns', () => {\n      const matches = [\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'win' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'b' }), outcome: 'loss' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'c' }), outcome: 'draw' }),\n      ];\n      \n      const diversity = calculatePatternDiversity(matches);\n      \n      expect(diversity).toBe(1); // All unique archetypes and outcomes\n    });\n\n    it('should return low value for homogeneous patterns', () => {\n      const matches = [\n        createMockMatch({ signature: createMockSignature({ archetype: 'same' }), outcome: 'win' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'same' }), outcome: 'win' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'same' }), outcome: 'win' }),\n      ];\n      \n      const diversity = calculatePatternDiversity(matches);\n      \n      expect(diversity).toBeLessThan(0.5);\n    });\n\n    it('should be between 0 and 1', () => {\n      const matches = [\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'x' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'y' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'b' }), outcome: 'x' }),\n      ];\n      \n      const diversity = calculatePatternDiversity(matches);\n      \n      expect(diversity).toBeGreaterThanOrEqual(0);\n      expect(diversity).toBeLessThanOrEqual(1);\n    });\n  });\n\n  // ============================================================================\n  // calculateMatchConfidence\n  // ============================================================================\n  describe('calculateMatchConfidence', () => {\n    it('should return 0 for no matches', () => {\n      const confidence = calculateMatchConfidence([]);\n      \n      expect(confidence).toBe(0);\n    });\n\n    it('should increase with more matches', () => {\n      const fewMatches = [createMockMatch()];\n      const manyMatches = Array.from({ length: 10 }, () => createMockMatch());\n      \n      const confidenceFew = calculateMatchConfidence(fewMatches);\n      const confidenceMany = calculateMatchConfidence(manyMatches);\n      \n      expect(confidenceMany).toBeGreaterThan(confidenceFew);\n    });\n\n    it('should increase with higher similarity', () => {\n      const lowSimilarity = [\n        createMockMatch({ similarity: 0.3 }),\n        createMockMatch({ similarity: 0.4 }),\n      ];\n      const highSimilarity = [\n        createMockMatch({ similarity: 0.9 }),\n        createMockMatch({ similarity: 0.95 }),\n      ];\n      \n      const confidenceLow = calculateMatchConfidence(lowSimilarity);\n      const confidenceHigh = calculateMatchConfidence(highSimilarity);\n      \n      expect(confidenceHigh).toBeGreaterThan(confidenceLow);\n    });\n\n    it('should increase with less diversity (more consensus)', () => {\n      const diverse = [\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'x' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'b' }), outcome: 'y' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'c' }), outcome: 'z' }),\n      ];\n      const consensus = [\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'x' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'x' }),\n        createMockMatch({ signature: createMockSignature({ archetype: 'a' }), outcome: 'x' }),\n      ];\n      \n      const confidenceDiverse = calculateMatchConfidence(diverse);\n      const confidenceConsensus = calculateMatchConfidence(consensus);\n      \n      expect(confidenceConsensus).toBeGreaterThan(confidenceDiverse);\n    });\n\n    it('should respect minSampleSize parameter', () => {\n      const matches = Array.from({ length: 3 }, () => createMockMatch());\n      \n      const confidenceLowMin = calculateMatchConfidence(matches, 3);\n      const confidenceHighMin = calculateMatchConfidence(matches, 10);\n      \n      expect(confidenceLowMin).toBeGreaterThan(confidenceHighMin);\n    });\n\n    it('should be between 0 and 1', () => {\n      const matches = Array.from({ length: 20 }, () => createMockMatch({ similarity: 0.95 }));\n      \n      const confidence = calculateMatchConfidence(matches);\n      \n      expect(confidence).toBeGreaterThanOrEqual(0);\n      expect(confidence).toBeLessThanOrEqual(1);\n    });\n  });\n});\n";export{e as default};
