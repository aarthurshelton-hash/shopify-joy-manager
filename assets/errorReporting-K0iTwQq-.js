const r="import { supabase } from '@/integrations/supabase/client';\n\ninterface ErrorReport {\n  message: string;\n  stack?: string;\n  componentName?: string;\n  errorType?: 'runtime' | 'network' | 'validation' | 'render' | 'performance';\n  url?: string;\n  metadata?: Record<string, unknown>;\n}\n\n// Queue for batching errors\nlet errorQueue: ErrorReport[] = [];\nlet flushTimeout: ReturnType<typeof setTimeout> | null = null;\n\nconst BATCH_SIZE = 5;\nconst FLUSH_INTERVAL = 5000; // 5 seconds\n\nasync function sendErrors(errors: ErrorReport[]): Promise<void> {\n  if (errors.length === 0) return;\n\n  try {\n    // Send errors via edge function\n    for (const error of errors) {\n      await supabase.functions.invoke('collect-error', {\n        body: {\n          message: error.message,\n          stack: error.stack,\n          componentName: error.componentName,\n          errorType: error.errorType || 'runtime',\n          url: error.url || window.location.href,\n          userAgent: navigator.userAgent,\n          metadata: {\n            ...error.metadata,\n            timestamp: new Date().toISOString(),\n            viewport: {\n              width: window.innerWidth,\n              height: window.innerHeight,\n            },\n          },\n        },\n      });\n    }\n  } catch (e) {\n    // Silently fail - don't create infinite error loops\n    console.warn('Failed to report errors:', e);\n  }\n}\n\nfunction flushErrorQueue(): void {\n  if (errorQueue.length > 0) {\n    const errorsToSend = [...errorQueue];\n    errorQueue = [];\n    sendErrors(errorsToSend);\n  }\n  flushTimeout = null;\n}\n\nfunction scheduleFlush(): void {\n  if (flushTimeout) return;\n  flushTimeout = setTimeout(flushErrorQueue, FLUSH_INTERVAL);\n}\n\nexport function reportError(error: Error | string, options: Partial<ErrorReport> = {}): void {\n  const errorReport: ErrorReport = {\n    message: typeof error === 'string' ? error : error.message,\n    stack: typeof error === 'object' ? error.stack : undefined,\n    ...options,\n  };\n\n  errorQueue.push(errorReport);\n\n  // Flush immediately if we hit batch size\n  if (errorQueue.length >= BATCH_SIZE) {\n    flushErrorQueue();\n  } else {\n    scheduleFlush();\n  }\n}\n\n// Global error handler\nexport function setupGlobalErrorHandlers(): void {\n  // Unhandled errors\n  window.addEventListener('error', (event) => {\n    reportError(event.error || event.message, {\n      errorType: 'runtime',\n      metadata: {\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n      },\n    });\n  });\n\n  // Unhandled promise rejections\n  window.addEventListener('unhandledrejection', (event) => {\n    const error = event.reason;\n    reportError(\n      error instanceof Error ? error : String(error),\n      {\n        errorType: 'runtime',\n        metadata: { type: 'unhandledrejection' },\n      }\n    );\n  });\n\n  // Flush on page unload\n  window.addEventListener('beforeunload', () => {\n    if (flushTimeout) {\n      clearTimeout(flushTimeout);\n    }\n    // Synchronous send attempt for remaining errors\n    if (errorQueue.length > 0 && navigator.sendBeacon) {\n      const payload = JSON.stringify({ errors: errorQueue });\n      navigator.sendBeacon('/api/collect-errors', payload);\n    }\n  });\n}\n\n// React Error Boundary integration\nexport function reportReactError(\n  error: Error,\n  componentStack: string,\n  componentName?: string\n): void {\n  reportError(error, {\n    errorType: 'render',\n    componentName,\n    metadata: {\n      componentStack,\n      reactVersion: '18',\n    },\n  });\n}\n";export{r as default};
