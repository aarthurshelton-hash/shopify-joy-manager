const e="/**\n * Temporal & Geographic Context Tracker\n * \n * Tracks when and where chess games are played to identify\n * universal patterns in human decision-making.\n * \n * Key Insights:\n * - Time of day affects cognitive performance (circadian rhythms)\n * - Geographic location reveals cultural play styles\n * - Time zones create \"market hours\" for chess activity\n * - Seasonal patterns may correlate with trading behavior\n */\n\nexport interface TemporalContext {\n  // UTC timestamp of game\n  timestamp: Date;\n  \n  // Derived temporal attributes\n  hourUTC: number;\n  dayOfWeek: number; // 0=Sunday\n  monthOfYear: number;\n  \n  // Inferred local context (from typical chess activity patterns)\n  likelyRegion: 'americas' | 'europe' | 'asia' | 'unknown';\n  localHourEstimate: number;\n  \n  // Temporal trading zones\n  marketSession: 'asia' | 'europe' | 'americas' | 'overlap' | 'closed';\n  \n  // Cognitive context\n  cognitiveWindow: 'peak' | 'standard' | 'fatigued';\n  weekendEffect: boolean;\n}\n\nexport interface GeographicPattern {\n  region: string;\n  totalGames: number;\n  avgAccuracy: number;\n  peakHours: number[];\n  preferredTimeControls: string[];\n  dominantArchetypes: string[];\n}\n\nexport interface TemporalPattern {\n  hour: number;\n  gamesCount: number;\n  avgHybridAccuracy: number;\n  avgStockfishAccuracy: number;\n  dominantArchetypes: string[];\n}\n\n/**\n * Extract temporal context from a game timestamp\n */\nexport function extractTemporalContext(timestamp: Date | string): TemporalContext {\n  const date = typeof timestamp === 'string' ? new Date(timestamp) : timestamp;\n  \n  const hourUTC = date.getUTCHours();\n  const dayOfWeek = date.getUTCDay();\n  const monthOfYear = date.getUTCMonth();\n  \n  // Infer likely region based on active hours\n  // Peak chess times: Americas (evening EST), Europe (evening CET), Asia (evening JST)\n  let likelyRegion: TemporalContext['likelyRegion'] = 'unknown';\n  let localHourEstimate = hourUTC;\n  \n  if (hourUTC >= 0 && hourUTC < 8) {\n    // UTC 00:00-08:00 = Americas evening / Asia morning\n    likelyRegion = 'americas';\n    localHourEstimate = (hourUTC - 5 + 24) % 24; // EST\n  } else if (hourUTC >= 8 && hourUTC < 16) {\n    // UTC 08:00-16:00 = Europe day / Asia evening\n    likelyRegion = hourUTC < 12 ? 'asia' : 'europe';\n    localHourEstimate = likelyRegion === 'asia' ? hourUTC + 9 : hourUTC + 1; // JST or CET\n  } else {\n    // UTC 16:00-24:00 = Americas day / Europe evening\n    likelyRegion = hourUTC < 22 ? 'europe' : 'americas';\n    localHourEstimate = likelyRegion === 'europe' ? hourUTC + 1 : hourUTC - 5;\n  }\n  \n  // Market session (forex-style)\n  let marketSession: TemporalContext['marketSession'] = 'closed';\n  if (hourUTC >= 0 && hourUTC < 8) marketSession = 'asia';\n  else if (hourUTC >= 7 && hourUTC < 9) marketSession = 'overlap'; // Asia/Europe\n  else if (hourUTC >= 8 && hourUTC < 13) marketSession = 'europe';\n  else if (hourUTC >= 13 && hourUTC < 17) marketSession = 'overlap'; // Europe/Americas\n  else if (hourUTC >= 14 && hourUTC < 21) marketSession = 'americas';\n  \n  // Cognitive window based on local time estimate\n  let cognitiveWindow: TemporalContext['cognitiveWindow'] = 'standard';\n  if (localHourEstimate >= 10 && localHourEstimate <= 14) {\n    cognitiveWindow = 'peak'; // Mid-morning to early afternoon\n  } else if (localHourEstimate >= 22 || localHourEstimate <= 6) {\n    cognitiveWindow = 'fatigued'; // Late night / early morning\n  }\n  \n  const weekendEffect = dayOfWeek === 0 || dayOfWeek === 6;\n  \n  return {\n    timestamp: date,\n    hourUTC,\n    dayOfWeek,\n    monthOfYear,\n    likelyRegion,\n    localHourEstimate: localHourEstimate % 24,\n    marketSession,\n    cognitiveWindow,\n    weekendEffect,\n  };\n}\n\n/**\n * Analyze temporal patterns from prediction attempts\n */\nexport function analyzeTemporalPatterns(\n  attempts: Array<{\n    created_at: string;\n    hybrid_correct: boolean;\n    stockfish_correct: boolean;\n    hybrid_archetype?: string | null;\n  }>\n): TemporalPattern[] {\n  const hourlyData: Record<number, {\n    count: number;\n    hybridCorrect: number;\n    sfCorrect: number;\n    archetypes: Record<string, number>;\n  }> = {};\n  \n  // Initialize all hours\n  for (let h = 0; h < 24; h++) {\n    hourlyData[h] = { count: 0, hybridCorrect: 0, sfCorrect: 0, archetypes: {} };\n  }\n  \n  // Aggregate by hour\n  attempts.forEach(attempt => {\n    const context = extractTemporalContext(attempt.created_at);\n    const hour = context.hourUTC;\n    \n    hourlyData[hour].count++;\n    if (attempt.hybrid_correct) hourlyData[hour].hybridCorrect++;\n    if (attempt.stockfish_correct) hourlyData[hour].sfCorrect++;\n    \n    if (attempt.hybrid_archetype) {\n      hourlyData[hour].archetypes[attempt.hybrid_archetype] = \n        (hourlyData[hour].archetypes[attempt.hybrid_archetype] || 0) + 1;\n    }\n  });\n  \n  return Object.entries(hourlyData).map(([hour, data]) => ({\n    hour: parseInt(hour),\n    gamesCount: data.count,\n    avgHybridAccuracy: data.count > 0 ? (data.hybridCorrect / data.count) * 100 : 0,\n    avgStockfishAccuracy: data.count > 0 ? (data.sfCorrect / data.count) * 100 : 0,\n    dominantArchetypes: Object.entries(data.archetypes)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 3)\n      .map(([arch]) => arch),\n  }));\n}\n\n/**\n * Get market correlation insights from temporal patterns\n */\nexport function getMarketCorrelationInsights(patterns: TemporalPattern[]): {\n  peakPredictionHours: number[];\n  asianSessionAdvantage: number;\n  europeanSessionAdvantage: number;\n  americasSessionAdvantage: number;\n  weekendCorrelation: string;\n} {\n  // Find hours with highest hybrid vs stockfish advantage\n  const advantages = patterns.map(p => ({\n    hour: p.hour,\n    advantage: p.avgHybridAccuracy - p.avgStockfishAccuracy,\n    count: p.gamesCount,\n  })).filter(p => p.count > 0);\n  \n  const peakPredictionHours = advantages\n    .sort((a, b) => b.advantage - a.advantage)\n    .slice(0, 3)\n    .map(p => p.hour);\n  \n  // Calculate session advantages\n  const asianHours = patterns.filter(p => p.hour >= 0 && p.hour < 8);\n  const europeanHours = patterns.filter(p => p.hour >= 8 && p.hour < 16);\n  const americasHours = patterns.filter(p => p.hour >= 16 && p.hour < 24);\n  \n  const calcAdvantage = (hours: TemporalPattern[]) => {\n    const totalCount = hours.reduce((sum, h) => sum + h.gamesCount, 0);\n    if (totalCount === 0) return 0;\n    const weightedHybrid = hours.reduce((sum, h) => sum + h.avgHybridAccuracy * h.gamesCount, 0);\n    const weightedSF = hours.reduce((sum, h) => sum + h.avgStockfishAccuracy * h.gamesCount, 0);\n    return (weightedHybrid - weightedSF) / totalCount;\n  };\n  \n  return {\n    peakPredictionHours,\n    asianSessionAdvantage: calcAdvantage(asianHours),\n    europeanSessionAdvantage: calcAdvantage(europeanHours),\n    americasSessionAdvantage: calcAdvantage(americasHours),\n    weekendCorrelation: 'Weekend games show different cognitive patterns - more recreational, less competitive pressure',\n  };\n}\n\n/**\n * Format temporal context for display\n */\nexport function formatTemporalContext(context: TemporalContext): string {\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const regions = {\n    americas: 'ğŸ‡ºğŸ‡¸ Americas',\n    europe: 'ğŸ‡ªğŸ‡º Europe',\n    asia: 'ğŸ‡¯ğŸ‡µ Asia',\n    unknown: 'ğŸŒ Unknown',\n  };\n  \n  return `${days[context.dayOfWeek]} ${context.hourUTC}:00 UTC | ${regions[context.likelyRegion]} (~${context.localHourEstimate}:00 local) | ${context.marketSession.toUpperCase()} session | ${context.cognitiveWindow} window`;\n}\n";export{e as default};
