const n="/**\n * Pattern-to-Move Translation Layer\n * \n * THE PARADIGM SHIFT:\n * Instead of calculating \"best move\" from position evaluation,\n * we select moves that ALIGN with winning trajectory patterns.\n * \n * Core Insight (CEO Alec Arthur Shelton):\n * \"If we know the destination (outcome), we can navigate the path (moves)\"\n * \n * This module translates learned archetype patterns into move preferences,\n * enabling En Pensent to PLAY chess using pattern recognition rather than\n * brute-force calculation.\n */\n\nimport { Chess, Move } from 'chess.js';\n\nexport interface PatternSignature {\n  fingerprint: string;\n  archetype: string;\n  outcome: 'white_wins' | 'black_wins' | 'draw';\n  confidence: number;\n  characteristics: {\n    tension: number;\n    momentum: number;\n    complexity: number;\n    phase: 'opening' | 'middlegame' | 'endgame';\n  };\n  movePatterns: MovePattern[];\n}\n\nexport interface MovePattern {\n  moveNumber: number;\n  phase: string;\n  pieceActivity: Record<string, number>;\n  centerControl: number;\n  kingSafety: number;\n  pawnStructure: string;\n  tacticalThemes: string[];\n}\n\nexport interface MoveScore {\n  move: Move;\n  san: string;\n  trajectoryAlignment: number;  // How well this move aligns with winning patterns\n  patternMatch: number;         // Similarity to known winning move patterns\n  momentumScore: number;        // Does this maintain/build momentum?\n  riskScore: number;            // Deviation from safe trajectory\n  compositeScore: number;       // Final weighted score\n  reasoning: string;\n}\n\nexport interface TranslationContext {\n  currentFen: string;\n  moveHistory: string[];\n  detectedArchetype: string;\n  trajectoryConfidence: number;\n  targetOutcome: 'white_wins' | 'black_wins' | 'draw';\n  learnedPatterns: PatternSignature[];\n}\n\n/**\n * Extract position characteristics for pattern matching\n */\nexport function extractPositionCharacteristics(chess: Chess): MovePattern {\n  const fen = chess.fen();\n  const history = chess.history({ verbose: true });\n  const moveNumber = Math.floor(history.length / 2) + 1;\n  \n  // Determine phase\n  let phase: 'opening' | 'middlegame' | 'endgame' = 'opening';\n  const pieceCount = countPieces(fen);\n  if (pieceCount <= 14) phase = 'endgame';\n  else if (moveNumber > 15 || pieceCount <= 24) phase = 'middlegame';\n  \n  // Calculate center control\n  const centerControl = calculateCenterControl(chess);\n  \n  // Assess king safety\n  const kingSafety = assessKingSafety(chess);\n  \n  // Analyze pawn structure\n  const pawnStructure = analyzePawnStructure(fen);\n  \n  // Detect tactical themes\n  const tacticalThemes = detectTacticalThemes(chess);\n  \n  // Calculate piece activity\n  const pieceActivity = calculatePieceActivity(chess);\n  \n  return {\n    moveNumber,\n    phase,\n    pieceActivity,\n    centerControl,\n    kingSafety,\n    pawnStructure,\n    tacticalThemes\n  };\n}\n\n/**\n * Count total pieces on the board\n */\nfunction countPieces(fen: string): number {\n  const position = fen.split(' ')[0];\n  return position.replace(/[^pnbrqkPNBRQK]/g, '').length;\n}\n\n/**\n * Calculate control of center squares (d4, d5, e4, e5)\n */\nfunction calculateCenterControl(chess: Chess): number {\n  const centerSquares = ['d4', 'd5', 'e4', 'e5'] as const;\n  let whiteControl = 0;\n  let blackControl = 0;\n  \n  for (const square of centerSquares) {\n    const piece = chess.get(square);\n    if (piece) {\n      if (piece.color === 'w') whiteControl += 2;\n      else blackControl += 2;\n    }\n    \n    // Check attacks on center\n    // Simplified: check if pieces can move to center\n    const moves = chess.moves({ verbose: true });\n    for (const move of moves) {\n      if (move.to === square) {\n        if (chess.turn() === 'w') whiteControl += 0.5;\n        else blackControl += 0.5;\n      }\n    }\n  }\n  \n  // Return normalized value (-1 = black control, +1 = white control)\n  const total = whiteControl + blackControl;\n  if (total === 0) return 0;\n  return (whiteControl - blackControl) / total;\n}\n\n/**\n * Assess king safety for both sides\n */\nfunction assessKingSafety(chess: Chess): number {\n  const fen = chess.fen();\n  const position = fen.split(' ')[0];\n  \n  // Check if kings are castled (simplified heuristic)\n  let whiteSafety = 0;\n  let blackSafety = 0;\n  \n  // White king on g1/h1 with pawns in front = castled kingside\n  if (position.includes('K') && (fen.includes('Kg1') || fen.includes('Kh1'))) {\n    whiteSafety += 0.5;\n  }\n  // White king on c1/b1 = castled queenside\n  if (position.includes('K') && (fen.includes('Kc1') || fen.includes('Kb1'))) {\n    whiteSafety += 0.4;\n  }\n  \n  // Similar for black\n  if (position.includes('k') && (fen.includes('kg8') || fen.includes('kh8'))) {\n    blackSafety += 0.5;\n  }\n  if (position.includes('k') && (fen.includes('kc8') || fen.includes('kb8'))) {\n    blackSafety += 0.4;\n  }\n  \n  // Pawn shield bonus (simplified)\n  const ranks = position.split('/');\n  // Check white's pawn shield (rank 2)\n  const whitePawns = (ranks[6] || '').match(/P/g)?.length || 0;\n  whiteSafety += whitePawns * 0.1;\n  \n  // Check black's pawn shield (rank 7)\n  const blackPawns = (ranks[1] || '').match(/p/g)?.length || 0;\n  blackSafety += blackPawns * 0.1;\n  \n  return (whiteSafety - blackSafety);\n}\n\n/**\n * Analyze pawn structure and return a fingerprint\n */\nfunction analyzePawnStructure(fen: string): string {\n  const position = fen.split(' ')[0];\n  const files = { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0 };\n  \n  // Count pawns per file\n  for (const char of position) {\n    if (char === 'P' || char === 'p') {\n      // This is simplified - in reality we'd track exact positions\n    }\n  }\n  \n  // Detect structures\n  const structures: string[] = [];\n  \n  // Check for doubled pawns, isolated pawns, etc. (simplified)\n  if (position.includes('PP') || position.includes('pp')) {\n    structures.push('doubled');\n  }\n  \n  // Check for pawn chains\n  if (position.match(/P.*P.*P/i)) {\n    structures.push('chain');\n  }\n  \n  return structures.join(',') || 'standard';\n}\n\n/**\n * Detect tactical themes present in the position\n */\nfunction detectTacticalThemes(chess: Chess): string[] {\n  const themes: string[] = [];\n  const moves = chess.moves({ verbose: true });\n  \n  // Check for checks\n  for (const move of moves) {\n    if (move.san.includes('+')) {\n      themes.push('check_available');\n      break;\n    }\n  }\n  \n  // Check for captures\n  const captures = moves.filter(m => m.captured);\n  if (captures.length > 0) {\n    themes.push('captures_available');\n  }\n  \n  // Check for promotions\n  const promotions = moves.filter(m => m.promotion);\n  if (promotions.length > 0) {\n    themes.push('promotion_available');\n  }\n  \n  // Check if in check\n  if (chess.inCheck()) {\n    themes.push('in_check');\n  }\n  \n  return themes;\n}\n\n/**\n * Calculate piece activity scores\n */\nfunction calculatePieceActivity(chess: Chess): Record<string, number> {\n  const activity: Record<string, number> = {\n    knights: 0,\n    bishops: 0,\n    rooks: 0,\n    queens: 0\n  };\n  \n  const moves = chess.moves({ verbose: true });\n  \n  for (const move of moves) {\n    switch (move.piece) {\n      case 'n': activity.knights += 0.1; break;\n      case 'b': activity.bishops += 0.1; break;\n      case 'r': activity.rooks += 0.1; break;\n      case 'q': activity.queens += 0.1; break;\n    }\n  }\n  \n  return activity;\n}\n\n/**\n * Score a move based on trajectory alignment\n */\nexport function scoreMoveByTrajectory(\n  chess: Chess,\n  move: Move,\n  context: TranslationContext\n): MoveScore {\n  const testChess = new Chess(chess.fen());\n  testChess.move(move.san);\n  \n  const beforePattern = extractPositionCharacteristics(chess);\n  const afterPattern = extractPositionCharacteristics(testChess);\n  \n  // Calculate trajectory alignment\n  const trajectoryAlignment = calculateTrajectoryAlignment(\n    beforePattern,\n    afterPattern,\n    context.targetOutcome,\n    context.detectedArchetype\n  );\n  \n  // Calculate pattern match against learned patterns\n  const patternMatch = calculatePatternMatch(\n    afterPattern,\n    context.learnedPatterns,\n    context.targetOutcome\n  );\n  \n  // Calculate momentum score\n  const momentumScore = calculateMomentumScore(\n    beforePattern,\n    afterPattern,\n    context.targetOutcome\n  );\n  \n  // Calculate risk score (deviation from known paths)\n  const riskScore = calculateRiskScore(\n    move,\n    context.learnedPatterns,\n    afterPattern\n  );\n  \n  // Composite score with learned weights\n  const compositeScore = (\n    trajectoryAlignment * 0.35 +\n    patternMatch * 0.30 +\n    momentumScore * 0.20 +\n    (1 - riskScore) * 0.15\n  );\n  \n  // Generate reasoning\n  const reasoning = generateMoveReasoning(\n    move,\n    trajectoryAlignment,\n    patternMatch,\n    momentumScore,\n    riskScore,\n    context\n  );\n  \n  return {\n    move,\n    san: move.san,\n    trajectoryAlignment,\n    patternMatch,\n    momentumScore,\n    riskScore,\n    compositeScore,\n    reasoning\n  };\n}\n\n/**\n * Calculate how well a move aligns with the target trajectory\n */\nfunction calculateTrajectoryAlignment(\n  before: MovePattern,\n  after: MovePattern,\n  targetOutcome: string,\n  archetype: string\n): number {\n  let alignment = 0.5; // Neutral baseline\n  \n  const isWhiteWinning = targetOutcome === 'white_wins';\n  \n  // Center control alignment\n  if (isWhiteWinning && after.centerControl > before.centerControl) {\n    alignment += 0.1;\n  } else if (!isWhiteWinning && after.centerControl < before.centerControl) {\n    alignment += 0.1;\n  }\n  \n  // King safety alignment\n  if (isWhiteWinning && after.kingSafety > before.kingSafety) {\n    alignment += 0.1;\n  } else if (!isWhiteWinning && after.kingSafety < before.kingSafety) {\n    alignment += 0.1;\n  }\n  \n  // Archetype-specific adjustments\n  switch (archetype) {\n    case 'The Constrictor':\n      // Favor moves that increase control\n      if (after.centerControl > before.centerControl) alignment += 0.15;\n      break;\n    case 'The Tactician':\n      // Favor moves with tactical themes\n      if (after.tacticalThemes.length > before.tacticalThemes.length) alignment += 0.15;\n      break;\n    case 'The Attacker':\n      // Favor aggressive moves\n      if (after.tacticalThemes.includes('check_available')) alignment += 0.15;\n      break;\n    case 'The Positional Master':\n      // Favor quiet improvements\n      if (after.pieceActivity.bishops > before.pieceActivity.bishops) alignment += 0.1;\n      if (after.pieceActivity.knights > before.pieceActivity.knights) alignment += 0.1;\n      break;\n  }\n  \n  return Math.min(1, Math.max(0, alignment));\n}\n\n/**\n * Calculate match against learned winning patterns\n */\nfunction calculatePatternMatch(\n  position: MovePattern,\n  learnedPatterns: PatternSignature[],\n  targetOutcome: string\n): number {\n  if (learnedPatterns.length === 0) return 0.5; // No data yet\n  \n  // Filter patterns by target outcome\n  const relevantPatterns = learnedPatterns.filter(p => p.outcome === targetOutcome);\n  if (relevantPatterns.length === 0) return 0.5;\n  \n  let totalMatch = 0;\n  let totalWeight = 0;\n  \n  for (const pattern of relevantPatterns) {\n    // Find move patterns in same phase\n    const phasePatterns = pattern.movePatterns.filter(mp => mp.phase === position.phase);\n    \n    for (const mp of phasePatterns) {\n      let matchScore = 0;\n      \n      // Compare center control\n      const centerDiff = Math.abs(mp.centerControl - position.centerControl);\n      matchScore += (1 - centerDiff) * 0.3;\n      \n      // Compare king safety\n      const safetyDiff = Math.abs(mp.kingSafety - position.kingSafety);\n      matchScore += (1 - Math.min(1, safetyDiff)) * 0.3;\n      \n      // Compare tactical themes\n      const commonThemes = mp.tacticalThemes.filter(t => \n        position.tacticalThemes.includes(t)\n      ).length;\n      matchScore += (commonThemes / Math.max(1, mp.tacticalThemes.length)) * 0.4;\n      \n      totalMatch += matchScore * pattern.confidence;\n      totalWeight += pattern.confidence;\n    }\n  }\n  \n  return totalWeight > 0 ? totalMatch / totalWeight : 0.5;\n}\n\n/**\n * Calculate momentum score - are we building or losing momentum?\n */\nfunction calculateMomentumScore(\n  before: MovePattern,\n  after: MovePattern,\n  targetOutcome: string\n): number {\n  let momentum = 0.5;\n  \n  const isWhiteWinning = targetOutcome === 'white_wins';\n  \n  // Activity increase = momentum\n  const beforeActivity = Object.values(before.pieceActivity).reduce((a, b) => a + b, 0);\n  const afterActivity = Object.values(after.pieceActivity).reduce((a, b) => a + b, 0);\n  \n  if (afterActivity > beforeActivity) {\n    momentum += 0.15;\n  }\n  \n  // Phase transitions\n  if (before.phase === 'opening' && after.phase === 'middlegame') {\n    momentum += 0.1; // Transitioning is progress\n  }\n  \n  // Center control change aligned with goal\n  if (isWhiteWinning && after.centerControl > before.centerControl) {\n    momentum += 0.1;\n  } else if (!isWhiteWinning && after.centerControl < before.centerControl) {\n    momentum += 0.1;\n  }\n  \n  return Math.min(1, Math.max(0, momentum));\n}\n\n/**\n * Calculate risk of deviating from known winning paths\n */\nfunction calculateRiskScore(\n  move: Move,\n  learnedPatterns: PatternSignature[],\n  afterPosition: MovePattern\n): number {\n  if (learnedPatterns.length === 0) return 0.5; // Unknown = medium risk\n  \n  let risk = 0.3; // Base risk\n  \n  // Piece sacrifices are higher risk\n  if (move.captured) {\n    const pieceValues: Record<string, number> = {\n      'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9\n    };\n    const capturedValue = pieceValues[move.captured] || 0;\n    const movingValue = pieceValues[move.piece] || 0;\n    \n    if (movingValue > capturedValue + 1) {\n      risk += 0.2; // Sacrificing material\n    }\n  }\n  \n  // Moving into check indicators\n  if (afterPosition.tacticalThemes.includes('in_check')) {\n    risk += 0.1;\n  }\n  \n  // Unknown territory (no matching patterns)\n  const hasMatchingPhasePatterns = learnedPatterns.some(p =>\n    p.movePatterns.some(mp => mp.phase === afterPosition.phase)\n  );\n  if (!hasMatchingPhasePatterns) {\n    risk += 0.2;\n  }\n  \n  return Math.min(1, risk);\n}\n\n/**\n * Generate human-readable reasoning for move selection\n */\nfunction generateMoveReasoning(\n  move: Move,\n  trajectoryAlignment: number,\n  patternMatch: number,\n  momentumScore: number,\n  riskScore: number,\n  context: TranslationContext\n): string {\n  const reasons: string[] = [];\n  \n  if (trajectoryAlignment > 0.7) {\n    reasons.push(`Strongly aligns with ${context.detectedArchetype} trajectory`);\n  } else if (trajectoryAlignment > 0.5) {\n    reasons.push(`Maintains ${context.detectedArchetype} pattern`);\n  }\n  \n  if (patternMatch > 0.7) {\n    reasons.push('Matches learned winning patterns');\n  }\n  \n  if (momentumScore > 0.7) {\n    reasons.push('Builds momentum toward target outcome');\n  }\n  \n  if (riskScore < 0.3) {\n    reasons.push('Low deviation from known paths');\n  } else if (riskScore > 0.6) {\n    reasons.push('Higher risk but potentially high reward');\n  }\n  \n  if (move.captured) {\n    reasons.push(`Captures ${move.captured}`);\n  }\n  \n  if (move.san.includes('+')) {\n    reasons.push('Delivers check');\n  }\n  \n  if (move.promotion) {\n    reasons.push(`Promotes to ${move.promotion}`);\n  }\n  \n  return reasons.length > 0 \n    ? reasons.join('. ') + '.'\n    : 'Standard continuation.';\n}\n\n/**\n * Rank all legal moves by trajectory alignment\n */\nexport function rankMovesByTrajectory(\n  chess: Chess,\n  context: TranslationContext\n): MoveScore[] {\n  const moves = chess.moves({ verbose: true });\n  \n  const scoredMoves = moves.map(move => \n    scoreMoveByTrajectory(chess, move, context)\n  );\n  \n  // Sort by composite score (highest first)\n  return scoredMoves.sort((a, b) => b.compositeScore - a.compositeScore);\n}\n\n/**\n * Select the best move based on pattern-trajectory alignment\n */\nexport function selectBestMove(\n  chess: Chess,\n  context: TranslationContext\n): MoveScore | null {\n  const rankedMoves = rankMovesByTrajectory(chess, context);\n  \n  if (rankedMoves.length === 0) return null;\n  \n  // Return the highest-scoring move\n  return rankedMoves[0];\n}\n";export{n as default};
