const n="/**\n * Move Quality Analysis System (Enhanced)\n * \n * Based on Stockfish and chess.com's evaluation systems.\n * Uses centipawn evaluation, win probability, and tactical detection\n * to classify moves with professional-grade accuracy.\n * \n * Classification: Brilliant, Great, Best, Good, Book, Inaccuracy, Mistake, Blunder\n * \n * Key metrics:\n * - Centipawn values (Stockfish-inspired: P=100, N=305, B=333, R=563, Q=950)\n * - Win probability conversion using Lichess K-factor\n * - Accuracy calculation using chess.com formula\n */\n\nimport { Chess, Move, Square, PieceSymbol } from 'chess.js';\n\n// ===================== PIECE VALUES (STOCKFISH-INSPIRED) =====================\n\n/**\n * Standard chess piece values in centipawns (cp)\n * Values calibrated to Stockfish's evaluation function\n * 100 centipawns = 1 pawn worth of material\n */\nexport const PIECE_VALUES: Record<PieceSymbol, number> = {\n  p: 100,   // Pawn - base unit\n  n: 305,   // Knight - ~3 pawns, but context-dependent\n  b: 333,   // Bishop - slightly > knight (bishop pair bonus)\n  r: 563,   // Rook - ~5.5 pawns\n  q: 950,   // Queen - ~9.5 pawns\n  k: 20000, // King - effectively infinite (game-ending)\n};\n\n/**\n * Simplified point values for quick calculations\n */\nexport const PIECE_POINTS: Record<PieceSymbol, number> = {\n  p: 1,\n  n: 3,\n  b: 3,\n  r: 5,\n  q: 9,\n  k: 0, // King has no exchange value\n};\n\n/**\n * Endgame piece values (pieces change importance)\n */\nexport const ENDGAME_PIECE_VALUES: Record<PieceSymbol, number> = {\n  p: 120,   // Pawns MORE valuable (promotion potential)\n  n: 290,   // Knights slightly weaker (less maneuverability)\n  b: 340,   // Bishops slightly stronger (open positions)\n  r: 590,   // Rooks more valuable (activity)\n  q: 980,   // Queen more valuable\n  k: 20000,\n};\n\n// ===================== WIN PROBABILITY =====================\n\n/**\n * Convert centipawn evaluation to win probability percentage\n * Based on Lichess/chess.com formula with K-factor 0.00368208\n * \n * @param centipawns - Position evaluation in centipawns (+ for white, - for black)\n * @returns Win probability for the side to move (0-100%)\n */\nexport function cpToWinProbability(centipawns: number): number {\n  const K = 0.00368208; // Lichess K-factor\n  return 50 + 50 * (2 / (1 + Math.exp(-K * centipawns)) - 1);\n}\n\n/**\n * Calculate move accuracy from win probability change\n * Uses chess.com's official accuracy formula\n * \n * Formula: accuracy = 103.1668 * exp(-0.04354 * probLoss) - 3.1669\n * \n * @param winProbBefore - Win probability before the move\n * @param winProbAfter - Win probability after the move\n * @returns Accuracy score (0-100)\n */\nexport function calculateMoveAccuracy(winProbBefore: number, winProbAfter: number): number {\n  const probLoss = winProbBefore - winProbAfter;\n  \n  // If position improved or stayed same, accuracy is 100%\n  if (probLoss <= 0) return 100;\n  \n  // Chess.com's official formula\n  const accuracy = 103.1668 * Math.exp(-0.04354 * probLoss) - 3.1669;\n  return Math.max(0, Math.min(100, accuracy));\n}\n\n// ===================== MOVE QUALITY TYPES =====================\n\nexport type MoveQuality = \n  | 'brilliant'   // !! - Exceptional sacrifice or only winning move\n  | 'great'       // !  - Significantly better than alternatives\n  | 'best'        // âœ“  - Engine's top choice (< 5cp loss)\n  | 'good'        // â—‹  - Solid move (< 30cp loss)\n  | 'book'        // ðŸ“– - Opening theory move\n  | 'inaccuracy'  // ?! - Small mistake (30-75cp loss)\n  | 'mistake'     // ?  - Clear error (75-200cp loss)\n  | 'blunder';    // ?? - Severe error (200+cp loss)\n\nexport interface MoveQualityInfo {\n  quality: MoveQuality;\n  symbol: string;\n  color: string;\n  label: string;\n  description: string;\n  cpLossRange?: string;\n}\n\nexport const MOVE_QUALITY_INFO: Record<MoveQuality, MoveQualityInfo> = {\n  brilliant: {\n    quality: 'brilliant',\n    symbol: '!!',\n    color: '#26C9A2',\n    label: 'Brilliant',\n    description: 'An exceptional move that sacrifices material for a winning position, or the only move that maintains advantage',\n    cpLossRange: 'Gains advantage through sacrifice',\n  },\n  great: {\n    quality: 'great',\n    symbol: '!',\n    color: '#81B64C',\n    label: 'Great',\n    description: 'A strong move that finds a tactical resource or significantly improves the position',\n    cpLossRange: '0 cp loss, tactical',\n  },\n  best: {\n    quality: 'best',\n    symbol: 'âœ“',\n    color: '#96BC4B',\n    label: 'Best',\n    description: 'The objectively strongest move - what Stockfish would play',\n    cpLossRange: '< 5 cp loss',\n  },\n  good: {\n    quality: 'good',\n    symbol: 'â—‹',\n    color: '#A3A3A3',\n    label: 'Good',\n    description: 'A solid move that maintains the position without significant loss',\n    cpLossRange: '5-30 cp loss',\n  },\n  book: {\n    quality: 'book',\n    symbol: 'ðŸ“–',\n    color: '#769656',\n    label: 'Book Move',\n    description: 'A standard opening theory move recognized by chess databases',\n    cpLossRange: 'Theoretical',\n  },\n  inaccuracy: {\n    quality: 'inaccuracy',\n    symbol: '?!',\n    color: '#F7C631',\n    label: 'Inaccuracy',\n    description: 'A suboptimal move that slightly weakens the position',\n    cpLossRange: '30-75 cp loss',\n  },\n  mistake: {\n    quality: 'mistake',\n    symbol: '?',\n    color: '#E58F2A',\n    label: 'Mistake',\n    description: 'A clear error that significantly damages the position',\n    cpLossRange: '75-200 cp loss',\n  },\n  blunder: {\n    quality: 'blunder',\n    symbol: '??',\n    color: '#CA3431',\n    label: 'Blunder',\n    description: 'A severe error that often leads to loss of game or major material',\n    cpLossRange: '> 200 cp loss',\n  },\n};\n\n// ===================== MOVE CLASSIFICATION =====================\n\nexport interface ClassifiedMove {\n  moveNumber: number;\n  color: 'w' | 'b';\n  san: string;\n  uci: string;\n  quality: MoveQuality;\n  info: MoveQualityInfo;\n  materialChange: number;\n  isCapture: boolean;\n  isCheck: boolean;\n  isCheckmate: boolean;\n  isCastle: boolean;\n  isPromotion: boolean;\n  isSacrifice: boolean;\n}\n\n/**\n * Analyze a game and classify each move's quality\n * \n * Note: Without a chess engine, we use heuristic analysis based on:\n * - Material changes\n * - Tactical patterns (checks, checkmates, captures)\n * - Opening theory recognition\n * - Sacrifice detection\n */\nexport function classifyMoves(pgn: string): ClassifiedMove[] {\n  const chess = new Chess();\n  const classifiedMoves: ClassifiedMove[] = [];\n  \n  try {\n    chess.loadPgn(pgn);\n    const history = chess.history({ verbose: true });\n    \n    // Reset to analyze move by move\n    chess.reset();\n    \n    let previousMaterialBalance = 0;\n    \n    history.forEach((move, index) => {\n      const moveNumber = Math.floor(index / 2) + 1;\n      const color = move.color;\n      \n      // Execute the move\n      chess.move(move.san);\n      \n      // Calculate material balance after move\n      const currentMaterialBalance = calculateMaterialBalance(chess);\n      const materialChange = color === 'w' \n        ? currentMaterialBalance - previousMaterialBalance\n        : previousMaterialBalance - currentMaterialBalance;\n      \n      // Detect move characteristics\n      const isCapture = move.flags.includes('c') || move.flags.includes('e');\n      const isCheck = move.san.includes('+');\n      const isCheckmate = move.san.includes('#');\n      const isCastle = move.flags.includes('k') || move.flags.includes('q');\n      const isPromotion = !!move.promotion;\n      const isSacrifice = detectSacrifice(move, chess, materialChange);\n      \n      // Classify the move quality\n      const quality = classifySingleMove({\n        move,\n        chess,\n        moveNumber,\n        isCapture,\n        isCheck,\n        isCheckmate,\n        isSacrifice,\n        materialChange,\n        isOpening: moveNumber <= 10,\n      });\n      \n      classifiedMoves.push({\n        moveNumber,\n        color,\n        san: move.san,\n        uci: move.from + move.to + (move.promotion || ''),\n        quality,\n        info: MOVE_QUALITY_INFO[quality],\n        materialChange,\n        isCapture,\n        isCheck,\n        isCheckmate,\n        isCastle,\n        isPromotion,\n        isSacrifice,\n      });\n      \n      previousMaterialBalance = currentMaterialBalance;\n    });\n  } catch (e) {\n    console.error('Error classifying moves:', e);\n  }\n  \n  return classifiedMoves;\n}\n\ninterface ClassifyMoveParams {\n  move: Move;\n  chess: Chess;\n  moveNumber: number;\n  isCapture: boolean;\n  isCheck: boolean;\n  isCheckmate: boolean;\n  isSacrifice: boolean;\n  materialChange: number;\n  isOpening: boolean;\n}\n\nfunction classifySingleMove(params: ClassifyMoveParams): MoveQuality {\n  const { move, chess, moveNumber, isCapture, isCheck, isCheckmate, isSacrifice, materialChange, isOpening } = params;\n  \n  // ========== CHECKMATE DETECTION ==========\n  // Checkmate is always brilliant - it's the ultimate goal\n  if (isCheckmate) {\n    return 'brilliant';\n  }\n  \n  // ========== BRILLIANT MOVE DETECTION ==========\n  // Based on chess.com criteria: sacrifice that leads to advantage\n  \n  // Sacrifice leading to check (discovered attacks, forcing moves)\n  if (isSacrifice && isCheck) {\n    return 'brilliant';\n  }\n  \n  // Sacrifice a significant piece for a forced winning position\n  // (giving up 3+ points of material that leads to a better position)\n  if (isSacrifice && materialChange < -200 && materialChange > -600) {\n    // This could be a brilliant exchange sacrifice or minor piece sacrifice\n    // for positional compensation\n    return 'brilliant';\n  }\n  \n  // Queen sacrifice that leads to winning position\n  if (isSacrifice && move.piece === 'q' && !isCheckmate) {\n    return 'brilliant';\n  }\n  \n  // ========== BLUNDER DETECTION (> 200 cp loss) ==========\n  // Losing queen without compensation\n  if (materialChange < -800) {\n    return 'blunder';\n  }\n  \n  // Losing rook without compensation\n  if (materialChange < -450 && !isSacrifice) {\n    return 'blunder';\n  }\n  \n  // Losing minor piece without any tactical benefit\n  if (materialChange < -200 && !isCheck && !isSacrifice) {\n    return 'blunder';\n  }\n  \n  // ========== MISTAKE DETECTION (75-200 cp loss) ==========\n  // Losing significant material (1-2 pawns worth)\n  if (materialChange < -75 && !isSacrifice) {\n    return 'mistake';\n  }\n  \n  // ========== INACCURACY DETECTION (30-75 cp loss) ==========\n  // Small material loss\n  if (materialChange < -30 && !isSacrifice) {\n    return 'inaccuracy';\n  }\n  \n  // ========== BOOK MOVES ==========\n  // Standard opening theory in first 15 moves\n  if (isOpening && isStandardOpeningMove(move, moveNumber)) {\n    return 'book';\n  }\n  \n  // ========== GREAT MOVE DETECTION ==========\n  // Winning queen or major material advantage\n  if (materialChange >= 800) {\n    return 'brilliant';\n  }\n  \n  // Winning rook or significant material\n  if (materialChange >= 450) {\n    return 'great';\n  }\n  \n  // Winning minor piece cleanly\n  if (materialChange >= 280) {\n    return 'great';\n  }\n  \n  // Check that wins significant material\n  if (isCheck && materialChange >= 200) {\n    return 'great';\n  }\n  \n  // ========== BEST MOVE DETECTION ==========\n  // Winning material worth 1-2 pawns\n  if (materialChange >= 80) {\n    return 'best';\n  }\n  \n  // Check with material gain\n  if (isCheck && materialChange > 0) {\n    return 'best';\n  }\n  \n  // Equal trade of pieces (good technique)\n  if (isCapture && Math.abs(materialChange) < 30) {\n    return 'best';\n  }\n  \n  // ========== GOOD MOVE DETECTION ==========\n  // Check that doesn't lose material\n  if (isCheck && materialChange >= -20) {\n    return 'good';\n  }\n  \n  // Castling in opening/middlegame (king safety)\n  if ((move.flags.includes('k') || move.flags.includes('q')) && moveNumber <= 25) {\n    return 'good';\n  }\n  \n  // Central pawn moves in opening\n  if (isOpening && ['e4', 'd4', 'e5', 'd5', 'c4', 'c5'].includes(move.san)) {\n    return 'best';\n  }\n  \n  // Knight development to ideal squares\n  if (isOpening && move.piece === 'n' && ['c3', 'f3', 'c6', 'f6', 'd2', 'e2', 'd7', 'e7'].includes(move.to)) {\n    return 'good';\n  }\n  \n  // Bishop development\n  if (isOpening && move.piece === 'b' && moveNumber <= 10) {\n    return 'good';\n  }\n  \n  // Rook to open file in middlegame\n  if (move.piece === 'r' && !isOpening && ['d', 'e'].includes(move.to[0])) {\n    return 'good';\n  }\n  \n  // Default: neutral move without clear improvement\n  // Without full engine analysis, this is the safest classification\n  return 'good';\n}\n\n/**\n * Calculate total material balance on the board (positive = white advantage)\n */\nfunction calculateMaterialBalance(chess: Chess): number {\n  let balance = 0;\n  const files = 'abcdefgh';\n  const ranks = '12345678';\n  \n  for (const file of files) {\n    for (const rank of ranks) {\n      const square = (file + rank) as Square;\n      const piece = chess.get(square);\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n        balance += piece.color === 'w' ? value : -value;\n      }\n    }\n  }\n  \n  return balance;\n}\n\n/**\n * Detect if a move is a sacrifice (giving up material for positional/tactical gain)\n */\nfunction detectSacrifice(move: Move, chess: Chess, materialChange: number): boolean {\n  // A sacrifice typically involves:\n  // 1. Giving up higher-value piece for lower-value piece\n  // 2. Or leaving a piece hanging\n  \n  if (!move.captured) return false;\n  \n  const attackerValue = PIECE_VALUES[move.piece];\n  const capturedValue = PIECE_VALUES[move.captured as PieceSymbol];\n  \n  // If we captured less than we're worth and didn't immediately gain material\n  if (attackerValue > capturedValue + 50 && materialChange < 0) {\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Extended opening theory database\n * Based on ECO encyclopedia and common GM practice\n */\nconst OPENING_THEORY: Record<number, string[]> = {\n  // Move 1\n  1: ['e4', 'd4', 'Nf3', 'c4', 'g3', 'b3', 'f4', 'Nc3', 'e3', 'd3',\n      'e5', 'd5', 'Nf6', 'c5', 'c6', 'e6', 'g6', 'd6', 'b6', 'f5'],\n  // Move 2\n  2: ['e4', 'd4', 'Nf3', 'c4', 'Nc3', 'Bc4', 'Bb5', 'f4', 'exd5', 'cxd4',\n      'e5', 'd5', 'Nf6', 'Nc6', 'e6', 'd6', 'g6', 'Bg7', 'Be7', 'c6', 'cxd4', 'exf4'],\n  // Move 3\n  3: ['Bc4', 'Bb5', 'Nf3', 'Nc3', 'd4', 'd3', 'Be2', 'f3', 'g3', 'exd4', 'Nxd4',\n      'Bc5', 'Bb4', 'Be7', 'Nf6', 'Nc6', 'd6', 'a6', 'g6', 'Bg7', 'cxd4', 'dxc4'],\n  // Move 4\n  4: ['O-O', 'Nf3', 'd4', 'd3', 'c3', 'Nc3', 'Ba4', 'Bxc6', 'Nxd4', 'exd5',\n      'O-O', 'Be7', 'Bc5', 'd6', 'a6', 'Nf6', 'Bg4', 'Be6', 'dxc4', 'Nxd4'],\n  // Move 5\n  5: ['O-O', 'd4', 'c3', 'Re1', 'd3', 'Bg5', 'Nxc6', 'e5', 'Qe2', 'Be3',\n      'O-O', 'Be7', 'd6', 'a6', 'O-O-O', 'Bg4', 'e5', 'Nbd7', 'h6', 'Qc7'],\n  // Move 6\n  6: ['Re1', 'Qe2', 'h3', 'a3', 'Bc2', 'c3', 'd4', 'Bg5', 'Bxf6', 'exd5',\n      'b5', 'Be7', 'Bb7', 'Qc7', 'Bd7', 'Be6', 'O-O', 'a6', 'h6', 'Rc8'],\n  // Move 7\n  7: ['Bb3', 'a4', 'c3', 'd4', 'Nbd2', 'h3', 'Re1', 'Bc2', 'd5', 'exd5',\n      'O-O', 'd5', 'Bb7', 'Be7', 'Nc6', 'Qc7', 'Bd7', 'a5', 'Rc8', 'h6'],\n  // Move 8\n  8: ['c3', 'd4', 'a4', 'h3', 'Bc2', 'Nbd2', 'd5', 'Bg5', 'a3', 'Re1',\n      'd5', 'O-O', 'Bb7', 'Qc7', 'Rc8', 'Be7', 'Nd7', 'a5', 'exd4', 'h6'],\n  // Move 9-15 (common continuations)\n  9: ['d4', 'Bc2', 'Nbd2', 'h3', 'a4', 'Be3', 'd5', 'exd5', 'Bg5', 'Re1',\n      'c5', 'd5', 'Bb7', 'O-O', 'Qc7', 'Nc6', 'Rc8', 'Be7', 'h6', 'exd4'],\n  10: ['Nbd2', 'd4', 'Bc2', 'cxd4', 'd5', 'a4', 'Bg5', 'dxc5', 'exd5', 'Qc2',\n       'cxd4', 'Bb7', 'Qc7', 'Rc8', 'Nc6', 'Be7', 'd5', 'O-O', 'Nxd4', 'h6'],\n  // Extended theory (moves 11-15)\n  11: ['Nf1', 'd5', 'Bc2', 'Ng3', 'a4', 'Qd3', 'b3', 'Bd2', 'cxd5', 'exd5'],\n  12: ['Ng3', 'a4', 'd5', 'Qd3', 'b4', 'Bd2', 'Rac1', 'f4', 'cxd5', 'Nxd5'],\n  13: ['Nf5', 'd6', 'a5', 'Qd2', 'b5', 'g4', 'f4', 'Rac1', 'Bd3', 'Kh1'],\n  14: ['Bxf5', 'g4', 'a6', 'Ng3', 'f4', 'Qf3', 'Rf3', 'Rg3', 'Kh1', 'b4'],\n  15: ['g4', 'f4', 'Ng3', 'Kh1', 'Rg3', 'Qf3', 'h4', 'Qh5', 'g5', 'f5'],\n};\n\n/**\n * Check if a move matches standard opening theory\n * Uses extended database covering 15 moves of main lines\n */\nfunction isStandardOpeningMove(move: Move, moveNumber: number): boolean {\n  // Only check first 15 moves for opening theory\n  if (moveNumber > 15) return false;\n  \n  const movesForNumber = OPENING_THEORY[moveNumber];\n  if (!movesForNumber) return false;\n  \n  // Clean move notation for comparison (remove check, capture, and annotation symbols)\n  const cleanSan = move.san.replace(/[+#!?x]/g, '');\n  return movesForNumber.includes(cleanSan);\n}\n\n// ===================== SUMMARY STATISTICS =====================\n\nexport interface MoveQualitySummary {\n  totalMoves: number;\n  brilliantCount: number;\n  greatCount: number;\n  bestCount: number;\n  goodCount: number;\n  bookCount: number;\n  inaccuracyCount: number;\n  mistakeCount: number;\n  blunderCount: number;\n  // Tactical event counts\n  checkCount: number;\n  checkmateCount: number;\n  captureCount: number;\n  castleCount: number;\n  promotionCount: number;\n  sacrificeCount: number;\n  accuracy: number; // Overall accuracy percentage\n  whiteAccuracy: number; // White's accuracy percentage\n  blackAccuracy: number; // Black's accuracy percentage\n  whiteMoves: ClassifiedMove[];\n  blackMoves: ClassifiedMove[];\n}\n\n// Helper function to calculate accuracy from moves array\nfunction calculateAccuracyFromMoves(moves: ClassifiedMove[]): number {\n  if (moves.length === 0) return 100;\n  \n  let score = 0;\n  for (const move of moves) {\n    switch (move.quality) {\n      case 'brilliant': score += 100; break;\n      case 'great': score += 95; break;\n      case 'best': score += 90; break;\n      case 'good': score += 75; break;\n      case 'book': score += 85; break;\n      case 'inaccuracy': score += 50; break;\n      case 'mistake': score += 25; break;\n      case 'blunder': score += 0; break;\n    }\n  }\n  \n  return Math.round((score / (moves.length * 100)) * 100);\n}\n\nexport function getMoveQualitySummary(classifiedMoves: ClassifiedMove[]): MoveQualitySummary {\n  const summary: MoveQualitySummary = {\n    totalMoves: classifiedMoves.length,\n    brilliantCount: 0,\n    greatCount: 0,\n    bestCount: 0,\n    goodCount: 0,\n    bookCount: 0,\n    inaccuracyCount: 0,\n    mistakeCount: 0,\n    blunderCount: 0,\n    checkCount: 0,\n    checkmateCount: 0,\n    captureCount: 0,\n    castleCount: 0,\n    promotionCount: 0,\n    sacrificeCount: 0,\n    accuracy: 0,\n    whiteAccuracy: 0,\n    blackAccuracy: 0,\n    whiteMoves: [],\n    blackMoves: [],\n  };\n  \n  for (const move of classifiedMoves) {\n    switch (move.quality) {\n      case 'brilliant': summary.brilliantCount++; break;\n      case 'great': summary.greatCount++; break;\n      case 'best': summary.bestCount++; break;\n      case 'good': summary.goodCount++; break;\n      case 'book': summary.bookCount++; break;\n      case 'inaccuracy': summary.inaccuracyCount++; break;\n      case 'mistake': summary.mistakeCount++; break;\n      case 'blunder': summary.blunderCount++; break;\n    }\n    \n    // Count tactical events\n    if (move.isCheckmate) summary.checkmateCount++;\n    else if (move.isCheck) summary.checkCount++; // Only count non-checkmate checks\n    if (move.isCapture) summary.captureCount++;\n    if (move.isCastle) summary.castleCount++;\n    if (move.isPromotion) summary.promotionCount++;\n    if (move.isSacrifice) summary.sacrificeCount++;\n    \n    if (move.color === 'w') {\n      summary.whiteMoves.push(move);\n    } else {\n      summary.blackMoves.push(move);\n    }\n  }\n  \n  // Calculate overall accuracy using weighted scoring (chess.com-like formula)\n  summary.accuracy = calculateAccuracyFromMoves(classifiedMoves);\n  \n  // Calculate per-player accuracy\n  summary.whiteAccuracy = calculateAccuracyFromMoves(summary.whiteMoves);\n  summary.blackAccuracy = calculateAccuracyFromMoves(summary.blackMoves);\n  \n  return summary;\n}\n\n// ===================== KEY MOMENTS =====================\n\nexport interface KeyMoment {\n  moveNumber: number;\n  color: 'w' | 'b';\n  san: string;\n  type: 'brilliant' | 'blunder' | 'checkmate' | 'check' | 'sacrifice' | 'capture';\n  description: string;\n  quality: MoveQuality;\n}\n\nexport function getKeyMoments(classifiedMoves: ClassifiedMove[]): KeyMoment[] {\n  const keyMoments: KeyMoment[] = [];\n  \n  for (const move of classifiedMoves) {\n    // Always include checkmates\n    if (move.isCheckmate) {\n      keyMoments.push({\n        moveNumber: move.moveNumber,\n        color: move.color,\n        san: move.san,\n        type: 'checkmate',\n        description: `${move.color === 'w' ? 'White' : 'Black'} delivers checkmate!`,\n        quality: move.quality,\n      });\n      continue;\n    }\n    \n    // Include brilliant moves\n    if (move.quality === 'brilliant') {\n      keyMoments.push({\n        moveNumber: move.moveNumber,\n        color: move.color,\n        san: move.san,\n        type: 'brilliant',\n        description: `Brilliant move ${move.san}!`,\n        quality: move.quality,\n      });\n      continue;\n    }\n    \n    // Include blunders\n    if (move.quality === 'blunder') {\n      keyMoments.push({\n        moveNumber: move.moveNumber,\n        color: move.color,\n        san: move.san,\n        type: 'blunder',\n        description: `Blunder ${move.san} - material lost`,\n        quality: move.quality,\n      });\n      continue;\n    }\n    \n    // Include sacrifices\n    if (move.isSacrifice) {\n      keyMoments.push({\n        moveNumber: move.moveNumber,\n        color: move.color,\n        san: move.san,\n        type: 'sacrifice',\n        description: `Sacrifice! ${move.san}`,\n        quality: move.quality,\n      });\n    }\n  }\n  \n  return keyMoments;\n}\n";export{n as default};
