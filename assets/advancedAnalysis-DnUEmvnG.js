const n="/**\n * Advanced Chess Analysis System\n * \n * Inspired by Stockfish and chess.com evaluation methods.\n * Provides comprehensive position evaluation, tactical detection,\n * and move quality scoring using centipawn-based analysis.\n * \n * Key Features:\n * - Centipawn evaluation system\n * - Win probability calculations\n * - Advanced tactical pattern detection\n * - Positional evaluation factors\n * - Enhanced move quality classification\n */\n\nimport { Chess, Move, Square, PieceSymbol, Color } from 'chess.js';\nimport { TemporalSignature, QuadrantProfile, TemporalFlow, CriticalMoment } from '@/lib/pensent-core/types';\nimport { classifyUniversalArchetype } from '@/lib/pensent-core/archetype';\n\n// ===================== PIECE VALUES (STOCKFISH-INSPIRED) =====================\n\n/**\n * Standard piece values in centipawns (100cp = 1 pawn)\n * Based on Stockfish's evaluation function\n */\nexport const CENTIPAWN_VALUES: Record<PieceSymbol, number> = {\n  p: 100,   // Pawn\n  n: 305,   // Knight (Stockfish uses ~305)\n  b: 333,   // Bishop (slightly > knight due to long-range)\n  r: 563,   // Rook\n  q: 950,   // Queen\n  k: 0,     // King (infinite value, but 0 for material calc)\n};\n\n/**\n * Endgame piece values (pieces change value in endgame)\n */\nexport const ENDGAME_VALUES: Record<PieceSymbol, number> = {\n  p: 120,   // Pawns more valuable in endgame\n  n: 290,   // Knights slightly weaker\n  b: 340,   // Bishops slightly stronger\n  r: 590,   // Rooks more valuable\n  q: 980,   // Queen more valuable\n  k: 0,\n};\n\n// ===================== WIN PROBABILITY =====================\n\n/**\n * Convert centipawn evaluation to win probability\n * Based on Lichess/chess.com formula\n * \n * Formula: winProb = 50 + 50 * (2 / (1 + exp(-0.00368208 * cp)) - 1)\n */\nexport function cpToWinProbability(centipawns: number): number {\n  const K = 0.00368208; // Scaling factor from Lichess\n  return 50 + 50 * (2 / (1 + Math.exp(-K * centipawns)) - 1);\n}\n\n/**\n * Calculate accuracy from win probability change\n * Formula: 103.1668 * exp(-0.04354 * (winProbBefore - winProbAfter)) - 3.1669\n * This matches chess.com's accuracy calculation\n */\nexport function calculateMoveAccuracy(winProbBefore: number, winProbAfter: number): number {\n  const probLoss = winProbBefore - winProbAfter;\n  \n  // If position improved, accuracy is 100%\n  if (probLoss <= 0) return 100;\n  \n  // Chess.com's formula\n  const accuracy = 103.1668 * Math.exp(-0.04354 * probLoss) - 3.1669;\n  return Math.max(0, Math.min(100, accuracy));\n}\n\n// ===================== POSITION EVALUATION =====================\n\nexport interface PositionEvaluation {\n  material: number;           // Material balance in centipawns\n  pawnStructure: number;      // Pawn structure score\n  kingSafety: number;         // King safety score\n  pieceActivity: number;      // Piece mobility and activity\n  centerControl: number;      // Control of central squares\n  development: number;        // Development score (opening)\n  space: number;              // Space advantage\n  threats: number;            // Immediate threats score\n  total: number;              // Total evaluation\n  phase: 'opening' | 'middlegame' | 'endgame';\n}\n\n/**\n * Evaluate a chess position (simplified Stockfish-like evaluation)\n */\nexport function evaluatePosition(chess: Chess): PositionEvaluation {\n  const board = chess.board();\n  const phase = detectGamePhase(chess);\n  \n  // Material count\n  const material = calculateMaterialBalance(chess, phase);\n  \n  // Pawn structure evaluation\n  const pawnStructure = evaluatePawnStructure(chess);\n  \n  // King safety\n  const kingSafety = evaluateKingSafety(chess, phase);\n  \n  // Piece activity (mobility)\n  const pieceActivity = evaluatePieceActivity(chess);\n  \n  // Center control\n  const centerControl = evaluateCenterControl(chess);\n  \n  // Development (mainly for opening)\n  const development = phase === 'opening' ? evaluateDevelopment(chess) : 0;\n  \n  // Space advantage\n  const space = evaluateSpace(chess);\n  \n  // Immediate threats\n  const threats = evaluateThreats(chess);\n  \n  const total = material + pawnStructure + kingSafety + pieceActivity + \n                centerControl + development + space + threats;\n  \n  return {\n    material,\n    pawnStructure,\n    kingSafety,\n    pieceActivity,\n    centerControl,\n    development,\n    space,\n    threats,\n    total,\n    phase,\n  };\n}\n\nfunction detectGamePhase(chess: Chess): 'opening' | 'middlegame' | 'endgame' {\n  let pieceCount = 0;\n  let queenCount = 0;\n  const board = chess.board();\n  \n  for (const row of board) {\n    for (const square of row) {\n      if (square && square.type !== 'k') {\n        pieceCount++;\n        if (square.type === 'q') queenCount++;\n      }\n    }\n  }\n  \n  // Opening: most pieces still on board\n  if (pieceCount >= 28) return 'opening';\n  // Endgame: few pieces or no queens\n  if (pieceCount <= 14 || queenCount === 0) return 'endgame';\n  return 'middlegame';\n}\n\nfunction calculateMaterialBalance(chess: Chess, phase: 'opening' | 'middlegame' | 'endgame'): number {\n  let balance = 0;\n  const values = phase === 'endgame' ? ENDGAME_VALUES : CENTIPAWN_VALUES;\n  const board = chess.board();\n  \n  for (const row of board) {\n    for (const square of row) {\n      if (square) {\n        const value = values[square.type];\n        balance += square.color === 'w' ? value : -value;\n      }\n    }\n  }\n  \n  return balance;\n}\n\nfunction evaluatePawnStructure(chess: Chess): number {\n  let score = 0;\n  const board = chess.board();\n  const files = { w: new Array(8).fill(0), b: new Array(8).fill(0) };\n  \n  // Count pawns per file\n  for (let file = 0; file < 8; file++) {\n    for (let rank = 0; rank < 8; rank++) {\n      const piece = board[rank][file];\n      if (piece?.type === 'p') {\n        files[piece.color][file]++;\n      }\n    }\n  }\n  \n  // Evaluate pawn structure factors\n  for (let file = 0; file < 8; file++) {\n    // Doubled pawns penalty (-15cp per doubled pawn)\n    if (files.w[file] > 1) score -= 15 * (files.w[file] - 1);\n    if (files.b[file] > 1) score += 15 * (files.b[file] - 1);\n    \n    // Isolated pawns penalty (-20cp)\n    const hasLeftNeighborW = file > 0 && files.w[file - 1] > 0;\n    const hasRightNeighborW = file < 7 && files.w[file + 1] > 0;\n    const hasLeftNeighborB = file > 0 && files.b[file - 1] > 0;\n    const hasRightNeighborB = file < 7 && files.b[file + 1] > 0;\n    \n    if (files.w[file] > 0 && !hasLeftNeighborW && !hasRightNeighborW) {\n      score -= 20 * files.w[file];\n    }\n    if (files.b[file] > 0 && !hasLeftNeighborB && !hasRightNeighborB) {\n      score += 20 * files.b[file];\n    }\n  }\n  \n  // Passed pawns bonus (simplified check)\n  for (let file = 0; file < 8; file++) {\n    for (let rank = 0; rank < 8; rank++) {\n      const piece = board[rank][file];\n      if (piece?.type === 'p') {\n        if (piece.color === 'w' && isPassedPawn(board, file, rank, 'w')) {\n          const bonus = 20 + (rank * 10); // More valuable as it advances\n          score += bonus;\n        }\n        if (piece.color === 'b' && isPassedPawn(board, file, rank, 'b')) {\n          const bonus = 20 + ((7 - rank) * 10);\n          score -= bonus;\n        }\n      }\n    }\n  }\n  \n  return score;\n}\n\nfunction isPassedPawn(board: ({ type: PieceSymbol; color: Color } | null)[][], file: number, rank: number, color: Color): boolean {\n  const direction = color === 'w' ? 1 : -1;\n  const startRank = color === 'w' ? rank + 1 : rank - 1;\n  const endRank = color === 'w' ? 7 : 0;\n  \n  for (let r = startRank; color === 'w' ? r <= endRank : r >= endRank; r += direction) {\n    // Check same file and adjacent files for enemy pawns\n    for (let f = Math.max(0, file - 1); f <= Math.min(7, file + 1); f++) {\n      const piece = board[r][f];\n      if (piece?.type === 'p' && piece.color !== color) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction evaluateKingSafety(chess: Chess, phase: 'opening' | 'middlegame' | 'endgame'): number {\n  // King safety less important in endgame\n  if (phase === 'endgame') return 0;\n  \n  let score = 0;\n  const board = chess.board();\n  \n  // Find kings\n  let whiteKingPos: [number, number] | null = null;\n  let blackKingPos: [number, number] | null = null;\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece?.type === 'k') {\n        if (piece.color === 'w') whiteKingPos = [rank, file];\n        else blackKingPos = [rank, file];\n      }\n    }\n  }\n  \n  // Check pawn shelter for castled kings\n  if (whiteKingPos) {\n    const [rank, file] = whiteKingPos;\n    // Bonus for castled position (corner)\n    if ((file === 6 || file === 1) && rank === 0) {\n      score += 30; // Castled bonus\n      // Check pawn shield\n      const shieldScore = countPawnShield(board, rank, file, 'w');\n      score += shieldScore;\n    }\n    // Penalty for exposed king in center\n    if (file >= 2 && file <= 5 && rank <= 1 && phase === 'middlegame') {\n      score -= 50; // King stuck in center penalty\n    }\n  }\n  \n  if (blackKingPos) {\n    const [rank, file] = blackKingPos;\n    if ((file === 6 || file === 1) && rank === 7) {\n      score -= 30;\n      const shieldScore = countPawnShield(board, rank, file, 'b');\n      score -= shieldScore;\n    }\n    if (file >= 2 && file <= 5 && rank >= 6 && phase === 'middlegame') {\n      score += 50;\n    }\n  }\n  \n  return score;\n}\n\nfunction countPawnShield(board: ({ type: PieceSymbol; color: Color } | null)[][], kingRank: number, kingFile: number, color: Color): number {\n  let shieldScore = 0;\n  const shieldRank = color === 'w' ? 1 : 6;\n  \n  for (let f = Math.max(0, kingFile - 1); f <= Math.min(7, kingFile + 1); f++) {\n    const piece = board[shieldRank][f];\n    if (piece?.type === 'p' && piece.color === color) {\n      shieldScore += 10;\n    }\n  }\n  return shieldScore;\n}\n\nfunction evaluatePieceActivity(chess: Chess): number {\n  // Simple mobility count\n  const moves = chess.moves();\n  const mobility = moves.length;\n  \n  // Baseline is around 30-35 moves\n  return (mobility - 30) * 2; // 2cp per extra move above baseline\n}\n\nfunction evaluateCenterControl(chess: Chess): number {\n  let score = 0;\n  const centerSquares: Square[] = ['d4', 'd5', 'e4', 'e5'];\n  const extendedCenter: Square[] = ['c3', 'c4', 'c5', 'c6', 'd3', 'd6', 'e3', 'e6', 'f3', 'f4', 'f5', 'f6'];\n  \n  for (const sq of centerSquares) {\n    const piece = chess.get(sq);\n    if (piece) {\n      if (piece.type === 'p') {\n        score += piece.color === 'w' ? 20 : -20;\n      } else if (piece.type !== 'k') {\n        score += piece.color === 'w' ? 10 : -10;\n      }\n    }\n  }\n  \n  for (const sq of extendedCenter) {\n    const piece = chess.get(sq);\n    if (piece && piece.type !== 'k' && piece.type !== 'p') {\n      score += piece.color === 'w' ? 5 : -5;\n    }\n  }\n  \n  return score;\n}\n\nfunction evaluateDevelopment(chess: Chess): number {\n  let score = 0;\n  const board = chess.board();\n  \n  // Check if minor pieces are developed\n  // White back rank pieces\n  if (board[0][1]?.type === 'n') score -= 15; // b1 knight not developed\n  if (board[0][2]?.type === 'b') score -= 15; // c1 bishop not developed\n  if (board[0][5]?.type === 'b') score -= 15; // f1 bishop not developed\n  if (board[0][6]?.type === 'n') score -= 15; // g1 knight not developed\n  \n  // Black back rank pieces\n  if (board[7][1]?.type === 'n') score += 15;\n  if (board[7][2]?.type === 'b') score += 15;\n  if (board[7][5]?.type === 'b') score += 15;\n  if (board[7][6]?.type === 'n') score += 15;\n  \n  return score;\n}\n\nfunction evaluateSpace(chess: Chess): number {\n  let whiteSpace = 0;\n  let blackSpace = 0;\n  const board = chess.board();\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece?.type === 'p') {\n        // Count squares behind pawns as controlled space\n        if (piece.color === 'w') {\n          whiteSpace += rank; // Higher rank = more space\n        } else {\n          blackSpace += (7 - rank);\n        }\n      }\n    }\n  }\n  \n  return (whiteSpace - blackSpace) * 3;\n}\n\nfunction evaluateThreats(chess: Chess): number {\n  let score = 0;\n  \n  // Check if there's a check\n  if (chess.inCheck()) {\n    score += chess.turn() === 'w' ? -30 : 30; // Being in check is bad\n  }\n  \n  return score;\n}\n\n// ===================== ADVANCED TACTICAL PATTERNS =====================\n\nexport interface AdvancedTactic {\n  type: TacticType;\n  moveNumber: number;\n  notation: string;\n  attacker: { piece: PieceSymbol; from: Square; to: Square };\n  targets: { piece: PieceSymbol; square: Square }[];\n  description: string;\n  value: number; // Material value involved\n  subtlety: 'obvious' | 'subtle' | 'deep'; // How hard to spot\n}\n\nexport type TacticType = \n  | 'fork'\n  | 'pin'\n  | 'skewer'\n  | 'discovered_attack'\n  | 'discovered_check'\n  | 'double_check'\n  | 'back_rank_threat'\n  | 'deflection'\n  | 'decoy'\n  | 'x_ray'\n  | 'interference'\n  | 'removing_defender'\n  | 'overloading'\n  | 'zugzwang'\n  | 'desperado'\n  | 'zwischenzug'\n  | 'clearance'\n  | 'check'\n  | 'checkmate'\n  | 'stalemate_threat';\n\nexport const TACTIC_DESCRIPTIONS: Record<TacticType, { name: string; description: string; value: number }> = {\n  fork: { \n    name: 'Fork', \n    description: 'One piece attacks two or more pieces simultaneously', \n    value: 5 \n  },\n  pin: { \n    name: 'Pin', \n    description: 'A piece cannot move without exposing a more valuable piece behind it', \n    value: 4 \n  },\n  skewer: { \n    name: 'Skewer', \n    description: 'A more valuable piece is attacked and must move, exposing a less valuable piece', \n    value: 4 \n  },\n  discovered_attack: { \n    name: 'Discovered Attack', \n    description: 'Moving a piece reveals an attack from another piece', \n    value: 5 \n  },\n  discovered_check: { \n    name: 'Discovered Check', \n    description: 'Moving a piece reveals a check from another piece', \n    value: 6 \n  },\n  double_check: { \n    name: 'Double Check', \n    description: 'King is attacked by two pieces simultaneously - only king move can escape', \n    value: 8 \n  },\n  back_rank_threat: { \n    name: 'Back Rank Threat', \n    description: 'Threatening checkmate on the back rank', \n    value: 6 \n  },\n  deflection: { \n    name: 'Deflection', \n    description: 'Forcing a defender away from protecting a key piece or square', \n    value: 5 \n  },\n  decoy: { \n    name: 'Decoy', \n    description: 'Luring a piece to a vulnerable square', \n    value: 5 \n  },\n  x_ray: { \n    name: 'X-Ray', \n    description: 'A piece attacks through another piece of the same type', \n    value: 3 \n  },\n  interference: { \n    name: 'Interference', \n    description: 'Placing a piece between an enemy piece and the square it defends', \n    value: 4 \n  },\n  removing_defender: { \n    name: 'Removing the Defender', \n    description: 'Eliminating a piece that defends a target', \n    value: 5 \n  },\n  overloading: { \n    name: 'Overloading', \n    description: 'A piece has too many defensive duties to handle', \n    value: 4 \n  },\n  zugzwang: { \n    name: 'Zugzwang', \n    description: 'Any move worsens the position - the obligation to move is a disadvantage', \n    value: 7 \n  },\n  desperado: { \n    name: 'Desperado', \n    description: 'A piece that is lost anyway captures maximum material before being taken', \n    value: 3 \n  },\n  zwischenzug: { \n    name: 'Zwischenzug', \n    description: 'An \"in-between move\" - an unexpected move before the expected recapture', \n    value: 6 \n  },\n  clearance: { \n    name: 'Clearance', \n    description: 'Moving a piece to clear a line or square for another piece', \n    value: 3 \n  },\n  check: { \n    name: 'Check', \n    description: 'The king is under direct attack', \n    value: 2 \n  },\n  checkmate: { \n    name: 'Checkmate', \n    description: 'The king is in check and cannot escape - game over', \n    value: 100 \n  },\n  stalemate_threat: { \n    name: 'Stalemate Threat', \n    description: 'Threatening to force a draw by stalemate', \n    value: 4 \n  },\n};\n\n// ===================== ENHANCED MOVE CLASSIFICATION =====================\n\nexport interface EnhancedMoveQuality {\n  quality: MoveQualityType;\n  symbol: string;\n  color: string;\n  label: string;\n  accuracy: number;           // 0-100 accuracy of the move\n  cpLoss: number;             // Centipawn loss from this move\n  winProbabilityLoss: number; // Win probability lost\n  isTheoretical: boolean;     // Is this a known book move\n  isCritical: boolean;        // Is this a critical moment\n  tacticsMissed: TacticType[];// Tactics that were available but not played\n  tacticsExecuted: TacticType[];// Tactics that were executed\n}\n\nexport type MoveQualityType = \n  | 'brilliant'    // !! - Sacrifice or only move that dramatically improves position\n  | 'great'        // !  - Strong move, significantly better than alternatives\n  | 'best'         // âœ“  - Engine's top choice\n  | 'excellent'    // âŠ›  - Very close to best, essentially equal\n  | 'good'         // â—‹  - Solid, maintains equality or advantage\n  | 'book'         // ðŸ“– - Opening theory\n  | 'inaccuracy'   // ?! - Small mistake, loses some advantage (10-50 cp)\n  | 'mistake'      // ?  - Clear error, significant loss (50-200 cp)\n  | 'blunder'      // ?? - Severe error, game-losing (200+ cp)\n  | 'miss'         // âŠ˜  - Missed a winning tactic\n  | 'forced';      // âŠ¡  - Only legal move\n\nexport const MOVE_QUALITY_THRESHOLDS = {\n  // Centipawn loss thresholds (similar to chess.com)\n  brilliant: { maxCpLoss: -50, minTacticalValue: 300 }, // Gained value through sacrifice\n  great: { maxCpLoss: 0, minTacticalValue: 100 },\n  best: { maxCpLoss: 5 },\n  excellent: { maxCpLoss: 15 },\n  good: { maxCpLoss: 30 },\n  inaccuracy: { maxCpLoss: 75 },\n  mistake: { maxCpLoss: 200 },\n  blunder: { maxCpLoss: Infinity },\n};\n\nexport const ENHANCED_QUALITY_INFO: Record<MoveQualityType, { symbol: string; color: string; label: string }> = {\n  brilliant: { symbol: '!!', color: '#26C9A2', label: 'Brilliant' },\n  great: { symbol: '!', color: '#81B64C', label: 'Great' },\n  best: { symbol: 'âœ“', color: '#96BC4B', label: 'Best' },\n  excellent: { symbol: 'âŠ›', color: '#A8D08D', label: 'Excellent' },\n  good: { symbol: 'â—‹', color: '#A3A3A3', label: 'Good' },\n  book: { symbol: 'ðŸ“–', color: '#769656', label: 'Book Move' },\n  inaccuracy: { symbol: '?!', color: '#F7C631', label: 'Inaccuracy' },\n  mistake: { symbol: '?', color: '#E58F2A', label: 'Mistake' },\n  blunder: { symbol: '??', color: '#CA3431', label: 'Blunder' },\n  miss: { symbol: 'âŠ˜', color: '#E63946', label: 'Missed Win' },\n  forced: { symbol: 'âŠ¡', color: '#9CA3AF', label: 'Forced' },\n};\n\n// ===================== COMPREHENSIVE GAME SCORE =====================\n\nexport interface GameScore {\n  whiteAccuracy: number;\n  blackAccuracy: number;\n  overallAccuracy: number;\n  whiteCpLoss: number;\n  blackCpLoss: number;\n  brilliantMoves: { white: number; black: number };\n  greatMoves: { white: number; black: number };\n  blunders: { white: number; black: number };\n  mistakes: { white: number; black: number };\n  inaccuracies: { white: number; black: number };\n  tacticsExecuted: { white: number; black: number };\n  tacticsMissed: { white: number; black: number };\n  complexity: number; // 0-100 game complexity score\n  sharpness: number;  // 0-100 tactical sharpness\n  rating: {\n    estimated: { white: number; black: number };\n    category: 'beginner' | 'intermediate' | 'advanced' | 'master' | 'grandmaster';\n  };\n}\n\n/**\n * Calculate comprehensive game score from move analysis\n */\nexport function calculateGameScore(\n  moves: EnhancedMoveQuality[], \n  totalMoves: number\n): GameScore {\n  const whiteMoves = moves.filter((_, i) => i % 2 === 0);\n  const blackMoves = moves.filter((_, i) => i % 2 === 1);\n  \n  const calcAvg = (arr: EnhancedMoveQuality[], key: keyof EnhancedMoveQuality) => \n    arr.length ? arr.reduce((sum, m) => sum + (m[key] as number), 0) / arr.length : 0;\n  \n  const countQuality = (arr: EnhancedMoveQuality[], quality: MoveQualityType) =>\n    arr.filter(m => m.quality === quality).length;\n  \n  const whiteAccuracy = calcAvg(whiteMoves, 'accuracy');\n  const blackAccuracy = calcAvg(blackMoves, 'accuracy');\n  \n  const whiteCpLoss = whiteMoves.reduce((sum, m) => sum + Math.max(0, m.cpLoss), 0);\n  const blackCpLoss = blackMoves.reduce((sum, m) => sum + Math.max(0, m.cpLoss), 0);\n  \n  // Estimate rating based on accuracy (simplified formula)\n  const estimateRating = (accuracy: number) => {\n    if (accuracy >= 98) return 2700;\n    if (accuracy >= 95) return 2400;\n    if (accuracy >= 90) return 2100;\n    if (accuracy >= 85) return 1800;\n    if (accuracy >= 80) return 1500;\n    if (accuracy >= 70) return 1200;\n    return 900;\n  };\n  \n  const whiteRating = estimateRating(whiteAccuracy);\n  const blackRating = estimateRating(blackAccuracy);\n  const avgRating = (whiteRating + blackRating) / 2;\n  \n  let category: GameScore['rating']['category'] = 'beginner';\n  if (avgRating >= 2500) category = 'grandmaster';\n  else if (avgRating >= 2200) category = 'master';\n  else if (avgRating >= 1800) category = 'advanced';\n  else if (avgRating >= 1400) category = 'intermediate';\n  \n  // Calculate complexity based on tactical density\n  const tacticsTotal = moves.reduce((sum, m) => sum + m.tacticsExecuted.length, 0);\n  const complexity = Math.min(100, (tacticsTotal / totalMoves) * 200);\n  \n  // Calculate sharpness based on critical moments\n  const criticalMoments = moves.filter(m => m.isCritical).length;\n  const sharpness = Math.min(100, (criticalMoments / totalMoves) * 150);\n  \n  return {\n    whiteAccuracy: Math.round(whiteAccuracy * 10) / 10,\n    blackAccuracy: Math.round(blackAccuracy * 10) / 10,\n    overallAccuracy: Math.round((whiteAccuracy + blackAccuracy) / 2 * 10) / 10,\n    whiteCpLoss,\n    blackCpLoss,\n    brilliantMoves: {\n      white: countQuality(whiteMoves, 'brilliant'),\n      black: countQuality(blackMoves, 'brilliant'),\n    },\n    greatMoves: {\n      white: countQuality(whiteMoves, 'great'),\n      black: countQuality(blackMoves, 'great'),\n    },\n    blunders: {\n      white: countQuality(whiteMoves, 'blunder'),\n      black: countQuality(blackMoves, 'blunder'),\n    },\n    mistakes: {\n      white: countQuality(whiteMoves, 'mistake'),\n      black: countQuality(blackMoves, 'mistake'),\n    },\n    inaccuracies: {\n      white: countQuality(whiteMoves, 'inaccuracy'),\n      black: countQuality(blackMoves, 'inaccuracy'),\n    },\n    tacticsExecuted: {\n      white: whiteMoves.reduce((sum, m) => sum + m.tacticsExecuted.length, 0),\n      black: blackMoves.reduce((sum, m) => sum + m.tacticsExecuted.length, 0),\n    },\n    tacticsMissed: {\n      white: whiteMoves.reduce((sum, m) => sum + m.tacticsMissed.length, 0),\n      black: blackMoves.reduce((sum, m) => sum + m.tacticsMissed.length, 0),\n    },\n    complexity: Math.round(complexity),\n    sharpness: Math.round(sharpness),\n    rating: {\n      estimated: { white: whiteRating, black: blackRating },\n      category,\n    },\n  };\n}\n\n// ===================== EN PENSENT INTEGRATION =====================\n\n/**\n * Extract En Pensent temporal signature from game analysis\n * Enables cross-domain pattern matching and archetype classification\n */\nexport function extractGameSignature(\n  chess: Chess,\n  evaluation: PositionEvaluation\n): TemporalSignature {\n  const board = chess.board();\n  const history = chess.history();\n  const moveCount = history.length;\n  \n  // Calculate quadrant activity from piece positions\n  let q1 = 0, q2 = 0, q3 = 0, q4 = 0;\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece) {\n        const pieceValue = CENTIPAWN_VALUES[piece.type] / 100;\n        const colorMultiplier = piece.color === 'w' ? 1 : 0.9;\n        const weight = pieceValue * colorMultiplier;\n        \n        if (rank < 4 && file < 4) q1 += weight;\n        else if (rank < 4 && file >= 4) q2 += weight;\n        else if (rank >= 4 && file < 4) q3 += weight;\n        else q4 += weight;\n      }\n    }\n  }\n  \n  // Normalize quadrant values\n  const maxQ = Math.max(q1, q2, q3, q4, 1);\n  const quadrantProfile: QuadrantProfile = {\n    q1: q1 / maxQ,\n    q2: q2 / maxQ,\n    q3: q3 / maxQ,\n    q4: q4 / maxQ,\n    center: Math.abs(evaluation.centerControl) / 100 + 0.5\n  };\n  \n  // Build temporal flow from evaluation components\n  const phase = evaluation.phase;\n  const temporalFlow: TemporalFlow = {\n    opening: phase === 'opening' ? 0.9 : 0.2,\n    middle: phase === 'middlegame' ? 0.9 : 0.3,\n    ending: phase === 'endgame' ? 0.9 : 0.1,\n    trend: evaluation.pieceActivity > 20 ? 'accelerating' : \n           evaluation.pieceActivity < -20 ? 'declining' : 'stable',\n    momentum: evaluation.total / 500 // Normalize to -1 to 1 range\n  };\n  \n  // Calculate intensity from position activity\n  const intensity = Math.min(1, (Math.abs(evaluation.pieceActivity) + Math.abs(evaluation.threats)) / 100);\n  \n  // Generate fingerprint from FEN\n  const fen = chess.fen();\n  const fingerprint = `adv_${fen.split(' ')[0].replace(/\\//g, '').slice(0, 16)}_${moveCount}`;\n  \n  // Determine dominant force from material balance\n  const dominantForce: 'primary' | 'secondary' | 'balanced' = \n    evaluation.material > 100 ? 'primary' :\n    evaluation.material < -100 ? 'secondary' : 'balanced';\n  \n  // Detect critical moments\n  const criticalMoments: CriticalMoment[] = [];\n  \n  if (chess.inCheck()) {\n    criticalMoments.push({\n      index: moveCount,\n      type: 'check',\n      severity: 0.7,\n      description: 'King under attack'\n    });\n  }\n  \n  if (Math.abs(evaluation.threats) > 50) {\n    criticalMoments.push({\n      index: moveCount,\n      type: 'threat',\n      severity: Math.min(1, Math.abs(evaluation.threats) / 100),\n      description: 'Significant threats on the board'\n    });\n  }\n  \n  if (Math.abs(evaluation.kingSafety) > 40) {\n    criticalMoments.push({\n      index: moveCount,\n      type: 'king_safety',\n      severity: Math.min(1, Math.abs(evaluation.kingSafety) / 80),\n      description: 'King safety concerns'\n    });\n  }\n  \n  // Build signature\n  const signature: TemporalSignature = {\n    fingerprint,\n    archetype: 'unknown',\n    dominantForce,\n    flowDirection: temporalFlow.momentum > 0.2 ? 'forward' : \n                   temporalFlow.momentum < -0.2 ? 'backward' : 'lateral',\n    intensity,\n    quadrantProfile,\n    temporalFlow,\n    criticalMoments,\n    domainData: {\n      fen,\n      evaluation,\n      phase,\n      moveCount\n    }\n  };\n  \n  // Classify archetype using universal classifier\n  signature.archetype = classifyUniversalArchetype(signature);\n  \n  return signature;\n}\n\n/**\n * Analyze game with En Pensent pattern extraction\n */\nexport function analyzeWithPatterns(chess: Chess): {\n  evaluation: PositionEvaluation;\n  signature: TemporalSignature;\n  archetype: string;\n} {\n  const evaluation = evaluatePosition(chess);\n  const signature = extractGameSignature(chess, evaluation);\n  \n  return {\n    evaluation,\n    signature,\n    archetype: signature.archetype\n  };\n}\n";export{n as default};
