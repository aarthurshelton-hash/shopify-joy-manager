const n="import { supabase } from '@/integrations/supabase/client';\nimport { z } from 'zod';\nimport { SecurityEvents } from '@/lib/security/auditLog';\n\n// Validation schema for listing price\nconst listingPriceSchema = z.number()\n  .int('Price must be a whole number of cents')\n  .min(0, 'Price cannot be negative')\n  .max(1000000, 'Maximum price is $10,000');\n\nexport interface MarketplaceListing {\n  id: string;\n  visualization_id: string;\n  seller_id: string;\n  price_cents: number;\n  status: 'active' | 'sold' | 'cancelled';\n  buyer_id: string | null;\n  created_at: string;\n  sold_at: string | null;\n  visualization?: {\n    id: string;\n    title: string;\n    image_path: string;\n    game_data: Record<string, unknown>;\n    pgn?: string | null;\n  };\n  seller?: {\n    display_name: string | null;\n  };\n}\n\nexport interface PaginationOptions {\n  page?: number;\n  limit?: number;\n}\n\nexport interface PaginatedResult<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  hasMore: boolean;\n  error: Error | null;\n}\n\nexport async function getActiveListings(\n  options: PaginationOptions = {}\n): Promise<PaginatedResult<MarketplaceListing>> {\n  const { page = 1, limit = 50 } = options;\n  const offset = (page - 1) * limit;\n\n  try {\n    // Get total count for pagination\n    const { count, error: countError } = await supabase\n      .from('visualization_listings')\n      .select('*', { count: 'exact', head: true })\n      .eq('status', 'active');\n\n    if (countError) throw countError;\n\n    // Get paginated listings with visualizations\n    const { data: listingsData, error: listingsError } = await supabase\n      .from('visualization_listings')\n      .select(`\n        *,\n        visualization:saved_visualizations(id, title, image_path, game_data)\n      `)\n      .eq('status', 'active')\n      .order('created_at', { ascending: false })\n      .range(offset, offset + limit - 1);\n\n    if (listingsError) throw listingsError;\n\n    // Get unique seller IDs and fetch profiles separately\n    const sellerIds = [...new Set((listingsData || []).map(l => l.seller_id))];\n    \n    let profilesMap: Record<string, { display_name: string | null }> = {};\n    if (sellerIds.length > 0) {\n      const { data: profilesData } = await supabase\n        .from('profiles')\n        .select('user_id, display_name')\n        .in('user_id', sellerIds);\n      \n      profilesMap = (profilesData || []).reduce((acc, p) => {\n        acc[p.user_id] = { display_name: p.display_name };\n        return acc;\n      }, {} as Record<string, { display_name: string | null }>);\n    }\n\n    // Transform the data to match our interface\n    const listings = (listingsData || []).map((item: Record<string, unknown>) => ({\n      ...item,\n      visualization: Array.isArray(item.visualization) ? item.visualization[0] : item.visualization,\n      seller: profilesMap[item.seller_id as string] || { display_name: null },\n    })) as MarketplaceListing[];\n\n    const total = count || 0;\n\n    return { \n      data: listings, \n      total,\n      page,\n      limit,\n      hasMore: offset + listings.length < total,\n      error: null \n    };\n  } catch (error) {\n    return { data: [], total: 0, page, limit, hasMore: false, error: error as Error };\n  }\n}\n\n// Batch check multiple visualizations for listing status (optimized for N+1)\nexport async function batchCheckVisualizationsListed(\n  visualizationIds: string[]\n): Promise<Record<string, boolean>> {\n  if (visualizationIds.length === 0) return {};\n\n  try {\n    const { data, error } = await supabase\n      .from('visualization_listings')\n      .select('visualization_id')\n      .in('visualization_id', visualizationIds)\n      .eq('status', 'active');\n\n    if (error) throw error;\n\n    const listedSet = new Set((data || []).map(l => l.visualization_id));\n    \n    return visualizationIds.reduce((acc, id) => {\n      acc[id] = listedSet.has(id);\n      return acc;\n    }, {} as Record<string, boolean>);\n  } catch (error) {\n    console.error('Batch listing check failed:', error);\n    return visualizationIds.reduce((acc, id) => {\n      acc[id] = false;\n      return acc;\n    }, {} as Record<string, boolean>);\n  }\n}\n\nexport async function getUserListings(userId: string): Promise<{\n  data: MarketplaceListing[];\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('visualization_listings')\n      .select(`\n        *,\n        visualization:saved_visualizations(id, title, image_path, game_data)\n      `)\n      .eq('seller_id', userId)\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n\n    const listings = (data || []).map((item: Record<string, unknown>) => ({\n      ...item,\n      visualization: Array.isArray(item.visualization) ? item.visualization[0] : item.visualization,\n    })) as MarketplaceListing[];\n\n    return { data: listings, error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\nexport async function createListing(\n  visualizationId: string,\n  priceCents: number\n): Promise<{ data: MarketplaceListing | null; error: Error | null }> {\n  try {\n    // Validate price before making API call\n    const validatedPrice = listingPriceSchema.parse(priceCents);\n\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Not authenticated');\n\n    const { data, error } = await supabase\n      .from('visualization_listings')\n      .insert({\n        visualization_id: visualizationId,\n        seller_id: user.id,\n        price_cents: validatedPrice,\n      })\n      .select()\n      .single();\n\n    if (error) throw error;\n    \n    // Log security event for listing creation\n    SecurityEvents.visionListed(user.id, visualizationId, validatedPrice);\n    \n    return { data: data as MarketplaceListing, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n\nexport async function cancelListing(listingId: string): Promise<{ error: Error | null }> {\n  try {\n    const { error } = await supabase\n      .from('visualization_listings')\n      .update({ status: 'cancelled' })\n      .eq('id', listingId);\n\n    if (error) throw error;\n    return { error: null };\n  } catch (error) {\n    return { error: error as Error };\n  }\n}\n\nexport async function updateListingPrice(\n  listingId: string,\n  priceCents: number\n): Promise<{ error: Error | null }> {\n  try {\n    // Validate price before making API call\n    const validatedPrice = listingPriceSchema.parse(priceCents);\n\n    const { error } = await supabase\n      .from('visualization_listings')\n      .update({ price_cents: validatedPrice })\n      .eq('id', listingId);\n\n    if (error) throw error;\n    return { error: null };\n  } catch (error) {\n    return { error: error as Error };\n  }\n}\n\nexport async function purchaseListing(listingId: string): Promise<{\n  url?: string;\n  success?: boolean;\n  message?: string;\n  visualizationId?: string;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase.functions.invoke('marketplace-purchase', {\n      body: { listingId },\n    });\n\n    if (error) throw error;\n    if (data.error) throw new Error(data.error);\n\n    return { ...data, error: null };\n  } catch (error) {\n    return { error: error as Error };\n  }\n}\n\nexport async function completePurchase(listingId: string): Promise<{\n  success?: boolean;\n  message?: string;\n  visualizationId?: string;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase.functions.invoke('complete-marketplace-purchase', {\n      body: { listingId },\n    });\n\n    if (error) throw error;\n    if (data.error) throw new Error(data.error);\n\n    return { ...data, error: null };\n  } catch (error) {\n    return { error: error as Error };\n  }\n}\n\nexport async function checkVisualizationListed(visualizationId: string): Promise<{\n  isListed: boolean;\n  listing?: MarketplaceListing;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('visualization_listings')\n      .select('*')\n      .eq('visualization_id', visualizationId)\n      .eq('status', 'active')\n      .single();\n\n    if (error || !data) return { isListed: false };\n    return { isListed: true, listing: data as MarketplaceListing };\n  } catch {\n    return { isListed: false };\n  }\n}\n\nexport async function getListingById(listingId: string): Promise<{\n  data: MarketplaceListing | null;\n  error: Error | null;\n}> {\n  try {\n    const { data: listingData, error: listingError } = await supabase\n      .from('visualization_listings')\n      .select(`\n        *,\n        visualization:saved_visualizations(id, title, image_path, game_data, pgn)\n      `)\n      .eq('id', listingId)\n      .single();\n\n    if (listingError) throw listingError;\n    if (!listingData) return { data: null, error: null };\n\n    // Fetch seller profile separately\n    const { data: profileData } = await supabase\n      .from('profiles')\n      .select('user_id, display_name')\n      .eq('user_id', listingData.seller_id)\n      .single();\n\n    const listing = {\n      ...listingData,\n      visualization: Array.isArray(listingData.visualization) \n        ? listingData.visualization[0] \n        : listingData.visualization,\n      seller: profileData ? { display_name: profileData.display_name } : { display_name: null },\n    } as MarketplaceListing;\n\n    return { data: listing, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n\n// Check remaining transfers for a visualization (max 3 per 24h)\nexport async function getRemainingTransfers(visualizationId: string): Promise<{\n  remaining: number;\n  canTransfer: boolean;\n  error: Error | null;\n}> {\n  try {\n    const { data: remaining, error } = await supabase\n      .rpc('get_remaining_transfers', { p_visualization_id: visualizationId });\n\n    if (error) throw error;\n\n    return { \n      remaining: remaining ?? 3, \n      canTransfer: (remaining ?? 3) > 0,\n      error: null \n    };\n  } catch (error) {\n    return { remaining: 0, canTransfer: false, error: error as Error };\n  }\n}\n\n// Get orphaned visualizations (available for claim by premium members)\nexport async function getOrphanedVisualizations(): Promise<{\n  data: Array<{\n    id: string;\n    title: string;\n    image_path: string;\n    game_data: unknown;\n    pgn?: string | null;\n  }>;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('saved_visualizations')\n      .select('id, title, image_path, game_data, pgn')\n      .is('user_id', null)\n      .order('updated_at', { ascending: false })\n      .limit(50);\n\n    if (error) throw error;\n    return { data: (data || []) as Array<{ id: string; title: string; image_path: string; game_data: unknown; pgn?: string | null }>, error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Claim an orphaned visualization (for premium members)\nexport async function claimOrphanedVisualization(visualizationId: string): Promise<{\n  success: boolean;\n  error: Error | null;\n}> {\n  try {\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Not authenticated');\n\n    // Check if user is premium\n    const { data: isPremium } = await supabase.rpc('is_premium_user', { p_user_id: user.id });\n    if (!isPremium) {\n      throw new Error('Premium membership required to claim visions');\n    }\n\n    // Check transfer limits\n    const { data: canTransfer, error: transferError } = await supabase\n      .rpc('can_transfer_visualization', { p_visualization_id: visualizationId });\n    \n    if (transferError) throw transferError;\n    if (!canTransfer) {\n      throw new Error('This vision has reached its transfer limit (3 per 24h). Try again later.');\n    }\n\n    // Claim the visualization\n    const { error: claimError } = await supabase\n      .from('saved_visualizations')\n      .update({ user_id: user.id })\n      .eq('id', visualizationId)\n      .is('user_id', null);\n\n    if (claimError) throw claimError;\n\n    // Record the transfer\n    // Note: This will fail silently if the user doesn't have permission, \n    // but the claim still succeeds - the record is just for tracking\n    await supabase\n      .from('visualization_transfers')\n      .insert({\n        visualization_id: visualizationId,\n        from_user_id: null, // Orphaned\n        to_user_id: user.id,\n        transfer_type: 'free_claim',\n      });\n\n    return { success: true, error: null };\n  } catch (error) {\n    return { success: false, error: error as Error };\n  }\n}";export{n as default};
