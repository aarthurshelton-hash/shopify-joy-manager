const n="/**\n * Pattern Learning Engine\n * \n * En Pensentâ„¢ Patent-Pending Technology\n * \n * Refactored into modular components for maintainability.\n */\n\nimport { \n  ColorFlowSignature, \n  extractColorFlowSignature,\n  ARCHETYPE_DEFINITIONS \n} from './colorFlowAnalysis';\nimport { simulateGame, GameData } from './gameSimulator';\n\n// Re-export types from modular structure\nexport type { PatternRecord, PatternMatch, PatternPrediction, PatternCharacteristics } from './patternLearning/types';\nexport { patternDatabase, PatternDatabase } from './patternLearning/patternDatabase';\n\nimport { patternDatabase } from './patternLearning/patternDatabase';\nimport { PatternRecord, PatternPrediction } from './patternLearning/types';\n\n/**\n * Learn a pattern from a completed game\n */\nexport function learnFromGame(\n  pgn: string,\n  outcome: 'white_wins' | 'black_wins' | 'draw'\n): PatternRecord {\n  const simulation = simulateGame(pgn);\n  \n  const signature = extractColorFlowSignature(\n    simulation.board,\n    simulation.gameData,\n    simulation.totalMoves\n  );\n  \n  return patternDatabase.addPattern(\n    signature,\n    outcome,\n    simulation.gameData,\n    simulation.totalMoves\n  );\n}\n\n/**\n * Get pattern-based prediction for a game in progress\n */\nexport function predictFromPatterns(pgn: string): PatternPrediction {\n  const simulation = simulateGame(pgn);\n  \n  const signature = extractColorFlowSignature(\n    simulation.board,\n    simulation.gameData,\n    simulation.totalMoves\n  );\n  \n  const matches = patternDatabase.findSimilar(signature, 10);\n  \n  // If no matches, use archetype-based prediction\n  if (matches.length === 0) {\n    const archetypeDef = ARCHETYPE_DEFINITIONS[signature.archetype];\n    return {\n      topMatches: [],\n      aggregatePrediction: {\n        whiteWinProbability: archetypeDef.historicalWinRate,\n        blackWinProbability: 1 - archetypeDef.historicalWinRate - 0.15,\n        drawProbability: 0.15,\n      },\n      mostLikelyOutcome: archetypeDef.predictedOutcome === 'white_favored' ? 'white_wins' : \n                         archetypeDef.predictedOutcome === 'black_favored' ? 'black_wins' : 'draw',\n      confidence: 40,\n      lookaheadMoves: archetypeDef.lookaheadConfidence,\n      insights: [\n        `Pattern type: ${archetypeDef.name}`,\n        'No historical matches found - using archetype baseline',\n        signature.dominantSide !== 'contested' \n          ? `${signature.dominantSide} has territorial advantage`\n          : 'Position is territorially contested',\n      ],\n    };\n  }\n  \n  // Aggregate predictions from matches\n  let whiteWins = 0, blackWins = 0, draws = 0;\n  let totalWeight = 0;\n  \n  for (const match of matches) {\n    const weight = match.similarity / 100;\n    totalWeight += weight;\n    \n    if (match.predictedOutcome === 'white_wins') whiteWins += weight;\n    else if (match.predictedOutcome === 'black_wins') blackWins += weight;\n    else draws += weight;\n  }\n  \n  const aggregatePrediction = {\n    whiteWinProbability: whiteWins / totalWeight,\n    blackWinProbability: blackWins / totalWeight,\n    drawProbability: draws / totalWeight,\n  };\n  \n  // Determine most likely outcome\n  let mostLikelyOutcome: 'white_wins' | 'black_wins' | 'draw';\n  if (aggregatePrediction.whiteWinProbability >= aggregatePrediction.blackWinProbability &&\n      aggregatePrediction.whiteWinProbability >= aggregatePrediction.drawProbability) {\n    mostLikelyOutcome = 'white_wins';\n  } else if (aggregatePrediction.blackWinProbability >= aggregatePrediction.drawProbability) {\n    mostLikelyOutcome = 'black_wins';\n  } else {\n    mostLikelyOutcome = 'draw';\n  }\n  \n  // Calculate confidence\n  const avgSimilarity = matches.reduce((sum, m) => sum + m.similarity, 0) / matches.length;\n  const confidence = Math.round(avgSimilarity * (matches.length / 10) * 0.9);\n  \n  // Calculate lookahead based on archetype\n  const archetypeDef = ARCHETYPE_DEFINITIONS[signature.archetype];\n  const lookaheadMoves = archetypeDef.lookaheadConfidence + \n    Math.round(avgSimilarity / 10) + \n    Math.min(10, matches.length * 2);\n  \n  // Generate insights\n  const insights: string[] = [];\n  insights.push(`Matched ${matches.length} historical patterns`);\n  insights.push(`Strongest match: ${matches[0].similarity}% similarity`);\n  \n  if (matches[0].pattern.gameMetadata?.white) {\n    insights.push(`Similar to: ${matches[0].pattern.gameMetadata.white} vs ${matches[0].pattern.gameMetadata.black}`);\n  }\n  \n  insights.push(`Pattern trajectory reliable for ~${lookaheadMoves} moves`);\n  \n  return {\n    topMatches: matches.slice(0, 5),\n    aggregatePrediction,\n    mostLikelyOutcome,\n    confidence,\n    lookaheadMoves,\n    insights,\n  };\n}\n\n/**\n * Seed the pattern database with famous games\n */\nexport function seedPatternDatabase(): void {\n  const seedGames = [\n    {\n      name: 'Kasparov vs Deep Blue 1997',\n      pgn: '1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O',\n      outcome: 'black_wins' as const,\n    },\n    {\n      name: 'Morphy Opera Game',\n      pgn: '1. e4 e5 2. Nf3 d6 3. d4 Bg4 4. dxe5 Bxf3 5. Qxf3 dxe5 6. Bc4 Nf6 7. Qb3 Qe7',\n      outcome: 'white_wins' as const,\n    },\n    {\n      name: 'Immortal Game',\n      pgn: '1. e4 e5 2. f4 exf4 3. Bc4 Qh4+ 4. Kf1 b5 5. Bxb5 Nf6 6. Nf3 Qh6 7. d3 Nh5',\n      outcome: 'white_wins' as const,\n    },\n    {\n      name: 'Evergreen Game',\n      pgn: '1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 4. b4 Bxb4 5. c3 Ba5 6. d4 exd4 7. O-O d3',\n      outcome: 'white_wins' as const,\n    },\n  ];\n  \n  for (const game of seedGames) {\n    try {\n      learnFromGame(game.pgn, game.outcome);\n    } catch (e) {\n      console.warn(`Failed to learn from ${game.name}:`, e);\n    }\n  }\n}\n\n/**\n * Get pattern database statistics\n */\nexport function getPatternDatabaseStats(): { totalPatterns: number; byArchetype: Record<string, number> } {\n  return patternDatabase.getStats();\n}\n\n/**\n * Clear the pattern database\n */\nexport function clearPatternDatabase(): void {\n  patternDatabase.clear();\n}\n\nexport default predictFromPatterns;\n";export{n as default};
