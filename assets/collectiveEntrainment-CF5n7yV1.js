const n="/**\n * Collective Entrainment Module\n * \n * Mathematical Framework for Detecting Synchronized Consciousness in Markets\n * \n * SCIENTIFIC BASIS:\n * - Kuramoto Model: Coupled oscillator synchronization (Kuramoto, 1975)\n * - Neural Binding Theory: Gamma-wave coherence in shared attention (Singer & Gray, 1995)\n * - Information Integration Theory (IIT): Î¦ (phi) as consciousness measure (Tononi, 2004)\n * - Social Resonance Theory: Limbic synchronization in groups (Lewis et al., 2000)\n * \n * \"When enough minds think the same thought at the same time,\n *  the market doesn't just moveâ€”it dances.\" - En Pensent Axiom #42\n */\n\nimport type { UniversalSignal, DomainType } from '../types';\n\n// ============================================================================\n// MATHEMATICAL CONSTANTS (Because even consciousness has rules)\n// ============================================================================\n\n/**\n * Kuramoto Coupling Constant (K)\n * Critical threshold for phase synchronization in coupled oscillators\n * K_c = 2/(Ï€g(0)) where g is the frequency distribution\n * For markets: K_c â‰ˆ 0.1592 (assuming Lorentzian distribution)\n */\nconst KURAMOTO_CRITICAL_COUPLING = 0.1592;\n\n/**\n * Phi (Î¦) - Integrated Information Threshold\n * Minimum integrated information for \"conscious\" market state\n * Based on Tononi's IIT: Î¦ > 0 indicates irreducible integration\n */\nconst PHI_CONSCIOUSNESS_THRESHOLD = 0.618; // Golden ratio, obviously\n\n/**\n * Alpha-Theta Crossover Frequency (Hz)\n * Boundary between analytical (alpha) and intuitive (theta) processing\n * Market equivalent: transition between rational and emotional trading\n */\nconst ALPHA_THETA_CROSSOVER = 8.0;\n\n/**\n * Schumann Resonance Base (Hz)\n * Earth's electromagnetic \"heartbeat\" - 7.83 Hz\n * Markets are just humans, humans are on Earth. QED.\n */\nconst SCHUMANN_RESONANCE = 7.83;\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\nexport interface EntrainmentState {\n  // Kuramoto order parameter: r âˆˆ [0, 1]\n  // r = 0: complete incoherence, r = 1: perfect synchronization\n  orderParameter: number;\n  \n  // Phase coherence across domains\n  phaseCoherence: number;\n  \n  // Integrated information (Î¦)\n  phi: number;\n  \n  // Dominant collective frequency\n  collectiveFrequency: number;\n  \n  // Emotional valence (-1 to 1): fear â† 0 â†’ greed\n  collectiveValence: number;\n  \n  // Entrainment classification\n  state: 'chaotic' | 'transitional' | 'entrained' | 'supercoherent';\n  \n  // Market implication\n  marketSignal: {\n    direction: 'up' | 'down' | 'neutral';\n    confidence: number;\n    expectedMagnitude: number;\n    timeToInflection: number; // milliseconds\n  };\n  \n  // Debug/humor\n  poeticDescription: string;\n}\n\nexport interface OscillatorState {\n  domain: DomainType;\n  phase: number;        // Î¸ âˆˆ [0, 2Ï€]\n  frequency: number;    // Ï‰ (natural frequency)\n  amplitude: number;    // A (signal strength)\n  coupling: number;     // K (coupling to collective)\n}\n\n// ============================================================================\n// KURAMOTO MODEL IMPLEMENTATION\n// ============================================================================\n\n/**\n * Kuramoto Order Parameter Calculation\n * \n * rÂ·e^(iÏˆ) = (1/N) Î£ e^(iÎ¸â±¼)\n * \n * Where:\n * - r is the order parameter (synchronization measure)\n * - Ïˆ is the average phase\n * - Î¸â±¼ is the phase of oscillator j\n * - N is the number of oscillators\n * \n * @param oscillators Array of oscillator states\n * @returns {r: number, psi: number} Order parameter and mean phase\n */\nfunction calculateKuramotoOrderParameter(\n  oscillators: OscillatorState[]\n): { r: number; psi: number } {\n  if (oscillators.length === 0) {\n    return { r: 0, psi: 0 };\n  }\n  \n  // Sum of complex exponentials: Î£ e^(iÎ¸â±¼) = Î£ (cos Î¸â±¼ + i sin Î¸â±¼)\n  let realSum = 0;\n  let imagSum = 0;\n  \n  for (const osc of oscillators) {\n    realSum += Math.cos(osc.phase);\n    imagSum += Math.sin(osc.phase);\n  }\n  \n  // Normalize by N\n  const N = oscillators.length;\n  const realMean = realSum / N;\n  const imagMean = imagSum / N;\n  \n  // r = |z| = âˆš(ReÂ² + ImÂ²)\n  const r = Math.sqrt(realMean ** 2 + imagMean ** 2);\n  \n  // Ïˆ = arg(z) = atan2(Im, Re)\n  const psi = Math.atan2(imagMean, realMean);\n  \n  return { r, psi };\n}\n\n/**\n * Phase Coherence using Circular Variance\n * \n * V = 1 - r (circular variance)\n * Coherence = 1 - V = r\n * \n * Extended with amplitude weighting for signal strength consideration\n */\nfunction calculatePhaseCoherence(oscillators: OscillatorState[]): number {\n  if (oscillators.length === 0) return 0;\n  \n  // Amplitude-weighted phase coherence\n  let totalWeight = 0;\n  let weightedRealSum = 0;\n  let weightedImagSum = 0;\n  \n  for (const osc of oscillators) {\n    const weight = osc.amplitude * osc.coupling;\n    totalWeight += weight;\n    weightedRealSum += weight * Math.cos(osc.phase);\n    weightedImagSum += weight * Math.sin(osc.phase);\n  }\n  \n  if (totalWeight === 0) return 0;\n  \n  const normalizedReal = weightedRealSum / totalWeight;\n  const normalizedImag = weightedImagSum / totalWeight;\n  \n  return Math.sqrt(normalizedReal ** 2 + normalizedImag ** 2);\n}\n\n// ============================================================================\n// INTEGRATED INFORMATION (Î¦) CALCULATION\n// ============================================================================\n\n/**\n * Simplified Î¦ (Phi) Calculation\n * \n * Full IIT computation is NP-hard, so we use an approximation:\n * Î¦ â‰ˆ I(X; X') - max[I(X_part; X'_part)]\n * \n * Where I is mutual information and X' is the system's past state\n * \n * For our purposes: Î¦ estimates how much the whole system knows\n * that its parts don't know individually (emergence measure)\n */\nfunction calculatePhi(signals: UniversalSignal[]): number {\n  if (signals.length < 2) return 0;\n  \n  // Calculate total system entropy\n  const frequencies = signals.map(s => s.frequency);\n  const intensities = signals.map(s => s.intensity);\n  \n  // Shannon entropy of the joint distribution\n  const jointEntropy = calculateShannonEntropy(\n    frequencies.map((f, i) => f * intensities[i])\n  );\n  \n  // Sum of individual entropies (if parts were independent)\n  const partEntropies = signals.map(s => \n    calculateShannonEntropy([s.frequency * s.intensity])\n  );\n  const sumPartEntropies = partEntropies.reduce((a, b) => a + b, 0);\n  \n  // Î¦ â‰ˆ synergy = joint < sum of parts means integration\n  // Normalize to [0, 1]\n  const rawPhi = Math.max(0, sumPartEntropies - jointEntropy);\n  const normalizedPhi = Math.min(1, rawPhi / Math.max(1, sumPartEntropies));\n  \n  return normalizedPhi;\n}\n\n/**\n * Shannon Entropy: H(X) = -Î£ p(x) logâ‚‚ p(x)\n */\nfunction calculateShannonEntropy(values: number[]): number {\n  const total = values.reduce((a, b) => Math.abs(a) + Math.abs(b), 0);\n  if (total === 0) return 0;\n  \n  let entropy = 0;\n  for (const v of values) {\n    const p = Math.abs(v) / total;\n    if (p > 0) {\n      entropy -= p * Math.log2(p);\n    }\n  }\n  \n  return entropy;\n}\n\n// ============================================================================\n// COLLECTIVE FREQUENCY DETECTION\n// ============================================================================\n\n/**\n * Dominant Collective Frequency via Weighted Average\n * \n * Ï‰_collective = Î£(Aâ±¼ Â· Ï‰â±¼) / Î£(Aâ±¼)\n * \n * Amplitude-weighted to emphasize stronger signals\n */\nfunction calculateCollectiveFrequency(oscillators: OscillatorState[]): number {\n  if (oscillators.length === 0) return SCHUMANN_RESONANCE;\n  \n  let weightedSum = 0;\n  let totalWeight = 0;\n  \n  for (const osc of oscillators) {\n    weightedSum += osc.amplitude * osc.frequency;\n    totalWeight += osc.amplitude;\n  }\n  \n  return totalWeight > 0 ? weightedSum / totalWeight : SCHUMANN_RESONANCE;\n}\n\n/**\n * Emotional Valence from Frequency Spectrum\n * \n * Low frequency (theta/delta) â†’ fear, uncertainty\n * High frequency (beta/gamma) â†’ excitement, greed\n * \n * Valence = tanh((f - f_neutral) / f_scale)\n */\nfunction calculateCollectiveValence(\n  frequency: number,\n  phaseCoherence: number\n): number {\n  const neutralFrequency = ALPHA_THETA_CROSSOVER;\n  const frequencyScale = 4.0; // Hz per unit valence\n  \n  // Base valence from frequency\n  const frequencyValence = Math.tanh((frequency - neutralFrequency) / frequencyScale);\n  \n  // Coherence amplifies valence (synchronized fear is scarier)\n  const amplifiedValence = frequencyValence * (0.5 + 0.5 * phaseCoherence);\n  \n  return Math.max(-1, Math.min(1, amplifiedValence));\n}\n\n// ============================================================================\n// STATE CLASSIFICATION\n// ============================================================================\n\n/**\n * Classify entrainment state based on order parameter thresholds\n * \n * These thresholds are derived from Kuramoto model phase transitions:\n * - r < K_c: subcritical (chaotic)\n * - r â‰ˆ K_c: critical (transitional)  \n * - r > K_c: supercritical (entrained)\n * - r â†’ 1: supercoherent (rare, powerful)\n */\nfunction classifyEntrainmentState(\n  orderParameter: number,\n  phi: number\n): 'chaotic' | 'transitional' | 'entrained' | 'supercoherent' {\n  // Supercoherent: both high synchronization AND high integration\n  if (orderParameter > 0.85 && phi > PHI_CONSCIOUSNESS_THRESHOLD) {\n    return 'supercoherent';\n  }\n  \n  // Entrained: above critical coupling\n  if (orderParameter > KURAMOTO_CRITICAL_COUPLING * 3) {\n    return 'entrained';\n  }\n  \n  // Transitional: near critical point\n  if (orderParameter > KURAMOTO_CRITICAL_COUPLING) {\n    return 'transitional';\n  }\n  \n  // Chaotic: below critical coupling\n  return 'chaotic';\n}\n\n/**\n * Generate poetic description (the humor you requested)\n */\nfunction generatePoeticDescription(\n  state: 'chaotic' | 'transitional' | 'entrained' | 'supercoherent',\n  valence: number,\n  orderParameter: number\n): string {\n  const descriptions = {\n    chaotic: [\n      \"The market's mind is a Jackson Pollock paintingâ€”beautiful chaos.\",\n      \"Every trader for themselves. The herd has scattered.\",\n      \"Entropy reigns. Even the algorithms are confused.\",\n      \"It's like a jazz improvisation where nobody told the drummer.\",\n    ],\n    transitional: [\n      \"Something's brewing. The collective unconscious stirs.\",\n      \"The phase transition approaches. Buckle up, buttercup.\",\n      \"SchrÃ¶dinger's market: simultaneously bullish and bearish until observed.\",\n      \"We're at the edge of chaos. The fun part.\",\n    ],\n    entrained: [\n      \"Minds aligned. The market breathes as one organism.\",\n      \"Collective consciousness achieved. Resistance is futile.\",\n      \"When millions think together, the chart becomes a self-fulfilling prophecy.\",\n      \"The Kuramoto model called. It wants its synchronization back.\",\n    ],\n    supercoherent: [\n      \"MAXIMUM RESONANCE. The market has achieved enlightenment.\",\n      \"Î¦ is off the charts. We've reached market nirvana.\",\n      \"This is the moment before the avalanche. Pure potential.\",\n      \"The collective has spoken with one voice. Listen.\",\n    ],\n  };\n  \n  const stateDescriptions = descriptions[state];\n  const index = Math.floor(Math.abs(orderParameter * 100) % stateDescriptions.length);\n  let base = stateDescriptions[index];\n  \n  // Add valence flavor\n  if (valence > 0.5) {\n    base += \" ğŸ“ˆ Greed frequency detected.\";\n  } else if (valence < -0.5) {\n    base += \" ğŸ“‰ Fear wavelength amplifying.\";\n  }\n  \n  return base;\n}\n\n// ============================================================================\n// MARKET SIGNAL DERIVATION\n// ============================================================================\n\n/**\n * Derive market signal from entrainment state\n * \n * The key insight: synchronized markets are predictable markets.\n * High coherence + clear valence = high confidence signal\n */\nfunction deriveMarketSignal(\n  orderParameter: number,\n  phaseCoherence: number,\n  valence: number,\n  collectiveFrequency: number,\n  state: 'chaotic' | 'transitional' | 'entrained' | 'supercoherent'\n): EntrainmentState['marketSignal'] {\n  // Direction from valence\n  let direction: 'up' | 'down' | 'neutral';\n  if (valence > 0.2) {\n    direction = 'up';\n  } else if (valence < -0.2) {\n    direction = 'down';\n  } else {\n    direction = 'neutral';\n  }\n  \n  // Confidence from coherence and order parameter\n  // Higher synchronization = more predictable outcome\n  const baseConfidence = (orderParameter + phaseCoherence) / 2;\n  \n  // State multiplier\n  const stateMultipliers = {\n    chaotic: 0.3,\n    transitional: 0.6,\n    entrained: 0.85,\n    supercoherent: 0.95,\n  };\n  \n  const confidence = Math.min(0.95, baseConfidence * stateMultipliers[state]);\n  \n  // Magnitude from valence intensity and coherence\n  // |valence| * coherence = expected move strength\n  const expectedMagnitude = Math.abs(valence) * phaseCoherence * 100; // basis points\n  \n  // Time to inflection inversely proportional to frequency\n  // Higher frequency = faster resolution\n  const baseTimeMs = 60000; // 1 minute base\n  const timeToInflection = baseTimeMs / Math.max(1, collectiveFrequency / SCHUMANN_RESONANCE);\n  \n  return {\n    direction,\n    confidence,\n    expectedMagnitude,\n    timeToInflection,\n  };\n}\n\n// ============================================================================\n// MAIN INTERFACE\n// ============================================================================\n\n/**\n * Collective Entrainment Detector\n * \n * Analyzes signals from Music, Soul, and Consciousness domains\n * to detect moments of synchronized market consciousness.\n */\nclass CollectiveEntrainmentDetector {\n  private signalHistory: UniversalSignal[] = [];\n  private readonly HISTORY_SIZE = 100;\n  private lastState: EntrainmentState | null = null;\n  \n  /**\n   * Process incoming signals and detect entrainment\n   */\n  processSignals(signals: UniversalSignal[]): EntrainmentState {\n    // Update history\n    this.signalHistory.push(...signals);\n    if (this.signalHistory.length > this.HISTORY_SIZE) {\n      this.signalHistory = this.signalHistory.slice(-this.HISTORY_SIZE);\n    }\n    \n    // Convert signals to oscillator states\n    const oscillators = this.signalsToOscillators(signals);\n    \n    // Calculate Kuramoto order parameter\n    const { r: orderParameter, psi: meanPhase } = calculateKuramotoOrderParameter(oscillators);\n    \n    // Calculate phase coherence\n    const phaseCoherence = calculatePhaseCoherence(oscillators);\n    \n    // Calculate integrated information (Î¦)\n    const phi = calculatePhi(signals);\n    \n    // Calculate collective frequency\n    const collectiveFrequency = calculateCollectiveFrequency(oscillators);\n    \n    // Calculate emotional valence\n    const collectiveValence = calculateCollectiveValence(collectiveFrequency, phaseCoherence);\n    \n    // Classify state\n    const state = classifyEntrainmentState(orderParameter, phi);\n    \n    // Derive market signal\n    const marketSignal = deriveMarketSignal(\n      orderParameter,\n      phaseCoherence,\n      collectiveValence,\n      collectiveFrequency,\n      state\n    );\n    \n    // Generate poetic description\n    const poeticDescription = generatePoeticDescription(state, collectiveValence, orderParameter);\n    \n    this.lastState = {\n      orderParameter,\n      phaseCoherence,\n      phi,\n      collectiveFrequency,\n      collectiveValence,\n      state,\n      marketSignal,\n      poeticDescription,\n    };\n    \n    return this.lastState;\n  }\n  \n  /**\n   * Convert UniversalSignals to oscillator states\n   */\n  private signalsToOscillators(signals: UniversalSignal[]): OscillatorState[] {\n    return signals.map(signal => ({\n      domain: signal.domain,\n      phase: signal.phase,\n      frequency: signal.frequency,\n      amplitude: signal.intensity,\n      coupling: this.getDomainCoupling(signal.domain),\n    }));\n  }\n  \n  /**\n   * Domain coupling strengths\n   * How strongly each domain couples to collective consciousness\n   */\n  private getDomainCoupling(domain: DomainType): number {\n    const couplings: Partial<Record<DomainType, number>> = {\n      music: 0.95,        // The Heart - strongest emotional carrier\n      soul: 0.90,         // The Spirit - archetypal resonance\n      bio: 0.85,          // Life rhythms - consciousness substrate\n      audio: 0.80,        // Sound patterns - frequency carrier\n      market: 0.75,       // Nervous system - reactive\n      chess: 0.70,        // Brain - strategic patterns\n      code: 0.60,         // Blood - life force flow\n      network: 0.55,      // Connectivity - information flow\n      light: 0.50,        // Vision - electromagnetic perception\n      satellite: 0.45,    // Orbital - macro observation\n    };\n    \n    return couplings[domain] ?? 0.5;\n  }\n  \n  /**\n   * Get current entrainment state\n   */\n  getState(): EntrainmentState | null {\n    return this.lastState;\n  }\n  \n  /**\n   * Get scientific summary for logging/display\n   */\n  getScientificSummary(): string {\n    if (!this.lastState) return 'No data yet. The collective sleeps.';\n    \n    const { orderParameter, phaseCoherence, phi, collectiveFrequency, state } = this.lastState;\n    \n    return `\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚           COLLECTIVE ENTRAINMENT ANALYSIS                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Kuramoto Order Parameter (r): ${orderParameter.toFixed(4).padStart(8)}                 â”‚\nâ”‚ Phase Coherence (Ï):          ${phaseCoherence.toFixed(4).padStart(8)}                 â”‚\nâ”‚ Integrated Information (Î¦):   ${phi.toFixed(4).padStart(8)}                 â”‚\nâ”‚ Collective Frequency (Ï‰):     ${collectiveFrequency.toFixed(2).padStart(6)} Hz             â”‚\nâ”‚ System State:                 ${state.padStart(14)}             â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Mathematical Basis:                                         â”‚\nâ”‚ â€¢ Kuramoto Model: dÎ¸áµ¢/dt = Ï‰áµ¢ + (K/N)Î£sin(Î¸â±¼ - Î¸áµ¢)        â”‚\nâ”‚ â€¢ Critical Coupling: K_c = ${KURAMOTO_CRITICAL_COUPLING.toFixed(4)}                      â”‚\nâ”‚ â€¢ Î¦ Threshold: ${PHI_CONSCIOUSNESS_THRESHOLD} (Golden Ratio, naturally)           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n    `.trim();\n  }\n}\n\n// Singleton instance\nexport const collectiveEntrainment = new CollectiveEntrainmentDetector();\n\n// Export mathematical constants for reference\nexport const ENTRAINMENT_CONSTANTS = {\n  KURAMOTO_CRITICAL_COUPLING,\n  PHI_CONSCIOUSNESS_THRESHOLD,\n  ALPHA_THETA_CROSSOVER,\n  SCHUMANN_RESONANCE,\n};\n";export{n as default};
