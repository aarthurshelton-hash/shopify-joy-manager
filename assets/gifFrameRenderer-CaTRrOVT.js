const n="/**\n * GIF Frame Renderer - Generates individual frames for GIF animation\n * Uses offscreen rendering with React to capture each timeline state\n * Captures the full \"trademark look\" with game info visible\n */\n\nimport { SquareData, GameData, SimulationResult } from './gameSimulator';\nimport { getCurrentPalette } from './pieceColors';\n\nexport interface GifFrameOptions {\n  board: SquareData[][];\n  currentMove: number;\n  totalMoves: number;\n  size: number;\n  darkMode?: boolean;\n  showCoordinates?: boolean;\n  gameData?: GameData;\n  showPieces?: boolean;\n  pieceOpacity?: number;\n  pgn?: string;\n}\n\n/**\n * Filter board data to show only moves up to a certain point\n */\nexport function filterBoardToMove(board: SquareData[][], moveNumber: number): SquareData[][] {\n  return board.map(rank =>\n    rank.map(square => ({\n      ...square,\n      visits: square.visits.filter(visit => visit.moveNumber <= moveNumber)\n    }))\n  );\n}\n\n/**\n * Render a single frame of the visualization to a canvas\n * Uses the full trademark look with game info and branding\n */\nexport async function renderFrameToCanvas(\n  options: GifFrameOptions\n): Promise<HTMLCanvasElement> {\n  const { board, currentMove, totalMoves, size, darkMode = false, showCoordinates = false, gameData, showPieces = false, pieceOpacity = 0.7, pgn } = options;\n  \n  const html2canvas = (await import('html2canvas')).default;\n  const React = await import('react');\n  const ReactDOM = await import('react-dom/client');\n  const { default: ChessBoardVisualization } = await import('@/components/chess/ChessBoardVisualization');\n  const { default: BoardCoordinateGuide } = await import('@/components/chess/BoardCoordinateGuide');\n  const { default: StaticPieceOverlay } = await import('@/components/chess/StaticPieceOverlay');\n  \n  // Filter board to current move\n  const filteredBoard = filterBoardToMove(board, currentMove);\n  \n  // Create temporary container\n  const container = document.createElement('div');\n  container.style.position = 'absolute';\n  container.style.left = '-9999px';\n  container.style.top = '-9999px';\n  document.body.appendChild(container);\n  \n  // Colors for trademark look\n  const bgColor = darkMode ? '#0A0A0A' : '#FDFCFB';\n  const borderColor = darkMode ? '#292524' : '#e7e5e4';\n  const mutedColor = darkMode ? '#78716c' : '#a8a29e';\n  const primaryText = darkMode ? '#e7e5e4' : '#292524';\n  const secondaryText = darkMode ? '#a8a29e' : '#78716c';\n  \n  try {\n    // Create wrapper with trademark styling\n    const wrapper = document.createElement('div');\n    Object.assign(wrapper.style, {\n      padding: '20px',\n      backgroundColor: bgColor,\n      borderRadius: '8px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      gap: '16px',\n      border: `1px solid ${borderColor}`,\n    });\n    container.appendChild(wrapper);\n    \n    // Render the board with optional piece overlay\n    const boardContainer = document.createElement('div');\n    boardContainer.style.position = 'relative';\n    wrapper.appendChild(boardContainer);\n    \n    const root = ReactDOM.createRoot(boardContainer);\n    \n    await new Promise<void>((resolve) => {\n      // Render board with optional static piece overlay (no context required)\n      root.render(\n        React.createElement('div', { style: { position: 'relative', width: size, height: size } },\n          showCoordinates && React.createElement(BoardCoordinateGuide, { size, position: 'inside' }),\n          React.createElement(ChessBoardVisualization, {\n            board: filteredBoard,\n            size: size\n          }),\n          // Add static piece overlay if enabled\n          showPieces && pgn && React.createElement(StaticPieceOverlay, {\n            pgn,\n            currentMoveNumber: currentMove,\n            size,\n            pieceOpacity,\n          })\n        )\n      );\n      setTimeout(resolve, showPieces ? 80 : 50);\n    });\n    \n    // Add game info section if gameData provided\n    if (gameData) {\n      const infoSection = document.createElement('div');\n      Object.assign(infoSection.style, {\n        width: '100%',\n        paddingTop: '12px',\n        borderTop: `1px solid ${borderColor}`,\n        textAlign: 'center',\n      });\n      \n      // Player names\n      const playersDiv = document.createElement('div');\n      Object.assign(playersDiv.style, {\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        gap: '8px',\n        marginBottom: '6px',\n      });\n      \n      const whiteSpan = document.createElement('span');\n      Object.assign(whiteSpan.style, {\n        fontSize: '14px',\n        fontWeight: '600',\n        color: primaryText,\n        textTransform: 'uppercase',\n        letterSpacing: '0.05em',\n        fontFamily: \"'Cinzel', 'Times New Roman', serif\",\n      });\n      whiteSpan.textContent = gameData.white || 'White';\n      \n      const vsSpan = document.createElement('span');\n      Object.assign(vsSpan.style, {\n        fontSize: '10px',\n        color: secondaryText,\n        fontStyle: 'italic',\n      });\n      vsSpan.textContent = 'vs';\n      \n      const blackSpan = document.createElement('span');\n      Object.assign(blackSpan.style, {\n        fontSize: '14px',\n        fontWeight: '600',\n        color: primaryText,\n        textTransform: 'uppercase',\n        letterSpacing: '0.05em',\n        fontFamily: \"'Cinzel', 'Times New Roman', serif\",\n      });\n      blackSpan.textContent = gameData.black || 'Black';\n      \n      playersDiv.appendChild(whiteSpan);\n      playersDiv.appendChild(vsSpan);\n      playersDiv.appendChild(blackSpan);\n      infoSection.appendChild(playersDiv);\n      \n      // Event and date\n      if (gameData.event || gameData.date) {\n        const eventDiv = document.createElement('div');\n        Object.assign(eventDiv.style, {\n          fontSize: '10px',\n          color: mutedColor,\n          marginBottom: '4px',\n        });\n        eventDiv.textContent = [gameData.event, gameData.date].filter(Boolean).join(' • ');\n        infoSection.appendChild(eventDiv);\n      }\n      \n      // Move counter\n      const moveDiv = document.createElement('div');\n      Object.assign(moveDiv.style, {\n        fontSize: '9px',\n        color: mutedColor,\n        marginTop: '4px',\n      });\n      moveDiv.textContent = `Move ${currentMove} of ${totalMoves}`;\n      infoSection.appendChild(moveDiv);\n      \n      wrapper.appendChild(infoSection);\n    }\n    \n    // Add branding footer\n    const brandingDiv = document.createElement('div');\n    Object.assign(brandingDiv.style, {\n      fontSize: '8px',\n      letterSpacing: '0.25em',\n      textTransform: 'uppercase',\n      fontWeight: '500',\n      color: mutedColor,\n      fontFamily: \"'Inter', system-ui, sans-serif\",\n    });\n    brandingDiv.textContent = '♔ En Pensent ♚';\n    wrapper.appendChild(brandingDiv);\n    \n    // Capture the frame\n    const canvas = await html2canvas(wrapper, {\n      scale: 2,\n      backgroundColor: bgColor,\n      useCORS: true,\n      allowTaint: true,\n      logging: false,\n    });\n    \n    root.unmount();\n    return canvas;\n  } finally {\n    document.body.removeChild(container);\n  }\n}\n\nexport interface GenerateGifOptions {\n  simulation: SimulationResult;\n  size?: number;\n  darkMode?: boolean;\n  showCoordinates?: boolean;\n  frameDelay?: number;\n  quality?: number;\n  maxFrames?: number;\n  onProgress?: (progress: number, message: string) => void;\n  showPieces?: boolean;\n  pieceOpacity?: number;\n}\n\n/**\n * Generate an animated GIF from a chess game simulation\n * Captures each move state using the timeline\n */\nexport async function generateAnimatedGif(\n  options: GenerateGifOptions\n): Promise<Blob> {\n  const {\n    simulation,\n    size = 400,\n    darkMode = false,\n    showCoordinates = true,\n    frameDelay = 150,\n    quality = 10,\n    maxFrames = 60,\n    onProgress,\n    showPieces = false,\n    pieceOpacity = 0.7,\n  } = options;\n  \n  // Validate simulation data\n  if (!simulation || !simulation.board || simulation.totalMoves === undefined) {\n    throw new Error('Invalid simulation data provided for GIF generation');\n  }\n  \n  const { board, totalMoves, gameData } = simulation;\n  \n  // Handle edge case of no moves\n  if (totalMoves === 0) {\n    throw new Error('Cannot generate GIF for a game with no moves');\n  }\n  \n  try {\n    const GIF = (await import('gif.js')).default;\n    \n    // Determine which moves to capture (sample if too many)\n    const step = totalMoves > maxFrames ? Math.ceil(totalMoves / maxFrames) : 1;\n    const movesToCapture: number[] = [0]; // Always start with position 0\n    \n    for (let i = step; i <= totalMoves; i += step) {\n      movesToCapture.push(i);\n    }\n    // Always include final frame\n    if (movesToCapture[movesToCapture.length - 1] !== totalMoves) {\n      movesToCapture.push(totalMoves);\n    }\n    \n    const totalFramesToCapture = movesToCapture.length;\n    onProgress?.(0, 'Preparing frames...');\n    \n    // Capture first frame to get dimensions\n    let firstCanvas: HTMLCanvasElement;\n    const pgn = gameData?.pgn || '';\n    \n    try {\n      firstCanvas = await renderFrameToCanvas({\n        board,\n        currentMove: 0,\n        totalMoves,\n        size,\n        darkMode,\n        showCoordinates,\n        gameData,\n        showPieces,\n        pieceOpacity,\n        pgn,\n      });\n    } catch (frameError) {\n      console.error('Failed to render first frame:', frameError);\n      throw new Error('Failed to render visualization frame. Please try again.');\n    }\n    \n    // Initialize GIF encoder with error handling for worker\n    let gif: InstanceType<typeof GIF>;\n    try {\n      gif = new GIF({\n        workers: 2,\n        quality,\n        width: firstCanvas.width,\n        height: firstCanvas.height,\n        workerScript: '/gif.worker.js',\n      });\n    } catch (workerError) {\n      console.error('Failed to initialize GIF encoder:', workerError);\n      throw new Error('GIF encoder initialization failed. The worker script may not be available.');\n    }\n    \n    // Add first frame with longer delay\n    gif.addFrame(firstCanvas, { delay: frameDelay * 3, copy: true });\n    onProgress?.(0.05, `Captured frame 1 of ${totalFramesToCapture}`);\n    \n    // Capture remaining frames\n    for (let i = 1; i < movesToCapture.length; i++) {\n      const moveNum = movesToCapture[i];\n      const isLastFrame = i === movesToCapture.length - 1;\n      \n      try {\n        const canvas = await renderFrameToCanvas({\n          board,\n          currentMove: moveNum,\n          totalMoves,\n          size,\n          darkMode,\n          showCoordinates,\n          gameData,\n          showPieces,\n          pieceOpacity,\n          pgn,\n        });\n        \n        // Hold first and last frames longer\n        const delay = isLastFrame ? frameDelay * 4 : frameDelay;\n        gif.addFrame(canvas, { delay, copy: true });\n        \n        const captureProgress = (i + 1) / totalFramesToCapture;\n        onProgress?.(\n          0.05 + captureProgress * 0.75,\n          `Captured frame ${i + 1} of ${totalFramesToCapture}`\n        );\n      } catch (frameError) {\n        console.warn(`Failed to capture frame ${i + 1}, skipping:`, frameError);\n        // Continue with remaining frames\n      }\n    }\n    \n    onProgress?.(0.8, 'Encoding GIF...');\n    \n    // Render GIF with timeout protection\n    return new Promise<Blob>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('GIF encoding timed out after 60 seconds'));\n      }, 60000);\n      \n      gif.on('progress', (p: number) => {\n        onProgress?.(0.8 + p * 0.2, 'Encoding GIF...');\n      });\n      \n      gif.on('finished', (blob: Blob) => {\n        clearTimeout(timeout);\n        onProgress?.(1, 'Complete!');\n        resolve(blob);\n      });\n      \n      gif.on('error', (error: Error) => {\n        clearTimeout(timeout);\n        console.error('GIF encoding error:', error);\n        reject(new Error('GIF encoding failed: ' + error.message));\n      });\n      \n      try {\n        gif.render();\n      } catch (renderError) {\n        clearTimeout(timeout);\n        console.error('GIF render call failed:', renderError);\n        reject(new Error('Failed to start GIF encoding'));\n      }\n    });\n  } catch (error) {\n    console.error('GIF generation failed:', error);\n    throw error instanceof Error ? error : new Error('Unknown error during GIF generation');\n  }\n}\n";export{n as default};
