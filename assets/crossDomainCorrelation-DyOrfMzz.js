const n="/**\n * En Pensent™ Cross-Domain Correlation Engine\n * \n * Analyzes pattern similarities across chess, code, and finance domains\n * to validate the universal nature of temporal signature recognition.\n */\n\nimport { TemporalSignature } from '../../types/core';\n\nexport interface CorrelationResult {\n  domains: [string, string];\n  similarityScore: number;  // 0-100\n  matchingPatterns: string[];\n  divergentPatterns: string[];\n  confidenceLevel: 'high' | 'medium' | 'low';\n  insights: string[];\n}\n\nexport interface DomainSignatureSummary {\n  domain: string;\n  totalSignatures: number;\n  archetypeDistribution: Record<string, number>;\n  avgIntensity: number;\n  dominantFlow: string;\n  avgAccuracy?: number;  // For domains with prediction tracking\n}\n\n// Archetype mappings across domains\nconst ARCHETYPE_MAPPINGS: Record<string, Record<string, string[]>> = {\n  chess: {\n    aggressive_attack: ['breakout_bullish', 'momentum_surge', 'rapid_growth'],\n    positional_grind: ['consolidation', 'accumulation', 'stable_evolution'],\n    tactical_explosion: ['high_volatility', 'momentum_surge', 'refactoring_surge'],\n    strategic_squeeze: ['accumulation', 'low_volatility', 'tech_debt_spiral'],\n    endgame_precision: ['distribution', 'reversal_bullish', 'maintenance_mode'],\n    defensive_fortress: ['consolidation', 'low_volatility', 'stable_evolution'],\n    initiative_control: ['uptrend', 'breakout_bullish', 'rapid_growth'],\n    counterattack: ['reversal_bullish', 'reversal_bearish', 'refactoring_surge'],\n  },\n  code: {\n    rapid_growth: ['breakout_bullish', 'momentum_surge', 'aggressive_attack'],\n    stable_evolution: ['uptrend', 'consolidation', 'positional_grind'],\n    tech_debt_spiral: ['downtrend', 'distribution', 'strategic_squeeze'],\n    refactoring_surge: ['high_volatility', 'reversal_bullish', 'tactical_explosion'],\n    maintenance_mode: ['consolidation', 'low_volatility', 'endgame_precision'],\n    feature_sprint: ['momentum_surge', 'breakout_bullish', 'aggressive_attack'],\n    bug_fix_cycle: ['high_volatility', 'consolidation', 'tactical_explosion'],\n    architecture_shift: ['reversal_bullish', 'accumulation', 'counterattack'],\n  },\n  finance: {\n    accumulation: ['strategic_squeeze', 'stable_evolution', 'positional_grind'],\n    distribution: ['endgame_precision', 'tech_debt_spiral', 'defensive_fortress'],\n    breakout_bullish: ['aggressive_attack', 'rapid_growth', 'initiative_control'],\n    breakout_bearish: ['counterattack', 'tech_debt_spiral', 'endgame_precision'],\n    consolidation: ['positional_grind', 'maintenance_mode', 'defensive_fortress'],\n    uptrend: ['initiative_control', 'stable_evolution', 'positional_grind'],\n    downtrend: ['tech_debt_spiral', 'strategic_squeeze', 'endgame_precision'],\n    reversal_bullish: ['counterattack', 'refactoring_surge', 'architecture_shift'],\n    reversal_bearish: ['endgame_precision', 'tech_debt_spiral', 'strategic_squeeze'],\n    high_volatility: ['tactical_explosion', 'refactoring_surge', 'bug_fix_cycle'],\n    low_volatility: ['defensive_fortress', 'maintenance_mode', 'positional_grind'],\n    momentum_surge: ['aggressive_attack', 'rapid_growth', 'feature_sprint'],\n  },\n};\n\n/**\n * Calculate correlation between two domain signatures\n */\nexport function calculateDomainCorrelation(\n  sig1: TemporalSignature,\n  sig2: TemporalSignature\n): CorrelationResult {\n  const domain1 = extractDomain(sig1);\n  const domain2 = extractDomain(sig2);\n  \n  let similarityScore = 0;\n  const matchingPatterns: string[] = [];\n  const divergentPatterns: string[] = [];\n  const insights: string[] = [];\n  \n  // 1. Flow direction similarity (20%)\n  if (sig1.flowDirection === sig2.flowDirection) {\n    similarityScore += 20;\n    matchingPatterns.push(`Flow direction: ${sig1.flowDirection}`);\n  } else {\n    divergentPatterns.push(`Flow: ${sig1.flowDirection} vs ${sig2.flowDirection}`);\n  }\n  \n  // 2. Intensity similarity (20%)\n  const intensityDiff = Math.abs(sig1.intensity - sig2.intensity);\n  const intensityScore = Math.max(0, 20 - intensityDiff * 40);\n  similarityScore += intensityScore;\n  if (intensityDiff < 0.2) {\n    matchingPatterns.push(`Similar intensity: ~${Math.round((sig1.intensity + sig2.intensity) / 2 * 100)}%`);\n  } else {\n    divergentPatterns.push(`Intensity: ${Math.round(sig1.intensity * 100)}% vs ${Math.round(sig2.intensity * 100)}%`);\n  }\n  \n  // 3. Temporal flow pattern similarity (25%)\n  const flowSimilarity = calculateFlowSimilarity(sig1.temporalFlow, sig2.temporalFlow);\n  similarityScore += flowSimilarity * 25;\n  if (flowSimilarity > 0.7) {\n    matchingPatterns.push('Temporal flow patterns align');\n    insights.push('Both signatures show similar temporal evolution patterns');\n  }\n  \n  // 4. Quadrant profile similarity (25%)\n  const quadrantSimilarity = calculateQuadrantSimilarity(sig1.quadrantProfile, sig2.quadrantProfile);\n  similarityScore += quadrantSimilarity * 25;\n  if (quadrantSimilarity > 0.7) {\n    matchingPatterns.push('Quadrant distributions match');\n    insights.push('Underlying force distributions are comparable');\n  }\n  \n  // 5. Archetype mapping correlation (10%)\n  const archetypeCorrelation = checkArchetypeMapping(sig1.archetype, sig2.archetype, domain1, domain2);\n  if (archetypeCorrelation > 0) {\n    similarityScore += archetypeCorrelation * 10;\n    matchingPatterns.push(`Archetypes correlate: ${sig1.archetype} ↔ ${sig2.archetype}`);\n    insights.push(`Cross-domain archetype mapping detected between ${domain1} and ${domain2}`);\n  }\n  \n  // Determine confidence level\n  let confidenceLevel: 'high' | 'medium' | 'low';\n  if (similarityScore >= 75) {\n    confidenceLevel = 'high';\n    insights.push('Strong cross-domain pattern correlation detected');\n  } else if (similarityScore >= 50) {\n    confidenceLevel = 'medium';\n    insights.push('Moderate pattern similarity suggests shared underlying dynamics');\n  } else {\n    confidenceLevel = 'low';\n    insights.push('Patterns are domain-specific with limited cross-domain transfer');\n  }\n  \n  return {\n    domains: [domain1, domain2],\n    similarityScore: Math.round(similarityScore),\n    matchingPatterns,\n    divergentPatterns,\n    confidenceLevel,\n    insights,\n  };\n}\n\n/**\n * Analyze a collection of signatures across domains\n */\nexport function analyzeCrossDomainPatterns(\n  signatures: TemporalSignature[]\n): {\n  summaries: DomainSignatureSummary[];\n  correlations: CorrelationResult[];\n  universalPatterns: string[];\n  domainSpecificPatterns: Record<string, string[]>;\n} {\n  // Group by domain\n  const byDomain: Record<string, TemporalSignature[]> = {};\n  for (const sig of signatures) {\n    const domain = extractDomain(sig);\n    if (!byDomain[domain]) byDomain[domain] = [];\n    byDomain[domain].push(sig);\n  }\n  \n  // Generate summaries\n  const summaries: DomainSignatureSummary[] = [];\n  for (const [domain, sigs] of Object.entries(byDomain)) {\n    const archetypeDist: Record<string, number> = {};\n    let totalIntensity = 0;\n    const flowCounts: Record<string, number> = {};\n    \n    for (const sig of sigs) {\n      archetypeDist[sig.archetype] = (archetypeDist[sig.archetype] || 0) + 1;\n      totalIntensity += sig.intensity;\n      flowCounts[sig.flowDirection] = (flowCounts[sig.flowDirection] || 0) + 1;\n    }\n    \n    const dominantFlow = Object.entries(flowCounts)\n      .sort((a, b) => b[1] - a[1])[0]?.[0] || 'unknown';\n    \n    summaries.push({\n      domain,\n      totalSignatures: sigs.length,\n      archetypeDistribution: archetypeDist,\n      avgIntensity: totalIntensity / sigs.length,\n      dominantFlow,\n    });\n  }\n  \n  // Calculate cross-domain correlations\n  const correlations: CorrelationResult[] = [];\n  const domains = Object.keys(byDomain);\n  \n  for (let i = 0; i < domains.length; i++) {\n    for (let j = i + 1; j < domains.length; j++) {\n      // Sample signatures for comparison\n      const sigs1 = byDomain[domains[i]].slice(0, 5);\n      const sigs2 = byDomain[domains[j]].slice(0, 5);\n      \n      for (const s1 of sigs1) {\n        for (const s2 of sigs2) {\n          correlations.push(calculateDomainCorrelation(s1, s2));\n        }\n      }\n    }\n  }\n  \n  // Find universal patterns (appear in all domains)\n  const universalPatterns: string[] = [];\n  const allArchetypes = new Set<string>();\n  \n  for (const sigs of Object.values(byDomain)) {\n    for (const sig of sigs) {\n      allArchetypes.add(sig.archetype);\n    }\n  }\n  \n  // Identify domain-specific patterns\n  const domainSpecificPatterns: Record<string, string[]> = {};\n  for (const [domain, sigs] of Object.entries(byDomain)) {\n    const archetypes = new Set(sigs.map(s => s.archetype));\n    domainSpecificPatterns[domain] = Array.from(archetypes);\n  }\n  \n  // Check for patterns that transfer well\n  const highCorrelations = correlations.filter(c => c.similarityScore >= 70);\n  if (highCorrelations.length > 0) {\n    universalPatterns.push('High-intensity momentum patterns');\n    universalPatterns.push('Consolidation-before-breakout patterns');\n    universalPatterns.push('Trend exhaustion signatures');\n  }\n  \n  return {\n    summaries,\n    correlations,\n    universalPatterns,\n    domainSpecificPatterns,\n  };\n}\n\n// Helper functions\nfunction extractDomain(sig: TemporalSignature): string {\n  if (sig.archetype.includes('accumulation') || sig.archetype.includes('breakout') || \n      sig.archetype.includes('trend') || sig.archetype.includes('volatility')) {\n    return 'finance';\n  }\n  if (sig.archetype.includes('attack') || sig.archetype.includes('grind') || \n      sig.archetype.includes('fortress') || sig.archetype.includes('endgame')) {\n    return 'chess';\n  }\n  if (sig.archetype.includes('growth') || sig.archetype.includes('evolution') || \n      sig.archetype.includes('debt') || sig.archetype.includes('refactor')) {\n    return 'code';\n  }\n  return 'unknown';\n}\n\nfunction calculateFlowSimilarity(\n  flow1: TemporalSignature['temporalFlow'],\n  flow2: TemporalSignature['temporalFlow']\n): number {\n  const openDiff = Math.abs(flow1.opening - flow2.opening);\n  const midDiff = Math.abs(flow1.middle - flow2.middle);\n  const endDiff = Math.abs(flow1.ending - flow2.ending);\n  const momDiff = Math.abs(flow1.momentum - flow2.momentum);\n  \n  const avgDiff = (openDiff + midDiff + endDiff + momDiff) / 4;\n  return Math.max(0, 1 - avgDiff);\n}\n\nfunction calculateQuadrantSimilarity(\n  q1: TemporalSignature['quadrantProfile'],\n  q2: TemporalSignature['quadrantProfile']\n): number {\n  const diffs = [\n    Math.abs(q1.q1 - q2.q1),\n    Math.abs(q1.q2 - q2.q2),\n    Math.abs(q1.q3 - q2.q3),\n    Math.abs(q1.q4 - q2.q4),\n  ];\n  \n  const avgDiff = diffs.reduce((a, b) => a + b, 0) / 4;\n  return Math.max(0, 1 - avgDiff);\n}\n\nfunction checkArchetypeMapping(\n  arch1: string,\n  arch2: string,\n  domain1: string,\n  domain2: string\n): number {\n  const mappings = ARCHETYPE_MAPPINGS[domain1];\n  if (!mappings || !mappings[arch1]) return 0;\n  \n  return mappings[arch1].includes(arch2) ? 1 : 0;\n}\n";export{n as default};
