const n="/**\n * Lichess API Integration for Historical Game Import\n * Routes through Edge Function proxy to avoid CORS and centralize rate limiting\n * \n * v7.54-FIX: Added Chess.js import for UCI-to-SAN conversion\n */\n\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { Chess } from 'chess.js';\n\nexport interface LichessGame {\n  id: string;\n  rated: boolean;\n  variant: string;\n  speed: string;\n  perf: string;\n  createdAt: number;\n  lastMoveAt: number;\n  status: string;\n  players: {\n    white: { user?: { name: string; id: string }; rating?: number };\n    black: { user?: { name: string; id: string }; rating?: number };\n  };\n  winner?: 'white' | 'black';\n  moves?: string;\n  pgn?: string;\n  opening?: {\n    eco: string;\n    name: string;\n    ply: number;\n  };\n}\n\nexport interface LichessImportResult {\n  games: LichessGame[];\n  username: string;\n  totalGames: number;\n  importedCount: number;\n  errors: string[];\n}\n\n/**\n * Fetch games from Lichess via Edge Function proxy\n * This avoids CORS issues and centralizes rate limiting\n */\nexport async function fetchLichessGames(\n  username: string,\n  options: {\n    max?: number;\n    since?: number;\n    until?: number;\n    rated?: boolean;\n    perfType?: string;\n    opening?: boolean;\n    moves?: boolean;\n    pgnInJson?: boolean;\n  } = {}\n): Promise<LichessImportResult> {\n  const {\n    max = 50,\n    since,\n    until,\n  } = options;\n\n  try {\n    // Use Edge Function proxy to avoid CORS and centralize rate limiting\n    const { data, error } = await supabase.functions.invoke('lichess-games', {\n      body: {\n        player: username,\n        max,\n        since,\n        until,\n      },\n    });\n\n    if (error) {\n      console.error('[Lichess API] Edge function error:', error);\n      return {\n        games: [],\n        username,\n        totalGames: 0,\n        importedCount: 0,\n        errors: [error.message || 'Edge function error']\n      };\n    }\n\n    // Handle rate limit response\n    if (data?.error === 'Rate limited') {\n      console.warn(`[Lichess API] Rate limited, retry after ${data.retryAfter}s`);\n      return {\n        games: [],\n        username,\n        totalGames: 0,\n        importedCount: 0,\n        errors: [`Rate limited - retry after ${data.retryAfter}s`]\n      };\n    }\n\n    if (data?.error) {\n      return {\n        games: [],\n        username,\n        totalGames: 0,\n        importedCount: 0,\n        errors: [data.error]\n      };\n    }\n\n    // Transform edge function response to LichessGame format\n    const games: LichessGame[] = (data?.games || []).map((g: Record<string, unknown>) => ({\n      id: g.id as string,\n      rated: (g.rated as boolean) ?? true,\n      variant: (g.variant as string) || 'standard',\n      speed: (g.speed as string) || 'blitz',\n      perf: (g.perf as string) || (g.speed as string) || 'blitz',\n      createdAt: g.createdAt as number,\n      lastMoveAt: g.lastMoveAt as number,\n      status: g.status as string,\n      players: {\n        white: { \n          user: { name: g.whiteName as string, id: g.whiteName as string }, \n          rating: g.whiteElo as number \n        },\n        black: { \n          user: { name: g.blackName as string, id: g.blackName as string }, \n          rating: g.blackElo as number \n        },\n      },\n      winner: g.winner as 'white' | 'black' | undefined,\n      moves: g.moves as string,\n      pgn: g.pgn as string,\n      opening: g.openingEco ? {\n        eco: g.openingEco as string,\n        name: (g.openingName as string) || 'Unknown',\n        ply: (g.openingPly as number) || 0,\n      } : undefined,\n    }));\n\n    return {\n      games,\n      username,\n      totalGames: games.length,\n      importedCount: games.length,\n      errors: []\n    };\n  } catch (error) {\n    console.error('[Lichess API] Fetch error:', error);\n    return {\n      games: [],\n      username,\n      totalGames: 0,\n      importedCount: 0,\n      errors: [error instanceof Error ? error.message : 'Unknown error']\n    };\n  }\n}\n\n/**\n * Get user profile info from Lichess (direct API call - profile is public/simple)\n */\nexport async function getLichessUserProfile(username: string) {\n  const response = await fetch(`https://lichess.org/api/user/${username}`);\n  if (!response.ok) {\n    throw new Error(`User not found: ${username}`);\n  }\n  return response.json();\n}\n\n/**\n * Convert Lichess game to standard PGN format\n * v7.54-FIX: Properly convert UCI moves to SAN notation\n */\nexport function lichessGameToPgn(game: LichessGame): string {\n  // If we already have a proper PGN, use it directly\n  if (game.pgn) return game.pgn;\n  \n  const headers: string[] = [];\n  headers.push(`[Event \"Lichess ${game.perf}\"]`);\n  headers.push(`[Site \"https://lichess.org/${game.id}\"]`);\n  headers.push(`[Date \"${new Date(game.createdAt).toISOString().split('T')[0].replace(/-/g, '.')}\"]`);\n  headers.push(`[White \"${game.players.white.user?.name || 'Anonymous'}\"]`);\n  headers.push(`[Black \"${game.players.black.user?.name || 'Anonymous'}\"]`);\n  headers.push(`[Result \"${getResult(game)}\"]`);\n  if (game.players.white.rating) headers.push(`[WhiteElo \"${game.players.white.rating}\"]`);\n  if (game.players.black.rating) headers.push(`[BlackElo \"${game.players.black.rating}\"]`);\n  if (game.opening) {\n    headers.push(`[ECO \"${game.opening.eco}\"]`);\n    headers.push(`[Opening \"${game.opening.name}\"]`);\n  }\n  \n  // v7.54-FIX: Convert UCI moves to SAN notation\n  // Lichess API returns moves in UCI format (e2e4, g1f3, etc.) when pgnInJson is false\n  // We need to replay the game and extract SAN notation\n  let sanMoves = '';\n  if (game.moves) {\n    try {\n      const chess = new Chess();\n      const uciMoves = game.moves.split(' ');\n      const sanList: string[] = [];\n      \n      for (const uci of uciMoves) {\n        if (!uci || uci.length < 4) continue;\n        \n        const from = uci.slice(0, 2);\n        const to = uci.slice(2, 4);\n        const promotion = uci.length > 4 ? uci[4] : undefined;\n        \n        try {\n          const move = chess.move({ from, to, promotion });\n          if (move) {\n            sanList.push(move.san);\n          }\n        } catch {\n          // Skip invalid moves (might be corrupted data)\n          console.warn(`[lichessApi] Invalid UCI move: ${uci} in game ${game.id}`);\n          break;\n        }\n      }\n      \n      // Format as proper PGN move text\n      sanMoves = sanList.map((san, i) => \n        i % 2 === 0 ? `${Math.floor(i / 2) + 1}. ${san}` : san\n      ).join(' ');\n    } catch (err) {\n      console.warn(`[lichessApi] Failed to convert moves for ${game.id}:`, err);\n      sanMoves = '';\n    }\n  }\n  \n  return `${headers.join('\\n')}\\n\\n${sanMoves} ${getResult(game)}`;\n}\n\nfunction getResult(game: LichessGame): string {\n  // v6.4-TIMEOUT: Handle ALL decisive statuses including timeout\n  // Lichess statuses: mate, resign, stalemate, timeout, draw, outoftime, cheat, noStart, unknownFinish, variantEnd\n  \n  // Draw statuses\n  if (game.status === 'draw' || game.status === 'stalemate') return '1/2-1/2';\n  \n  // Decisive games - check winner field (works for mate, resign, timeout, outoftime, etc.)\n  if (game.winner === 'white') return '1-0';\n  if (game.winner === 'black') return '0-1';\n  \n  // Fallback for edge cases: check status directly\n  // \"timeout\" and \"outoftime\" should have winner set, but handle if not\n  if (game.status === 'timeout' || game.status === 'outoftime') {\n    // Try to infer from clock data if available, otherwise mark as unresolved\n    console.log(`[Lichess] Timeout game ${game.id} without winner field - marking as draw`);\n    return '1/2-1/2'; // Conservative: treat as draw rather than skip\n  }\n  \n  return '*';\n}\n";export{n as default};
