const n="/**\n * Unified Rate Limiting Core - v7.12\n * \n * Single source of truth for rate limiting with:\n * - Sliding window algorithm (more accurate than fixed buckets)\n * - Bounded memory with automatic cleanup\n * - No redundant DB calls (log only on limit exceeded)\n * - Shared configuration across client and edge functions\n */\n\nexport interface RateLimitConfig {\n  maxRequests: number;\n  windowMs: number;\n}\n\nexport interface RateLimitResult {\n  allowed: boolean;\n  remaining: number;\n  resetInMs: number;\n  retryAfter?: number;\n}\n\ninterface SlidingWindowEntry {\n  timestamps: number[];\n  lastCleanup: number;\n}\n\n// Bounded cache with automatic eviction\nconst MAX_CACHE_ENTRIES = 1000;\nconst CLEANUP_INTERVAL_MS = 60_000; // 1 minute\n\nclass SlidingWindowLimiter {\n  private cache = new Map<string, SlidingWindowEntry>();\n  private lastGlobalCleanup = Date.now();\n\n  check(key: string, config: RateLimitConfig): RateLimitResult {\n    const now = Date.now();\n    \n    // Periodic global cleanup\n    if (now - this.lastGlobalCleanup > CLEANUP_INTERVAL_MS) {\n      this.globalCleanup(now, config.windowMs);\n    }\n\n    let entry = this.cache.get(key);\n    \n    if (!entry) {\n      // Evict oldest if at capacity\n      if (this.cache.size >= MAX_CACHE_ENTRIES) {\n        const oldestKey = this.cache.keys().next().value;\n        if (oldestKey) this.cache.delete(oldestKey);\n      }\n      entry = { timestamps: [], lastCleanup: now };\n      this.cache.set(key, entry);\n    }\n\n    // Sliding window: filter to only timestamps within window\n    const windowStart = now - config.windowMs;\n    entry.timestamps = entry.timestamps.filter(t => t > windowStart);\n    \n    const requestCount = entry.timestamps.length;\n    const allowed = requestCount < config.maxRequests;\n    \n    if (allowed) {\n      entry.timestamps.push(now);\n    }\n\n    // Calculate reset time (when oldest request expires)\n    const oldestInWindow = entry.timestamps[0] || now;\n    const resetInMs = Math.max(0, (oldestInWindow + config.windowMs) - now);\n\n    return {\n      allowed,\n      remaining: Math.max(0, config.maxRequests - entry.timestamps.length),\n      resetInMs,\n      retryAfter: allowed ? undefined : Math.ceil(resetInMs / 1000),\n    };\n  }\n\n  private globalCleanup(now: number, windowMs: number): void {\n    this.lastGlobalCleanup = now;\n    const windowStart = now - windowMs;\n    \n    for (const [key, entry] of this.cache) {\n      // Remove entries with no recent activity\n      if (entry.timestamps.every(t => t <= windowStart)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  getStats(): { size: number; maxSize: number } {\n    return { size: this.cache.size, maxSize: MAX_CACHE_ENTRIES };\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Singleton instance\nexport const rateLimiter = new SlidingWindowLimiter();\n\n// ============================================\n// Pre-configured rate limit profiles\n// ============================================\n\nexport const RATE_LIMIT_PROFILES = {\n  // User-facing actions (generous)\n  auth: { maxRequests: 10, windowMs: 60_000 },\n  search: { maxRequests: 60, windowMs: 60_000 },\n  \n  // Data operations (moderate)\n  download: { maxRequests: 10, windowMs: 60_000 },\n  upload: { maxRequests: 20, windowMs: 60_000 },\n  save: { maxRequests: 30, windowMs: 60_000 },\n  listing: { maxRequests: 50, windowMs: 60_000 },\n  \n  // Payment/sensitive (strict)\n  payment: { maxRequests: 5, windowMs: 60_000 },\n  offer: { maxRequests: 10, windowMs: 60_000 },\n  \n  // Expensive operations (very strict)\n  benchmark: { maxRequests: 5, windowMs: 300_000 }, // 5 per 5 min\n  scan: { maxRequests: 3, windowMs: 300_000 },\n  \n  // External API proxies (conservative to avoid upstream limits)\n  lichessApi: { maxRequests: 30, windowMs: 60_000 },\n  lichessCloudEval: { maxRequests: 20, windowMs: 60_000 },\n  chesscomApi: { maxRequests: 30, windowMs: 60_000 },\n} as const;\n\nexport type RateLimitProfile = keyof typeof RATE_LIMIT_PROFILES;\n\n// ============================================\n// Utility functions\n// ============================================\n\n/**\n * Generate a consistent identifier from request metadata\n */\nexport function generateIdentifier(ip?: string, userAgent?: string, userId?: string): string {\n  if (userId) return `user:${userId}`;\n  \n  // Anonymous: hash of IP + UA\n  const raw = `${ip || 'unknown'}:${userAgent || 'unknown'}`;\n  let hash = 0;\n  for (let i = 0; i < raw.length; i++) {\n    hash = ((hash << 5) - hash) + raw.charCodeAt(i);\n    hash |= 0;\n  }\n  return `anon:${Math.abs(hash).toString(36)}`;\n}\n\n/**\n * Check rate limit with a pre-defined profile\n */\nexport function checkRateLimit(\n  identifier: string, \n  profile: RateLimitProfile | RateLimitConfig\n): RateLimitResult {\n  const config = typeof profile === 'string' \n    ? RATE_LIMIT_PROFILES[profile] \n    : profile;\n  \n  const key = typeof profile === 'string' \n    ? `${profile}:${identifier}` \n    : `custom:${identifier}`;\n    \n  return rateLimiter.check(key, config);\n}\n\n/**\n * Browser-safe identifier using fingerprinting\n */\nexport function getBrowserIdentifier(): string {\n  if (typeof window === 'undefined') return 'server';\n  \n  const components = [\n    navigator.userAgent,\n    navigator.language,\n    screen.width,\n    screen.height,\n    new Date().getTimezoneOffset(),\n  ];\n  \n  let hash = 0;\n  const str = components.join('|');\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) - hash) + str.charCodeAt(i);\n    hash |= 0;\n  }\n  return `browser:${Math.abs(hash).toString(36)}`;\n}\n";export{n as default};
