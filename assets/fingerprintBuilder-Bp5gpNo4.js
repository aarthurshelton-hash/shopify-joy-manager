const e="/**\n * Fingerprint Builder Module\n * \n * Core functions for building and merging player fingerprints.\n */\n\nimport { hashString } from '../../../signature/fingerprintGenerator';\nimport { PlayerFingerprint, GameData } from './types';\nimport { analyzeGame } from './gameAnalyzer';\nimport {\n  calculateStyleProfile,\n  calculatePressureProfile,\n  calculateBlunderSignature,\n  calculateTemporalPatterns\n} from './profileCalculators';\n\n/**\n * Build or update a player fingerprint from game data\n */\nexport function buildFingerprint(\n  games: GameData[],\n  existingFingerprint?: PlayerFingerprint\n): PlayerFingerprint {\n  const gamesHash = hashString(games.map(g => g.moves.map(m => m.san).join('')).join('|'));\n  \n  // Analyze all games\n  const analyses = games.map(analyzeGame);\n  \n  // Build profiles\n  const styleProfile = calculateStyleProfile(analyses);\n  const pressureProfile = calculatePressureProfile(analyses);\n  const blunderSignature = calculateBlunderSignature(analyses);\n  const temporalPatterns = calculateTemporalPatterns(analyses);\n  \n  const newFingerprint: PlayerFingerprint = {\n    fingerprintId: existingFingerprint?.fingerprintId || `FP-${gamesHash}`,\n    styleProfile,\n    pressureProfile,\n    blunderSignature,\n    temporalPatterns,\n    gamesAnalyzed: (existingFingerprint?.gamesAnalyzed || 0) + games.length,\n    confidence: Math.min(0.95, 0.3 + games.length * 0.05),\n    lastUpdated: Date.now()\n  };\n  \n  // Merge with existing if available\n  if (existingFingerprint && existingFingerprint.gamesAnalyzed > 0) {\n    return mergeFingerprints(existingFingerprint, newFingerprint);\n  }\n  \n  return newFingerprint;\n}\n\n/**\n * Merge two fingerprints with weighted averaging\n */\nexport function mergeFingerprints(\n  existing: PlayerFingerprint,\n  newData: PlayerFingerprint\n): PlayerFingerprint {\n  const totalGames = existing.gamesAnalyzed + newData.gamesAnalyzed;\n  const existingWeight = existing.gamesAnalyzed / totalGames;\n  const newWeight = newData.gamesAnalyzed / totalGames;\n  \n  const mergeValue = (a: number, b: number) => a * existingWeight + b * newWeight;\n  \n  return {\n    fingerprintId: existing.fingerprintId,\n    styleProfile: {\n      aggressiveness: mergeValue(existing.styleProfile.aggressiveness, newData.styleProfile.aggressiveness),\n      complexity: mergeValue(existing.styleProfile.complexity, newData.styleProfile.complexity),\n      speedPreference: mergeValue(existing.styleProfile.speedPreference, newData.styleProfile.speedPreference),\n      riskTolerance: mergeValue(existing.styleProfile.riskTolerance, newData.styleProfile.riskTolerance),\n      endgameSkill: mergeValue(existing.styleProfile.endgameSkill, newData.styleProfile.endgameSkill)\n    },\n    pressureProfile: {\n      tiltResistance: mergeValue(existing.pressureProfile.tiltResistance, newData.pressureProfile.tiltResistance),\n      timePressurePerformance: mergeValue(existing.pressureProfile.timePressurePerformance, newData.pressureProfile.timePressurePerformance),\n      complicatingTendency: mergeValue(existing.pressureProfile.complicatingTendency, newData.pressureProfile.complicatingTendency),\n      simplifyingTendency: mergeValue(existing.pressureProfile.simplifyingTendency, newData.pressureProfile.simplifyingTendency)\n    },\n    blunderSignature: existing.blunderSignature, // Keep more established signature\n    temporalPatterns: {\n      ...existing.temporalPatterns,\n      averageMoveTime: mergeValue(existing.temporalPatterns.averageMoveTime, newData.temporalPatterns.averageMoveTime),\n      comebackProbability: mergeValue(existing.temporalPatterns.comebackProbability, newData.temporalPatterns.comebackProbability)\n    },\n    gamesAnalyzed: totalGames,\n    confidence: Math.min(0.95, 0.3 + totalGames * 0.01),\n    lastUpdated: Date.now()\n  };\n}\n";export{e as default};
