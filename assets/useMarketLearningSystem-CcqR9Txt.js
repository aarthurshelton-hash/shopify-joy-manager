const n="/**\n * Market Learning System Hook\n * Connects to the persistent 24/7 learning backend\n * Provides real-time sync and report access\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useLiveHeartbeat } from './useLiveHeartbeat';\n\nexport interface SecurityMetrics {\n  symbol: string;\n  total_predictions: number;\n  correct_predictions: number;\n  direction_accuracy: number;\n  magnitude_accuracy: number;\n  timing_accuracy: number;\n  calibration_accuracy: number;\n  composite_accuracy: number;\n  best_timeframe_ms?: number;\n  optimal_confidence_threshold?: number;\n  volatility_profile?: Record<string, unknown>;\n  correlation_strengths?: Record<string, number>;\n  last_prediction_at?: string;\n}\n\nexport interface MarketCorrelation {\n  symbol_a: string;\n  symbol_b: string;\n  correlation_coefficient: number;\n  lag_ms: number;\n  sample_size: number;\n  confidence_interval?: number;\n  timeframe: string;\n  calculated_at: string;\n}\n\nexport interface EvolutionState {\n  generation: number;\n  fitness_score: number;\n  genes: Record<string, number>;\n  learned_patterns?: unknown[];\n  adaptation_history?: unknown[];\n  total_predictions: number;\n  last_mutation_at?: string;\n}\n\nexport interface SystemReport {\n  generatedAt: string;\n  overallAccuracy: number;\n  securityMetrics: SecurityMetrics[];\n  topCorrelations: MarketCorrelation[];\n  evolutionState: EvolutionState | null;\n  recentPredictions: unknown[];\n  summary: {\n    totalSecurities: number;\n    totalPredictions: number;\n    avgDirectionAccuracy: number;\n    generation: number;\n    systemFitness: number;\n  };\n}\n\nexport interface MarketLearningState {\n  isConnected: boolean;\n  isCollecting: boolean;\n  lastUpdate: Date | null;\n  securityMetrics: SecurityMetrics[];\n  correlations: MarketCorrelation[];\n  evolutionState: EvolutionState | null;\n  report: SystemReport | null;\n  ticksCollectedToday: number;\n  predictionsToday: number;\n  error: string | null;\n}\n\nexport function useMarketLearningSystem(autoSync = true) {\n  const [state, setState] = useState<MarketLearningState>({\n    isConnected: false,\n    isCollecting: false,\n    lastUpdate: null,\n    securityMetrics: [],\n    correlations: [],\n    evolutionState: null,\n    report: null,\n    ticksCollectedToday: 0,\n    predictionsToday: 0,\n    error: null\n  });\n\n  const channelRef = useRef<ReturnType<typeof supabase.channel> | null>(null);\n\n  // Fetch security metrics\n  const fetchSecurityMetrics = useCallback(async () => {\n    const { data, error } = await supabase\n      .from('security_accuracy_metrics')\n      .select('*')\n      .order('composite_accuracy', { ascending: false });\n\n    if (!error && data) {\n      setState(prev => ({\n        ...prev,\n        securityMetrics: data as SecurityMetrics[],\n        lastUpdate: new Date()\n      }));\n    }\n  }, []);\n\n  // Fetch correlations\n  const fetchCorrelations = useCallback(async () => {\n    const { data, error } = await supabase\n      .from('market_correlations')\n      .select('*')\n      .order('correlation_coefficient', { ascending: false });\n\n    if (!error && data) {\n      setState(prev => ({\n        ...prev,\n        correlations: data as MarketCorrelation[],\n        lastUpdate: new Date()\n      }));\n    }\n  }, []);\n\n  // Fetch evolution state\n  const fetchEvolutionState = useCallback(async () => {\n    const { data, error } = await supabase\n      .from('evolution_state')\n      .select('*')\n      .eq('state_type', 'global')\n      .single();\n\n    if (!error && data) {\n      setState(prev => ({\n        ...prev,\n        evolutionState: data as EvolutionState,\n        lastUpdate: new Date()\n      }));\n    }\n  }, []);\n\n  // Trigger background collection\n  const triggerCollection = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('market-collector', {\n        body: { action: 'collect' }\n      });\n\n      if (error) throw error;\n      \n      setState(prev => ({\n        ...prev,\n        isCollecting: true,\n        ticksCollectedToday: prev.ticksCollectedToday + (data?.ticksCollected || 0)\n      }));\n\n      return data;\n    } catch (error) {\n      console.error('Collection error:', error);\n      setState(prev => ({ ...prev, error: (error as Error).message }));\n      return null;\n    }\n  }, []);\n\n  // Trigger prediction resolution\n  const triggerResolution = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('market-collector', {\n        body: { action: 'resolve' }\n      });\n\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Resolution error:', error);\n      return null;\n    }\n  }, []);\n\n  // Trigger correlation calculation\n  const triggerCorrelation = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('market-collector', {\n        body: { action: 'correlate' }\n      });\n\n      if (error) throw error;\n      await fetchCorrelations();\n      return data;\n    } catch (error) {\n      console.error('Correlation error:', error);\n      return null;\n    }\n  }, [fetchCorrelations]);\n\n  // Trigger evolution\n  const triggerEvolution = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('market-collector', {\n        body: { action: 'evolve' }\n      });\n\n      if (error) throw error;\n      await fetchEvolutionState();\n      return data;\n    } catch (error) {\n      console.error('Evolution error:', error);\n      return null;\n    }\n  }, [fetchEvolutionState]);\n\n  // Generate comprehensive report\n  const generateReport = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('market-collector', {\n        body: { action: 'report' }\n      });\n\n      if (error) throw error;\n      \n      if (data?.report) {\n        setState(prev => ({\n          ...prev,\n          report: data.report as SystemReport,\n          lastUpdate: new Date()\n        }));\n      }\n\n      return data?.report;\n    } catch (error) {\n      console.error('Report error:', error);\n      setState(prev => ({ ...prev, error: (error as Error).message }));\n      return null;\n    }\n  }, []);\n\n  // Record a new prediction\n  const recordPrediction = useCallback(async (prediction: {\n    symbol: string;\n    predicted_direction: string;\n    predicted_confidence: number;\n    predicted_magnitude?: number;\n    entry_price: number;\n    prediction_horizon_ms: number;\n    market_conditions?: Record<string, unknown>;\n    correlated_assets?: Record<string, unknown>;\n  }) => {\n    try {\n      const insertData = {\n        symbol: prediction.symbol,\n        predicted_direction: prediction.predicted_direction,\n        predicted_confidence: prediction.predicted_confidence,\n        predicted_magnitude: prediction.predicted_magnitude,\n        entry_price: prediction.entry_price,\n        prediction_horizon_ms: prediction.prediction_horizon_ms,\n        market_conditions: prediction.market_conditions ? JSON.parse(JSON.stringify(prediction.market_conditions)) : null,\n        correlated_assets: prediction.correlated_assets ? JSON.parse(JSON.stringify(prediction.correlated_assets)) : null\n      };\n      \n      const { data, error } = await supabase\n        .from('prediction_outcomes')\n        .insert([insertData])\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      setState(prev => ({\n        ...prev,\n        predictionsToday: prev.predictionsToday + 1\n      }));\n\n      return data;\n    } catch (error) {\n      console.error('Record prediction error:', error);\n      return null;\n    }\n  }, []);\n\n  // Sync all data\n  const syncAll = useCallback(async () => {\n    await Promise.all([\n      fetchSecurityMetrics(),\n      fetchCorrelations(),\n      fetchEvolutionState()\n    ]);\n    setState(prev => ({ ...prev, isConnected: true }));\n  }, [fetchSecurityMetrics, fetchCorrelations, fetchEvolutionState]);\n\n  // Heartbeat for continuous sync\n  const heartbeat = useLiveHeartbeat({\n    interval: 30000, // 30 seconds\n    autoStart: autoSync,\n    enabled: autoSync,\n    onPulse: async () => {\n      await triggerCollection();\n      await triggerResolution();\n      await syncAll();\n    }\n  });\n\n  // Set up realtime subscriptions\n  useEffect(() => {\n    if (!autoSync) return;\n\n    channelRef.current = supabase\n      .channel('market-learning')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'security_accuracy_metrics' },\n        () => fetchSecurityMetrics()\n      )\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'evolution_state' },\n        () => fetchEvolutionState()\n      )\n      .on(\n        'postgres_changes',\n        { event: 'INSERT', schema: 'public', table: 'prediction_outcomes' },\n        () => {\n          setState(prev => ({\n            ...prev,\n            predictionsToday: prev.predictionsToday + 1\n          }));\n        }\n      )\n      .subscribe((status) => {\n        setState(prev => ({\n          ...prev,\n          isConnected: status === 'SUBSCRIBED'\n        }));\n      });\n\n    // Initial sync\n    syncAll();\n\n    return () => {\n      if (channelRef.current) {\n        supabase.removeChannel(channelRef.current);\n      }\n    };\n  }, [autoSync, fetchSecurityMetrics, fetchEvolutionState, syncAll]);\n\n  return {\n    ...state,\n    heartbeat,\n    actions: {\n      triggerCollection,\n      triggerResolution,\n      triggerCorrelation,\n      triggerEvolution,\n      generateReport,\n      recordPrediction,\n      syncAll\n    }\n  };\n}\n";export{n as default};
