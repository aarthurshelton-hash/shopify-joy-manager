const e="/**\n * Sentiment Divergence - v7.53-ACCURACY\n * \n * Detects divergences between price action and sentiment.\n * Divergences often precede reversals.\n */\n\nexport interface SentimentData {\n  timestamp: number;\n  source: 'social' | 'news' | 'options' | 'positioning';\n  value: number;      // -1 to 1 (bearish to bullish)\n  confidence: number; // 0-1\n  volume: number;     // Sample size or volume\n}\n\nexport interface PriceData {\n  timestamp: number;\n  price: number;\n  change: number;     // Percent change\n  volume: number;\n}\n\nexport interface DivergenceSignal {\n  type: 'bullish_divergence' | 'bearish_divergence' | 'confirmation' | 'none';\n  strength: number;   // 0-1\n  confidence: number; // 0-1\n  description: string;\n  expectedReversal: boolean;\n  timeframe: 'immediate' | 'short_term' | 'medium_term';\n}\n\n/**\n * Calculate sentiment from multiple sources\n */\nexport function aggregateSentiment(sources: SentimentData[]): {\n  composite: number;\n  confidence: number;\n  dominantSource: string;\n} {\n  if (sources.length === 0) {\n    return { composite: 0, confidence: 0, dominantSource: 'none' };\n  }\n  \n  // Volume-weighted average\n  const totalVolume = sources.reduce((sum, s) => sum + s.volume, 0);\n  const weightedSum = sources.reduce((sum, s) => \n    sum + (s.value * s.volume * s.confidence), 0\n  );\n  \n  const composite = totalVolume > 0 ? weightedSum / totalVolume : 0;\n  const avgConfidence = sources.reduce((sum, s) => sum + s.confidence, 0) / sources.length;\n  \n  // Find dominant source\n  const bySource = sources.reduce((acc, s) => {\n    acc[s.source] = (acc[s.source] || 0) + s.volume;\n    return acc;\n  }, {} as Record<string, number>);\n  \n  const dominantSource = Object.entries(bySource)\n    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'none';\n  \n  return { composite, confidence: avgConfidence, dominantSource };\n}\n\n/**\n * Detect divergence between price and sentiment\n */\nexport function detectDivergence(\n  priceData: PriceData[],\n  sentimentData: SentimentData[]\n): DivergenceSignal {\n  if (priceData.length < 3 || sentimentData.length < 3) {\n    return {\n      type: 'none',\n      strength: 0,\n      confidence: 0,\n      description: 'Insufficient data',\n      expectedReversal: false,\n      timeframe: 'short_term',\n    };\n  }\n  \n  // Calculate price trend\n  const recentPrices = priceData.slice(-5);\n  const priceChange = recentPrices[recentPrices.length - 1].price / recentPrices[0].price - 1;\n  const priceTrend: 'up' | 'down' | 'flat' = \n    priceChange > 0.02 ? 'up' : priceChange < -0.02 ? 'down' : 'flat';\n  \n  // Calculate sentiment trend\n  const recentSentiment = sentimentData.slice(-5);\n  const avgSentiment = recentSentiment.reduce((sum, s) => sum + s.value, 0) / recentSentiment.length;\n  const sentimentTrend: 'bullish' | 'bearish' | 'neutral' =\n    avgSentiment > 0.2 ? 'bullish' : avgSentiment < -0.2 ? 'bearish' : 'neutral';\n  \n  // Calculate divergence strength\n  const divergenceStrength = Math.abs(priceChange - avgSentiment);\n  \n  // Bullish divergence: Price down but sentiment improving\n  if (priceTrend === 'down' && sentimentTrend === 'bullish') {\n    return {\n      type: 'bullish_divergence',\n      strength: divergenceStrength,\n      confidence: Math.min(1, divergenceStrength * 2),\n      description: 'Price falling while sentiment remains bullish - potential reversal',\n      expectedReversal: true,\n      timeframe: divergenceStrength > 0.3 ? 'immediate' : 'short_term',\n    };\n  }\n  \n  // Bearish divergence: Price up but sentiment deteriorating\n  if (priceTrend === 'up' && sentimentTrend === 'bearish') {\n    return {\n      type: 'bearish_divergence',\n      strength: divergenceStrength,\n      confidence: Math.min(1, divergenceStrength * 2),\n      description: 'Price rising while sentiment turns bearish - potential reversal',\n      expectedReversal: true,\n      timeframe: divergenceStrength > 0.3 ? 'immediate' : 'short_term',\n    };\n  }\n  \n  // Confirmation: Price and sentiment aligned\n  if ((priceTrend === 'up' && sentimentTrend === 'bullish') ||\n      (priceTrend === 'down' && sentimentTrend === 'bearish')) {\n    return {\n      type: 'confirmation',\n      strength: Math.abs(avgSentiment),\n      confidence: 0.7,\n      description: 'Price and sentiment aligned - trend continuation likely',\n      expectedReversal: false,\n      timeframe: 'medium_term',\n    };\n  }\n  \n  return {\n    type: 'none',\n    strength: 0,\n    confidence: 0.5,\n    description: 'No clear divergence or confirmation',\n    expectedReversal: false,\n    timeframe: 'short_term',\n  };\n}\n\n/**\n * Extreme sentiment detection (contrarian signals)\n */\nexport function detectExtremeSentiment(\n  sentimentData: SentimentData[],\n  extremeThreshold: number = 0.7\n): {\n  isExtreme: boolean;\n  direction: 'extremely_bullish' | 'extremely_bearish' | 'normal';\n  contrarianSignal: 'buy' | 'sell' | 'none';\n  confidence: number;\n} {\n  const { composite, confidence } = aggregateSentiment(sentimentData);\n  \n  if (Math.abs(composite) < extremeThreshold) {\n    return {\n      isExtreme: false,\n      direction: 'normal',\n      contrarianSignal: 'none',\n      confidence: 0,\n    };\n  }\n  \n  const isExtremeBullish = composite >= extremeThreshold;\n  const isExtremeBearish = composite <= -extremeThreshold;\n  \n  return {\n    isExtreme: true,\n    direction: isExtremeBullish ? 'extremely_bullish' : 'extremely_bearish',\n    // Contrarian: extreme bullish = sell, extreme bearish = buy\n    contrarianSignal: isExtremeBullish ? 'sell' : 'buy',\n    confidence: confidence * (Math.abs(composite) - extremeThreshold) / (1 - extremeThreshold),\n  };\n}\n\n/**\n * Integrate divergence into prediction\n */\nexport function integrateDivergencePrediction(\n  basePrediction: { direction: 'up' | 'down' | 'neutral'; confidence: number },\n  divergence: DivergenceSignal\n): { direction: 'up' | 'down' | 'neutral'; confidence: number; divergenceAdjustment: string } {\n  let { direction, confidence } = basePrediction;\n  let divergenceAdjustment = 'none';\n  \n  if (divergence.type === 'none') {\n    return { direction, confidence, divergenceAdjustment };\n  }\n  \n  if (divergence.type === 'confirmation') {\n    // Confirmation boosts confidence\n    confidence = Math.min(1, confidence * (1 + divergence.strength * 0.3));\n    divergenceAdjustment = 'confirmation_boost';\n  } else if (divergence.expectedReversal) {\n    // Divergence suggests reversal\n    if (divergence.type === 'bullish_divergence' && direction === 'down') {\n      if (divergence.strength > 0.5) {\n        direction = 'up';\n        confidence = divergence.confidence * 0.7;\n        divergenceAdjustment = 'reversal_to_bullish';\n      } else {\n        confidence *= (1 - divergence.strength);\n        divergenceAdjustment = 'reduced_bearish_confidence';\n      }\n    } else if (divergence.type === 'bearish_divergence' && direction === 'up') {\n      if (divergence.strength > 0.5) {\n        direction = 'down';\n        confidence = divergence.confidence * 0.7;\n        divergenceAdjustment = 'reversal_to_bearish';\n      } else {\n        confidence *= (1 - divergence.strength);\n        divergenceAdjustment = 'reduced_bullish_confidence';\n      }\n    }\n  }\n  \n  return { direction, confidence, divergenceAdjustment };\n}\n";export{e as default};
