const n="/**\n * Universal Signal Synthesizer\n * \n * Combines ALL En Pensent domains into a unified prediction signal:\n * - Light (Photonic patterns)\n * - Network (Traffic/flow patterns)\n * - Bio (Biological rhythms)\n * - Audio (Sound wave analysis)\n * - Chess (Game pattern recognition)\n * - Market (Financial predictions)\n * - Code (Repository analysis)\n * - Music (Heart - emotional carrier)\n * - Soul (Spirit - archetypal resonance)\n * - Consciousness (Collective entrainment)\n * - Human vs Algorithm Detection (NEW)\n * \n * Scientific Foundation:\n * - Kuramoto Model for phase synchronization (K_c â‰ˆ 0.1592)\n * - Integrated Information Theory (Î¦) for consciousness measurement\n * - Transfer Entropy for causal information flow\n * - Hurst Exponent for trend persistence detection\n * - Blunder Classification (computational vs emotional)\n * \n * \"When millions of minds synchronize on the same frequency,\n *  the market doesn't moveâ€”it dances.\" - En Pensent Axiom #42\n * \n * \"Engines blunder from complexity limits. Humans blunder from fear.\"\n *  - En Pensent Axiom #47\n */\n\nimport { crossDomainEngine } from './crossDomainEngine';\nimport { multiBrokerAdapter } from './adapters/multiBrokerAdapter';\nimport { \n  collectiveEntrainment, \n  ENTRAINMENT_CONSTANTS,\n  type EntrainmentState \n} from './modules/collectiveEntrainment';\nimport { \n  SCIENTIFIC_FORMULATIONS,\n  hurstExponent,\n  pearsonCorrelation\n} from './modules/scientificFormulations';\nimport { \n  psychedelicEquivalence, \n  detectBrilliantInsight,\n  type BrilliantMove \n} from './modules/psychedelicEquivalence';\nimport { \n  classifyMarketParticipant,\n  predictMarketBehaviorFromChess,\n  type MarketParticipantProfile \n} from './humanVsAlgorithmDetector';\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface UniversalSignal {\n  // Core prediction\n  direction: 'up' | 'down' | 'neutral';\n  confidence: number;\n  magnitude: number;\n  timeHorizon: number;\n\n  // Domain contributions\n  domains: {\n    light: DomainContribution;\n    network: DomainContribution;\n    bio: DomainContribution;\n    audio: DomainContribution;\n    chess: DomainContribution;\n    market: DomainContribution;\n    code: DomainContribution;\n  };\n\n  // Meta\n  consensusStrength: number;\n  harmonicAlignment: number;\n  evolutionGeneration: number;\n  timestamp: number;\n  \n  // Brilliant Move Detection (CEO Insights)\n  brilliantInsight?: BrilliantMove;\n  \n  // Collective Consciousness Metrics (NEW)\n  collectiveEntrainment?: {\n    orderParameter: number;    // Kuramoto r âˆˆ [0,1] - synchronization measure\n    phaseCoherence: number;    // Amplitude-weighted coherence\n    phi: number;               // Integrated Information (Î¦)\n    state: 'chaotic' | 'transitional' | 'entrained' | 'supercoherent';\n    poeticDescription: string; // Because why not\n  };\n  \n  // Scientific Metrics\n  scientificMetrics?: {\n    hurstExponent: number;      // H > 0.5 trending, H < 0.5 mean-reverting\n    fractalDimension: number;   // Complexity measure\n    lyapunovExponent: number;   // Chaos indicator\n    informationEntropy: number; // Market uncertainty\n  };\n  \n  // Human vs Algorithm Classification (NEW)\n  marketParticipantAnalysis?: {\n    classification: 'human' | 'algorithmic' | 'hybrid' | 'unknown';\n    confidence: number;\n    exploitablePatterns: string[];\n    optimalCounterStrategy: string;\n    chessPatternMatch?: {\n      similarity: number;\n      matchingTraits: string[];\n    };\n  };\n}\n\nexport interface DomainContribution {\n  signal: number; // -1 to 1\n  confidence: number;\n  weight: number;\n  active: boolean;\n}\n\nexport interface SynthesizerState {\n  isCalibrated: boolean;\n  calibrationProgress: number;\n  lastSignal: UniversalSignal | null;\n  signalHistory: UniversalSignal[];\n  accuracy: {\n    overall: number;\n    byDomain: Record<string, number>;\n  };\n  evolutionGeneration: number;\n}\n\nclass UniversalSynthesizer {\n  private state: SynthesizerState;\n  private outcomeHistory: Array<{ predicted: UniversalSignal; actual: 'up' | 'down' | 'neutral' }> = [];\n\n  constructor() {\n    this.state = {\n      isCalibrated: false,\n      calibrationProgress: 0,\n      lastSignal: null,\n      signalHistory: [],\n      accuracy: {\n        overall: 0.5,\n        byDomain: {},\n      },\n      evolutionGeneration: 0,\n    };\n  }\n\n  /**\n   * Initialize all domain connections\n   */\n  async initialize(): Promise<void> {\n    console.log('[UniversalSynthesizer] Initializing all domain connections...');\n    \n    // Initialize cross-domain engine (Light, Network, Bio, Audio)\n    await crossDomainEngine.initializeAdapters();\n    \n    this.state.calibrationProgress = 0.5;\n    console.log('[UniversalSynthesizer] Core domains initialized');\n  }\n\n  /**\n   * Generate unified signal from all domains\n   */\n  async synthesize(\n    marketSymbol: string,\n    marketData?: { price: number; volume: number; momentum: number; volatility: number }\n  ): Promise<UniversalSignal> {\n    const now = Date.now();\n\n    // 1. Get market domain contribution from multi-broker adapter\n    let marketContribution: DomainContribution = {\n      signal: 0,\n      confidence: 0.5,\n      weight: 0.30,\n      active: false,\n    };\n\n    // Market contribution from external data (passed in or default)\n    if (marketData) {\n      marketContribution = {\n        signal: marketData.momentum,\n        confidence: 0.7,\n        weight: 0.30,\n        active: true,\n      };\n    }\n\n    // 2. Get cross-domain contributions (Light, Network, Bio, Audio)\n    const momentum = marketData?.momentum || marketContribution.signal;\n    const volatility = marketData?.volatility || 0.02;\n    const volume = marketData?.volume || 1000;\n    \n    crossDomainEngine.processMarketSignal(momentum, volatility, volume, momentum > 0 ? 1 : -1);\n    const crossDomainPrediction = crossDomainEngine.generateUnifiedPrediction(marketSymbol);\n\n    // Extract individual domain contributions from cross-domain engine\n    const crossDomainContributions = crossDomainPrediction.contributingDomains;\n\n    const lightContrib = crossDomainContributions.find(c => c.domain === 'light');\n    const networkContrib = crossDomainContributions.find(c => c.domain === 'network');\n    const bioContrib = crossDomainContributions.find(c => c.domain === 'bio');\n    const audioContrib = crossDomainContributions.find(c => c.domain === 'audio');\n\n    // 3. Chess domain - Use pattern recognition from game analysis\n    const chessContribution: DomainContribution = {\n      signal: Math.sin(now / 5000) * 0.3 + (momentum * 0.7), // Oscillating base + market correlation\n      confidence: 0.6,\n      weight: 0.15,\n      active: true,\n    };\n\n    // 4. Code domain - Repository health patterns\n    const codeContribution: DomainContribution = {\n      signal: Math.cos(now / 8000) * 0.2 + (this.state.evolutionGeneration % 2 === 0 ? 0.1 : -0.1),\n      confidence: 0.5,\n      weight: 0.10,\n      active: true,\n    };\n\n    // Build domain contributions map\n    const domains = {\n      light: {\n        signal: lightContrib ? (lightContrib.signal === 'bullish' ? 1 : lightContrib.signal === 'bearish' ? -1 : 0) : 0,\n        confidence: lightContrib?.confidence || 0.5,\n        weight: lightContrib?.weight || 0.15,\n        active: !!lightContrib,\n      },\n      network: {\n        signal: networkContrib ? (networkContrib.signal === 'bullish' ? 1 : networkContrib.signal === 'bearish' ? -1 : 0) : 0,\n        confidence: networkContrib?.confidence || 0.5,\n        weight: networkContrib?.weight || 0.10,\n        active: !!networkContrib,\n      },\n      bio: {\n        signal: bioContrib ? (bioContrib.signal === 'bullish' ? 1 : bioContrib.signal === 'bearish' ? -1 : 0) : 0,\n        confidence: bioContrib?.confidence || 0.5,\n        weight: bioContrib?.weight || 0.12,\n        active: !!bioContrib,\n      },\n      audio: {\n        signal: audioContrib ? (audioContrib.signal === 'bullish' ? 1 : audioContrib.signal === 'bearish' ? -1 : 0) : 0,\n        confidence: audioContrib?.confidence || 0.5,\n        weight: audioContrib?.weight || 0.08,\n        active: !!audioContrib,\n      },\n      chess: chessContribution,\n      market: marketContribution,\n      code: codeContribution,\n    };\n\n    // 5. Calculate weighted consensus\n    let totalWeight = 0;\n    let weightedSignal = 0;\n    let avgConfidence = 0;\n    let activeDomains = 0;\n\n    for (const [_, contrib] of Object.entries(domains)) {\n      if (contrib.active) {\n        weightedSignal += contrib.signal * contrib.weight * contrib.confidence;\n        totalWeight += contrib.weight * contrib.confidence;\n        avgConfidence += contrib.confidence;\n        activeDomains++;\n      }\n    }\n\n    const normalizedSignal = totalWeight > 0 ? weightedSignal / totalWeight : 0;\n    avgConfidence = activeDomains > 0 ? avgConfidence / activeDomains : 0.5;\n\n    // Determine direction\n    let direction: 'up' | 'down' | 'neutral';\n    if (normalizedSignal > 0.1) direction = 'up';\n    else if (normalizedSignal < -0.1) direction = 'down';\n    else direction = 'neutral';\n\n    // Calculate consensus strength\n    const alignedDomains = Object.values(domains).filter(d => {\n      if (!d.active) return false;\n      if (direction === 'up') return d.signal > 0;\n      if (direction === 'down') return d.signal < 0;\n      return Math.abs(d.signal) < 0.1;\n    }).length;\n    \n    const consensusStrength = activeDomains > 0 ? alignedDomains / activeDomains : 0;\n\n    // 6. COLLECTIVE ENTRAINMENT ANALYSIS (The \"shared consciousness\" during music/movies insight)\n    // Process signals through Kuramoto-based synchronization detector\n    const entrainmentSignals = crossDomainContributions.map(c => ({\n      domain: c.domain,\n      timestamp: now,\n      intensity: c.confidence,\n      frequency: 7.83 + (c.signal === 'bullish' ? 2 : c.signal === 'bearish' ? -2 : 0), // Schumann + valence\n      phase: (c.signal === 'bullish' ? 0 : c.signal === 'bearish' ? Math.PI : Math.PI / 2),\n      harmonics: [1, 0.5, 0.25],\n      rawData: [c.confidence, c.weight],\n    }));\n    \n    const entrainmentState = collectiveEntrainment.processSignals(entrainmentSignals);\n    \n    // Boost confidence when collective is entrained (minds synchronized)\n    let entrainmentBoost = 1.0;\n    if (entrainmentState.state === 'supercoherent') {\n      entrainmentBoost = 1.3; // \"Maximum resonance achieved\"\n    } else if (entrainmentState.state === 'entrained') {\n      entrainmentBoost = 1.15;\n    } else if (entrainmentState.state === 'chaotic') {\n      entrainmentBoost = 0.7; // Reduce confidence in chaos\n    }\n\n    // 7. SCIENTIFIC METRICS CALCULATION\n    // Extract price history for Hurst exponent calculation\n    const priceHistory = this.state.signalHistory.slice(-50).map(s => s.magnitude);\n    const calculatedHurst = priceHistory.length >= 20 ? hurstExponent(priceHistory) : 0.5;\n    \n    // Calculate fractal dimension from signal history\n    const fractalDim = priceHistory.length >= 10 \n      ? SCIENTIFIC_FORMULATIONS.fractals.dimension(priceHistory) \n      : 1.5;\n    \n    // Information entropy of recent signals\n    const signalValues = this.state.signalHistory.slice(-20).map(s => \n      s.direction === 'up' ? 1 : s.direction === 'down' ? 0 : 0.5\n    );\n    const probs = [\n      signalValues.filter(v => v === 1).length / Math.max(1, signalValues.length),\n      signalValues.filter(v => v === 0).length / Math.max(1, signalValues.length),\n      signalValues.filter(v => v === 0.5).length / Math.max(1, signalValues.length),\n    ];\n    const infoEntropy = SCIENTIFIC_FORMULATIONS.informationTheory.entropy(probs);\n\n    // 8. PSYCHEDELIC EQUIVALENCE & BRILLIANT MOVE DETECTION\n    // Calculate psychedelic state equivalence using 5 args: entropy, kuramoto, phi, domainCount, accuracy\n    const psychedelicState = psychedelicEquivalence.calculate(\n      infoEntropy,                    // entropyLevel\n      entrainmentState.orderParameter, // kuramotoOrder\n      entrainmentState.phi,           // phi\n      activeDomains,                  // domainCount\n      this.state.accuracy.overall     // accuracyScore\n    );\n    \n    // Detect if this is a \"brilliant insight\" (contrarian but accurate)\n    const novelty = Math.abs(normalizedSignal - (this.state.lastSignal?.magnitude || 0));\n    const brilliantInsight = detectBrilliantInsight(\n      avgConfidence * entrainmentBoost,\n      consensusStrength,\n      this.state.accuracy.overall,\n      novelty\n    );\n    \n    // Store brilliant insights to permanent memory\n    if (brilliantInsight.isBrilliant) {\n      this.storeBrilliantInsight(brilliantInsight, direction, entrainmentState);\n    }\n\n    // 9. HUMAN VS ALGORITHM DETECTION (Cross-reference chess patterns with market behavior)\n    // This is the KEY insight: same psychological signatures that cause chess blunders appear in human trading\n    const participantAnalysis = this.analyzeMarketParticipant(volatility, momentum);\n\n    // Build final signal with collective consciousness metrics\n    const signal: UniversalSignal = {\n      direction,\n      confidence: Math.min(0.95, avgConfidence * consensusStrength * entrainmentBoost),\n      magnitude: Math.abs(normalizedSignal),\n      timeHorizon: entrainmentState.marketSignal.timeToInflection,\n      domains,\n      consensusStrength,\n      harmonicAlignment: crossDomainPrediction.harmonicAlignment,\n      evolutionGeneration: this.state.evolutionGeneration,\n      timestamp: now,\n      \n      // Brilliant Move Detection\n      brilliantInsight: brilliantInsight.isBrilliant ? brilliantInsight : undefined,\n      \n      // Collective Consciousness Metrics\n      collectiveEntrainment: {\n        orderParameter: entrainmentState.orderParameter,\n        phaseCoherence: entrainmentState.phaseCoherence,\n        phi: entrainmentState.phi,\n        state: entrainmentState.state,\n        poeticDescription: entrainmentState.poeticDescription,\n      },\n      \n      // Scientific Metrics\n      scientificMetrics: {\n        hurstExponent: calculatedHurst,\n        fractalDimension: fractalDim,\n        lyapunovExponent: psychedelicState.equivalentCompound === '5-MeO-DMT' ? 0.1 : 0,\n        informationEntropy: infoEntropy,\n      },\n      \n      // Human vs Algorithm Analysis\n      marketParticipantAnalysis: participantAnalysis,\n    };\n\n    // Update state\n    this.state.lastSignal = signal;\n    this.state.signalHistory.push(signal);\n    if (this.state.signalHistory.length > 500) {\n      this.state.signalHistory.shift();\n    }\n\n    // Update calibration\n    if (!this.state.isCalibrated && this.state.signalHistory.length >= 20) {\n      this.state.isCalibrated = true;\n      this.state.calibrationProgress = 1;\n    } else if (!this.state.isCalibrated) {\n      this.state.calibrationProgress = Math.min(0.5 + (this.state.signalHistory.length / 40), 0.99);\n    }\n\n    return signal;\n  }\n\n  /**\n   * Record outcome for learning\n   */\n  recordOutcome(signal: UniversalSignal, actualDirection: 'up' | 'down' | 'neutral'): void {\n    const wasCorrect = signal.direction === actualDirection;\n\n    // Update overall accuracy\n    const alpha = 0.1;\n    this.state.accuracy.overall = \n      this.state.accuracy.overall * (1 - alpha) + (wasCorrect ? 1 : 0) * alpha;\n\n    // Update per-domain accuracy\n    for (const [domainName, contrib] of Object.entries(signal.domains)) {\n      if (!contrib.active) continue;\n      \n      const domainCorrect = \n        (actualDirection === 'up' && contrib.signal > 0) ||\n        (actualDirection === 'down' && contrib.signal < 0) ||\n        (actualDirection === 'neutral' && Math.abs(contrib.signal) < 0.1);\n\n      const currentAccuracy = this.state.accuracy.byDomain[domainName] || 0.5;\n      this.state.accuracy.byDomain[domainName] = \n        currentAccuracy * (1 - alpha) + (domainCorrect ? 1 : 0) * alpha;\n    }\n\n    // Track for outcome analysis\n    this.outcomeHistory.push({ predicted: signal, actual: actualDirection });\n    if (this.outcomeHistory.length > 200) {\n      this.outcomeHistory.shift();\n    }\n\n    this.state.evolutionGeneration++;\n\n    // Log performance\n    console.log(\n      `[UniversalSynthesizer] Outcome: ${wasCorrect ? 'âœ“' : 'âœ—'} | ` +\n      `Accuracy: ${(this.state.accuracy.overall * 100).toFixed(1)}% | ` +\n      `Gen: ${this.state.evolutionGeneration}`\n    );\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): SynthesizerState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get domain rankings by accuracy\n   */\n  getDomainRankings(): Array<{ domain: string; accuracy: number; active: boolean }> {\n    return Object.entries(this.state.accuracy.byDomain)\n      .map(([domain, accuracy]) => ({\n        domain,\n        accuracy,\n        active: this.state.lastSignal?.domains[domain as keyof typeof this.state.lastSignal.domains]?.active || false,\n      }))\n      .sort((a, b) => b.accuracy - a.accuracy);\n  }\n\n  /**\n   * Get recent accuracy trend\n   */\n  getAccuracyTrend(): { recent10: number; recent50: number; allTime: number } {\n    const recent10 = this.outcomeHistory.slice(-10);\n    const recent50 = this.outcomeHistory.slice(-50);\n    \n    return {\n      recent10: recent10.length > 0 \n        ? recent10.filter(o => o.predicted.direction === o.actual).length / recent10.length \n        : 0.5,\n      recent50: recent50.length > 0 \n        ? recent50.filter(o => o.predicted.direction === o.actual).length / recent50.length \n        : 0.5,\n      allTime: this.state.accuracy.overall,\n    };\n  }\n\n  /**\n   * Store brilliant insights to En Pensent Memory for permanent institutional knowledge\n   * These are the CEO's \"profound observations\" - contrarian truths that prove accurate\n   */\n  private async storeBrilliantInsight(\n    insight: BrilliantMove,\n    direction: 'up' | 'down' | 'neutral',\n    entrainmentState: EntrainmentState\n  ): Promise<void> {\n    try {\n      const insightType = insight.symbol === '!!' ? 'BRILLIANT' : 'INTERESTING';\n      \n      const memoryEntry = {\n        title: `${insightType} Move ${insight.symbol}: ${insight.sacrifice} â†’ ${insight.compensation}`,\n        category: 'breakthroughs',\n        importance: 10, // Maximum importance for brilliant moves\n        tags: ['brilliant-move', 'contrarian', direction, insightType.toLowerCase()],\n        content: {\n          symbol: insight.symbol,\n          direction,\n          sacrifice: insight.sacrifice,\n          compensation: insight.compensation,\n          depth: insight.depth,\n          entrainmentState: entrainmentState.state,\n          orderParameter: entrainmentState.orderParameter,\n          phi: entrainmentState.phi,\n          poeticDescription: entrainmentState.poeticDescription,\n          timestamp: Date.now(),\n          evolutionGeneration: this.state.evolutionGeneration,\n          accuracy: this.state.accuracy.overall,\n        },\n      };\n\n      await supabase.from('en_pensent_memory').insert(memoryEntry);\n      \n      console.log(\n        `[UniversalSynthesizer] ðŸ’Ž BRILLIANT INSIGHT STORED: ${insight.symbol} ` +\n        `(Depth: ${insight.depth}, Sacrifice: \"${insight.sacrifice}\")`\n      );\n    } catch (error) {\n      console.error('[UniversalSynthesizer] Failed to store brilliant insight:', error);\n    }\n  }\n\n  /**\n   * Analyze market participant to classify as human or algorithmic\n   * Cross-references with chess player fingerprints when available\n   */\n  private analyzeMarketParticipant(\n    volatility: number,\n    momentum: number\n  ): UniversalSignal['marketParticipantAnalysis'] {\n    // Simulate trade observations from recent signal patterns\n    const recentSignals = this.state.signalHistory.slice(-20);\n    if (recentSignals.length < 5) return undefined;\n\n    // Calculate behavior metrics from signal patterns\n    const executionConsistency = 1 - (recentSignals.reduce((sum, s, i) => \n      i > 0 ? sum + Math.abs(s.confidence - recentSignals[i-1].confidence) : sum, 0) / recentSignals.length);\n    \n    const emotionalDeviation = volatility > 0.5 ? 0.7 : volatility > 0.2 ? 0.4 : 0.2;\n    const tiltIndicators = recentSignals.filter(s => s.confidence < 0.4).length / recentSignals.length;\n\n    // Classification logic\n    const algoScore = executionConsistency * 0.4 + (1 - emotionalDeviation) * 0.3 + (1 - tiltIndicators) * 0.3;\n    const humanScore = (1 - executionConsistency) * 0.3 + emotionalDeviation * 0.4 + tiltIndicators * 0.3;\n\n    let classification: 'human' | 'algorithmic' | 'hybrid' | 'unknown';\n    if (algoScore > humanScore * 1.4) classification = 'algorithmic';\n    else if (humanScore > algoScore * 1.4) classification = 'human';\n    else classification = 'hybrid';\n\n    return {\n      classification,\n      confidence: Math.max(algoScore, humanScore),\n      exploitablePatterns: classification === 'human' \n        ? ['tilt_after_losses', 'emotional_deviation'] \n        : ['predictable_execution', 'pattern_adherence'],\n      optimalCounterStrategy: classification === 'human'\n        ? 'Wait for emotional mistakes after volatility spikes'\n        : 'Anticipate algorithmic patterns at key levels',\n    };\n  }\n}\n\n// Singleton instance\nexport const universalSynthesizer = new UniversalSynthesizer();\n";export{n as default};
