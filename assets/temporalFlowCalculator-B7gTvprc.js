const n="/**\n * En Pensent Core SDK - Temporal Flow Calculator\n * \n * Analyzes activity sequences to determine temporal patterns\n */\n\nimport { TemporalFlow } from '../types';\n\nexport interface PhaseConfig {\n  opening: number;\n  middle: number;\n}\n\nconst DEFAULT_PHASES: PhaseConfig = { opening: 0.25, middle: 0.5 };\n\n/**\n * Calculate temporal flow from sequence of activity levels\n */\nexport function calculateTemporalFlow(\n  activityLevels: number[],\n  phases: PhaseConfig = DEFAULT_PHASES\n): TemporalFlow {\n  if (activityLevels.length === 0) {\n    return {\n      opening: 0,\n      middle: 0,\n      ending: 0,\n      trend: 'stable',\n      momentum: 0\n    };\n  }\n  \n  const { openingAvg, middleAvg, endingAvg } = calculatePhaseAverages(activityLevels, phases);\n  const trend = determineTrend(activityLevels, openingAvg, endingAvg);\n  const momentum = calculateMomentum(activityLevels);\n  \n  return {\n    opening: openingAvg,\n    middle: middleAvg,\n    ending: endingAvg,\n    trend,\n    momentum\n  };\n}\n\n/**\n * Calculate averages for each phase of the activity sequence\n */\nfunction calculatePhaseAverages(\n  activityLevels: number[],\n  phases: PhaseConfig\n): { openingAvg: number; middleAvg: number; endingAvg: number } {\n  const total = activityLevels.length;\n  const openingEnd = Math.floor(total * phases.opening);\n  const middleEnd = Math.floor(total * (phases.opening + phases.middle));\n  \n  const openingActivity = activityLevels.slice(0, openingEnd);\n  const middleActivity = activityLevels.slice(openingEnd, middleEnd);\n  const endingActivity = activityLevels.slice(middleEnd);\n  \n  return {\n    openingAvg: avg(openingActivity),\n    middleAvg: avg(middleActivity),\n    endingAvg: avg(endingActivity)\n  };\n}\n\n/**\n * Determine the trend based on activity changes\n */\nfunction determineTrend(\n  activityLevels: number[],\n  openingAvg: number,\n  endingAvg: number\n): TemporalFlow['trend'] {\n  // Check for volatility first (high variation between consecutive values)\n  if (activityLevels.length > 1) {\n    const avgChange = activityLevels.slice(1).reduce((sum, val, i) =>\n      sum + Math.abs(val - activityLevels[i]), 0) / (activityLevels.length - 1);\n    if (avgChange > 0.3) {\n      return 'volatile';\n    }\n  }\n\n  const variance = Math.abs(endingAvg - openingAvg);\n\n  if (variance < 0.1) {\n    return 'stable';\n  }\n\n  if (endingAvg > openingAvg * 1.2) {\n    return 'accelerating';\n  }\n\n  if (endingAvg < openingAvg * 0.8) {\n    return 'declining';\n  }\n\n  return 'stable';\n}\n\n/**\n * Calculate momentum (-1 to 1) based on recent vs earlier activity\n */\nfunction calculateMomentum(activityLevels: number[]): number {\n  const total = activityLevels.length;\n  const recentWindow = Math.max(1, Math.floor(total * 0.2));\n  \n  const recentActivity = activityLevels.slice(-recentWindow);\n  const earlierActivity = activityLevels.slice(-recentWindow * 2, -recentWindow);\n  \n  const recentAvg = avg(recentActivity);\n  const earlierAvg = avg(earlierActivity);\n  \n  return earlierAvg > 0 \n    ? Math.max(-1, Math.min(1, (recentAvg - earlierAvg) / earlierAvg)) \n    : 0;\n}\n\n/**\n * Calculate average of an array\n */\nfunction avg(arr: number[]): number {\n  return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;\n}\n";export{n as default};
