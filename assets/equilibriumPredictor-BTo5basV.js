const n="/**\n * Equilibrium Predictor v8.06-EQUILIBRIUM\n * \n * v8.06 LEARNING FROM v8.05:\n * - v8.05 over-corrected: 69% black predictions but only 47.8% accurate\n * - Swinging between white-bias and black-bias doesn't work\n * \n * SOLUTION: True equilibrium with balanced weights\n * - Reduce archetype-specific boosts to prevent overcorrection\n * - Use Stockfish as symmetric tiebreaker (same thresholds for both colors)\n * - Target ~50% white / ~35% black / ~15% draw distribution\n * \n * TARGET: 55-60% accuracy with balanced prediction distribution\n */\n\nimport { ColorFlowSignature, QuadrantProfile, TemporalFlow } from './types';\nimport { ARCHETYPE_DEFINITIONS } from './archetypeDefinitions';\n\nexport interface EquilibriumScores {\n  /** Confidence that white will win (0-100) */\n  whiteConfidence: number;\n  /** Confidence that black will win (0-100) */\n  blackConfidence: number;\n  /** Confidence the game will draw (0-100) */\n  drawConfidence: number;\n  /** The predicted outcome based on highest confidence */\n  prediction: 'white_wins' | 'black_wins' | 'draw';\n  /** Final confidence of the prediction */\n  finalConfidence: number;\n  /** Reasoning for the prediction */\n  reasoning: string;\n  /** Whether the prediction meets the clarity threshold */\n  highClarity: boolean;\n}\n\n/**\n * Calculate equilibrium scores for all three outcomes\n * \n * This is the core of the balanced prediction system.\n * We calculate independent confidence for each outcome rather than\n * binary classification that can flip-flop.\n */\nexport function calculateEquilibriumScores(\n  signature: ColorFlowSignature,\n  stockfishEval: number,\n  stockfishDepth: number,\n  currentMoveNumber: number\n): EquilibriumScores {\n  const archetype = ARCHETYPE_DEFINITIONS[signature.archetype];\n  const quadrant = signature.quadrantProfile;\n  const temporal = signature.temporalFlow;\n  \n  // ===== COMPONENT 1: Board Control Signals =====\n  const controlSignal = calculateControlSignal(signature);\n  \n  // ===== COMPONENT 2: Temporal Momentum =====\n  const momentumSignal = calculateMomentumSignal(temporal);\n  \n  // ===== COMPONENT 3: Archetype Historical Rates =====\n  // v7.91: Pass dominantSide so archetype signal knows WHO is attacking\n  const archetypeSignal = calculateArchetypeSignal(signature.archetype, archetype, signature.dominantSide);\n  \n  // ===== COMPONENT 4: Stockfish Evaluation =====\n  const sfSignal = calculateStockfishSignal(stockfishEval);\n  \n  // ===== COMPONENT 5: Game Phase Context =====\n  const phaseSignal = calculatePhaseSignal(currentMoveNumber, signature.intensity);\n  \n  // ===== FUSION: Weighted combination of all signals =====\n  // Weights determine how much each component contributes\n  const weights = {\n    control: 0.25,    // Board control is fundamental\n    momentum: 0.20,   // Trajectory matters\n    archetype: 0.15,  // Historical patterns\n    stockfish: 0.30,  // Tactical assessment\n    phase: 0.10,      // Context adjustment\n  };\n  \n  // Calculate raw scores for each outcome\n  const whiteRaw = \n    controlSignal.white * weights.control +\n    momentumSignal.white * weights.momentum +\n    archetypeSignal.white * weights.archetype +\n    sfSignal.white * weights.stockfish +\n    phaseSignal.white * weights.phase;\n    \n  const blackRaw = \n    controlSignal.black * weights.control +\n    momentumSignal.black * weights.momentum +\n    archetypeSignal.black * weights.archetype +\n    sfSignal.black * weights.stockfish +\n    phaseSignal.black * weights.phase;\n    \n  const drawRaw = \n    controlSignal.draw * weights.control +\n    momentumSignal.draw * weights.momentum +\n    archetypeSignal.draw * weights.archetype +\n    sfSignal.draw * weights.stockfish +\n    phaseSignal.draw * weights.phase;\n  \n  // Normalize to sum to 100\n  const total = whiteRaw + blackRaw + drawRaw;\n  const whiteConfidence = Math.round((whiteRaw / total) * 100);\n  const blackConfidence = Math.round((blackRaw / total) * 100);\n  const drawConfidence = Math.round((drawRaw / total) * 100);\n  \n  // Determine prediction from highest confidence\n  let prediction: 'white_wins' | 'black_wins' | 'draw';\n  let finalConfidence: number;\n  let reasoning: string;\n  \n  // v8.06-EQUILIBRIUM: Symmetric decision making with SF as balanced tiebreaker\n  \n  // CASE 1: Clear leader with significant margin (require 10% gap)\n  if (whiteConfidence > blackConfidence + 10 && whiteConfidence > drawConfidence + 8) {\n    prediction = 'white_wins';\n    finalConfidence = whiteConfidence;\n    reasoning = `White leads clearly (${whiteConfidence}% vs B:${blackConfidence}% D:${drawConfidence}%)`;\n  } else if (blackConfidence > whiteConfidence + 10 && blackConfidence > drawConfidence + 8) {\n    prediction = 'black_wins';\n    finalConfidence = blackConfidence;\n    reasoning = `Black leads clearly (${blackConfidence}% vs W:${whiteConfidence}% D:${drawConfidence}%)`;\n  } else if (drawConfidence > whiteConfidence + 12 && drawConfidence > blackConfidence + 12) {\n    prediction = 'draw';\n    finalConfidence = drawConfidence;\n    reasoning = `Draw leads (${drawConfidence}% vs W:${whiteConfidence}% B:${blackConfidence}%)`;\n  } \n  // CASE 2: v8.06 - Stockfish as SYMMETRIC tiebreaker (equal thresholds)\n  else if (stockfishEval > 100) {\n    prediction = 'white_wins';\n    finalConfidence = Math.max(whiteConfidence + 8, 55);\n    reasoning = `SF strong white (+${stockfishEval}cp)`;\n  } else if (stockfishEval < -100) {\n    prediction = 'black_wins';\n    finalConfidence = Math.max(blackConfidence + 8, 55);\n    reasoning = `SF strong black (${stockfishEval}cp)`;\n  } else if (stockfishEval > 50) {\n    prediction = 'white_wins';\n    finalConfidence = Math.max(whiteConfidence, 48);\n    reasoning = `SF white advantage (+${stockfishEval}cp)`;\n  } else if (stockfishEval < -50) {\n    prediction = 'black_wins';\n    finalConfidence = Math.max(blackConfidence, 48);\n    reasoning = `SF black advantage (${stockfishEval}cp)`;\n  }\n  // CASE 3: Near-equal SF eval - use our confidence scores\n  else if (whiteConfidence > blackConfidence && whiteConfidence > drawConfidence) {\n    prediction = 'white_wins';\n    finalConfidence = whiteConfidence;\n    reasoning = `White edge (SF: ${stockfishEval}cp)`;\n  } else if (blackConfidence > whiteConfidence && blackConfidence > drawConfidence) {\n    prediction = 'black_wins';\n    finalConfidence = blackConfidence;\n    reasoning = `Black edge (SF: ${stockfishEval}cp)`;\n  } else if (drawConfidence >= whiteConfidence && drawConfidence >= blackConfidence) {\n    prediction = 'draw';\n    finalConfidence = drawConfidence;\n    reasoning = `Draw likely (SF: ${stockfishEval}cp)`;\n  }\n  // CASE 4: Truly tied - slight favor to higher Elo attacker\n  else {\n    if (stockfishEval >= 0) {\n      prediction = 'white_wins';\n      finalConfidence = Math.max(whiteConfidence, 42);\n      reasoning = `Tie broken: SF slightly favors white`;\n    } else {\n      prediction = 'black_wins';\n      finalConfidence = Math.max(blackConfidence, 42);\n      reasoning = `Tie broken: SF slightly favors black`;\n    }\n  }\n  \n  // High clarity = the leading outcome is significantly ahead\n  const secondHighest = prediction === 'white_wins' \n    ? Math.max(blackConfidence, drawConfidence)\n    : prediction === 'black_wins'\n      ? Math.max(whiteConfidence, drawConfidence)\n      : Math.max(whiteConfidence, blackConfidence);\n  \n  const highClarity = finalConfidence - secondHighest >= 15;\n  \n  return {\n    whiteConfidence,\n    blackConfidence,\n    drawConfidence,\n    prediction,\n    finalConfidence,\n    reasoning,\n    highClarity,\n  };\n}\n\n/**\n * Calculate control signal from quadrant profile\n * v7.95-DUAL-LENS: Use dominantSide directly - the extraction already handles bias compensation\n */\nfunction calculateControlSignal(\n  signature: ColorFlowSignature\n): { white: number; black: number; draw: number } {\n  const dominantSide = signature.dominantSide;\n  const q = signature.quadrantProfile;\n  \n  // Calculate intensity for confidence scaling\n  const totalActivity = (\n    Math.abs(q.kingsideWhite) + Math.abs(q.kingsideBlack) +\n    Math.abs(q.queensideWhite) + Math.abs(q.queensideBlack) +\n    Math.abs(q.center)\n  );\n  \n  // Low activity = uncertain\n  if (totalActivity < 50) {\n    return { white: 33, black: 33, draw: 34 };\n  }\n  \n  // Calculate advantage strength based on intensity\n  const intensity = Math.min(1, totalActivity / 300);\n  const baseAdvantage = 15 + intensity * 20; // 15-35 point advantage\n  \n  // v7.95-DUAL-LENS: Trust the dual-lens dominantSide detection completely\n  // It already combines both black-favoring and white-favoring detection methods\n  switch (dominantSide) {\n    case 'white':\n      return { \n        white: 35 + baseAdvantage, \n        black: 30 - baseAdvantage / 2, \n        draw: 35 - baseAdvantage / 2 \n      };\n    case 'black':\n      return { \n        white: 30 - baseAdvantage / 2, \n        black: 35 + baseAdvantage, \n        draw: 35 - baseAdvantage / 2 \n      };\n    case 'contested':\n    default:\n      // v8.04-SYMMETRIC: Contested = truly equal, let SF be the tiebreaker\n      // Previous versions artificially favored one color, causing oscillation\n      return { white: 33, black: 33, draw: 34 };\n  }\n}\n\n/**\n * Calculate momentum signal from temporal flow\n */\nfunction calculateMomentumSignal(\n  temporal: TemporalFlow\n): { white: number; black: number; draw: number } {\n  // Positive = white gaining, negative = black gaining\n  const openingToMiddle = temporal.middlegame - temporal.opening;\n  const middleToEnd = temporal.endgame - temporal.middlegame;\n  \n  // Overall momentum trend\n  const momentum = openingToMiddle * 0.4 + middleToEnd * 0.6;\n  \n  // High volatility suggests unclear result\n  const volatilityPenalty = Math.min(temporal.volatility / 3, 20);\n  \n  if (momentum > 15) {\n    // White gaining momentum\n    const gain = Math.min(momentum, 40);\n    return { \n      white: 40 + gain - volatilityPenalty / 2, \n      black: 25 - gain / 2, \n      draw: 35 - gain / 2 + volatilityPenalty / 2 \n    };\n  } else if (momentum < -15) {\n    // Black gaining momentum\n    const gain = Math.min(-momentum, 40);\n    return { \n      white: 25 - gain / 2, \n      black: 40 + gain - volatilityPenalty / 2, \n      draw: 35 - gain / 2 + volatilityPenalty / 2 \n    };\n  } else {\n    // Balanced - depends on volatility\n    if (temporal.volatility > 50) {\n      // High volatility = decisive result likely\n      return { white: 35, black: 35, draw: 30 };\n    } else {\n      // Low volatility in balanced game = draw likely\n      return { white: 30, black: 30, draw: 40 };\n    }\n  }\n}\n\n/**\n * Calculate archetype signal from historical patterns\n * v8.06-EQUILIBRIUM: Reduced archetype boosts to prevent overcorrection\n * \n * v8.05 showed that aggressive boosts cause oscillation.\n * v8.06 uses moderate, balanced adjustments.\n */\nfunction calculateArchetypeSignal(\n  archetype: string,\n  archetypeDef: typeof ARCHETYPE_DEFINITIONS[keyof typeof ARCHETYPE_DEFINITIONS] | undefined,\n  dominantSide?: 'white' | 'black' | 'contested'\n): { white: number; black: number; draw: number } {\n  if (!archetypeDef) {\n    // No archetype = equal split\n    return { white: 33, black: 33, draw: 34 };\n  }\n  \n  // v8.06: Moderate archetype boosts (reduced from v8.05)\n  const ARCHETYPE_WEIGHTS: Record<string, { whiteBoost: number; blackBoost: number; drawBoost: number }> = {\n    // Defensive archetypes - slight black boost\n    prophylactic_defense: { whiteBoost: -2, blackBoost: 5, drawBoost: 4 },\n    closed_maneuvering: { whiteBoost: -1, blackBoost: 3, drawBoost: 5 },\n    \n    // Tactical archetypes - depends on who is attacking\n    kingside_attack: { whiteBoost: 0, blackBoost: 0, drawBoost: -5 },\n    queenside_expansion: { whiteBoost: 0, blackBoost: 0, drawBoost: -3 },\n    sacrificial_attack: { whiteBoost: 0, blackBoost: 0, drawBoost: -8 },\n    \n    // Balanced archetypes\n    opposite_castling: { whiteBoost: -2, blackBoost: 2, drawBoost: 0 },\n    open_tactical: { whiteBoost: -1, blackBoost: 2, drawBoost: -3 },\n    \n    // Strategic archetypes\n    central_domination: { whiteBoost: 2, blackBoost: 0, drawBoost: -3 },\n    positional_squeeze: { whiteBoost: 2, blackBoost: -1, drawBoost: -2 },\n    piece_harmony: { whiteBoost: 0, blackBoost: 1, drawBoost: 0 },\n    \n    // Endgame/pawn archetypes\n    endgame_technique: { whiteBoost: -1, blackBoost: 2, drawBoost: 6 },\n    pawn_storm: { whiteBoost: 0, blackBoost: 0, drawBoost: -5 },\n  };\n  \n  const weights = ARCHETYPE_WEIGHTS[archetype] || { whiteBoost: 0, blackBoost: 0, drawBoost: 0 };\n  \n  // Base draw probability by archetype style\n  const drawProneArchetypes = ['prophylactic_defense', 'closed_maneuvering', 'endgame_technique'];\n  const decisiveArchetypes = ['kingside_attack', 'sacrificial_attack', 'opposite_castling', 'pawn_storm'];\n  \n  let baseDrawProb: number;\n  \n  if (drawProneArchetypes.includes(archetype)) {\n    baseDrawProb = 35;\n  } else if (decisiveArchetypes.includes(archetype)) {\n    baseDrawProb = 25;\n  } else {\n    baseDrawProb = 30;\n  }\n  \n  const drawProb = Math.max(18, Math.min(45, baseDrawProb + weights.drawBoost));\n  const decisiveProb = 100 - drawProb;\n  \n  // v8.06: Symmetric split based on dominantSide\n  let whiteShare: number;\n  let blackShare: number;\n  \n  if (dominantSide === 'white') {\n    whiteShare = (decisiveProb * 0.55) + weights.whiteBoost;\n    blackShare = (decisiveProb * 0.45) + weights.blackBoost;\n  } else if (dominantSide === 'black') {\n    blackShare = (decisiveProb * 0.55) + weights.blackBoost;\n    whiteShare = (decisiveProb * 0.45) + weights.whiteBoost;\n  } else {\n    // Contested: exactly 50/50\n    whiteShare = (decisiveProb / 2) + weights.whiteBoost;\n    blackShare = (decisiveProb / 2) + weights.blackBoost;\n  }\n  \n  // Normalize\n  const total = whiteShare + blackShare + drawProb;\n  return { \n    white: Math.round((whiteShare / total) * 100), \n    black: Math.round((blackShare / total) * 100), \n    draw: Math.round((drawProb / total) * 100)\n  };\n}\n\n/**\n * Calculate Stockfish signal from centipawn evaluation\n */\nfunction calculateStockfishSignal(\n  eval_cp: number\n): { white: number; black: number; draw: number } {\n  // TCEC-calibrated thresholds\n  if (eval_cp > 200) {\n    // Winning for white\n    const winPct = Math.min(85, 60 + Math.abs(eval_cp - 200) / 10);\n    return { white: winPct, black: 5, draw: 100 - winPct - 5 };\n  } else if (eval_cp < -200) {\n    // Winning for black\n    const winPct = Math.min(85, 60 + Math.abs(eval_cp + 200) / 10);\n    return { white: 5, black: winPct, draw: 100 - winPct - 5 };\n  } else if (eval_cp > 50) {\n    // White advantage\n    const advantage = (eval_cp - 50) / 150 * 25;\n    return { white: 45 + advantage, black: 25 - advantage / 2, draw: 30 };\n  } else if (eval_cp < -50) {\n    // Black advantage\n    const advantage = (-eval_cp - 50) / 150 * 25;\n    return { white: 25 - advantage / 2, black: 45 + advantage, draw: 30 };\n  } else if (eval_cp > 15) {\n    // Slight white edge\n    return { white: 38, black: 28, draw: 34 };\n  } else if (eval_cp < -15) {\n    // Slight black edge\n    return { white: 28, black: 38, draw: 34 };\n  } else {\n    // Equal position - draw likely\n    return { white: 30, black: 30, draw: 40 };\n  }\n}\n\n/**\n * Calculate phase signal based on game stage\n */\nfunction calculatePhaseSignal(\n  moveNumber: number,\n  intensity: number\n): { white: number; black: number; draw: number } {\n  // Early game: predictions are less reliable, slightly favor white (first-move advantage)\n  if (moveNumber < 15) {\n    return { white: 36, black: 32, draw: 32 };\n  }\n  \n  // Middlegame: balanced predictions\n  if (moveNumber < 30) {\n    return { white: 34, black: 34, draw: 32 };\n  }\n  \n  // Late game: intensity determines draw likelihood\n  if (intensity < 30) {\n    // Low intensity late game = draw likely\n    return { white: 28, black: 28, draw: 44 };\n  } else if (intensity > 60) {\n    // High intensity late game = decisive result\n    return { white: 38, black: 38, draw: 24 };\n  }\n  \n  return { white: 33, black: 33, draw: 34 };\n}\n";export{n as default};
