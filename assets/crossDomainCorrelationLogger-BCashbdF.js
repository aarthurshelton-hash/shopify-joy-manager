const n="/**\n * Cross-Domain Correlation Logger\n * \n * Tracks and persists correlations between chess patterns,\n * code health events, and market movements.\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport { photonicEngine } from '@/lib/pensent-core/architecture/photonicComputing';\n\nexport interface CorrelationEvent {\n  id: string;\n  timestamp: Date;\n  domainA: string;\n  domainB: string;\n  metricA: { name: string; value: number };\n  metricB: { name: string; value: number };\n  correlation: number;\n  significance: 'strong' | 'moderate' | 'weak';\n  context?: string;\n}\n\nclass CrossDomainCorrelationLogger {\n  private events: CorrelationEvent[] = [];\n  private readonly maxMemoryEvents = 100;\n\n  /**\n   * Log a correlation event between two domains\n   */\n  log(event: Omit<CorrelationEvent, 'id' | 'timestamp' | 'significance'>): CorrelationEvent {\n    const fullEvent: CorrelationEvent = {\n      ...event,\n      id: `corr_${Date.now()}_${Math.random().toString(36).substring(7)}`,\n      timestamp: new Date(),\n      significance: event.correlation > 0.7 ? 'strong' : \n        event.correlation > 0.4 ? 'moderate' : 'weak'\n    };\n\n    this.events.unshift(fullEvent);\n    \n    // Trim memory\n    if (this.events.length > this.maxMemoryEvents) {\n      this.events = this.events.slice(0, this.maxMemoryEvents);\n    }\n\n    // Inject into photonic engine for coherence tracking\n    this.updatePhotonicState(event.domainA, event.metricA.value);\n    this.updatePhotonicState(event.domainB, event.metricB.value);\n\n    return fullEvent;\n  }\n\n  /**\n   * Log chess pattern event\n   */\n  logChessEvent(metric: string, value: number, context?: string): void {\n    this.updatePhotonicState('chess', value);\n    console.log(`[CrossDomain] Chess: ${metric} = ${value}`, context || '');\n  }\n\n  /**\n   * Log code health event\n   */\n  logCodeEvent(metric: string, value: number, context?: string): void {\n    this.updatePhotonicState('code', value);\n    console.log(`[CrossDomain] Code: ${metric} = ${value}`, context || '');\n  }\n\n  /**\n   * Log market event\n   */\n  logMarketEvent(metric: string, value: number, context?: string): void {\n    this.updatePhotonicState('market', value);\n    console.log(`[CrossDomain] Market: ${metric} = ${value}`, context || '');\n  }\n\n  /**\n   * Update photonic engine with domain signal\n   */\n  private updatePhotonicState(domain: string, value: number): void {\n    const photonicDomain = domain.toLowerCase() as any;\n    try {\n      photonicEngine.injectSignal(photonicDomain, {\n        amplitude: Math.max(0.1, Math.min(1, value)),\n        phase: (Date.now() % 6283) / 1000, // Cycle phase\n        coherence: 0.5 + value * 0.5\n      });\n    } catch (e) {\n      // Domain may not exist in photonic engine\n    }\n  }\n\n  /**\n   * Get recent events\n   */\n  getRecentEvents(limit = 20): CorrelationEvent[] {\n    return this.events.slice(0, limit);\n  }\n\n  /**\n   * Get correlation summary\n   */\n  getSummary(): {\n    totalEvents: number;\n    strongCorrelations: number;\n    topDomainPairs: Array<{ pair: string; count: number; avgCorrelation: number }>;\n  } {\n    const pairStats: Record<string, { count: number; totalCorr: number }> = {};\n\n    this.events.forEach(event => {\n      const pair = [event.domainA, event.domainB].sort().join('-');\n      if (!pairStats[pair]) {\n        pairStats[pair] = { count: 0, totalCorr: 0 };\n      }\n      pairStats[pair].count++;\n      pairStats[pair].totalCorr += event.correlation;\n    });\n\n    const topPairs = Object.entries(pairStats)\n      .map(([pair, stats]) => ({\n        pair,\n        count: stats.count,\n        avgCorrelation: stats.totalCorr / stats.count\n      }))\n      .sort((a, b) => b.avgCorrelation - a.avgCorrelation)\n      .slice(0, 5);\n\n    return {\n      totalEvents: this.events.length,\n      strongCorrelations: this.events.filter(e => e.significance === 'strong').length,\n      topDomainPairs: topPairs\n    };\n  }\n\n  /**\n   * Check for glitch (synchronized domains)\n   */\n  checkForGlitch(): {\n    detected: boolean;\n    type: string | null;\n    confidence: number;\n    description: string;\n  } {\n    return photonicEngine.detectGlitchInMatrix();\n  }\n}\n\nexport const correlationLogger = new CrossDomainCorrelationLogger();\n\n// Hook into existing systems\nexport function setupCorrelationLogging(): void {\n  // This will be called from the main app initialization\n  console.log('[CrossDomain] Correlation logging initialized');\n  \n  // Log initial state\n  correlationLogger.logChessEvent('init', 1, 'System startup');\n  correlationLogger.logCodeEvent('init', 1, 'System startup');\n  correlationLogger.logMarketEvent('init', 1, 'System startup');\n}\n";export{n as default};
