const n="/**\n * Engine-Powered Analysis Integration\n * \n * Bridges the Stockfish WASM engine with the existing analysis system.\n * Falls back to heuristic analysis when engine is unavailable.\n */\n\nimport { Chess } from 'chess.js';\nimport { \n  StockfishEngine, \n  getStockfishEngine,\n  GameAnalysis,\n  MoveAnalysis,\n} from '@/lib/chess/stockfishEngine';\nimport {\n  MoveQuality,\n  MoveQualityInfo,\n  MOVE_QUALITY_INFO,\n  ClassifiedMove,\n  classifyMoves as heuristicClassifyMoves,\n} from '@/lib/chess/moveQuality';\nimport {\n  GameScore,\n  MoveQualityType,\n  ENHANCED_QUALITY_INFO,\n} from '@/lib/chess/advancedAnalysis';\n\n// ===================== TYPES =====================\n\nexport interface EngineClassifiedMove extends ClassifiedMove {\n  engineAnalysis?: {\n    evalBefore: number;\n    evalAfter: number;\n    cpLoss: number;\n    accuracy: number;\n    bestMove: string;\n    wasBestMove: boolean;\n    pvLine: string[];\n  };\n}\n\nexport interface EnhancedGameAnalysis {\n  moves: EngineClassifiedMove[];\n  whiteAccuracy: number;\n  blackAccuracy: number;\n  enginePowered: boolean;\n  engineVersion?: string;\n  analysisDepth: number;\n  gameScore: GameScore;\n}\n\n// ===================== MAIN ANALYSIS FUNCTION =====================\n\n/**\n * Analyze a game with Stockfish engine, falling back to heuristics if unavailable\n */\nexport async function analyzeGameWithEngine(\n  pgn: string,\n  options: {\n    depth?: number;\n    useEngine?: boolean;\n    onProgress?: (current: number, total: number) => void;\n  } = {}\n): Promise<EnhancedGameAnalysis> {\n  const { depth = 15, useEngine = true, onProgress } = options;\n  \n  const chess = new Chess();\n  try {\n    chess.loadPgn(pgn);\n  } catch (e) {\n    throw new Error('Invalid PGN');\n  }\n  \n  const history = chess.history({ verbose: true });\n  const totalMoves = history.length;\n  \n  // Try engine analysis first\n  if (useEngine) {\n    try {\n      const engine = getStockfishEngine();\n      const ready = await engine.waitReady();\n      \n      if (ready) {\n        const engineAnalysis = await engine.analyzeGame(pgn, {\n          depth,\n          onProgress,\n        });\n        \n        // Convert engine analysis to our format\n        return convertEngineAnalysis(engineAnalysis, pgn);\n      }\n    } catch (e) {\n      console.warn('Engine analysis failed, falling back to heuristics:', e);\n    }\n  }\n  \n  // Fallback to heuristic analysis\n  const heuristicMoves = heuristicClassifyMoves(pgn);\n  \n  if (onProgress) {\n    onProgress(totalMoves, totalMoves);\n  }\n  \n  return convertHeuristicAnalysis(heuristicMoves, totalMoves);\n}\n\n// ===================== CONVERSION FUNCTIONS =====================\n\nfunction convertEngineAnalysis(\n  engineAnalysis: GameAnalysis,\n  pgn: string\n): EnhancedGameAnalysis {\n  const chess = new Chess();\n  chess.loadPgn(pgn);\n  const history = chess.history({ verbose: true });\n  \n  const moves: EngineClassifiedMove[] = engineAnalysis.moves.map((m, i) => {\n    const move = history[i];\n    const quality = cpLossToQuality(m.cpLoss, m.wasBestMove);\n    \n    return {\n      moveNumber: Math.floor(i / 2) + 1,\n      color: i % 2 === 0 ? 'w' : 'b',\n      san: m.san,\n      uci: m.uci,\n      quality,\n      info: MOVE_QUALITY_INFO[quality],\n      materialChange: 0, // Not calculated by engine\n      isCapture: m.san.includes('x'),\n      isCheck: m.san.includes('+'),\n      isCheckmate: m.san.includes('#'),\n      isCastle: m.san === 'O-O' || m.san === 'O-O-O',\n      isPromotion: m.san.includes('='),\n      isSacrifice: false, // Would need more complex analysis\n      engineAnalysis: {\n        evalBefore: m.evalBefore,\n        evalAfter: m.evalAfter,\n        cpLoss: m.cpLoss,\n        accuracy: m.accuracy,\n        bestMove: m.bestMove,\n        wasBestMove: m.wasBestMove,\n        pvLine: m.pvLine,\n      },\n    };\n  });\n  \n  // Calculate game score from engine analysis\n  const gameScore = calculateGameScoreFromEngine(moves, engineAnalysis);\n  \n  return {\n    moves,\n    whiteAccuracy: engineAnalysis.whiteAccuracy,\n    blackAccuracy: engineAnalysis.blackAccuracy,\n    enginePowered: true,\n    engineVersion: engineAnalysis.engineVersion,\n    analysisDepth: engineAnalysis.averageDepth,\n    gameScore,\n  };\n}\n\nfunction convertHeuristicAnalysis(\n  moves: ClassifiedMove[],\n  totalMoves: number\n): EnhancedGameAnalysis {\n  const whiteMoves = moves.filter((_, i) => i % 2 === 0);\n  const blackMoves = moves.filter((_, i) => i % 2 === 1);\n  \n  // Estimate accuracy from heuristic quality\n  const qualityToAccuracy = (q: MoveQuality): number => {\n    switch (q) {\n      case 'brilliant': return 100;\n      case 'great': return 98;\n      case 'best': return 95;\n      case 'good': return 85;\n      case 'book': return 90;\n      case 'inaccuracy': return 70;\n      case 'mistake': return 50;\n      case 'blunder': return 20;\n      default: return 80;\n    }\n  };\n  \n  const whiteAccuracy = whiteMoves.length\n    ? whiteMoves.reduce((sum, m) => sum + qualityToAccuracy(m.quality), 0) / whiteMoves.length\n    : 0;\n  const blackAccuracy = blackMoves.length\n    ? blackMoves.reduce((sum, m) => sum + qualityToAccuracy(m.quality), 0) / blackMoves.length\n    : 0;\n  \n  const gameScore = calculateGameScoreFromHeuristics(moves);\n  \n  return {\n    moves: moves as EngineClassifiedMove[],\n    whiteAccuracy: Math.round(whiteAccuracy * 10) / 10,\n    blackAccuracy: Math.round(blackAccuracy * 10) / 10,\n    enginePowered: false,\n    analysisDepth: 0,\n    gameScore,\n  };\n}\n\n// ===================== UTILITY FUNCTIONS =====================\n\nfunction cpLossToQuality(cpLoss: number, wasBest: boolean): MoveQuality {\n  if (cpLoss < 0) return 'brilliant';\n  if (wasBest || cpLoss <= 5) return 'best';\n  if (cpLoss <= 15) return 'great';\n  if (cpLoss <= 30) return 'good';\n  if (cpLoss <= 75) return 'inaccuracy';\n  if (cpLoss <= 200) return 'mistake';\n  return 'blunder';\n}\n\nfunction calculateGameScoreFromEngine(\n  moves: EngineClassifiedMove[],\n  engineAnalysis: GameAnalysis\n): GameScore {\n  const whiteMoves = moves.filter((_, i) => i % 2 === 0);\n  const blackMoves = moves.filter((_, i) => i % 2 === 1);\n  \n  const countQuality = (arr: EngineClassifiedMove[], quality: MoveQuality) =>\n    arr.filter(m => m.quality === quality).length;\n  \n  const whiteCpLoss = whiteMoves.reduce((sum, m) => \n    sum + (m.engineAnalysis?.cpLoss || 0), 0);\n  const blackCpLoss = blackMoves.reduce((sum, m) => \n    sum + (m.engineAnalysis?.cpLoss || 0), 0);\n  \n  // Estimate rating from accuracy\n  const estimateRating = (accuracy: number) => {\n    if (accuracy >= 98) return 2700;\n    if (accuracy >= 95) return 2400;\n    if (accuracy >= 90) return 2100;\n    if (accuracy >= 85) return 1800;\n    if (accuracy >= 80) return 1500;\n    if (accuracy >= 70) return 1200;\n    return 900;\n  };\n  \n  const whiteRating = estimateRating(engineAnalysis.whiteAccuracy);\n  const blackRating = estimateRating(engineAnalysis.blackAccuracy);\n  const avgRating = (whiteRating + blackRating) / 2;\n  \n  let category: GameScore['rating']['category'] = 'beginner';\n  if (avgRating >= 2500) category = 'grandmaster';\n  else if (avgRating >= 2200) category = 'master';\n  else if (avgRating >= 1800) category = 'advanced';\n  else if (avgRating >= 1400) category = 'intermediate';\n  \n  // Calculate complexity (based on evaluation swings)\n  const evalSwings = moves.filter(m => \n    m.engineAnalysis && Math.abs(m.engineAnalysis.evalAfter - m.engineAnalysis.evalBefore) > 100\n  ).length;\n  const complexity = Math.min(100, (evalSwings / moves.length) * 200);\n  \n  // Calculate sharpness (based on tactical density)\n  const tacticalMoves = moves.filter(m => \n    m.isCapture || m.isCheck || m.isSacrifice\n  ).length;\n  const sharpness = Math.min(100, (tacticalMoves / moves.length) * 150);\n  \n  return {\n    whiteAccuracy: engineAnalysis.whiteAccuracy,\n    blackAccuracy: engineAnalysis.blackAccuracy,\n    overallAccuracy: (engineAnalysis.whiteAccuracy + engineAnalysis.blackAccuracy) / 2,\n    whiteCpLoss,\n    blackCpLoss,\n    brilliantMoves: {\n      white: countQuality(whiteMoves, 'brilliant'),\n      black: countQuality(blackMoves, 'brilliant'),\n    },\n    greatMoves: {\n      white: countQuality(whiteMoves, 'great'),\n      black: countQuality(blackMoves, 'great'),\n    },\n    blunders: {\n      white: countQuality(whiteMoves, 'blunder'),\n      black: countQuality(blackMoves, 'blunder'),\n    },\n    mistakes: {\n      white: countQuality(whiteMoves, 'mistake'),\n      black: countQuality(blackMoves, 'mistake'),\n    },\n    inaccuracies: {\n      white: countQuality(whiteMoves, 'inaccuracy'),\n      black: countQuality(blackMoves, 'inaccuracy'),\n    },\n    tacticsExecuted: { white: 0, black: 0 }, // Not tracked by engine\n    tacticsMissed: { white: 0, black: 0 },\n    complexity: Math.round(complexity),\n    sharpness: Math.round(sharpness),\n    rating: {\n      estimated: { white: whiteRating, black: blackRating },\n      category,\n    },\n  };\n}\n\nfunction calculateGameScoreFromHeuristics(moves: ClassifiedMove[]): GameScore {\n  const whiteMoves = moves.filter((_, i) => i % 2 === 0);\n  const blackMoves = moves.filter((_, i) => i % 2 === 1);\n  \n  const qualityToAccuracy = (q: MoveQuality): number => {\n    switch (q) {\n      case 'brilliant': return 100;\n      case 'great': return 98;\n      case 'best': return 95;\n      case 'good': return 85;\n      case 'book': return 90;\n      case 'inaccuracy': return 70;\n      case 'mistake': return 50;\n      case 'blunder': return 20;\n      default: return 80;\n    }\n  };\n  \n  const countQuality = (arr: ClassifiedMove[], quality: MoveQuality) =>\n    arr.filter(m => m.quality === quality).length;\n  \n  const whiteAccuracy = whiteMoves.length\n    ? whiteMoves.reduce((sum, m) => sum + qualityToAccuracy(m.quality), 0) / whiteMoves.length\n    : 0;\n  const blackAccuracy = blackMoves.length\n    ? blackMoves.reduce((sum, m) => sum + qualityToAccuracy(m.quality), 0) / blackMoves.length\n    : 0;\n  \n  const estimateRating = (accuracy: number) => {\n    if (accuracy >= 98) return 2700;\n    if (accuracy >= 95) return 2400;\n    if (accuracy >= 90) return 2100;\n    if (accuracy >= 85) return 1800;\n    if (accuracy >= 80) return 1500;\n    if (accuracy >= 70) return 1200;\n    return 900;\n  };\n  \n  const whiteRating = estimateRating(whiteAccuracy);\n  const blackRating = estimateRating(blackAccuracy);\n  const avgRating = (whiteRating + blackRating) / 2;\n  \n  let category: GameScore['rating']['category'] = 'beginner';\n  if (avgRating >= 2500) category = 'grandmaster';\n  else if (avgRating >= 2200) category = 'master';\n  else if (avgRating >= 1800) category = 'advanced';\n  else if (avgRating >= 1400) category = 'intermediate';\n  \n  return {\n    whiteAccuracy: Math.round(whiteAccuracy * 10) / 10,\n    blackAccuracy: Math.round(blackAccuracy * 10) / 10,\n    overallAccuracy: Math.round((whiteAccuracy + blackAccuracy) / 2 * 10) / 10,\n    whiteCpLoss: 0,\n    blackCpLoss: 0,\n    brilliantMoves: {\n      white: countQuality(whiteMoves, 'brilliant'),\n      black: countQuality(blackMoves, 'brilliant'),\n    },\n    greatMoves: {\n      white: countQuality(whiteMoves, 'great'),\n      black: countQuality(blackMoves, 'great'),\n    },\n    blunders: {\n      white: countQuality(whiteMoves, 'blunder'),\n      black: countQuality(blackMoves, 'blunder'),\n    },\n    mistakes: {\n      white: countQuality(whiteMoves, 'mistake'),\n      black: countQuality(blackMoves, 'mistake'),\n    },\n    inaccuracies: {\n      white: countQuality(whiteMoves, 'inaccuracy'),\n      black: countQuality(blackMoves, 'inaccuracy'),\n    },\n    tacticsExecuted: { white: 0, black: 0 },\n    tacticsMissed: { white: 0, black: 0 },\n    complexity: 50, // Default estimate\n    sharpness: 50,\n    rating: {\n      estimated: { white: whiteRating, black: blackRating },\n      category,\n    },\n  };\n}\n\n// ===================== EXPORTS =====================\n\nexport { getStockfishEngine, type GameAnalysis, type MoveAnalysis };\n";export{n as default};
