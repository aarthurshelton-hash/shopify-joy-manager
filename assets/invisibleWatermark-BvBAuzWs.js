const n="/**\n * Invisible Watermark Utility\n * \n * Embeds invisible ownership data into visualization images using LSB steganography.\n * This allows tracking of unauthorized distribution without visible marks on the image.\n * \n * The watermark encodes:\n * - Visualization ID\n * - Owner user ID  \n * - Timestamp of export\n * - Checksum for verification\n */\n\n// Magic header to identify En Pensent watermarked images\nconst WATERMARK_HEADER = 'ENPENSENT';\nconst VERSION = 1;\n\ninterface WatermarkData {\n  visualizationId: string;\n  userId: string;\n  timestamp: number;\n  shareId?: string;\n}\n\n/**\n * Converts a string to binary representation\n */\nfunction stringToBinary(str: string): string {\n  return str.split('').map(char => {\n    return char.charCodeAt(0).toString(2).padStart(8, '0');\n  }).join('');\n}\n\n/**\n * Converts binary string back to regular string\n */\nfunction binaryToString(binary: string): string {\n  const bytes = binary.match(/.{8}/g);\n  if (!bytes) return '';\n  return bytes.map(byte => String.fromCharCode(parseInt(byte, 2))).join('');\n}\n\n/**\n * Simple checksum for data verification\n */\nfunction calculateChecksum(data: string): string {\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return Math.abs(hash).toString(16).padStart(8, '0').slice(0, 8);\n}\n\n/**\n * Prepares watermark payload\n */\nfunction preparePayload(data: WatermarkData): string {\n  const content = JSON.stringify({\n    v: VERSION,\n    vid: data.visualizationId,\n    uid: data.userId,\n    ts: data.timestamp,\n    sid: data.shareId || '',\n  });\n  \n  const checksum = calculateChecksum(content);\n  return `${WATERMARK_HEADER}|${checksum}|${content}|END`;\n}\n\n/**\n * Embeds invisible watermark into a canvas using LSB steganography\n * Modifies the least significant bit of color channels to encode data\n * \n * @param canvas - The canvas to watermark\n * @param data - The watermark data to embed\n * @returns The watermarked canvas\n */\nexport function embedInvisibleWatermark(\n  canvas: HTMLCanvasElement,\n  data: WatermarkData\n): HTMLCanvasElement {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return canvas;\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const pixels = imageData.data;\n  \n  const payload = preparePayload(data);\n  const binaryData = stringToBinary(payload);\n  \n  // Calculate how many pixels we need (3 bits per pixel - R, G, B channels)\n  const bitsNeeded = binaryData.length;\n  const pixelsNeeded = Math.ceil(bitsNeeded / 3);\n  \n  // Check if image has enough capacity\n  const totalPixels = canvas.width * canvas.height;\n  if (pixelsNeeded > totalPixels * 0.1) {\n    console.warn('Watermark data too large for image, truncating');\n  }\n  \n  // Embed data using LSB steganography\n  // We modify the least significant bit of R, G, B channels\n  const bitIndex = 0;\n  \n  // First, encode the length of the data (32 bits)\n  const lengthBinary = binaryData.length.toString(2).padStart(32, '0');\n  \n  // Embed length in first ~11 pixels\n  for (let i = 0; i < 32 && i < pixels.length; i++) {\n    const pixelBase = Math.floor(i / 3) * 4;\n    const channel = i % 3; // 0=R, 1=G, 2=B\n    \n    if (pixelBase + channel < pixels.length) {\n      // Clear LSB and set new value\n      pixels[pixelBase + channel] = (pixels[pixelBase + channel] & 0xFE) | parseInt(lengthBinary[i], 10);\n    }\n  }\n  \n  // Start embedding actual data after length header\n  const startPixel = 11 * 4; // Start after length pixels\n  \n  for (let i = 0; i < binaryData.length && startPixel + Math.floor(i / 3) * 4 < pixels.length; i++) {\n    const pixelBase = startPixel + Math.floor(i / 3) * 4;\n    const channel = i % 3;\n    \n    if (pixelBase + channel < pixels.length) {\n      const bit = parseInt(binaryData[i], 10);\n      pixels[pixelBase + channel] = (pixels[pixelBase + channel] & 0xFE) | bit;\n    }\n  }\n  \n  ctx.putImageData(imageData, 0, 0);\n  return canvas;\n}\n\n/**\n * Extracts invisible watermark from an image\n * Used for verification and tracking\n * \n * @param canvas - The canvas to extract from\n * @returns The watermark data or null if not found/invalid\n */\nexport function extractInvisibleWatermark(canvas: HTMLCanvasElement): WatermarkData | null {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return null;\n  \n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const pixels = imageData.data;\n  \n  try {\n    // Extract length from first 32 bits\n    let lengthBinary = '';\n    for (let i = 0; i < 32 && i < pixels.length; i++) {\n      const pixelBase = Math.floor(i / 3) * 4;\n      const channel = i % 3;\n      lengthBinary += (pixels[pixelBase + channel] & 1).toString();\n    }\n    \n    const dataLength = parseInt(lengthBinary, 2);\n    if (dataLength <= 0 || dataLength > 10000) {\n      return null; // Invalid or no watermark\n    }\n    \n    // Extract actual data\n    const startPixel = 11 * 4;\n    let binaryData = '';\n    \n    for (let i = 0; i < dataLength && startPixel + Math.floor(i / 3) * 4 < pixels.length; i++) {\n      const pixelBase = startPixel + Math.floor(i / 3) * 4;\n      const channel = i % 3;\n      binaryData += (pixels[pixelBase + channel] & 1).toString();\n    }\n    \n    const payload = binaryToString(binaryData);\n    \n    // Verify header\n    if (!payload.startsWith(WATERMARK_HEADER)) {\n      return null;\n    }\n    \n    // Parse payload\n    const parts = payload.split('|');\n    if (parts.length < 4) return null;\n    \n    const checksum = parts[1];\n    const content = parts[2];\n    \n    // Verify checksum\n    if (calculateChecksum(content) !== checksum) {\n      console.warn('Watermark checksum mismatch');\n      return null;\n    }\n    \n    const parsed = JSON.parse(content);\n    \n    return {\n      visualizationId: parsed.vid,\n      userId: parsed.uid,\n      timestamp: parsed.ts,\n      shareId: parsed.sid || undefined,\n    };\n  } catch (error) {\n    console.error('Failed to extract watermark:', error);\n    return null;\n  }\n}\n\n/**\n * Applies invisible watermark to a base64 image\n * \n * @param base64Image - The base64 encoded image\n * @param data - The watermark data to embed\n * @returns Promise with the watermarked base64 image\n */\nexport async function watermarkBase64Image(\n  base64Image: string,\n  data: WatermarkData\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    \n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      \n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        reject(new Error('Failed to get canvas context'));\n        return;\n      }\n      \n      ctx.drawImage(img, 0, 0);\n      \n      // Embed watermark\n      embedInvisibleWatermark(canvas, data);\n      \n      // Return as base64\n      resolve(canvas.toDataURL('image/png', 1.0));\n    };\n    \n    img.onerror = () => reject(new Error('Failed to load image'));\n    img.src = base64Image;\n  });\n}\n";export{n as default};
