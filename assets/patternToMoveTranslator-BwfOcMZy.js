const e="/**\n * Pattern-to-Move Translator\n * \n * The bridge from outcome prediction to move selection.\n * This is the path from \"knowing who will win\" to \"knowing how to play.\"\n * \n * Architecture:\n * 1. Use Color Flow patterns to understand strategic trajectory\n * 2. Use Stockfish for tactical validation\n * 3. Synthesize: Choose moves that align with predicted winning trajectory\n * \n * Goal: Eventually enable move-selection superiority over Stockfish by\n * choosing strategically correct moves that engines might not prioritize.\n */\n\nimport { Chess, Move } from 'chess.js';\n\nexport interface PatternMoveContext {\n  archetype: string;\n  dominantForce: 'material' | 'position' | 'initiative' | 'structure';\n  flowDirection: 'aggressive' | 'defensive' | 'balanced' | 'transitional';\n  intensity: number;\n  trajectoryPrediction: 'WHITE_WINS' | 'BLACK_WINS' | 'DRAW';\n  trajectoryConfidence: number;\n}\n\nexport interface MoveCandidate {\n  move: Move;\n  san: string;\n  strategicScore: number;\n  tacticalScore: number;\n  compositeScore: number;\n  alignsWithTrajectory: boolean;\n  reasoning: string;\n}\n\nexport interface StrategicMoveTheme {\n  theme: string;\n  description: string;\n  movePatterns: string[];\n  archetypeAffinity: string[];\n}\n\n// Strategic themes that pattern recognition can identify\nconst STRATEGIC_THEMES: StrategicMoveTheme[] = [\n  {\n    theme: 'SPACE_EXPANSION',\n    description: 'Pushing pawns to claim territory',\n    movePatterns: ['e4', 'd4', 'c4', 'f4', 'e5', 'd5', 'c5'],\n    archetypeAffinity: ['GRAND_MASTER_CONTROL', 'POSITIONAL_PYTHON']\n  },\n  {\n    theme: 'PIECE_ACTIVATION',\n    description: 'Developing pieces to active squares',\n    movePatterns: ['Nf3', 'Nc3', 'Bc4', 'Bb5', 'Bf4', 'Bg5'],\n    archetypeAffinity: ['TACTICAL_STORM', 'DYNAMIC_BALANCE']\n  },\n  {\n    theme: 'KING_SAFETY',\n    description: 'Castling and securing the king',\n    movePatterns: ['O-O', 'O-O-O', 'Kg1', 'Kh1'],\n    archetypeAffinity: ['FORTRESS_BUILDER', 'ENDGAME_SPECIALIST']\n  },\n  {\n    theme: 'CENTRAL_CONTROL',\n    description: 'Controlling key central squares',\n    movePatterns: ['e4', 'd4', 'Nc3', 'Nf3', 'Bc4', 'Bd3'],\n    archetypeAffinity: ['GRAND_MASTER_CONTROL', 'CLASSICAL_MAESTRO']\n  },\n  {\n    theme: 'FLANK_ATTACK',\n    description: 'Attacking on the flanks while center is stable',\n    movePatterns: ['h4', 'g4', 'a4', 'b4', 'h5', 'g5'],\n    archetypeAffinity: ['AGGRESSIVE_ATTACKER', 'TACTICAL_STORM']\n  },\n  {\n    theme: 'EXCHANGE_SIMPLIFICATION',\n    description: 'Trading pieces to simplify to favorable endgame',\n    movePatterns: ['Bxc6', 'Nxd5', 'Rxe8', 'Qxd8'],\n    archetypeAffinity: ['ENDGAME_SPECIALIST', 'GRINDER']\n  },\n  {\n    theme: 'PROPHYLAXIS',\n    description: 'Preventing opponent threats before they materialize',\n    movePatterns: ['h3', 'a3', 'Be3', 'Bf4'],\n    archetypeAffinity: ['FORTRESS_BUILDER', 'POSITIONAL_PYTHON']\n  },\n  {\n    theme: 'BREAKTHROUGH_PREPARATION',\n    description: 'Preparing a pawn break to open lines',\n    movePatterns: ['f5', 'c5', 'b5', 'd5', 'e5'],\n    archetypeAffinity: ['TACTICAL_STORM', 'DYNAMIC_BALANCE']\n  }\n];\n\nclass PatternToMoveTranslator {\n  /**\n   * Analyze all legal moves and score them based on pattern context\n   */\n  analyzeMoves(\n    fen: string,\n    context: PatternMoveContext,\n    stockfishEvals?: Map<string, number>\n  ): MoveCandidate[] {\n    const chess = new Chess(fen);\n    const legalMoves = chess.moves({ verbose: true });\n    const candidates: MoveCandidate[] = [];\n    \n    const isWhiteToMove = chess.turn() === 'w';\n    const weArePredictedWinner = \n      (isWhiteToMove && context.trajectoryPrediction === 'WHITE_WINS') ||\n      (!isWhiteToMove && context.trajectoryPrediction === 'BLACK_WINS');\n    \n    for (const move of legalMoves) {\n      const strategicScore = this.calculateStrategicScore(move, context, chess);\n      const tacticalScore = stockfishEvals?.get(move.san) ?? 0.5;\n      \n      // Composite score weighs strategy higher when we're predicted to win\n      // (maintain winning trajectory) vs. tactics when losing (seek complications)\n      const strategyWeight = weArePredictedWinner ? 0.6 : 0.35;\n      const tacticsWeight = 1 - strategyWeight;\n      \n      const compositeScore = (strategicScore * strategyWeight) + (tacticalScore * tacticsWeight);\n      \n      const alignsWithTrajectory = this.checkTrajectoryAlignment(move, context, chess);\n      \n      candidates.push({\n        move,\n        san: move.san,\n        strategicScore,\n        tacticalScore,\n        compositeScore,\n        alignsWithTrajectory,\n        reasoning: this.generateMoveReasoning(move, context, strategicScore, alignsWithTrajectory)\n      });\n    }\n    \n    // Sort by composite score\n    candidates.sort((a, b) => b.compositeScore - a.compositeScore);\n    \n    return candidates;\n  }\n\n  /**\n   * Calculate strategic score for a move based on pattern context\n   */\n  private calculateStrategicScore(\n    move: Move,\n    context: PatternMoveContext,\n    chess: Chess\n  ): number {\n    let score = 0.5; // Neutral baseline\n    \n    // 1. Theme alignment\n    const relevantThemes = STRATEGIC_THEMES.filter(t => \n      t.archetypeAffinity.some(a => context.archetype.includes(a) || a.includes(context.archetype))\n    );\n    \n    for (const theme of relevantThemes) {\n      if (theme.movePatterns.some(pattern => this.moveMatchesPattern(move.san, pattern))) {\n        score += 0.15;\n      }\n    }\n    \n    // 2. Flow direction alignment\n    switch (context.flowDirection) {\n      case 'aggressive':\n        // Prefer captures, checks, forward pawn moves\n        if (move.flags.includes('c') || move.flags.includes('e')) score += 0.1;\n        if (move.san.includes('+')) score += 0.1;\n        if (move.piece === 'p' && this.isPawnAdvancing(move, chess.turn())) score += 0.05;\n        break;\n      case 'defensive':\n        // Prefer consolidating moves, king safety\n        if (move.san.includes('O-O')) score += 0.15;\n        if (move.piece === 'k' && this.isKingTowardsSafety(move)) score += 0.1;\n        break;\n      case 'balanced':\n        // Prefer central control, development\n        if (this.isCentralSquare(move.to)) score += 0.1;\n        break;\n      case 'transitional':\n        // Prefer flexible moves that don't commit\n        if (!move.flags.includes('c') && !move.san.includes('+')) score += 0.05;\n        break;\n    }\n    \n    // 3. Dominant force alignment\n    switch (context.dominantForce) {\n      case 'material':\n        // Prefer material-gaining moves\n        if (move.captured) {\n          const pieceValues: Record<string, number> = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9 };\n          score += (pieceValues[move.captured] || 0) * 0.02;\n        }\n        break;\n      case 'position':\n        // Prefer piece placement improvement\n        if (this.isBetterSquare(move)) score += 0.1;\n        break;\n      case 'initiative':\n        // Prefer tempo-gaining moves\n        if (move.san.includes('+') || this.isThreatCreating(move, chess)) score += 0.1;\n        break;\n      case 'structure':\n        // Prefer pawn structure improvement\n        if (move.piece === 'p' && !this.createsPawnWeakness(move, chess)) score += 0.1;\n        break;\n    }\n    \n    // 4. Intensity scaling\n    // Higher intensity = more decisive moves preferred\n    if (context.intensity > 0.7) {\n      if (move.san.includes('+') || move.captured) score += 0.1;\n    } else if (context.intensity < 0.3) {\n      if (!move.captured && !move.san.includes('+')) score += 0.05;\n    }\n    \n    // Clamp to 0-1\n    return Math.max(0, Math.min(1, score));\n  }\n\n  /**\n   * Check if move aligns with predicted trajectory\n   */\n  private checkTrajectoryAlignment(\n    move: Move,\n    context: PatternMoveContext,\n    chess: Chess\n  ): boolean {\n    const isWhite = chess.turn() === 'w';\n    const predictedWinner = context.trajectoryPrediction;\n    \n    // If we're the predicted winner, prefer consolidating moves\n    // If we're the predicted loser, prefer complicating moves\n    \n    if ((isWhite && predictedWinner === 'WHITE_WINS') || \n        (!isWhite && predictedWinner === 'BLACK_WINS')) {\n      // We're winning - avoid unnecessary risks\n      if (move.san.includes('O-O')) return true; // Castling is safe\n      if (move.captured && this.isSafeCapture(move, chess)) return true;\n      return !this.isRiskyMove(move, chess);\n    } else if ((isWhite && predictedWinner === 'BLACK_WINS') || \n               (!isWhite && predictedWinner === 'WHITE_WINS')) {\n      // We're losing - seek complications\n      if (move.san.includes('+')) return true;\n      if (this.isThreatCreating(move, chess)) return true;\n      return this.isRiskyMove(move, chess); // Risky moves are good when losing\n    }\n    \n    // Draw prediction - prefer simplification\n    return move.captured !== undefined;\n  }\n\n  /**\n   * Generate human-readable reasoning for a move\n   */\n  private generateMoveReasoning(\n    move: Move,\n    context: PatternMoveContext,\n    strategicScore: number,\n    alignsWithTrajectory: boolean\n  ): string {\n    const parts: string[] = [];\n    \n    // Move type description\n    if (move.san.includes('O-O')) {\n      parts.push('Secures king safety');\n    } else if (move.captured) {\n      parts.push(`Captures ${move.captured}`);\n    } else if (move.san.includes('+')) {\n      parts.push('Gives check');\n    } else if (move.flags.includes('p')) {\n      parts.push('Promotes pawn');\n    } else {\n      parts.push(`Develops ${move.piece.toUpperCase()} to ${move.to}`);\n    }\n    \n    // Strategic alignment\n    if (strategicScore > 0.7) {\n      parts.push(`strongly aligns with ${context.archetype} strategy`);\n    } else if (strategicScore > 0.5) {\n      parts.push(`supports ${context.flowDirection} flow`);\n    }\n    \n    // Trajectory alignment\n    if (alignsWithTrajectory) {\n      parts.push(`maintains winning trajectory`);\n    }\n    \n    return parts.join(', ');\n  }\n\n  // Helper methods\n  private moveMatchesPattern(san: string, pattern: string): boolean {\n    return san.startsWith(pattern) || san === pattern;\n  }\n\n  private isPawnAdvancing(move: Move, turn: 'w' | 'b'): boolean {\n    if (move.piece !== 'p') return false;\n    const fromRank = parseInt(move.from[1]);\n    const toRank = parseInt(move.to[1]);\n    return turn === 'w' ? toRank > fromRank : toRank < fromRank;\n  }\n\n  private isKingTowardsSafety(move: Move): boolean {\n    // King moving toward corner is generally safer\n    const safeSquares = ['g1', 'h1', 'g8', 'h8', 'b1', 'a1', 'b8', 'a8'];\n    return safeSquares.includes(move.to);\n  }\n\n  private isCentralSquare(square: string): boolean {\n    const central = ['d4', 'd5', 'e4', 'e5', 'c4', 'c5', 'f4', 'f5'];\n    return central.includes(square);\n  }\n\n  private isBetterSquare(move: Move): boolean {\n    // Pieces generally prefer central and active squares\n    return this.isCentralSquare(move.to) || \n           (move.piece === 'n' && ['c3', 'c6', 'f3', 'f6'].includes(move.to));\n  }\n\n  private isThreatCreating(move: Move, chess: Chess): boolean {\n    // Simplified: checks and attacks on high-value pieces\n    return move.san.includes('+') || \n           (move.captured && ['q', 'r'].includes(move.captured));\n  }\n\n  private createsPawnWeakness(move: Move, chess: Chess): boolean {\n    // Simplified: doubled pawns, isolated pawns\n    // Would need more complex logic in production\n    return false;\n  }\n\n  private isSafeCapture(move: Move, chess: Chess): boolean {\n    // Simplified: captures that don't leave piece hanging\n    // Would need SEE (Static Exchange Evaluation) in production\n    return move.captured !== undefined;\n  }\n\n  private isRiskyMove(move: Move, chess: Chess): boolean {\n    // Moves that change the character of the position\n    return move.san.includes('+') || \n           move.flags.includes('e') || // en passant\n           (move.piece === 'q' && !move.captured); // Queen moves without capture\n  }\n\n  /**\n   * Get the recommended move based on pattern analysis\n   */\n  getRecommendedMove(\n    fen: string,\n    context: PatternMoveContext,\n    stockfishEvals?: Map<string, number>\n  ): MoveCandidate | null {\n    const candidates = this.analyzeMoves(fen, context, stockfishEvals);\n    return candidates.length > 0 ? candidates[0] : null;\n  }\n\n  /**\n   * Find \"Brilliant Moves\" (!!) - moves that align strongly with pattern\n   * but might not be the engine's top choice\n   */\n  findBrilliantMoves(\n    candidates: MoveCandidate[],\n    stockfishTopMove: string\n  ): MoveCandidate[] {\n    return candidates.filter(c => \n      c.san !== stockfishTopMove &&\n      c.strategicScore > 0.75 &&\n      c.alignsWithTrajectory &&\n      c.compositeScore > 0.65\n    );\n  }\n}\n\nexport const patternToMoveTranslator = new PatternToMoveTranslator();\n";export{e as default};
