const e="/**\n * Blunder Classification Engine\n * \n * Distinguishes between:\n * - Computational Blunders: Pure knowledge gaps (engines make these too)\n * - Human Blunders: Emotional/psychological pressure-induced errors\n * \n * The key insight: Engines blunder from complexity limits.\n * Humans blunder from time pressure, tilt, fatigue, and emotional states.\n */\n\nexport interface BlunderAnalysis {\n  type: 'computational' | 'human' | 'hybrid';\n  confidence: number;\n  \n  // Computational indicators\n  complexityScore: number;      // Position complexity (0-1)\n  depthRequired: number;        // Plies needed to see the issue\n  tacticalPattern: string;      // e.g., 'fork', 'pin', 'discovered_attack'\n  \n  // Human indicators\n  timePressureScore: number;    // Time remaining vs average (0-1)\n  emotionalMarkers: EmotionalMarker[];\n  patternFromProfile: boolean;  // Does this match player's blunder profile?\n  tiltProbability: number;      // Likelihood of being \"on tilt\"\n  \n  // Cross-domain insight\n  marketEquivalent: string;     // What this looks like in trading\n}\n\nexport interface EmotionalMarker {\n  type: 'frustration' | 'overconfidence' | 'fear' | 'fatigue' | 'revenge' | 'impatience';\n  evidence: string;\n  intensity: number;\n}\n\nexport interface MoveContext {\n  fen: string;\n  movePlayed: string;\n  bestMove: string;\n  evalBefore: number;\n  evalAfter: number;\n  timeSpent: number;\n  averageTimeSpent: number;\n  moveNumber: number;\n  totalMoves: number;\n  previousBlunders: number;\n  timeSinceLastBlunder: number;\n  gamePhase: 'opening' | 'middlegame' | 'endgame';\n}\n\n/**\n * Classify a blunder as computational or human\n */\nexport function classifyBlunder(context: MoveContext): BlunderAnalysis {\n  const evalDrop = Math.abs(context.evalAfter - context.evalBefore);\n  \n  // Computational indicators\n  const complexityScore = calculateComplexityScore(context);\n  const depthRequired = estimateDepthRequired(evalDrop, context.gamePhase);\n  const tacticalPattern = detectTacticalPattern(context);\n  \n  // Human indicators\n  const timePressureScore = calculateTimePressure(context);\n  const emotionalMarkers = detectEmotionalMarkers(context);\n  const tiltProbability = calculateTiltProbability(context);\n  \n  // Classification logic\n  const computationalWeight = complexityScore * 0.4 + (depthRequired > 10 ? 0.3 : 0.1) + 0.2;\n  const humanWeight = timePressureScore * 0.3 + tiltProbability * 0.3 + \n                     (emotionalMarkers.length > 0 ? 0.2 : 0) + 0.2;\n  \n  let type: 'computational' | 'human' | 'hybrid';\n  let confidence: number;\n  \n  if (computationalWeight > humanWeight * 1.5) {\n    type = 'computational';\n    confidence = Math.min(0.95, computationalWeight / (computationalWeight + humanWeight));\n  } else if (humanWeight > computationalWeight * 1.5) {\n    type = 'human';\n    confidence = Math.min(0.95, humanWeight / (computationalWeight + humanWeight));\n  } else {\n    type = 'hybrid';\n    confidence = 0.6;\n  }\n  \n  return {\n    type,\n    confidence,\n    complexityScore,\n    depthRequired,\n    tacticalPattern,\n    timePressureScore,\n    emotionalMarkers,\n    patternFromProfile: false, // Will be set by fingerprint matcher\n    tiltProbability,\n    marketEquivalent: mapToMarketBehavior(type, emotionalMarkers)\n  };\n}\n\nfunction calculateComplexityScore(context: MoveContext): number {\n  // Complexity indicators\n  let score = 0;\n  \n  // Middlegame is most complex\n  if (context.gamePhase === 'middlegame') score += 0.3;\n  else if (context.gamePhase === 'opening') score += 0.1;\n  \n  // Position tension from eval swing potential\n  const evalMagnitude = Math.abs(context.evalBefore);\n  if (evalMagnitude < 1) score += 0.3; // Equal positions are complex\n  \n  // Move number in typical complexity curve\n  if (context.moveNumber > 15 && context.moveNumber < 35) score += 0.2;\n  \n  // Time spent indicates perceived complexity\n  if (context.timeSpent > context.averageTimeSpent * 1.5) score += 0.2;\n  \n  return Math.min(1, score);\n}\n\nfunction estimateDepthRequired(evalDrop: number, phase: string): number {\n  // Rough estimate of calculation depth needed\n  const baseDepth = evalDrop > 3 ? 5 : evalDrop > 1 ? 8 : 12;\n  \n  if (phase === 'endgame') return baseDepth + 5; // Endgames need deeper calc\n  if (phase === 'opening') return baseDepth - 2; // Opening blunders are shallow\n  \n  return baseDepth;\n}\n\nfunction detectTacticalPattern(context: MoveContext): string {\n  // Simplified pattern detection\n  const evalDrop = context.evalAfter - context.evalBefore;\n  \n  if (evalDrop < -3) return 'material_loss';\n  if (evalDrop < -1.5) return 'positional_collapse';\n  if (evalDrop < -0.5) return 'tactical_oversight';\n  \n  return 'subtle_inaccuracy';\n}\n\nfunction calculateTimePressure(context: MoveContext): number {\n  // Time pressure increases blunder likelihood\n  const timeRatio = context.timeSpent / context.averageTimeSpent;\n  \n  if (timeRatio < 0.3) return 0.9; // Very rushed\n  if (timeRatio < 0.5) return 0.7; // Rushed\n  if (timeRatio < 0.8) return 0.4; // Slightly rushed\n  if (timeRatio > 2) return 0.1;   // Overthinking (different pressure)\n  \n  return 0.2;\n}\n\nfunction detectEmotionalMarkers(context: MoveContext): EmotionalMarker[] {\n  const markers: EmotionalMarker[] = [];\n  \n  // Revenge pattern: Quick move after being blundered against\n  if (context.timeSinceLastBlunder < 3 && context.timeSpent < context.averageTimeSpent * 0.5) {\n    markers.push({\n      type: 'revenge',\n      evidence: 'Quick response after opponent blunder',\n      intensity: 0.7\n    });\n  }\n  \n  // Tilt pattern: Multiple blunders in sequence\n  if (context.previousBlunders >= 2) {\n    markers.push({\n      type: 'frustration',\n      evidence: `${context.previousBlunders} previous blunders in game`,\n      intensity: Math.min(1, context.previousBlunders * 0.3)\n    });\n  }\n  \n  // Impatience in winning positions\n  if (context.evalBefore > 2 && context.timeSpent < context.averageTimeSpent * 0.3) {\n    markers.push({\n      type: 'overconfidence',\n      evidence: 'Rushing in winning position',\n      intensity: 0.6\n    });\n  }\n  \n  // Fear in losing positions\n  if (context.evalBefore < -2 && context.timeSpent > context.averageTimeSpent * 2) {\n    markers.push({\n      type: 'fear',\n      evidence: 'Paralysis in losing position',\n      intensity: 0.5\n    });\n  }\n  \n  return markers;\n}\n\nfunction calculateTiltProbability(context: MoveContext): number {\n  let tilt = 0;\n  \n  // Previous blunders increase tilt\n  tilt += context.previousBlunders * 0.15;\n  \n  // Late game fatigue\n  if (context.moveNumber > 40) tilt += 0.1;\n  if (context.moveNumber > 60) tilt += 0.15;\n  \n  // Time scramble\n  if (context.timeSpent < context.averageTimeSpent * 0.2) tilt += 0.2;\n  \n  return Math.min(1, tilt);\n}\n\n/**\n * Map chess blunder patterns to equivalent market behaviors\n * This is the KEY insight for cross-domain pattern recognition\n */\nfunction mapToMarketBehavior(\n  type: 'computational' | 'human' | 'hybrid',\n  markers: EmotionalMarker[]\n): string {\n  if (type === 'computational') {\n    return 'algorithmic_edge_case'; // Like algos hitting unusual market conditions\n  }\n  \n  const dominantEmotion = markers.length > 0 ? markers[0].type : null;\n  \n  switch (dominantEmotion) {\n    case 'revenge':\n      return 'revenge_trade'; // Doubling down after loss\n    case 'frustration':\n      return 'tilt_trading'; // Abandoning strategy\n    case 'overconfidence':\n      return 'overleveraged_greed'; // Position too large\n    case 'fear':\n      return 'panic_sell'; // Cutting winners too early\n    case 'impatience':\n      return 'fomo_entry'; // Chasing momentum\n    case 'fatigue':\n      return 'end_of_day_errors'; // Late session mistakes\n    default:\n      return 'mixed_pressure';\n  }\n}\n\n/**\n * Detect if a market trade exhibits human vs algorithmic characteristics\n */\nexport function classifyTradeOrigin(tradePattern: {\n  executionSpeed: number;      // Milliseconds\n  sizeConsistency: number;     // How consistent with previous (0-1)\n  timingPrecision: number;     // Deviation from round numbers\n  reactionToNews: number;      // Speed of news reaction\n  patternAdherence: number;    // Following technical levels\n  emotionalIndicators: number; // Counter-trend behavior\n}): { origin: 'algorithmic' | 'human' | 'unknown'; confidence: number; reasoning: string } {\n  \n  let algoScore = 0;\n  let humanScore = 0;\n  \n  // Execution speed\n  if (tradePattern.executionSpeed < 50) algoScore += 0.3;\n  else if (tradePattern.executionSpeed > 500) humanScore += 0.2;\n  \n  // Size consistency\n  if (tradePattern.sizeConsistency > 0.9) algoScore += 0.2;\n  else if (tradePattern.sizeConsistency < 0.5) humanScore += 0.2;\n  \n  // Timing precision\n  if (tradePattern.timingPrecision > 0.95) algoScore += 0.15;\n  else if (tradePattern.timingPrecision < 0.7) humanScore += 0.15;\n  \n  // News reaction\n  if (tradePattern.reactionToNews < 100) algoScore += 0.2;\n  else if (tradePattern.reactionToNews > 1000) humanScore += 0.15;\n  \n  // Pattern adherence\n  if (tradePattern.patternAdherence > 0.85) algoScore += 0.15;\n  \n  // Emotional indicators (counter-trend = human)\n  if (tradePattern.emotionalIndicators > 0.6) humanScore += 0.25;\n  \n  const total = algoScore + humanScore;\n  \n  if (algoScore > humanScore * 1.5) {\n    return {\n      origin: 'algorithmic',\n      confidence: algoScore / total,\n      reasoning: 'High execution speed, consistent sizing, precise timing'\n    };\n  } else if (humanScore > algoScore * 1.5) {\n    return {\n      origin: 'human',\n      confidence: humanScore / total,\n      reasoning: 'Variable sizing, emotional patterns, slower execution'\n    };\n  }\n  \n  return {\n    origin: 'unknown',\n    confidence: 0.5,\n    reasoning: 'Mixed signals - could be human-guided algorithm'\n  };\n}\n";export{e as default};
