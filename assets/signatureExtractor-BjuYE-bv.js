const n="/**\n * En Pensentâ„¢ Finance Domain - Signature Extraction\n * \n * Extracts TemporalSignatures from stock market candlestick data.\n */\n\nimport { \n  TemporalSignature, \n  QuadrantProfile, \n  TemporalFlow, \n  CriticalMoment \n} from '../../types/core';\nimport { CandleStick, MarketArchetype, MARKET_ARCHETYPES } from './types';\n\n/**\n * Extract a TemporalSignature from candlestick data\n */\nexport function extractMarketSignature(\n  symbol: string,\n  candles: CandleStick[],\n  timeHorizon: '1h' | '4h' | '1d' | '1w' = '1d'\n): TemporalSignature {\n  if (candles.length < 5) {\n    return createEmptySignature(symbol);\n  }\n\n  const quadrantProfile = calculateQuadrantProfile(candles);\n  const temporalFlow = calculateTemporalFlow(candles);\n  const criticalMoments = findCriticalMoments(candles);\n  const intensity = calculateIntensity(candles);\n  const archetype = classifyMarketArchetype(quadrantProfile, temporalFlow, intensity, candles);\n  const fingerprint = generateFingerprint(symbol, archetype, quadrantProfile, temporalFlow);\n\n  return {\n    fingerprint,\n    archetype,\n    dominantForce: determineDominantForce(candles),\n    flowDirection: determineFlowDirection(candles),\n    intensity,\n    quadrantProfile,\n    temporalFlow,\n    criticalMoments,\n    domainData: {\n      symbol,\n      timeHorizon,\n      candleCount: candles.length,\n      volumeProfile: calculateVolumeProfile(candles),\n      volatility: calculateVolatility(candles),\n      trendStrength: calculateTrendStrength(candles)\n    }\n  };\n}\n\n/**\n * Map price action to quadrant profile\n * Q1: Price momentum (bullish strength)\n * Q2: Volume activity (conviction)\n * Q3: Volatility (risk/opportunity)\n * Q4: Trend consistency (reliability)\n */\nfunction calculateQuadrantProfile(candles: CandleStick[]): QuadrantProfile {\n  const returns = candles.slice(1).map((c, i) => \n    (c.close - candles[i].close) / candles[i].close\n  );\n  \n  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n  const positiveReturns = returns.filter(r => r > 0).length / returns.length;\n  \n  // Q1: Price momentum (0-1 scale)\n  const q1 = Math.min(1, Math.max(0, 0.5 + avgReturn * 10));\n  \n  // Q2: Volume activity\n  const avgVolume = candles.reduce((a, c) => a + c.volume, 0) / candles.length;\n  const recentVolume = candles.slice(-5).reduce((a, c) => a + c.volume, 0) / 5;\n  const q2 = Math.min(1, recentVolume / avgVolume);\n  \n  // Q3: Volatility (higher = more activity)\n  const volatility = calculateVolatility(candles);\n  const q3 = Math.min(1, volatility * 10);\n  \n  // Q4: Trend consistency\n  const q4 = Math.abs(positiveReturns - 0.5) * 2;\n  \n  // Center: Overall market health\n  const center = (q1 + q2 + q4) / 3;\n\n  return { q1, q2, q3, q4, center };\n}\n\n/**\n * Calculate temporal flow from candle sequence\n */\nfunction calculateTemporalFlow(candles: CandleStick[]): TemporalFlow {\n  const third = Math.floor(candles.length / 3);\n  \n  const openingCandles = candles.slice(0, third);\n  const middleCandles = candles.slice(third, third * 2);\n  const endingCandles = candles.slice(third * 2);\n  \n  const getPhaseActivity = (phase: CandleStick[]) => {\n    if (phase.length === 0) return 0.5;\n    const avgRange = phase.reduce((a, c) => a + (c.high - c.low) / c.open, 0) / phase.length;\n    return Math.min(1, avgRange * 20);\n  };\n  \n  const opening = getPhaseActivity(openingCandles);\n  const middle = getPhaseActivity(middleCandles);\n  const ending = getPhaseActivity(endingCandles);\n  \n  // Determine trend\n  let trend: TemporalFlow['trend'];\n  if (ending > middle && middle > opening) {\n    trend = 'accelerating';\n  } else if (ending < middle && middle < opening) {\n    trend = 'declining';\n  } else if (Math.abs(ending - opening) < 0.1) {\n    trend = 'stable';\n  } else {\n    trend = 'volatile';\n  }\n  \n  // Calculate momentum\n  const priceChange = (candles[candles.length - 1].close - candles[0].close) / candles[0].close;\n  const momentum = Math.max(-1, Math.min(1, priceChange * 10));\n\n  return { opening, middle, ending, trend, momentum };\n}\n\n/**\n * Find significant price turning points\n */\nfunction findCriticalMoments(candles: CandleStick[]): CriticalMoment[] {\n  const moments: CriticalMoment[] = [];\n  \n  if (candles.length < 3) return moments;\n  \n  for (let i = 2; i < candles.length; i++) {\n    const prev = candles[i - 2];\n    const curr = candles[i - 1];\n    const next = candles[i];\n    \n    const prevChange = (curr.close - prev.close) / prev.close;\n    const nextChange = (next.close - curr.close) / curr.close;\n    \n    // Detect reversals\n    if (prevChange < -0.02 && nextChange > 0.02) {\n      moments.push({\n        index: i - 1,\n        type: 'bullish_reversal',\n        severity: Math.min(1, Math.abs(nextChange - prevChange) * 10),\n        description: `Bullish reversal at ${new Date(curr.timestamp).toLocaleDateString()}`,\n        metadata: { price: curr.close, volume: curr.volume }\n      });\n    } else if (prevChange > 0.02 && nextChange < -0.02) {\n      moments.push({\n        index: i - 1,\n        type: 'bearish_reversal',\n        severity: Math.min(1, Math.abs(nextChange - prevChange) * 10),\n        description: `Bearish reversal at ${new Date(curr.timestamp).toLocaleDateString()}`,\n        metadata: { price: curr.close, volume: curr.volume }\n      });\n    }\n    \n    // Detect volume spikes\n    const avgVolume = candles.slice(0, i).reduce((a, c) => a + c.volume, 0) / i;\n    if (curr.volume > avgVolume * 2) {\n      moments.push({\n        index: i - 1,\n        type: 'volume_spike',\n        severity: Math.min(1, curr.volume / avgVolume / 5),\n        description: `Volume spike at ${new Date(curr.timestamp).toLocaleDateString()}`,\n        metadata: { volume: curr.volume, avgVolume }\n      });\n    }\n  }\n  \n  return moments.slice(0, 10); // Top 10 moments\n}\n\n/**\n * Calculate overall market intensity\n */\nfunction calculateIntensity(candles: CandleStick[]): number {\n  const avgRange = candles.reduce((a, c) => a + (c.high - c.low) / c.open, 0) / candles.length;\n  const avgVolume = candles.reduce((a, c) => a + c.volume, 0) / candles.length;\n  const recentVolume = candles.slice(-5).reduce((a, c) => a + c.volume, 0) / 5;\n  \n  const rangeIntensity = Math.min(1, avgRange * 15);\n  const volumeIntensity = Math.min(1, recentVolume / avgVolume);\n  \n  return (rangeIntensity + volumeIntensity) / 2;\n}\n\n/**\n * Classify the market archetype based on signature components\n */\nfunction classifyMarketArchetype(\n  quadrant: QuadrantProfile,\n  temporal: TemporalFlow,\n  intensity: number,\n  candles: CandleStick[]\n): MarketArchetype {\n  const { q1, q2, q3, q4 } = quadrant;\n  const { trend, momentum } = temporal;\n  const volatility = calculateVolatility(candles);\n  \n  // Strong bullish breakout\n  if (q1 > 0.7 && q2 > 0.7 && momentum > 0.3 && trend === 'accelerating') {\n    return 'breakout_bullish';\n  }\n  \n  // Strong bearish breakout\n  if (q1 < 0.3 && q2 > 0.7 && momentum < -0.3 && trend === 'accelerating') {\n    return 'breakout_bearish';\n  }\n  \n  // Accumulation: low volatility, building volume, slight bullish\n  if (q3 < 0.4 && q2 > 0.5 && q1 > 0.45 && q1 < 0.6 && trend === 'stable') {\n    return 'accumulation';\n  }\n  \n  // Distribution: topping action, volume, slight bearish\n  if (q3 < 0.4 && q2 > 0.5 && q1 < 0.55 && q1 > 0.4 && momentum < 0) {\n    return 'distribution';\n  }\n  \n  // Clear uptrend\n  if (q1 > 0.6 && q4 > 0.6 && momentum > 0.1) {\n    return 'uptrend';\n  }\n  \n  // Clear downtrend\n  if (q1 < 0.4 && q4 > 0.6 && momentum < -0.1) {\n    return 'downtrend';\n  }\n  \n  // Bullish reversal\n  if (temporal.opening < 0.4 && temporal.ending > 0.6 && momentum > 0.2) {\n    return 'reversal_bullish';\n  }\n  \n  // Bearish reversal\n  if (temporal.opening > 0.6 && temporal.ending < 0.4 && momentum < -0.2) {\n    return 'reversal_bearish';\n  }\n  \n  // High volatility\n  if (q3 > 0.7 || volatility > 0.05) {\n    return 'high_volatility';\n  }\n  \n  // Low volatility compression\n  if (q3 < 0.2 && volatility < 0.01) {\n    return 'low_volatility';\n  }\n  \n  // Momentum surge\n  if (intensity > 0.8 && Math.abs(momentum) > 0.4) {\n    return 'momentum_surge';\n  }\n  \n  // Consolidation\n  if (q4 < 0.3 && Math.abs(momentum) < 0.1) {\n    return 'consolidation';\n  }\n  \n  return 'unknown';\n}\n\nfunction calculateVolatility(candles: CandleStick[]): number {\n  if (candles.length < 2) return 0;\n  const returns = candles.slice(1).map((c, i) => \n    (c.close - candles[i].close) / candles[i].close\n  );\n  const mean = returns.reduce((a, b) => a + b, 0) / returns.length;\n  const variance = returns.reduce((a, r) => a + Math.pow(r - mean, 2), 0) / returns.length;\n  return Math.sqrt(variance);\n}\n\nfunction calculateVolumeProfile(candles: CandleStick[]): { avg: number; trend: string } {\n  const avg = candles.reduce((a, c) => a + c.volume, 0) / candles.length;\n  const recentAvg = candles.slice(-5).reduce((a, c) => a + c.volume, 0) / 5;\n  const trend = recentAvg > avg * 1.2 ? 'increasing' : recentAvg < avg * 0.8 ? 'decreasing' : 'stable';\n  return { avg, trend };\n}\n\nfunction calculateTrendStrength(candles: CandleStick[]): number {\n  if (candles.length < 2) return 0;\n  const returns = candles.slice(1).map((c, i) => \n    c.close > candles[i].close ? 1 : -1\n  );\n  const consistency = Math.abs(returns.reduce((a, b) => a + b, 0)) / returns.length;\n  return consistency;\n}\n\nfunction determineDominantForce(candles: CandleStick[]): 'primary' | 'secondary' | 'balanced' {\n  const change = (candles[candles.length - 1].close - candles[0].close) / candles[0].close;\n  if (change > 0.02) return 'primary';\n  if (change < -0.02) return 'secondary';\n  return 'balanced';\n}\n\nfunction determineFlowDirection(candles: CandleStick[]): 'forward' | 'lateral' | 'backward' | 'chaotic' {\n  const returns = candles.slice(1).map((c, i) => \n    (c.close - candles[i].close) / candles[i].close\n  );\n  const positiveCount = returns.filter(r => r > 0).length;\n  const ratio = positiveCount / returns.length;\n  \n  if (ratio > 0.6) return 'forward';\n  if (ratio < 0.4) return 'backward';\n  \n  const volatility = calculateVolatility(candles);\n  if (volatility > 0.03) return 'chaotic';\n  \n  return 'lateral';\n}\n\nfunction generateFingerprint(\n  symbol: string,\n  archetype: string,\n  quadrant: QuadrantProfile,\n  temporal: TemporalFlow\n): string {\n  const components = [\n    symbol,\n    archetype,\n    Math.round(quadrant.q1 * 100),\n    Math.round(quadrant.q2 * 100),\n    Math.round(quadrant.q3 * 100),\n    Math.round(quadrant.q4 * 100),\n    temporal.trend,\n    Math.round(temporal.momentum * 100)\n  ];\n  return components.join('-');\n}\n\nfunction createEmptySignature(symbol: string): TemporalSignature {\n  return {\n    fingerprint: `${symbol}-empty-${Date.now()}`,\n    archetype: 'unknown',\n    dominantForce: 'balanced',\n    flowDirection: 'lateral',\n    intensity: 0,\n    quadrantProfile: { q1: 0.5, q2: 0.5, q3: 0.5, q4: 0.5 },\n    temporalFlow: { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 },\n    criticalMoments: []\n  };\n}\n";export{n as default};
