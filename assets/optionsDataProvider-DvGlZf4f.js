const n="/**\n * Options Data Provider - Multi-Broker Real-Time Data\n * \n * Aggregates options data from Tradier, IBKR, Polygon, and other sources.\n * Provides unified interface for options chain, flow, and quote data.\n * \n * En Pensentâ„¢ Patent-Pending Technology\n * @version 7.50-OPTIONS\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport {\n  OptionsChain,\n  OptionContract,\n  OptionsTick,\n  OptionsFlowData,\n  UnderlyingAnalysis,\n  MarketContext,\n  MarketSession,\n  SCALPING_UNDERLYINGS,\n} from './types';\n\nconst PROVIDER_VERSION = '7.50-OPTIONS';\n\ninterface DataSource {\n  name: string;\n  priority: number;\n  enabled: boolean;\n  lastSuccess: number;\n  failCount: number;\n}\n\nclass OptionsDataProvider {\n  private sources: Map<string, DataSource> = new Map();\n  private chainCache: Map<string, { data: OptionsChain; timestamp: number }> = new Map();\n  private tickCache: Map<string, OptionsTick[]> = new Map();\n  private underlyingCache: Map<string, { data: UnderlyingAnalysis; timestamp: number }> = new Map();\n  private contextCache: MarketContext | null = null;\n  private cacheTTL = 15000; // 15 seconds\n\n  constructor() {\n    this.initializeSources();\n  }\n\n  private initializeSources(): void {\n    const sources: DataSource[] = [\n      { name: 'tradier', priority: 1, enabled: true, lastSuccess: 0, failCount: 0 },\n      { name: 'polygon', priority: 2, enabled: true, lastSuccess: 0, failCount: 0 },\n      { name: 'ibkr', priority: 3, enabled: true, lastSuccess: 0, failCount: 0 },\n      { name: 'binance', priority: 4, enabled: true, lastSuccess: 0, failCount: 0 },\n      { name: 'finnhub', priority: 5, enabled: true, lastSuccess: 0, failCount: 0 },\n    ];\n\n    sources.forEach(s => this.sources.set(s.name, s));\n    console.log(`[OptionsDataProvider] ${PROVIDER_VERSION} initialized with ${sources.length} sources`);\n  }\n\n  /**\n   * Get options chain for underlying\n   */\n  async getOptionsChain(underlying: string, expiration?: string): Promise<OptionsChain | null> {\n    const cacheKey = `${underlying}:${expiration || 'all'}`;\n    const cached = this.chainCache.get(cacheKey);\n\n    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n      return cached.data;\n    }\n\n    try {\n      const { data, error } = await supabase.functions.invoke('options-data', {\n        body: {\n          action: 'chain',\n          underlying,\n          expiration,\n        },\n      });\n\n      if (error) throw error;\n\n      if (data?.chain) {\n        this.chainCache.set(cacheKey, { data: data.chain, timestamp: Date.now() });\n        return data.chain;\n      }\n\n      // Fallback to simulated data for development\n      return this.generateSimulatedChain(underlying);\n    } catch (err) {\n      console.error('[OptionsDataProvider] Chain fetch error:', err);\n      return this.generateSimulatedChain(underlying);\n    }\n  }\n\n  /**\n   * Get real-time quote for specific option\n   */\n  async getOptionQuote(optionSymbol: string): Promise<OptionsTick | null> {\n    try {\n      const { data, error } = await supabase.functions.invoke('options-data', {\n        body: {\n          action: 'quote',\n          symbol: optionSymbol,\n        },\n      });\n\n      if (error) throw error;\n      return data?.tick || null;\n    } catch (err) {\n      console.error('[OptionsDataProvider] Quote fetch error:', err);\n      return null;\n    }\n  }\n\n  /**\n   * Get underlying analysis with technicals\n   */\n  async getUnderlyingAnalysis(symbol: string): Promise<UnderlyingAnalysis | null> {\n    const cached = this.underlyingCache.get(symbol);\n\n    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {\n      return cached.data;\n    }\n\n    try {\n      const { data, error } = await supabase.functions.invoke('options-data', {\n        body: {\n          action: 'analysis',\n          symbol,\n        },\n      });\n\n      if (error) throw error;\n\n      if (data?.analysis) {\n        this.underlyingCache.set(symbol, { data: data.analysis, timestamp: Date.now() });\n        return data.analysis;\n      }\n\n      return this.generateSimulatedAnalysis(symbol);\n    } catch (err) {\n      console.error('[OptionsDataProvider] Analysis fetch error:', err);\n      return this.generateSimulatedAnalysis(symbol);\n    }\n  }\n\n  /**\n   * Get unusual options activity / flow\n   */\n  async getOptionsFlow(underlying?: string): Promise<OptionsFlowData[]> {\n    try {\n      const { data, error } = await supabase.functions.invoke('options-data', {\n        body: {\n          action: 'flow',\n          underlying,\n        },\n      });\n\n      if (error) throw error;\n      return data?.flow || [];\n    } catch (err) {\n      console.error('[OptionsDataProvider] Flow fetch error:', err);\n      return [];\n    }\n  }\n\n  /**\n   * Get current market context\n   */\n  async getMarketContext(): Promise<MarketContext> {\n    if (this.contextCache && Date.now() - this.contextCache.timestamp < this.cacheTTL) {\n      return this.contextCache;\n    }\n\n    try {\n      const { data, error } = await supabase.functions.invoke('options-data', {\n        body: { action: 'context' },\n      });\n\n      if (error) throw error;\n\n      if (data?.context) {\n        this.contextCache = data.context;\n        return data.context;\n      }\n    } catch (err) {\n      console.error('[OptionsDataProvider] Context fetch error:', err);\n    }\n\n    return this.generateSimulatedContext();\n  }\n\n  /**\n   * Subscribe to real-time option quotes\n   */\n  subscribeToQuotes(\n    symbols: string[],\n    callback: (tick: OptionsTick) => void\n  ): () => void {\n    // In production, this would use WebSocket connection\n    // For now, poll at high frequency\n    const pollInterval = setInterval(async () => {\n      for (const symbol of symbols) {\n        const tick = await this.getOptionQuote(symbol);\n        if (tick) callback(tick);\n      }\n    }, 1000);\n\n    return () => clearInterval(pollInterval);\n  }\n\n  /**\n   * Get current market session\n   */\n  getMarketSession(): MarketSession {\n    const now = new Date();\n    const hour = now.getHours();\n    const minute = now.getMinutes();\n    const day = now.getDay();\n\n    // Weekend\n    if (day === 0 || day === 6) return 'closed';\n\n    const time = hour * 60 + minute;\n    const marketOpen = 9 * 60 + 30; // 9:30 AM\n    const marketClose = 16 * 60; // 4:00 PM\n\n    if (time < marketOpen - 30) return 'premarket'; // 9:00 AM\n    if (time < marketOpen) return 'premarket';\n    if (time < marketClose) return 'regular';\n    if (time < marketClose + 120) return 'afterhours'; // Until 6 PM\n    return 'closed';\n  }\n\n  /**\n   * Check if market is tradeable\n   */\n  isMarketOpen(includeExtended: boolean = false): boolean {\n    const session = this.getMarketSession();\n    if (session === 'regular') return true;\n    if (includeExtended && (session === 'premarket' || session === 'afterhours')) return true;\n    return false;\n  }\n\n  // ========================================\n  // SIMULATION METHODS (for development)\n  // ========================================\n\n  private generateSimulatedChain(underlying: string): OptionsChain {\n    const basePrice = this.getBasePrice(underlying);\n    const now = new Date();\n    const expirations = this.generateExpirations(now);\n    const calls: OptionContract[] = [];\n    const puts: OptionContract[] = [];\n\n    // Generate strikes around current price\n    const strikesRange = [-10, -5, -3, -2, -1, 0, 1, 2, 3, 5, 10];\n    const strikeInterval = basePrice > 100 ? 5 : basePrice > 50 ? 2.5 : 1;\n\n    for (const exp of expirations.slice(0, 3)) {\n      const daysToExp = Math.max(1, Math.floor((new Date(exp).getTime() - now.getTime()) / 86400000));\n      const iv = 0.20 + Math.random() * 0.30; // 20-50% IV\n\n      for (const offset of strikesRange) {\n        const strike = Math.round((basePrice + offset * strikeInterval) / strikeInterval) * strikeInterval;\n        \n        // Black-Scholes approximation\n        const callPrice = this.estimateOptionPrice(basePrice, strike, daysToExp, iv, true);\n        const putPrice = this.estimateOptionPrice(basePrice, strike, daysToExp, iv, false);\n        const delta = this.estimateDelta(basePrice, strike, daysToExp, iv, true);\n\n        calls.push({\n          symbol: `${underlying}${exp.replace(/-/g, '')}C${strike * 1000}`,\n          underlying,\n          type: 'call',\n          strike,\n          expiration: exp,\n          bid: callPrice * 0.98,\n          ask: callPrice * 1.02,\n          last: callPrice,\n          volume: Math.floor(Math.random() * 5000) + 100,\n          openInterest: Math.floor(Math.random() * 20000) + 500,\n          impliedVolatility: iv,\n          delta,\n          gamma: 0.02 + Math.random() * 0.05,\n          theta: -callPrice * 0.01 * (1 / daysToExp),\n          vega: callPrice * 0.1,\n          timestamp: Date.now(),\n        });\n\n        puts.push({\n          symbol: `${underlying}${exp.replace(/-/g, '')}P${strike * 1000}`,\n          underlying,\n          type: 'put',\n          strike,\n          expiration: exp,\n          bid: putPrice * 0.98,\n          ask: putPrice * 1.02,\n          last: putPrice,\n          volume: Math.floor(Math.random() * 4000) + 80,\n          openInterest: Math.floor(Math.random() * 18000) + 400,\n          impliedVolatility: iv,\n          delta: delta - 1,\n          gamma: 0.02 + Math.random() * 0.05,\n          theta: -putPrice * 0.01 * (1 / daysToExp),\n          vega: putPrice * 0.1,\n          timestamp: Date.now(),\n        });\n      }\n    }\n\n    return {\n      underlying,\n      underlyingPrice: basePrice,\n      expirations,\n      calls,\n      puts,\n      timestamp: Date.now(),\n    };\n  }\n\n  private generateSimulatedAnalysis(symbol: string): UnderlyingAnalysis {\n    const price = this.getBasePrice(symbol);\n    const change = (Math.random() - 0.5) * price * 0.03;\n    const rsi = 30 + Math.random() * 40;\n\n    return {\n      symbol,\n      price,\n      change,\n      changePercent: (change / price) * 100,\n      volume: Math.floor(Math.random() * 50000000) + 5000000,\n      avgVolume: 30000000,\n      volumeRatio: 0.8 + Math.random() * 0.6,\n      rsi,\n      macd: {\n        value: (Math.random() - 0.5) * 2,\n        signal: (Math.random() - 0.5) * 1.5,\n        histogram: (Math.random() - 0.5) * 0.5,\n      },\n      sma20: price * (0.98 + Math.random() * 0.04),\n      sma50: price * (0.96 + Math.random() * 0.08),\n      ema9: price * (0.99 + Math.random() * 0.02),\n      vwap: price * (0.995 + Math.random() * 0.01),\n      supports: [price * 0.98, price * 0.95, price * 0.92],\n      resistances: [price * 1.02, price * 1.05, price * 1.08],\n      trend: rsi > 60 ? 'bullish' : rsi < 40 ? 'bearish' : 'neutral',\n      trendStrength: Math.abs(rsi - 50) / 50,\n      historicalVolatility: 0.15 + Math.random() * 0.20,\n      ivRank: Math.random() * 100,\n      ivPercentile: Math.random() * 100,\n      timestamp: Date.now(),\n    };\n  }\n\n  private generateSimulatedContext(): MarketContext {\n    return {\n      session: this.getMarketSession(),\n      spyTrend: Math.random() > 0.5 ? 'up' : 'down',\n      vixLevel: 15 + Math.random() * 15,\n      vixChange: (Math.random() - 0.5) * 3,\n      marketBreadth: (Math.random() - 0.5) * 100,\n      sectorRotation: {\n        XLK: Math.random() * 2 - 1,\n        XLF: Math.random() * 2 - 1,\n        XLE: Math.random() * 2 - 1,\n        XLV: Math.random() * 2 - 1,\n        XLI: Math.random() * 2 - 1,\n      },\n      economicEvents: [],\n      timestamp: Date.now(),\n    };\n  }\n\n  private getBasePrice(symbol: string): number {\n    const prices: Record<string, number> = {\n      SPY: 590,\n      QQQ: 520,\n      IWM: 225,\n      AAPL: 235,\n      TSLA: 430,\n      NVDA: 145,\n      AMD: 125,\n      AMZN: 225,\n      META: 610,\n      GOOGL: 195,\n    };\n    return prices[symbol] || 100;\n  }\n\n  private generateExpirations(from: Date): string[] {\n    const expirations: string[] = [];\n    const current = new Date(from);\n\n    // Find next Friday (0DTE candidate)\n    while (current.getDay() !== 5) {\n      current.setDate(current.getDate() + 1);\n    }\n\n    // Add weekly expirations\n    for (let i = 0; i < 8; i++) {\n      expirations.push(current.toISOString().split('T')[0]);\n      current.setDate(current.getDate() + 7);\n    }\n\n    return expirations;\n  }\n\n  private estimateOptionPrice(\n    spot: number,\n    strike: number,\n    daysToExp: number,\n    iv: number,\n    isCall: boolean\n  ): number {\n    // Simplified option pricing\n    const t = daysToExp / 365;\n    const intrinsic = isCall\n      ? Math.max(0, spot - strike)\n      : Math.max(0, strike - spot);\n    const timeValue = spot * iv * Math.sqrt(t) * 0.4;\n    \n    const moneyness = isCall ? (spot - strike) / spot : (strike - spot) / spot;\n    const atmFactor = Math.exp(-Math.pow(moneyness * 10, 2));\n    \n    return Math.max(0.01, intrinsic + timeValue * atmFactor);\n  }\n\n  private estimateDelta(\n    spot: number,\n    strike: number,\n    daysToExp: number,\n    iv: number,\n    isCall: boolean\n  ): number {\n    const moneyness = (spot - strike) / strike;\n    const t = daysToExp / 365;\n    \n    // Approximate delta\n    let delta = 0.5 + moneyness / (iv * Math.sqrt(t) * 2);\n    delta = Math.max(0, Math.min(1, delta));\n    \n    return isCall ? delta : delta - 1;\n  }\n}\n\nexport const optionsDataProvider = new OptionsDataProvider();\n";export{n as default};
