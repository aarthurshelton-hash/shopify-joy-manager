const n="/**\n * Benchmark Coordinator v7.42-AUTONOMOUS\n * \n * Coordinates between manual benchmarks and auto-evolution to prevent\n * resource conflicts (Stockfish worker contention).\n * \n * v7.42 AUTONOMOUS CHANGES:\n * - Sets DATABASE LOCK when manual benchmark starts (so server-side cron yields)\n * - Lock expires after 10 minutes (stale lock protection)\n * - Auto-evolution (both client and server) checks lock before starting\n * \n * When manual benchmark starts:\n * - Sets database lock (for server-side awareness)\n * - Pauses client-side auto-evolution\n * - Gives exclusive access to manual benchmark\n * \n * When manual benchmark ends:\n * - Releases database lock\n * - Resumes auto-evolution if it was running\n */\n\nimport { \n  pauseAutoEvolution, \n  resumeAutoEvolution, \n  getEvolutionState \n} from './autoEvolutionEngine';\nimport { supabase } from '@/integrations/supabase/client';\n\nconst COORDINATOR_VERSION = \"8.01-SMOOTH\";\n\ninterface CoordinatorState {\n  manualBenchmarkActive: boolean;\n  wasAutoEvolutionRunning: boolean;\n  startedAt: Date | null;\n  abortController: AbortController | null;\n}\n\nconst state: CoordinatorState = {\n  manualBenchmarkActive: false,\n  wasAutoEvolutionRunning: false,\n  startedAt: null,\n  abortController: null,\n};\n\n// v7.13: Subscribers that get notified when lock state changes\ntype LockListener = (isLocked: boolean) => void;\nconst lockListeners: Set<LockListener> = new Set();\n\nexport function subscribeToBenchmarkLock(listener: LockListener): () => void {\n  lockListeners.add(listener);\n  return () => lockListeners.delete(listener);\n}\n\nfunction notifyListeners(isLocked: boolean): void {\n  lockListeners.forEach(listener => {\n    try {\n      listener(isLocked);\n    } catch (e) {\n      console.warn('[BenchmarkCoordinator] Listener error:', e);\n    }\n  });\n}\n\n/**\n * v8.01-SMOOTH: Set database lock with retry logic to prevent constraint errors\n */\nasync function setDatabaseLock(locked: boolean): Promise<void> {\n  const maxRetries = 3;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      // v8.01: First try to update existing record\n      const { data: existing } = await supabase\n        .from('evolution_state')\n        .select('id')\n        .eq('state_type', 'benchmark_lock')\n        .maybeSingle();\n      \n      const payload = {\n        state_type: 'benchmark_lock',\n        genes: { \n          locked,\n          version: COORDINATOR_VERSION,\n          timestamp: new Date().toISOString(),\n        },\n        fitness_score: locked ? 0 : 100,\n        generation: 0,\n      };\n      \n      let error;\n      if (existing?.id) {\n        // Update existing record by ID (no conflict possible)\n        const result = await supabase\n          .from('evolution_state')\n          .update(payload)\n          .eq('id', existing.id);\n        error = result.error;\n      } else {\n        // Insert new with upsert as fallback\n        const result = await supabase\n          .from('evolution_state')\n          .upsert(payload, { \n            onConflict: 'state_type',\n            ignoreDuplicates: false \n          });\n        error = result.error;\n      }\n      \n      if (!error) {\n        console.log(`[${COORDINATOR_VERSION}] Database lock ${locked ? 'SET' : 'RELEASED'}`);\n        return;\n      }\n      \n      // If duplicate key error, retry after brief delay\n      if (error.message.includes('duplicate key') || error.message.includes('unique constraint')) {\n        if (attempt < maxRetries) {\n          await new Promise(r => setTimeout(r, 100 * attempt));\n          continue;\n        }\n      }\n      \n      console.warn(`[${COORDINATOR_VERSION}] Failed to set database lock:`, error);\n      return;\n      \n    } catch (err) {\n      if (attempt < maxRetries) {\n        await new Promise(r => setTimeout(r, 100 * attempt));\n        continue;\n      }\n      console.warn(`[${COORDINATOR_VERSION}] Database lock error:`, err);\n      return;\n    }\n  }\n}\n\n/**\n * Call this BEFORE starting a manual benchmark\n * Sets database lock + pauses client-side auto-evolution\n */\nexport async function acquireBenchmarkLock(): Promise<AbortController> {\n  if (state.manualBenchmarkActive) {\n    console.log(`[${COORDINATOR_VERSION}] Lock already held, returning existing abort controller`);\n    return state.abortController || new AbortController();\n  }\n  \n  console.log(`[${COORDINATOR_VERSION}] Acquiring benchmark lock...`);\n  \n  // Create abort controller for this benchmark session\n  state.abortController = new AbortController();\n  \n  // v7.42: Set database lock FIRST (so server-side cron yields)\n  await setDatabaseLock(true);\n  \n  // Check current auto-evolution state\n  const evolutionState = getEvolutionState();\n  state.wasAutoEvolutionRunning = evolutionState.isRunning && !evolutionState.isPaused;\n  \n  // Pause client-side auto-evolution if running\n  if (state.wasAutoEvolutionRunning) {\n    console.log(`[${COORDINATOR_VERSION}] Pausing client-side auto-evolution for manual benchmark`);\n    pauseAutoEvolution();\n    \n    // Quick wait for auto-evolution to yield\n    await new Promise(r => setTimeout(r, 100));\n  }\n  \n  state.manualBenchmarkActive = true;\n  state.startedAt = new Date();\n  \n  // Notify listeners\n  notifyListeners(true);\n  \n  console.log(`[${COORDINATOR_VERSION}] ✅ Benchmark lock acquired (database + client)`);\n  \n  return state.abortController;\n}\n\n/**\n * Call this AFTER a manual benchmark completes (success or failure)\n * Releases database lock + resumes auto-evolution if it was running before\n */\nexport async function releaseBenchmarkLock(): Promise<void> {\n  if (!state.manualBenchmarkActive) {\n    console.log(`[${COORDINATOR_VERSION}] No lock to release`);\n    return;\n  }\n  \n  const duration = state.startedAt \n    ? Math.round((Date.now() - state.startedAt.getTime()) / 1000) \n    : 0;\n  \n  console.log(`[${COORDINATOR_VERSION}] Releasing benchmark lock after ${duration}s`);\n  \n  // Signal abort to any remaining operations\n  if (state.abortController) {\n    state.abortController.abort();\n    state.abortController = null;\n  }\n  \n  state.manualBenchmarkActive = false;\n  state.startedAt = null;\n  \n  // Notify listeners\n  notifyListeners(false);\n  \n  // v7.42: Release database lock (so server-side cron can resume)\n  await setDatabaseLock(false);\n  \n  // Quick cleanup\n  await new Promise(r => setTimeout(r, 200));\n  \n  // Resume client-side auto-evolution if it was running before\n  if (state.wasAutoEvolutionRunning) {\n    console.log(`[${COORDINATOR_VERSION}] Resuming client-side auto-evolution`);\n    resumeAutoEvolution();\n  }\n  \n  state.wasAutoEvolutionRunning = false;\n  \n  console.log(`[${COORDINATOR_VERSION}] ✅ Benchmark lock released (database + client)`);\n}\n\n/**\n * Check if a manual benchmark is currently active\n * CRITICAL: Auto-evolution should check this before EVERY batch\n */\nexport function isManualBenchmarkActive(): boolean {\n  return state.manualBenchmarkActive;\n}\n\n/**\n * Get the current abort signal (for cancellation)\n */\nexport function getBenchmarkAbortSignal(): AbortSignal | null {\n  return state.abortController?.signal || null;\n}\n\n/**\n * Get coordinator state for debugging\n */\nexport function getCoordinatorState(): CoordinatorState & { hasAbortController: boolean } {\n  return { \n    ...state,\n    hasAbortController: state.abortController !== null,\n  };\n}\n";export{n as default};
