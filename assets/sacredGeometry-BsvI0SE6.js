const n="/**\n * Sacred Geometry Module\n * Fibonacci spirals, golden ratios, and geometric patterns in price data\n * Mathematics is the language of the universe - we listen through geometry\n */\n\n// Golden Ratio and Fibonacci Constants\nexport const PHI = 1.6180339887498948482; // Golden ratio\nexport const PHI_INVERSE = 0.6180339887498948482; // 1/PHI\nexport const PHI_SQUARED = 2.6180339887498948482; // PHI^2\n\n// Fibonacci Sequence (first 21 numbers)\nexport const FIBONACCI = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946];\n\n// Fibonacci Retracement Levels\nexport const FIBONACCI_RETRACEMENTS = {\n  0: 0,\n  0.236: 0.236,  // 1 - 0.764\n  0.382: 0.382,  // 1 - PHI_INVERSE\n  0.5: 0.5,      // Not Fibonacci but commonly used\n  0.618: 0.618,  // PHI_INVERSE\n  0.764: 0.764,  // 1 - 0.236\n  0.786: 0.786,  // sqrt(PHI_INVERSE)\n  1: 1,\n  1.272: 1.272,  // sqrt(PHI)\n  1.414: 1.414,  // sqrt(2)\n  1.618: 1.618,  // PHI\n  2.618: 2.618,  // PHI^2\n  4.236: 4.236   // PHI^3\n};\n\n// Sacred Geometric Patterns\nexport const SACRED_PATTERNS = {\n  vesica_piscis: {\n    name: 'Vesica Piscis',\n    ratio: Math.sqrt(3),\n    meaning: 'Creation, intersection of two realms',\n    pricePattern: 'Symmetrical consolidation'\n  },\n  flower_of_life: {\n    name: 'Flower of Life',\n    circles: 19,\n    meaning: 'Universal pattern of creation',\n    pricePattern: 'Multi-level support/resistance grid'\n  },\n  metatrons_cube: {\n    name: 'Metatrons Cube',\n    vertices: 13,\n    meaning: 'Contains all platonic solids',\n    pricePattern: 'Five-wave price structure'\n  },\n  seed_of_life: {\n    name: 'Seed of Life',\n    circles: 7,\n    meaning: 'Genesis, seven days of creation',\n    pricePattern: 'Weekly cycle completion'\n  }\n};\n\n// Price Pattern Analysis Results\nexport interface GeometricAnalysis {\n  nearestFibLevel: number;\n  distanceFromLevel: number;\n  levelStrength: 'strong' | 'moderate' | 'weak';\n  fibonacciZone: 'expansion' | 'retracement' | 'neutral';\n  goldenRatioAlignment: number; // 0-1 how aligned with golden ratio\n  spiralPhase: number; // 0-1 position in fibonacci spiral\n  patternDetected: string | null;\n  harmonicRatios: number[];\n  sacredScore: number; // Overall geometric significance 0-1\n}\n\n// Detect Fibonacci levels in price action\nexport function detectFibonacciLevels(\n  prices: number[],\n  swingHigh: number,\n  swingLow: number\n): { level: number; price: number; distance: number }[] {\n  const range = swingHigh - swingLow;\n  const levels: { level: number; price: number; distance: number }[] = [];\n  \n  for (const [name, level] of Object.entries(FIBONACCI_RETRACEMENTS)) {\n    const priceAtLevel = swingLow + (range * level);\n    const currentPrice = prices[prices.length - 1];\n    const distance = Math.abs(currentPrice - priceAtLevel) / currentPrice;\n    \n    levels.push({\n      level: level,\n      price: priceAtLevel,\n      distance\n    });\n  }\n  \n  return levels.sort((a, b) => a.distance - b.distance);\n}\n\n// Calculate Fibonacci spiral position\nexport function calculateSpiralPosition(\n  prices: number[],\n  lookback: number = 144 // Fibonacci number\n): number {\n  if (prices.length < lookback) return 0.5;\n  \n  const recentPrices = prices.slice(-lookback);\n  const high = Math.max(...recentPrices);\n  const low = Math.min(...recentPrices);\n  const current = recentPrices[recentPrices.length - 1];\n  \n  // Position in the range as spiral phase\n  const position = (current - low) / (high - low || 1);\n  \n  // Apply golden ratio modulation\n  return (position * PHI) % 1;\n}\n\n// Detect harmonic ratios in price swings\nexport function detectHarmonicRatios(swings: number[]): number[] {\n  if (swings.length < 2) return [];\n  \n  const ratios: number[] = [];\n  \n  for (let i = 1; i < swings.length; i++) {\n    const ratio = Math.abs(swings[i]) / Math.abs(swings[i - 1] || 1);\n    ratios.push(ratio);\n  }\n  \n  return ratios;\n}\n\n// Check if a ratio is close to a Fibonacci ratio\nexport function isFibonacciRatio(ratio: number, tolerance: number = 0.02): boolean {\n  const fibRatios = [0.236, 0.382, 0.5, 0.618, 0.786, 1.0, 1.272, 1.618, 2.618];\n  \n  return fibRatios.some(fibRatio => Math.abs(ratio - fibRatio) <= tolerance);\n}\n\n// Calculate golden ratio alignment\nexport function calculateGoldenRatioAlignment(\n  value1: number,\n  value2: number\n): number {\n  const ratio = Math.max(value1, value2) / Math.min(value1, value2);\n  const distanceFromPhi = Math.abs(ratio - PHI);\n  \n  // Convert distance to alignment score (closer = higher score)\n  return Math.max(0, 1 - (distanceFromPhi / PHI));\n}\n\n// Comprehensive geometric analysis\nexport function analyzeGeometry(\n  prices: number[],\n  swingHigh: number,\n  swingLow: number,\n  recentSwings: number[] = []\n): GeometricAnalysis {\n  const currentPrice = prices[prices.length - 1];\n  const range = swingHigh - swingLow;\n  \n  // Find nearest Fibonacci level\n  const fibLevels = detectFibonacciLevels(prices, swingHigh, swingLow);\n  const nearestLevel = fibLevels[0];\n  \n  // Determine level strength based on significance of the Fibonacci number\n  const strongLevels = [0.382, 0.5, 0.618, 1.618];\n  const moderateLevels = [0.236, 0.764, 0.786, 1.272];\n  let levelStrength: 'strong' | 'moderate' | 'weak';\n  \n  if (strongLevels.some(l => Math.abs(nearestLevel.level - l) < 0.01)) {\n    levelStrength = 'strong';\n  } else if (moderateLevels.some(l => Math.abs(nearestLevel.level - l) < 0.01)) {\n    levelStrength = 'moderate';\n  } else {\n    levelStrength = 'weak';\n  }\n  \n  // Determine Fibonacci zone\n  const retracement = (currentPrice - swingLow) / range;\n  let fibonacciZone: 'expansion' | 'retracement' | 'neutral';\n  if (retracement > 1) fibonacciZone = 'expansion';\n  else if (retracement < 0) fibonacciZone = 'retracement';\n  else fibonacciZone = 'neutral';\n  \n  // Calculate golden ratio alignment from recent price action\n  let goldenRatioAlignment = 0;\n  if (prices.length >= 3) {\n    const move1 = Math.abs(prices[prices.length - 1] - prices[prices.length - 2]);\n    const move2 = Math.abs(prices[prices.length - 2] - prices[prices.length - 3]);\n    goldenRatioAlignment = calculateGoldenRatioAlignment(move1, move2);\n  }\n  \n  // Spiral phase\n  const spiralPhase = calculateSpiralPosition(prices);\n  \n  // Harmonic ratios in swings\n  const harmonicRatios = detectHarmonicRatios(recentSwings);\n  const fibonacciHarmonics = harmonicRatios.filter(r => isFibonacciRatio(r));\n  \n  // Detect sacred pattern\n  let patternDetected: string | null = null;\n  if (fibonacciHarmonics.length >= 3) {\n    patternDetected = 'Fibonacci Harmonic Pattern';\n  } else if (goldenRatioAlignment > 0.8) {\n    patternDetected = 'Golden Ratio Price Action';\n  }\n  \n  // Calculate sacred score\n  const sacredScore = calculateSacredScore(\n    nearestLevel.distance,\n    levelStrength,\n    goldenRatioAlignment,\n    fibonacciHarmonics.length,\n    harmonicRatios.length\n  );\n  \n  return {\n    nearestFibLevel: nearestLevel.level,\n    distanceFromLevel: nearestLevel.distance,\n    levelStrength,\n    fibonacciZone,\n    goldenRatioAlignment,\n    spiralPhase,\n    patternDetected,\n    harmonicRatios,\n    sacredScore\n  };\n}\n\n// Calculate overall sacred geometry score\nfunction calculateSacredScore(\n  distanceFromLevel: number,\n  levelStrength: 'strong' | 'moderate' | 'weak',\n  goldenAlignment: number,\n  fibHarmonicCount: number,\n  totalHarmonics: number\n): number {\n  let score = 0;\n  \n  // Distance from Fibonacci level (closer = higher score)\n  score += Math.max(0, 0.25 - distanceFromLevel) * 1.5;\n  \n  // Level strength bonus\n  if (levelStrength === 'strong') score += 0.2;\n  else if (levelStrength === 'moderate') score += 0.1;\n  \n  // Golden ratio alignment\n  score += goldenAlignment * 0.25;\n  \n  // Fibonacci harmonic ratio\n  if (totalHarmonics > 0) {\n    score += (fibHarmonicCount / totalHarmonics) * 0.2;\n  }\n  \n  return Math.min(1, score);\n}\n\n// Get Fibonacci extension targets\nexport function getFibonacciExtensions(\n  swingLow: number,\n  swingHigh: number,\n  direction: 'up' | 'down'\n): { level: number; price: number }[] {\n  const range = Math.abs(swingHigh - swingLow);\n  const extensionLevels = [1.272, 1.414, 1.618, 2.0, 2.618, 4.236];\n  \n  return extensionLevels.map(level => ({\n    level,\n    price: direction === 'up' \n      ? swingHigh + (range * (level - 1))\n      : swingLow - (range * (level - 1))\n  }));\n}\n\n// Sacred Geometry Overlay data for visualization\nexport interface SacredGeometryOverlay {\n  fibonacciLevels: { level: number; price: number; distance: number }[];\n  extensions: { level: number; price: number }[];\n  spiralPhase: number;\n  goldenZones: { start: number; end: number }[];\n  sacredScore: number;\n  currentAnalysis: GeometricAnalysis;\n}\n\n// Generate overlay data for charts\nexport function generateSacredOverlay(\n  prices: number[],\n  swingHigh: number,\n  swingLow: number,\n  direction: 'up' | 'down' = 'up'\n): SacredGeometryOverlay {\n  const fibLevels = detectFibonacciLevels(prices, swingHigh, swingLow);\n  const extensions = getFibonacciExtensions(swingLow, swingHigh, direction);\n  const analysis = analyzeGeometry(prices, swingHigh, swingLow);\n  \n  // Golden zones are 0.618 retracement areas\n  const range = swingHigh - swingLow;\n  const goldenZones = [\n    { start: swingLow + range * 0.5, end: swingLow + range * 0.618 },\n    { start: swingLow + range * 0.618, end: swingLow + range * 0.786 }\n  ];\n  \n  return {\n    fibonacciLevels: fibLevels,\n    extensions,\n    spiralPhase: analysis.spiralPhase,\n    goldenZones,\n    sacredScore: analysis.sacredScore,\n    currentAnalysis: analysis\n  };\n}\n\n// Export module\nexport const sacredGeometry = {\n  PHI,\n  PHI_INVERSE,\n  FIBONACCI,\n  FIBONACCI_RETRACEMENTS,\n  SACRED_PATTERNS,\n  \n  detectFibonacciLevels,\n  calculateSpiralPosition,\n  detectHarmonicRatios,\n  isFibonacciRatio,\n  calculateGoldenRatioAlignment,\n  analyzeGeometry,\n  getFibonacciExtensions,\n  generateSacredOverlay,\n  \n  philosophy: `\n    The universe writes its laws in geometry.\n    Fibonacci appears in galaxies, hurricanes, flowers, and DNA.\n    Why would markets - collective human action - be exempt from this universal pattern?\n    The golden ratio is not mysticism - it is mathematics made manifest.\n    When price touches a Fibonacci level, it touches the structure of reality.\n    Sacred geometry is simply the recognition that pattern is primary.\n  `\n};\n\nexport default sacredGeometry;\n";export{n as default};
