const n="import { Chess, Move } from 'chess.js';\n\nexport interface PgnFixSuggestion {\n  originalMove: string;\n  suggestedMove: string;\n  moveNumber: number;\n  reason: string;\n  confidence: 'high' | 'medium' | 'low';\n}\n\nexport interface PgnFixResult {\n  canFix: boolean;\n  fixedPgn?: string;\n  suggestions: PgnFixSuggestion[];\n  originalError: string;\n}\n\n/**\n * Common move notation corrections\n */\nconst COMMON_TYPOS: Record<string, string[]> = {\n  // Castle notation variants\n  '0-0': ['O-O'],\n  '0-0-0': ['O-O-O'],\n  'o-o': ['O-O'],\n  'o-o-o': ['O-O-O'],\n  // Common OCR/typing errors\n  'l': ['1'],\n  'O': ['0'],\n  'I': ['1'],\n};\n\n/**\n * Attempts to fix an invalid PGN by analyzing and correcting common issues\n */\nexport function fixPgn(pgn: string): PgnFixResult {\n  const chess = new Chess();\n  const suggestions: PgnFixSuggestion[] = [];\n  \n  // First check if PGN is actually valid\n  try {\n    chess.loadPgn(pgn);\n    return {\n      canFix: true,\n      fixedPgn: pgn,\n      suggestions: [],\n      originalError: 'PGN is already valid',\n    };\n  } catch (e) {\n    // Continue to fix\n  }\n\n  // Extract headers and moves section\n  const headerMatches = pgn.match(/\\[[^\\]]*\\]/g) || [];\n  const headers = headerMatches.join('\\n');\n  let movesSection = pgn.replace(/\\[[^\\]]*\\]/g, '').trim();\n  \n  // Store original moves section for reference\n  const originalMovesSection = movesSection;\n  \n  // Clean up common formatting issues\n  movesSection = movesSection\n    .replace(/\\{[^}]*\\}/g, '') // Remove comments\n    .replace(/\\([^)]*\\)/g, '') // Remove variations  \n    .replace(/\\$\\d+/g, '') // Remove NAG annotations\n    .replace(/1-0|0-1|1\\/2-1\\/2|\\*/g, '') // Remove results temporarily\n    .trim();\n\n  // Parse move tokens\n  const tokens = movesSection.split(/\\s+/).filter(t => t.length > 0);\n  const fixedMoves: string[] = [];\n  let currentMoveNumber = 1;\n  let isWhiteMove = true;\n  \n  chess.reset();\n  \n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    \n    // Skip move numbers\n    if (token.match(/^\\d+\\.+$/)) {\n      const num = parseInt(token);\n      if (!isNaN(num)) {\n        currentMoveNumber = num;\n        isWhiteMove = !token.includes('...');\n      }\n      continue;\n    }\n    \n    if (token === '...') {\n      isWhiteMove = false;\n      continue;\n    }\n    \n    // Try the move as-is first\n    const moveResult = tryMove(chess, token);\n    \n    if (moveResult) {\n      fixedMoves.push(moveResult.san);\n      isWhiteMove = !isWhiteMove;\n      if (!isWhiteMove) currentMoveNumber++;\n      continue;\n    }\n    \n    // Try to fix the move\n    const fixResult = attemptMoveFix(chess, token, currentMoveNumber, isWhiteMove);\n    \n    if (fixResult) {\n      suggestions.push({\n        originalMove: token,\n        suggestedMove: fixResult.move.san,\n        moveNumber: currentMoveNumber,\n        reason: fixResult.reason,\n        confidence: fixResult.confidence,\n      });\n      \n      fixedMoves.push(fixResult.move.san);\n      isWhiteMove = !isWhiteMove;\n      if (!isWhiteMove) currentMoveNumber++;\n    } else {\n      // Cannot fix this move - try to suggest alternatives\n      const legalMoves = chess.moves();\n      const similarMoves = findSimilarMoves(token, legalMoves);\n      \n      if (similarMoves.length > 0) {\n        // Use the most similar legal move\n        const bestMatch = similarMoves[0];\n        const move = chess.move(bestMatch);\n        if (move) {\n          suggestions.push({\n            originalMove: token,\n            suggestedMove: bestMatch,\n            moveNumber: currentMoveNumber,\n            reason: `\"${token}\" is not legal. Closest legal move: \"${bestMatch}\"`,\n            confidence: 'low',\n          });\n          fixedMoves.push(move.san);\n          isWhiteMove = !isWhiteMove;\n          if (!isWhiteMove) currentMoveNumber++;\n          continue;\n        }\n      }\n      \n      // Cannot fix - return partial result\n      return {\n        canFix: false,\n        suggestions,\n        originalError: `Cannot determine correct move for \"${token}\" at move ${currentMoveNumber}. No similar legal moves found.`,\n      };\n    }\n  }\n  \n  // Reconstruct the PGN\n  let fixedPgn = headers ? headers + '\\n\\n' : '';\n  \n  for (let i = 0; i < fixedMoves.length; i++) {\n    const moveNum = Math.floor(i / 2) + 1;\n    if (i % 2 === 0) {\n      fixedPgn += `${moveNum}. ${fixedMoves[i]} `;\n    } else {\n      fixedPgn += `${fixedMoves[i]} `;\n    }\n  }\n  \n  // Add result if it was in original\n  const resultMatch = originalMovesSection.match(/(1-0|0-1|1\\/2-1\\/2|\\*)$/);\n  if (resultMatch) {\n    fixedPgn += resultMatch[1];\n  }\n  \n  return {\n    canFix: true,\n    fixedPgn: fixedPgn.trim(),\n    suggestions,\n    originalError: suggestions.length > 0 \n      ? `Fixed ${suggestions.length} move(s)` \n      : 'PGN formatted correctly',\n  };\n}\n\nfunction tryMove(chess: Chess, move: string): Move | null {\n  try {\n    return chess.move(move);\n  } catch {\n    return null;\n  }\n}\n\ninterface FixAttempt {\n  move: Move;\n  reason: string;\n  confidence: 'high' | 'medium' | 'low';\n}\n\nfunction attemptMoveFix(\n  chess: Chess, \n  originalMove: string, \n  moveNumber: number,\n  isWhiteMove: boolean\n): FixAttempt | null {\n  const legalMoves = chess.moves({ verbose: true });\n  \n  // Try common typo corrections first\n  for (const [typo, corrections] of Object.entries(COMMON_TYPOS)) {\n    if (originalMove.toLowerCase().includes(typo.toLowerCase())) {\n      for (const correction of corrections) {\n        const correctedMove = originalMove.replace(new RegExp(typo, 'gi'), correction);\n        const result = tryMove(chess, correctedMove);\n        if (result) {\n          return {\n            move: result,\n            reason: `Fixed notation: \"${originalMove}\" → \"${correctedMove}\"`,\n            confidence: 'high',\n          };\n        }\n      }\n    }\n  }\n  \n  // Try castle notation fixes\n  if (originalMove.match(/^[0Oo]-[0Oo](-[0Oo])?$/i)) {\n    const isLongCastle = originalMove.length > 3;\n    const castleMove = isLongCastle ? 'O-O-O' : 'O-O';\n    const result = tryMove(chess, castleMove);\n    if (result) {\n      return {\n        move: result,\n        reason: `Fixed castle notation: \"${originalMove}\" → \"${castleMove}\"`,\n        confidence: 'high',\n      };\n    }\n  }\n  \n  // Try to find a move with the same piece to a similar square\n  const pieceMatch = originalMove.match(/^([KQRBN])?([a-h])?([1-8])?(x)?([a-h])([1-8])/i);\n  if (pieceMatch) {\n    const [, piece, fromFile, fromRank, capture, toFile, toRank] = pieceMatch;\n    const targetSquare = `${toFile}${toRank}`;\n    \n    // Find moves to the same target square\n    const movesToSquare = legalMoves.filter(m => m.to === targetSquare);\n    \n    if (movesToSquare.length === 1) {\n      const result = tryMove(chess, movesToSquare[0].san);\n      if (result) {\n        return {\n          move: result,\n          reason: `Corrected move to ${targetSquare}: \"${originalMove}\" → \"${result.san}\"`,\n          confidence: 'medium',\n        };\n      }\n    }\n    \n    // If piece is specified, filter by piece type\n    if (piece && movesToSquare.length > 1) {\n      const pieceType = piece.toLowerCase();\n      const pieceMatches = movesToSquare.filter(m => m.piece === pieceType);\n      if (pieceMatches.length === 1) {\n        const result = tryMove(chess, pieceMatches[0].san);\n        if (result) {\n          return {\n            move: result,\n            reason: `Corrected ${piece} move: \"${originalMove}\" → \"${result.san}\"`,\n            confidence: 'medium',\n          };\n        }\n      }\n    }\n  }\n  \n  // Try pawn moves with incorrect notation\n  if (originalMove.match(/^[a-h][1-8]/i)) {\n    const toSquare = originalMove.slice(0, 2).toLowerCase();\n    const pawnMoves = legalMoves.filter(m => m.piece === 'p' && m.to === toSquare);\n    if (pawnMoves.length === 1) {\n      const result = tryMove(chess, pawnMoves[0].san);\n      if (result) {\n        return {\n          move: result,\n          reason: `Fixed pawn move: \"${originalMove}\" → \"${result.san}\"`,\n          confidence: 'high',\n        };\n      }\n    }\n  }\n  \n  // Try removing extraneous characters\n  const cleanedMove = originalMove.replace(/[+#!?]+$/, '');\n  if (cleanedMove !== originalMove) {\n    const result = tryMove(chess, cleanedMove);\n    if (result) {\n      return {\n        move: result,\n        reason: `Removed extra characters: \"${originalMove}\" → \"${result.san}\"`,\n        confidence: 'high',\n      };\n    }\n  }\n  \n  return null;\n}\n\nfunction findSimilarMoves(invalidMove: string, legalMoves: string[]): string[] {\n  // Calculate similarity scores\n  const scored = legalMoves.map(legal => ({\n    move: legal,\n    score: calculateSimilarity(invalidMove.toLowerCase(), legal.toLowerCase()),\n  }));\n  \n  // Sort by similarity and return top matches\n  return scored\n    .filter(s => s.score > 0.3)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 3)\n    .map(s => s.move);\n}\n\nfunction calculateSimilarity(a: string, b: string): number {\n  // Simple Levenshtein-based similarity\n  const maxLen = Math.max(a.length, b.length);\n  if (maxLen === 0) return 1;\n  \n  const distance = levenshteinDistance(a, b);\n  return 1 - distance / maxLen;\n}\n\nfunction levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n  \n  for (let i = 0; i <= a.length; i++) {\n    matrix[i] = [i];\n  }\n  \n  for (let j = 0; j <= b.length; j++) {\n    matrix[0][j] = j;\n  }\n  \n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      if (a[i - 1] === b[j - 1]) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          matrix[i][j - 1] + 1,\n          matrix[i - 1][j] + 1\n        );\n      }\n    }\n  }\n  \n  return matrix[a.length][b.length];\n}\n\n/**\n * Generate a human-readable explanation of the fixes\n */\nexport function explainFixes(result: PgnFixResult): string {\n  if (!result.canFix) {\n    return result.originalError;\n  }\n  \n  if (result.suggestions.length === 0) {\n    return 'No fixes needed - PGN is valid.';\n  }\n  \n  const fixes = result.suggestions.map((s, i) => \n    `${i + 1}. Move ${s.moveNumber}: \"${s.originalMove}\" → \"${s.suggestedMove}\" (${s.reason})`\n  );\n  \n  return `Found ${result.suggestions.length} issue(s):\\n${fixes.join('\\n')}`;\n}\n";export{n as default};
