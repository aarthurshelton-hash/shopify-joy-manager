const n="/**\n * Quantum Probability Clouds\n * \n * Instead of single-point predictions, generates probability distributions\n * representing superposition of possible outcomes until \"measurement\" (actual result).\n * Prevents overconfidence and captures uncertainty properly.\n */\n\ninterface ProbabilityPoint {\n  value: number;\n  probability: number;\n}\n\ninterface ProbabilityCloud {\n  distribution: ProbabilityPoint[];\n  mean: number;\n  standardDeviation: number;\n  skewness: number; // Asymmetry\n  kurtosis: number; // Fat tails\n  confidenceIntervals: {\n    ci50: [number, number];\n    ci75: [number, number];\n    ci95: [number, number];\n  };\n  dominantOutcome: 'up' | 'down' | 'neutral';\n  outcomeDistribution: {\n    up: number;\n    down: number;\n    neutral: number;\n  };\n  entropy: number; // Uncertainty measure\n}\n\ninterface CloudCollapse {\n  predictedCloud: ProbabilityCloud;\n  actualOutcome: number;\n  wasWithinCI50: boolean;\n  wasWithinCI75: boolean;\n  wasWithinCI95: boolean;\n  collapsedAt: number;\n}\n\nclass QuantumProbabilityCloudGenerator {\n  private collapseHistory: CloudCollapse[] = [];\n  private readonly maxHistory = 500;\n  private readonly uncertaintyFloor = 0.1; // Minimum uncertainty to prevent overconfidence\n  \n  /**\n   * Generate a probability cloud from multiple prediction sources\n   */\n  generateCloud(\n    predictions: Array<{ value: number; confidence: number; source: string }>,\n    baseVolatility: number = 0.1\n  ): ProbabilityCloud {\n    if (predictions.length === 0) {\n      return this.generateUniformCloud();\n    }\n    \n    // Weight predictions by confidence\n    const totalWeight = predictions.reduce((sum, p) => sum + p.confidence, 0);\n    const weightedMean = predictions.reduce(\n      (sum, p) => sum + p.value * p.confidence, 0\n    ) / totalWeight;\n    \n    // Calculate weighted variance\n    const weightedVariance = predictions.reduce(\n      (sum, p) => sum + p.confidence * Math.pow(p.value - weightedMean, 2), 0\n    ) / totalWeight;\n    \n    // Add base volatility to prevent overconfidence\n    const adjustedVariance = weightedVariance + Math.pow(baseVolatility, 2) + Math.pow(this.uncertaintyFloor, 2);\n    const standardDeviation = Math.sqrt(adjustedVariance);\n    \n    // Generate distribution points\n    const distribution = this.generateGaussianMixture(predictions, standardDeviation);\n    \n    // Calculate moments\n    const skewness = this.calculateSkewness(distribution);\n    const kurtosis = this.calculateKurtosis(distribution);\n    \n    // Calculate confidence intervals\n    const sortedPoints = [...distribution].sort((a, b) => a.value - b.value);\n    const ci50 = this.calculateConfidenceInterval(sortedPoints, 0.50);\n    const ci75 = this.calculateConfidenceInterval(sortedPoints, 0.75);\n    const ci95 = this.calculateConfidenceInterval(sortedPoints, 0.95);\n    \n    // Calculate outcome distribution\n    const outcomeDistribution = this.calculateOutcomeDistribution(distribution);\n    \n    // Determine dominant outcome\n    const dominantOutcome = outcomeDistribution.up > outcomeDistribution.down \n      ? (outcomeDistribution.up > outcomeDistribution.neutral ? 'up' : 'neutral')\n      : (outcomeDistribution.down > outcomeDistribution.neutral ? 'down' : 'neutral');\n    \n    // Calculate entropy (uncertainty)\n    const entropy = this.calculateEntropy(outcomeDistribution);\n    \n    return {\n      distribution,\n      mean: weightedMean,\n      standardDeviation,\n      skewness,\n      kurtosis,\n      confidenceIntervals: { ci50, ci75, ci95 },\n      dominantOutcome,\n      outcomeDistribution,\n      entropy,\n    };\n  }\n  \n  /**\n   * Generate a uniform (maximum uncertainty) cloud\n   */\n  private generateUniformCloud(): ProbabilityCloud {\n    const distribution: ProbabilityPoint[] = [];\n    for (let i = -1; i <= 1; i += 0.1) {\n      distribution.push({ value: i, probability: 1 / 21 });\n    }\n    \n    return {\n      distribution,\n      mean: 0,\n      standardDeviation: 0.5,\n      skewness: 0,\n      kurtosis: 0,\n      confidenceIntervals: {\n        ci50: [-0.25, 0.25],\n        ci75: [-0.5, 0.5],\n        ci95: [-0.9, 0.9],\n      },\n      dominantOutcome: 'neutral',\n      outcomeDistribution: { up: 0.33, down: 0.33, neutral: 0.34 },\n      entropy: 1.0,\n    };\n  }\n  \n  /**\n   * Generate a Gaussian mixture from multiple predictions\n   */\n  private generateGaussianMixture(\n    predictions: Array<{ value: number; confidence: number }>,\n    globalSd: number\n  ): ProbabilityPoint[] {\n    const points: Map<number, number> = new Map();\n    const step = 0.02;\n    \n    for (let x = -1; x <= 1; x += step) {\n      let totalProbability = 0;\n      let totalWeight = 0;\n      \n      for (const pred of predictions) {\n        const localSd = globalSd / Math.sqrt(pred.confidence + 0.1);\n        const probability = this.gaussianPDF(x, pred.value, localSd);\n        totalProbability += probability * pred.confidence;\n        totalWeight += pred.confidence;\n      }\n      \n      points.set(Math.round(x * 100) / 100, totalWeight > 0 ? totalProbability / totalWeight : 0);\n    }\n    \n    // Normalize\n    const sum = Array.from(points.values()).reduce((a, b) => a + b, 0);\n    const distribution: ProbabilityPoint[] = [];\n    \n    for (const [value, prob] of points) {\n      distribution.push({ value, probability: sum > 0 ? prob / sum : 0 });\n    }\n    \n    return distribution;\n  }\n  \n  /**\n   * Gaussian probability density function\n   */\n  private gaussianPDF(x: number, mean: number, sd: number): number {\n    const coefficient = 1 / (sd * Math.sqrt(2 * Math.PI));\n    const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(sd, 2));\n    return coefficient * Math.exp(exponent);\n  }\n  \n  /**\n   * Calculate skewness (asymmetry)\n   */\n  private calculateSkewness(distribution: ProbabilityPoint[]): number {\n    const mean = distribution.reduce((sum, p) => sum + p.value * p.probability, 0);\n    const variance = distribution.reduce((sum, p) => sum + Math.pow(p.value - mean, 2) * p.probability, 0);\n    const sd = Math.sqrt(variance);\n    \n    if (sd === 0) return 0;\n    \n    const m3 = distribution.reduce((sum, p) => sum + Math.pow((p.value - mean) / sd, 3) * p.probability, 0);\n    return m3;\n  }\n  \n  /**\n   * Calculate kurtosis (fat tails)\n   */\n  private calculateKurtosis(distribution: ProbabilityPoint[]): number {\n    const mean = distribution.reduce((sum, p) => sum + p.value * p.probability, 0);\n    const variance = distribution.reduce((sum, p) => sum + Math.pow(p.value - mean, 2) * p.probability, 0);\n    const sd = Math.sqrt(variance);\n    \n    if (sd === 0) return 0;\n    \n    const m4 = distribution.reduce((sum, p) => sum + Math.pow((p.value - mean) / sd, 4) * p.probability, 0);\n    return m4 - 3; // Excess kurtosis (0 for normal distribution)\n  }\n  \n  /**\n   * Calculate confidence interval from sorted distribution\n   */\n  private calculateConfidenceInterval(\n    sortedPoints: ProbabilityPoint[],\n    confidenceLevel: number\n  ): [number, number] {\n    const tail = (1 - confidenceLevel) / 2;\n    \n    let cumulative = 0;\n    let lowerBound = sortedPoints[0].value;\n    let upperBound = sortedPoints[sortedPoints.length - 1].value;\n    \n    for (const point of sortedPoints) {\n      cumulative += point.probability;\n      if (cumulative >= tail && lowerBound === sortedPoints[0].value) {\n        lowerBound = point.value;\n      }\n      if (cumulative >= 1 - tail) {\n        upperBound = point.value;\n        break;\n      }\n    }\n    \n    return [lowerBound, upperBound];\n  }\n  \n  /**\n   * Calculate outcome distribution (up/down/neutral)\n   */\n  private calculateOutcomeDistribution(distribution: ProbabilityPoint[]): { up: number; down: number; neutral: number } {\n    const neutralThreshold = 0.02; // ±2% is considered neutral\n    \n    let up = 0, down = 0, neutral = 0;\n    \n    for (const point of distribution) {\n      if (point.value > neutralThreshold) {\n        up += point.probability;\n      } else if (point.value < -neutralThreshold) {\n        down += point.probability;\n      } else {\n        neutral += point.probability;\n      }\n    }\n    \n    return { up, down, neutral };\n  }\n  \n  /**\n   * Calculate entropy (uncertainty measure)\n   */\n  private calculateEntropy(outcomeDistribution: { up: number; down: number; neutral: number }): number {\n    const values = [outcomeDistribution.up, outcomeDistribution.down, outcomeDistribution.neutral];\n    let entropy = 0;\n    \n    for (const p of values) {\n      if (p > 0) {\n        entropy -= p * Math.log2(p);\n      }\n    }\n    \n    // Normalize to 0-1 (max entropy for 3 outcomes is log2(3) ≈ 1.58)\n    return entropy / Math.log2(3);\n  }\n  \n  /**\n   * Record a \"wave function collapse\" when actual outcome is known\n   */\n  recordCollapse(cloud: ProbabilityCloud, actualOutcome: number): void {\n    const collapse: CloudCollapse = {\n      predictedCloud: cloud,\n      actualOutcome,\n      wasWithinCI50: actualOutcome >= cloud.confidenceIntervals.ci50[0] && \n                     actualOutcome <= cloud.confidenceIntervals.ci50[1],\n      wasWithinCI75: actualOutcome >= cloud.confidenceIntervals.ci75[0] && \n                     actualOutcome <= cloud.confidenceIntervals.ci75[1],\n      wasWithinCI95: actualOutcome >= cloud.confidenceIntervals.ci95[0] && \n                     actualOutcome <= cloud.confidenceIntervals.ci95[1],\n      collapsedAt: Date.now(),\n    };\n    \n    this.collapseHistory.push(collapse);\n    \n    if (this.collapseHistory.length > this.maxHistory) {\n      this.collapseHistory.shift();\n    }\n  }\n  \n  /**\n   * Get calibration statistics\n   */\n  getCalibrationStats(): {\n    ci50Coverage: number;\n    ci75Coverage: number;\n    ci95Coverage: number;\n    isWellCalibrated: boolean;\n  } {\n    if (this.collapseHistory.length < 10) {\n      return { ci50Coverage: 0.5, ci75Coverage: 0.75, ci95Coverage: 0.95, isWellCalibrated: true };\n    }\n    \n    const ci50Coverage = this.collapseHistory.filter(c => c.wasWithinCI50).length / this.collapseHistory.length;\n    const ci75Coverage = this.collapseHistory.filter(c => c.wasWithinCI75).length / this.collapseHistory.length;\n    const ci95Coverage = this.collapseHistory.filter(c => c.wasWithinCI95).length / this.collapseHistory.length;\n    \n    // Well-calibrated if actual coverage is close to expected\n    const isWellCalibrated = \n      Math.abs(ci50Coverage - 0.50) < 0.15 &&\n      Math.abs(ci75Coverage - 0.75) < 0.10 &&\n      Math.abs(ci95Coverage - 0.95) < 0.05;\n    \n    return { ci50Coverage, ci75Coverage, ci95Coverage, isWellCalibrated };\n  }\n  \n  /**\n   * Get confidence modifier based on cloud characteristics\n   */\n  getConfidenceModifier(cloud: ProbabilityCloud): number {\n    // Lower entropy = more confident\n    const entropyModifier = 1 - (cloud.entropy * 0.3);\n    \n    // Higher kurtosis (fat tails) = more uncertainty\n    const kurtosisModifier = 1 - Math.min(0.2, Math.abs(cloud.kurtosis) * 0.05);\n    \n    // Check calibration\n    const calibration = this.getCalibrationStats();\n    const calibrationModifier = calibration.isWellCalibrated ? 1.05 : 0.95;\n    \n    return entropyModifier * kurtosisModifier * calibrationModifier;\n  }\n}\n\nexport const quantumProbabilityCloudGenerator = new QuantumProbabilityCloudGenerator();\nexport type { ProbabilityCloud, ProbabilityPoint, CloudCollapse };\n";export{n as default};
