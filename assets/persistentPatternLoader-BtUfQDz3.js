const n="/**\n * Persistent Pattern Loader v7.13\n * \n * Loads learned patterns from the database into the in-memory pattern system.\n * Ensures En Pensent's predictions leverage ALL historical knowledge from\n * the 802+ validated positions in chess_prediction_attempts.\n * \n * v7.13: Added timeout protection to prevent DB calls from blocking pipeline\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport { patternDatabase } from './patternDatabase';\nimport { PatternRecord } from './types';\nimport { StrategicArchetype } from '../colorFlowAnalysis';\n\n// v7.14-FAST: Reduced timeouts for faster benchmark startup\nconst DB_TIMEOUT_MS = 8000; // 8 seconds max (was 15s)\nconst MAX_PAGES = 5; // v7.14: Limit to 5 pages (was 10)\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number, name: string): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => \n      setTimeout(() => reject(new Error(`${name} timeout after ${ms}ms`)), ms)\n    )\n  ]);\n}\n\ninterface LearnedPattern {\n  id: string;\n  fen: string;\n  hybrid_archetype: string | null;\n  hybrid_confidence: number | null;\n  hybrid_correct: boolean | null;\n  actual_result: string;\n  lesson_learned: Record<string, unknown> | null;\n  stockfish_correct: boolean | null;\n}\n\n// Track if we've loaded patterns this session\nlet patternsLoaded = false;\nlet loadedPatternCount = 0;\n\n/**\n * Load all learned patterns from the database into the in-memory pattern system\n * This ensures predictions use historical knowledge from all 802+ validated positions\n */\nexport async function loadLearnedPatterns(): Promise<{\n  loaded: number;\n  hybridWins: number;\n  stockfishWins: number;\n  totalAccuracy: number;\n}> {\n  if (patternsLoaded && loadedPatternCount > 0) {\n    console.log(`[PatternLoader] Already loaded ${loadedPatternCount} patterns this session`);\n    return {\n      loaded: loadedPatternCount,\n      hybridWins: 0,\n      stockfishWins: 0,\n      totalAccuracy: 0,\n    };\n  }\n\n  console.log('[PatternLoader] Loading patterns (fast mode)...');\n  \n  const patterns: LearnedPattern[] = [];\n  let from = 0;\n  const pageSize = 500;\n  let hasMore = true;\n  let pageCount = 0;\n\n  // v7.14: Fast pagination with reduced limits\n  while (hasMore && pageCount < MAX_PAGES) {\n    pageCount++;\n    \n    try {\n      // v7.13: Create proper Promise with timeout\n      const fetchPage = async () => {\n        return await supabase\n          .from('chess_prediction_attempts')\n          .select('id, fen, hybrid_archetype, hybrid_confidence, hybrid_correct, actual_result, lesson_learned, stockfish_correct')\n          .range(from, from + pageSize - 1);\n      };\n      \n      const result = await withTimeout(\n        fetchPage(),\n        DB_TIMEOUT_MS,\n        `PatternPage${pageCount}`\n      );\n\n      if (result.error) {\n        console.error('[PatternLoader] Error loading patterns:', result.error);\n        break;\n      }\n\n      if (!result.data || result.data.length === 0) {\n        hasMore = false;\n        break;\n      }\n\n      patterns.push(...(result.data as LearnedPattern[]));\n      from += pageSize;\n      hasMore = result.data.length === pageSize;\n    } catch (err) {\n      console.warn(`[PatternLoader] Page ${pageCount} failed (timeout?):`, err);\n      // Continue with what we have rather than failing completely\n      break;\n    }\n  }\n\n  // Calculate statistics\n  let hybridWins = 0;\n  let stockfishWins = 0;\n  let hybridCorrect = 0;\n\n  for (const pattern of patterns) {\n    // Count wins\n    if (pattern.hybrid_correct && !pattern.stockfish_correct) {\n      hybridWins++;\n    }\n    if (pattern.stockfish_correct && !pattern.hybrid_correct) {\n      stockfishWins++;\n    }\n    if (pattern.hybrid_correct) {\n      hybridCorrect++;\n    }\n\n    // Inject learned patterns into the in-memory database\n    // Focus on patterns where we were correct - these are validated insights\n    if (pattern.hybrid_correct && pattern.hybrid_archetype) {\n      const outcome = normalizeOutcome(pattern.actual_result);\n      const archetype = normalizeArchetype(pattern.hybrid_archetype);\n      \n      if (outcome && archetype) {\n        // Create a synthetic pattern record from the learned prediction\n        const syntheticPattern: PatternRecord = {\n          id: pattern.id,\n          fingerprint: pattern.fen.substring(0, 20), // Use FEN as fingerprint\n          archetype,\n          outcome,\n          totalMoves: 30, // Estimate\n          characteristics: {\n            flowDirection: 'balanced',\n            intensity: pattern.hybrid_confidence || 0.5,\n            volatility: 0.3,\n            dominantSide: outcome === 'white_wins' ? 'white' : outcome === 'black_wins' ? 'black' : 'contested',\n            centerControl: 0.5,\n            kingsideActivity: 0.5,\n            queensideActivity: 0.5,\n          },\n          gameMetadata: {\n            event: 'Learned Pattern',\n            white: 'GM',\n            black: 'GM',\n          },\n        };\n\n        // Add to in-memory database for pattern matching\n        patternDatabase.injectLearnedPattern(syntheticPattern);\n      }\n    }\n  }\n\n  const totalAccuracy = patterns.length > 0 ? (hybridCorrect / patterns.length) * 100 : 0;\n\n  patternsLoaded = true;\n  loadedPatternCount = patterns.length;\n\n  console.log(`[PatternLoader] Loaded ${patterns.length} patterns:`);\n  console.log(`  - Hybrid wins over Stockfish: ${hybridWins}`);\n  console.log(`  - Stockfish wins over Hybrid: ${stockfishWins}`);\n  console.log(`  - Overall accuracy: ${totalAccuracy.toFixed(1)}%`);\n\n  return {\n    loaded: patterns.length,\n    hybridWins,\n    stockfishWins,\n    totalAccuracy,\n  };\n}\n\n/**\n * Get archetype-specific insights from historical data\n */\nexport async function getArchetypeInsights(archetype: string): Promise<{\n  accuracy: number;\n  sampleSize: number;\n  bestConfidenceThreshold: number;\n  beatsStockfishRate: number;\n}> {\n  const { data, error } = await supabase\n    .from('chess_prediction_attempts')\n    .select('hybrid_correct, hybrid_confidence, stockfish_correct')\n    .eq('hybrid_archetype', archetype);\n\n  if (error || !data || data.length === 0) {\n    return {\n      accuracy: 50,\n      sampleSize: 0,\n      bestConfidenceThreshold: 0.5,\n      beatsStockfishRate: 0,\n    };\n  }\n\n  const correct = data.filter(d => d.hybrid_correct).length;\n  const beatsStockfish = data.filter(d => d.hybrid_correct && !d.stockfish_correct).length;\n  \n  // Find optimal confidence threshold\n  const confidences = data.map(d => d.hybrid_confidence || 0.5);\n  const avgConfidenceWhenCorrect = data\n    .filter(d => d.hybrid_correct)\n    .reduce((sum, d) => sum + (d.hybrid_confidence || 0.5), 0) / Math.max(1, correct);\n\n  return {\n    accuracy: (correct / data.length) * 100,\n    sampleSize: data.length,\n    bestConfidenceThreshold: avgConfidenceWhenCorrect,\n    beatsStockfishRate: (beatsStockfish / data.length) * 100,\n  };\n}\n\n/**\n * Get patterns where En Pensent beat Stockfish (breakthrough cases)\n */\nexport async function getBreakthroughPatterns(): Promise<{\n  count: number;\n  archetypes: Record<string, number>;\n  avgConfidence: number;\n}> {\n  const { data, error } = await supabase\n    .from('chess_prediction_attempts')\n    .select('hybrid_archetype, hybrid_confidence')\n    .eq('hybrid_correct', true)\n    .eq('stockfish_correct', false);\n\n  if (error || !data) {\n    return { count: 0, archetypes: {}, avgConfidence: 0 };\n  }\n\n  const archetypes: Record<string, number> = {};\n  let totalConfidence = 0;\n\n  for (const d of data) {\n    const arch = d.hybrid_archetype || 'Unknown';\n    archetypes[arch] = (archetypes[arch] || 0) + 1;\n    totalConfidence += d.hybrid_confidence || 0.5;\n  }\n\n  return {\n    count: data.length,\n    archetypes,\n    avgConfidence: data.length > 0 ? totalConfidence / data.length : 0,\n  };\n}\n\n/**\n * Reset the loaded state (for testing)\n */\nexport function resetPatternLoader(): void {\n  patternsLoaded = false;\n  loadedPatternCount = 0;\n}\n\n/**\n * Normalize outcome string to standard format\n */\nfunction normalizeOutcome(result: string): 'white_wins' | 'black_wins' | 'draw' | null {\n  const lower = result.toLowerCase();\n  if (lower === 'white' || lower === 'white_wins') return 'white_wins';\n  if (lower === 'black' || lower === 'black_wins') return 'black_wins';\n  if (lower === 'draw') return 'draw';\n  return null;\n}\n\n/**\n * Normalize archetype string to valid StrategicArchetype\n */\nfunction normalizeArchetype(archetype: string): StrategicArchetype | null {\n  const validArchetypes: StrategicArchetype[] = [\n    'kingside_attack',\n    'queenside_expansion', \n    'central_domination',\n    'prophylactic_defense',\n    'pawn_storm',\n    'piece_harmony',\n    'opposite_castling',\n    'closed_maneuvering',\n    'open_tactical',\n    'endgame_technique',\n    'sacrificial_attack',\n    'positional_squeeze',\n    'unknown',\n  ];\n  \n  const lower = archetype.toLowerCase().replace(/\\s+/g, '_');\n  \n  // Direct match\n  if (validArchetypes.includes(lower as StrategicArchetype)) {\n    return lower as StrategicArchetype;\n  }\n  \n  // Fuzzy match\n  for (const valid of validArchetypes) {\n    if (lower.includes(valid) || valid.includes(lower)) {\n      return valid;\n    }\n  }\n  \n  return 'unknown';\n}\n";export{n as default};
