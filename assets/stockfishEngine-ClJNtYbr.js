const n="/**\n * Stockfish Engine Integration\n * \n * CRITICAL METHODOLOGY FOR EN PENSENT BENCHMARKS:\n * ================================================\n * This engine is used by BOTH sides of the benchmark:\n * 1. Pure Stockfish: Raw tactical evaluation only\n * 2. En Pensent Hybrid: Stockfish + Temporal Pattern Recognition\n * \n * We are NOT comparing different Stockfish versions.\n * We test if ADDING pattern recognition improves predictions.\n * \n * Engine: TCEC Stockfish 17 NNUE (ELO 3600)\n * Used by BOTH sides of benchmark for fair comparison\n */\n\nimport { Chess } from 'chess.js';\n\n// ===================== TYPES =====================\n\nexport interface StockfishEvaluation {\n  depth: number;\n  score: number;           // Centipawns (+ for white, - for black)\n  scoreType: 'cp' | 'mate';\n  mateIn?: number;         // Moves to mate (if scoreType is 'mate')\n  pv: string[];            // Principal variation (best line)\n  nodes: number;\n  nps: number;             // Nodes per second\n  time: number;            // Time in ms\n  multipv?: number;        // Multi-PV line number\n}\n\nexport interface PositionAnalysis {\n  fen: string;\n  bestMove: string;\n  ponder?: string;\n  evaluation: StockfishEvaluation;\n  winProbability: number;  // 0-100 for side to move\n  isCheckmate: boolean;\n  isStalemate: boolean;\n  isDraw: boolean;\n}\n\nexport interface MoveAnalysis {\n  san: string;\n  uci: string;\n  evalBefore: number;\n  evalAfter: number;\n  cpLoss: number;\n  accuracy: number;\n  bestMove: string;\n  wasBestMove: boolean;\n  pvLine: string[];\n}\n\nexport interface GameAnalysis {\n  moves: MoveAnalysis[];\n  whiteAccuracy: number;\n  blackAccuracy: number;\n  averageDepth: number;\n  engineVersion: string;\n}\n\n// ===================== ENGINE CLASS =====================\n\nexport class StockfishEngine {\n  private worker: Worker | null = null;\n  private isReady = false;\n  private pendingCallbacks: Map<string, (data: any) => void> = new Map();\n  private analysisCallbacks: ((eval_: StockfishEvaluation) => void)[] = [];\n  private currentDepth = 0;\n  private analysisBuffer: string[] = [];\n  private crashCount = 0;\n  private lastCrashTime = 0;\n  private isRecovering = false;\n\n  constructor() {\n    this.initWorker();\n  }\n\n  /**\n   * v7.60-CRASH-RECOVERY: Terminate crashed worker and reset state\n   */\n  private terminateWorker(): void {\n    if (this.worker) {\n      try {\n        this.worker.terminate();\n      } catch (e) {\n        console.warn('[Stockfish] Error terminating worker:', e);\n      }\n      this.worker = null;\n    }\n    this.isReady = false;\n    this.waitReadyPromise = null;\n    this.pendingCallbacks.clear();\n    this.analysisCallbacks = [];\n  }\n\n  private initWorker(): void {\n    // v7.60: Terminate any existing worker first\n    this.terminateWorker();\n    \n    try {\n      console.log('[Stockfish] Creating new worker...');\n      this.worker = new Worker('/stockfish.worker.js');\n      \n      this.worker.onmessage = (e) => {\n        const { type, data } = e.data;\n        \n        if (type === 'ready') {\n          console.log('[Stockfish] Engine ready!');\n          this.isReady = true;\n          this.crashCount = 0; // Reset crash count on successful init\n          this.isRecovering = false;\n          this.configure();\n        } else if (type === 'uci') {\n          this.handleUciMessage(data);\n        } else if (type === 'error') {\n          console.error('[Stockfish] Error:', data);\n          // v7.60: Check if this is a fatal WASM error\n          if (data && (data.includes('RuntimeError') || data.includes('Unreachable') || data.includes('Out of bounds'))) {\n            this.handleCrash('WASM runtime error');\n          }\n        } else if (type === 'status') {\n          console.log('[Stockfish]', data);\n        }\n      };\n      \n      this.worker.onerror = (e) => {\n        console.error('[Stockfish] Worker error:', e);\n        this.handleCrash('Worker error');\n      };\n    } catch (error) {\n      console.error('[Stockfish] Failed to create worker:', error);\n      this.handleCrash('Worker creation failed');\n    }\n  }\n\n  /**\n   * v7.60-CRASH-RECOVERY: Handle engine crashes with auto-recovery\n   */\n  private handleCrash(reason: string): void {\n    const now = Date.now();\n    \n    // Prevent infinite crash loops - max 3 crashes per 30 seconds\n    if (now - this.lastCrashTime < 30000) {\n      this.crashCount++;\n    } else {\n      this.crashCount = 1;\n    }\n    this.lastCrashTime = now;\n    \n    console.error(`[Stockfish] CRASH #${this.crashCount}: ${reason}`);\n    this.isReady = false;\n    \n    if (this.crashCount >= 3) {\n      console.error('[Stockfish] Too many crashes, giving up for 30 seconds');\n      return;\n    }\n    \n    // Auto-recover after a minimal delay\n    if (!this.isRecovering) {\n      this.isRecovering = true;\n      console.log('[Stockfish] Scheduling auto-recovery in 200ms...');\n      setTimeout(() => {\n        if (this.isRecovering) {\n          console.log('[Stockfish] Attempting auto-recovery...');\n          this.initWorker();\n        }\n      }, 200); // v7.95: 200ms (was 500ms)\n    }\n  }\n\n  private configure(): void {\n    // MAXIMUM STRENGTH SETTINGS for En Pensent Benchmarks\n    // Both Pure Stockfish AND En Pensent Hybrid use these IDENTICAL settings\n    // This ensures the ONLY variable is En Pensent's 25 domain adapters\n    this.sendCommand('setoption', { name: 'Threads', value: 1 }); // Single thread for consistency\n    this.sendCommand('setoption', { name: 'Hash', value: 128 }); // 128MB hash for deeper caching\n    this.sendCommand('setoption', { name: 'MultiPV', value: 1 }); // Focus on best line only\n    this.sendCommand('setoption', { name: 'Slow Mover', value: 100 }); // Maximum time usage for depth\n    // NNUE is enabled by default in Stockfish 17.1 - provides ~3600 ELO strength\n    // We do NOT use Skill Level or limit strength - full power on both sides\n  }\n\n  private sendCommand(command: string, options?: Record<string, any>): void {\n    if (this.worker) {\n      this.worker.postMessage({ command, options });\n    }\n  }\n\n  private handleUciMessage(message: string): void {\n    // Parse UCI info lines\n    if (message.startsWith('info')) {\n      const evaluation = this.parseInfoLine(message);\n      if (evaluation && evaluation.depth > this.currentDepth) {\n        this.currentDepth = evaluation.depth;\n        this.analysisCallbacks.forEach(cb => cb(evaluation));\n      }\n    }\n    \n    // Parse bestmove response\n    if (message.startsWith('bestmove')) {\n      const parts = message.split(' ');\n      const bestMove = parts[1];\n      const ponder = parts[3];\n      \n      const callback = this.pendingCallbacks.get('bestmove');\n      if (callback) {\n        callback({ bestMove, ponder });\n        this.pendingCallbacks.delete('bestmove');\n      }\n    }\n    \n    // Store for debugging\n    this.analysisBuffer.push(message);\n    if (this.analysisBuffer.length > 100) {\n      this.analysisBuffer.shift();\n    }\n  }\n\n  private parseInfoLine(line: string): StockfishEvaluation | null {\n    const parts = line.split(' ');\n    const evaluation: Partial<StockfishEvaluation> = {\n      pv: [],\n    };\n    \n    let i = 1; // Skip 'info'\n    while (i < parts.length) {\n      switch (parts[i]) {\n        case 'depth':\n          evaluation.depth = parseInt(parts[++i]);\n          break;\n        case 'score':\n          if (parts[++i] === 'cp') {\n            evaluation.scoreType = 'cp';\n            evaluation.score = parseInt(parts[++i]);\n          } else if (parts[i] === 'mate') {\n            evaluation.scoreType = 'mate';\n            evaluation.mateIn = parseInt(parts[++i]);\n            evaluation.score = evaluation.mateIn > 0 ? 10000 : -10000;\n          }\n          break;\n        case 'nodes':\n          evaluation.nodes = parseInt(parts[++i]);\n          break;\n        case 'nps':\n          evaluation.nps = parseInt(parts[++i]);\n          break;\n        case 'time':\n          evaluation.time = parseInt(parts[++i]);\n          break;\n        case 'multipv':\n          evaluation.multipv = parseInt(parts[++i]);\n          break;\n        case 'pv':\n          i++;\n          while (i < parts.length && !parts[i].startsWith('info')) {\n            evaluation.pv!.push(parts[i++]);\n          }\n          i--; // Back up one\n          break;\n        default:\n          break;\n      }\n      i++;\n    }\n    \n    if (evaluation.depth && evaluation.score !== undefined) {\n      return evaluation as StockfishEvaluation;\n    }\n    return null;\n  }\n\n  // ===================== PUBLIC API =====================\n  \n  // v7.59: Mutex to prevent concurrent waitReady calls\n  private waitReadyPromise: Promise<boolean> | null = null;\n\n  /**\n   * Wait for engine to be ready with optional progress callback\n   * v7.59: Added mutex to prevent multiple concurrent wait loops (causes pauses)\n   */\n  async waitReady(onProgress?: (progress: number) => void): Promise<boolean> {\n    // Fast path - already ready\n    if (this.isReady && this.worker) {\n      onProgress?.(1);\n      return true;\n    }\n    \n    // v7.59: If already waiting, reuse the existing promise (prevents duplicate wait loops)\n    if (this.waitReadyPromise) {\n      return this.waitReadyPromise;\n    }\n    \n    // If worker died, try to reinitialize\n    if (!this.worker) {\n      console.log('[Stockfish] Worker not found, reinitializing...');\n      this.initWorker();\n    }\n    \n    // v7.59: Create and cache the wait promise\n    this.waitReadyPromise = new Promise<boolean>((resolve) => {\n      let attempts = 0;\n      const maxAttempts = 150; // v7.59: 15 seconds max (was 60s - too long!)\n      let lastProgress = 0;\n      let lastLogTime = 0;\n      \n      const checkReady = setInterval(() => {\n        attempts++;\n        const progress = Math.min(attempts / maxAttempts, 0.99);\n        \n        // Only call progress callback if progress changed significantly\n        if (progress - lastProgress > 0.1) {\n          lastProgress = progress;\n          onProgress?.(progress);\n        }\n        \n        if (this.isReady) {\n          clearInterval(checkReady);\n          this.waitReadyPromise = null; // v7.59: Clear mutex\n          console.log('[Stockfish] Engine ready after', attempts * 100, 'ms');\n          onProgress?.(1);\n          resolve(true);\n        } else if (attempts >= maxAttempts) {\n          clearInterval(checkReady);\n          this.waitReadyPromise = null; // v7.59: Clear mutex\n          console.error('[Stockfish] Engine timeout after 15 seconds');\n          resolve(false);\n        }\n        \n        // v7.59: Log less frequently (every 5 seconds, not every 10s)\n        const now = Date.now();\n        if (now - lastLogTime > 5000) {\n          lastLogTime = now;\n          console.log(`[Stockfish] Waiting for engine... ${Math.round(attempts / 10)}s`);\n        }\n      }, 100);\n    });\n    \n    return this.waitReadyPromise;\n  }\n\n  /**\n   * Analyze a position by FEN with GUARANTEED depth verification\n   * For Maximum Depth mode: validates the engine actually reaches requested depth\n   * Includes timeout protection for deep analysis\n   */\n  async analyzePosition(\n    fen: string, \n    options: { depth?: number; movetime?: number; nodes?: number; requireExactDepth?: boolean } = {}\n  ): Promise<PositionAnalysis> {\n    await this.waitReady();\n    \n    this.currentDepth = 0;\n    const requestedDepth = options.depth || 12;\n    const requireExact = options.requireExactDepth ?? false;\n    \n    // v7.51-PUMP: Fast timeout - 8s base + 200ms per depth level\n    const timeoutMs = Math.max(8000, Math.min(requestedDepth * 200, 30000));\n    \n    return new Promise((resolve, reject) => {\n      let timeoutId: NodeJS.Timeout | undefined;\n      let resolved = false;\n      \n      // Set position\n      this.sendCommand('position', { fen });\n      \n      // Start analysis\n      let lastEval: StockfishEvaluation | null = null;\n      let highestDepthReached = 0;\n      \n      const onEval = (evaluation: StockfishEvaluation) => {\n        lastEval = evaluation;\n        if (evaluation.depth > highestDepthReached) {\n          highestDepthReached = evaluation.depth;\n        }\n      };\n      \n      this.analysisCallbacks.push(onEval);\n      \n      const cleanup = () => {\n        if (timeoutId) clearTimeout(timeoutId);\n        this.analysisCallbacks = this.analysisCallbacks.filter(cb => cb !== onEval);\n        this.pendingCallbacks.delete('bestmove');\n      };\n      \n      // Set up bestmove callback\n      this.pendingCallbacks.set('bestmove', ({ bestMove, ponder }) => {\n        if (resolved) return;\n        resolved = true;\n        cleanup();\n        \n        const chess = new Chess(fen);\n        const actualDepth = lastEval?.depth || 0;\n        \n        // Verify depth was reached for Maximum Depth mode\n        if (requireExact && actualDepth < requestedDepth) {\n          console.warn(`[Stockfish] Depth shortfall: requested ${requestedDepth}, reached ${actualDepth}`);\n        }\n        \n        console.log(`[Stockfish] Analysis complete: depth ${actualDepth}/${requestedDepth}, eval ${lastEval?.score || 0}cp`);\n        \n        resolve({\n          fen,\n          bestMove,\n          ponder,\n          evaluation: lastEval || {\n            depth: 0,\n            score: 0,\n            scoreType: 'cp',\n            pv: [],\n            nodes: 0,\n            nps: 0,\n            time: 0,\n          },\n          winProbability: lastEval?.score !== undefined ? this.cpToWinProbability(lastEval.score) : 50, // null ≠ 0, null = unknown (50%)\n          isCheckmate: chess.isCheckmate(),\n          isStalemate: chess.isStalemate(),\n          isDraw: chess.isDraw(),\n        });\n      });\n      \n      // Timeout protection for deep analysis\n      timeoutId = setTimeout(() => {\n        if (resolved) return;\n        resolved = true;\n        \n        console.warn(`[Stockfish] Timeout after ${timeoutMs}ms, stopping analysis at depth ${highestDepthReached}`);\n        this.sendCommand('stop');\n        \n        cleanup();\n        \n        const chess = new Chess(fen);\n        \n        // Return best result we got before timeout\n        resolve({\n          fen,\n          bestMove: lastEval?.pv?.[0] || '',\n          evaluation: lastEval || {\n            depth: highestDepthReached,\n            score: 0,\n            scoreType: 'cp',\n            pv: [],\n            nodes: 0,\n            nps: 0,\n            time: timeoutMs,\n          },\n          winProbability: lastEval?.score !== undefined ? this.cpToWinProbability(lastEval.score) : 50, // null ≠ 0, null = unknown (50%)\n          isCheckmate: chess.isCheckmate(),\n          isStalemate: chess.isStalemate(),\n          isDraw: chess.isDraw(),\n        });\n      }, timeoutMs);\n      \n      // Use nodes for fastest consistent results, otherwise depth only (not both)\n      if (options.nodes) {\n        this.sendCommand('go', { nodes: options.nodes });\n      } else if (options.movetime) {\n        this.sendCommand('go', { movetime: options.movetime });\n      } else {\n        this.sendCommand('go', { depth: requestedDepth });\n      }\n    });\n  }\n\n  /**\n   * Analyze a full game from PGN\n   * OPTIMIZED: Only analyzes position BEFORE each move (not after), uses previous eval\n   */\n  async analyzeGame(\n    pgn: string, \n    options: { depth?: number; onProgress?: (move: number, total: number) => void } = {}\n  ): Promise<GameAnalysis> {\n    await this.waitReady();\n    \n    const depth = options.depth || 10; // Reduced depth for faster analysis\n    const chess = new Chess();\n    \n    try {\n      chess.loadPgn(pgn);\n    } catch (e) {\n      throw new Error('Invalid PGN');\n    }\n    \n    const history = chess.history({ verbose: true });\n    const moves: MoveAnalysis[] = [];\n    \n    // Reset and analyze move by move\n    chess.reset();\n    \n    // Analyze starting position once\n    let previousAnalysis = await this.analyzePosition(chess.fen(), { depth, nodes: 50000 });\n    let previousEval = previousAnalysis.evaluation.score;\n    \n    for (let i = 0; i < history.length; i++) {\n      const move = history[i];\n      const fenBefore = chess.fen();\n      const isWhiteMove = chess.turn() === 'w';\n      \n      // Use cached eval from previous iteration (much faster!)\n      const evalBefore = previousEval * (isWhiteMove ? 1 : -1);\n      const bestMoveBefore = previousAnalysis.bestMove;\n      const pvBefore = previousAnalysis.evaluation.pv;\n      \n      // Play the move\n      chess.move(move);\n      \n      // Analyze the new position (this becomes the \"before\" for next move)\n      previousAnalysis = await this.analyzePosition(chess.fen(), { depth, nodes: 50000 });\n      previousEval = previousAnalysis.evaluation.score;\n      \n      // Get eval after from new position's perspective (flip sign)\n      const evalAfter = previousEval * (isWhiteMove ? -1 : 1);\n      \n      // Calculate centipawn loss (from the perspective of the player who moved)\n      const cpLoss = Math.max(0, evalBefore - evalAfter);\n      \n      // Calculate accuracy\n      const accuracy = this.calculateAccuracy(cpLoss);\n      \n      // Check if this was the best move\n      const wasBestMove = move.from + move.to === bestMoveBefore.slice(0, 4);\n      \n      moves.push({\n        san: move.san,\n        uci: move.from + move.to + (move.promotion || ''),\n        evalBefore: isWhiteMove ? evalBefore : -evalBefore,\n        evalAfter: isWhiteMove ? evalAfter : -evalAfter,\n        cpLoss,\n        accuracy,\n        bestMove: bestMoveBefore,\n        wasBestMove,\n        pvLine: pvBefore,\n      });\n      \n      if (options.onProgress) {\n        options.onProgress(i + 1, history.length);\n      }\n    }\n    \n    // Calculate per-player accuracy\n    const whiteMoves = moves.filter((_, i) => i % 2 === 0);\n    const blackMoves = moves.filter((_, i) => i % 2 === 1);\n    \n    const whiteAccuracy = whiteMoves.length \n      ? whiteMoves.reduce((sum, m) => sum + m.accuracy, 0) / whiteMoves.length \n      : 0;\n    const blackAccuracy = blackMoves.length \n      ? blackMoves.reduce((sum, m) => sum + m.accuracy, 0) / blackMoves.length \n      : 0;\n    \n    return {\n      moves,\n      whiteAccuracy: Math.round(whiteAccuracy * 10) / 10,\n      blackAccuracy: Math.round(blackAccuracy * 10) / 10,\n      averageDepth: depth,\n      engineVersion: 'Stockfish 17.1 NNUE WASM',\n    };\n  }\n\n  /**\n   * Get evaluation for a specific move (without full game analysis)\n   */\n  async evaluateMove(\n    fen: string, \n    move: string, \n    depth: number = 15\n  ): Promise<{ cpLoss: number; accuracy: number; wasBest: boolean; bestMove: string }> {\n    await this.waitReady();\n    \n    const chess = new Chess(fen);\n    \n    // Analyze position before move\n    const before = await this.analyzePosition(fen, { depth, movetime: 500 });\n    const evalBefore = before.evaluation.score;\n    \n    // Play the move\n    chess.move(move);\n    \n    // Analyze position after move\n    const after = await this.analyzePosition(chess.fen(), { depth, movetime: 500 });\n    const evalAfter = -after.evaluation.score; // Flip perspective\n    \n    const cpLoss = Math.max(0, evalBefore - evalAfter);\n    const accuracy = this.calculateAccuracy(cpLoss);\n    const wasBest = move.toLowerCase().includes(before.bestMove.slice(0, 4).toLowerCase());\n    \n    return {\n      cpLoss,\n      accuracy,\n      wasBest,\n      bestMove: before.bestMove,\n    };\n  }\n\n  /**\n   * Quick position evaluation (low depth, fast)\n   */\n  async quickEval(fen: string): Promise<number> {\n    await this.waitReady();\n    \n    // Use node count for consistent fast evaluation\n    const analysis = await this.analyzePosition(fen, { nodes: 10000 });\n    return analysis.evaluation.score;\n  }\n\n  /**\n   * Stop current analysis\n   */\n  stop(): void {\n    this.sendCommand('stop');\n  }\n\n  /**\n   * Terminate the engine\n   */\n  terminate(): void {\n    this.sendCommand('quit');\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n    this.isReady = false;\n  }\n\n  // ===================== UTILITY FUNCTIONS =====================\n\n  /**\n   * Convert centipawns to win probability (Lichess formula)\n   */\n  private cpToWinProbability(cp: number): number {\n    const K = 0.00368208;\n    return 50 + 50 * (2 / (1 + Math.exp(-K * cp)) - 1);\n  }\n\n  /**\n   * Calculate move accuracy from centipawn loss (chess.com formula)\n   */\n  private calculateAccuracy(cpLoss: number): number {\n    if (cpLoss <= 0) return 100;\n    const accuracy = 103.1668 * Math.exp(-0.04354 * cpLoss) - 3.1669;\n    return Math.max(0, Math.min(100, accuracy));\n  }\n\n  /**\n   * Check if engine is available\n   * v7.60: Also check we haven't crashed too many times\n   */\n  get available(): boolean {\n    return this.isReady && this.worker !== null && this.crashCount < 3;\n  }\n\n  /**\n   * v7.60: Force engine recovery (for manual benchmark start)\n   */\n  forceRecovery(): void {\n    console.log('[Stockfish] Force recovery requested');\n    this.crashCount = 0;\n    this.isRecovering = false;\n    this.initWorker();\n  }\n\n  /**\n   * Get engine info\n   */\n  get info(): { version: string; available: boolean; crashCount: number } {\n    return {\n      version: 'Stockfish 17.1 NNUE WASM',\n      available: this.available,\n      crashCount: this.crashCount,\n    };\n  }\n}\n\n// ===================== SINGLETON INSTANCE =====================\n\nlet engineInstance: StockfishEngine | null = null;\n\n/**\n * Get or create the Stockfish engine singleton\n */\nexport function getStockfishEngine(): StockfishEngine {\n  if (!engineInstance) {\n    engineInstance = new StockfishEngine();\n  }\n  return engineInstance;\n}\n\n/**\n * Terminate and cleanup the engine\n */\nexport function terminateStockfish(): void {\n  if (engineInstance) {\n    engineInstance.terminate();\n    engineInstance = null;\n  }\n}\n";export{n as default};
