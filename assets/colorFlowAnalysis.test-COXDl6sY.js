const e="/**\n * Color Flow Analysis Tests\n * \n * Tests for chess-specific signature extraction and archetype identification.\n */\n\nimport { describe, it, expect } from 'vitest';\nimport {\n  extractColorFlowSignature,\n  ARCHETYPE_DEFINITIONS,\n  StrategicArchetype,\n  ColorFlowSignature,\n  QuadrantProfile,\n  TemporalFlow\n} from './colorFlowAnalysis';\nimport { SquareData, GameData } from './gameSimulator';\n\n// ============================================================================\n// Test Fixtures\n// ============================================================================\n\nconst createEmptyBoard = (): SquareData[][] => {\n  const board: SquareData[][] = [];\n  for (let rank = 0; rank < 8; rank++) {\n    board[rank] = [];\n    for (let file = 0; file < 8; file++) {\n      board[rank][file] = {\n        file,\n        rank,\n        visits: [],\n        isLight: (file + rank) % 2 === 1\n      };\n    }\n  }\n  return board;\n};\n\nconst createMockGameData = (): GameData => ({\n  pgn: '1. e4 e5 2. Nf3 Nc6',\n  white: 'Test White',\n  black: 'Test Black',\n  result: '*',\n  event: 'Test Event',\n  date: '2024.01.01',\n  moves: ['e4', 'e5', 'Nf3', 'Nc6']\n});\n\nconst addVisits = (\n  board: SquareData[][],\n  visits: Array<{ square: string; color: 'w' | 'b'; moveNumber: number; piece: string }>\n): void => {\n  for (const visit of visits) {\n    const file = visit.square.charCodeAt(0) - 97; // 'a' = 0\n    const rank = parseInt(visit.square[1]) - 1;\n    \n    if (rank >= 0 && rank < 8 && file >= 0 && file < 8) {\n      board[rank][file].visits.push({\n        color: visit.color,\n        moveNumber: visit.moveNumber,\n        piece: visit.piece as any,\n        hexColor: visit.color === 'w' ? '#ffffff' : '#000000'\n      });\n    }\n  }\n};\n\n// ============================================================================\n// Tests\n// ============================================================================\n\ndescribe('colorFlowAnalysis', () => {\n  // ============================================================================\n  // ARCHETYPE_DEFINITIONS\n  // ============================================================================\n  describe('ARCHETYPE_DEFINITIONS', () => {\n    it('should define all 12 archetypes plus unknown', () => {\n      const expectedArchetypes: StrategicArchetype[] = [\n        'kingside_attack',\n        'queenside_expansion',\n        'central_domination',\n        'prophylactic_defense',\n        'pawn_storm',\n        'piece_harmony',\n        'opposite_castling',\n        'closed_maneuvering',\n        'open_tactical',\n        'endgame_technique',\n        'sacrificial_attack',\n        'positional_squeeze',\n        'unknown'\n      ];\n      \n      for (const archetype of expectedArchetypes) {\n        expect(ARCHETYPE_DEFINITIONS[archetype]).toBeDefined();\n        expect(ARCHETYPE_DEFINITIONS[archetype].id).toBe(archetype);\n      }\n    });\n\n    it('should have valid properties for each archetype', () => {\n      for (const [id, def] of Object.entries(ARCHETYPE_DEFINITIONS)) {\n        expect(def.id).toBe(id);\n        expect(def.name).toBeDefined();\n        expect(def.name.length).toBeGreaterThan(0);\n        expect(def.description).toBeDefined();\n        expect(def.colorCharacteristics).toBeDefined();\n        expect(def.historicalWinRate).toBeGreaterThanOrEqual(0);\n        expect(def.historicalWinRate).toBeLessThanOrEqual(1);\n        expect(['white_favored', 'black_favored', 'balanced']).toContain(def.predictedOutcome);\n        expect(def.lookaheadConfidence).toBeGreaterThan(0);\n      }\n    });\n\n    it('should have reasonable win rates', () => {\n      // Most archetypes should have win rates between 0.45 and 0.65\n      const winRates = Object.values(ARCHETYPE_DEFINITIONS).map(d => d.historicalWinRate);\n      const avgWinRate = winRates.reduce((a, b) => a + b, 0) / winRates.length;\n      \n      expect(avgWinRate).toBeGreaterThan(0.45);\n      expect(avgWinRate).toBeLessThan(0.65);\n    });\n  });\n\n  // ============================================================================\n  // extractColorFlowSignature\n  // ============================================================================\n  describe('extractColorFlowSignature', () => {\n    it('should return signature with all required fields', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Add some basic visits\n      addVisits(board, [\n        { square: 'e4', color: 'w', moveNumber: 1, piece: 'p' },\n        { square: 'e5', color: 'b', moveNumber: 1, piece: 'p' },\n        { square: 'f3', color: 'w', moveNumber: 2, piece: 'n' },\n        { square: 'c6', color: 'b', moveNumber: 2, piece: 'n' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 4);\n      \n      expect(signature.fingerprint).toBeDefined();\n      expect(signature.fingerprint).toMatch(/^cf-/);\n      expect(signature.dominantSide).toBeDefined();\n      expect(['white', 'black', 'contested']).toContain(signature.dominantSide);\n      expect(signature.flowDirection).toBeDefined();\n      expect(signature.intensity).toBeGreaterThanOrEqual(0);\n      expect(signature.intensity).toBeLessThanOrEqual(100);\n      expect(signature.archetype).toBeDefined();\n      expect(signature.quadrantProfile).toBeDefined();\n      expect(signature.temporalFlow).toBeDefined();\n      expect(signature.criticalMoments).toBeDefined();\n    });\n\n    it('should generate unique fingerprints for different boards', () => {\n      const board1 = createEmptyBoard();\n      const board2 = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      addVisits(board1, [\n        { square: 'e4', color: 'w', moveNumber: 1, piece: 'p' },\n      ]);\n      addVisits(board2, [\n        { square: 'd4', color: 'w', moveNumber: 1, piece: 'p' },\n      ]);\n      \n      const sig1 = extractColorFlowSignature(board1, gameData, 1);\n      const sig2 = extractColorFlowSignature(board2, gameData, 1);\n      \n      expect(sig1.fingerprint).not.toBe(sig2.fingerprint);\n    });\n\n    it('should detect kingside attack pattern', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Simulate heavy kingside activity\n      addVisits(board, [\n        { square: 'h5', color: 'w', moveNumber: 5, piece: 'q' },\n        { square: 'g5', color: 'w', moveNumber: 6, piece: 'n' },\n        { square: 'f6', color: 'w', moveNumber: 7, piece: 'b' },\n        { square: 'h6', color: 'w', moveNumber: 8, piece: 'r' },\n        { square: 'g7', color: 'w', moveNumber: 9, piece: 'q' },\n        { square: 'h7', color: 'w', moveNumber: 10, piece: 'r' },\n        { square: 'f7', color: 'w', moveNumber: 11, piece: 'b' },\n        { square: 'g8', color: 'w', moveNumber: 12, piece: 'n' },\n        // High volatility\n        { square: 'h8', color: 'b', moveNumber: 13, piece: 'k' },\n        { square: 'h8', color: 'w', moveNumber: 14, piece: 'q' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 14);\n      \n      // Should recognize the kingside concentration\n      expect(signature.quadrantProfile.kingsideBlack).not.toBe(0);\n      expect(['kingside_attack', 'open_tactical', 'sacrificial_attack']).toContain(signature.archetype);\n    });\n\n    it('should detect central domination pattern', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Heavy center control\n      addVisits(board, [\n        { square: 'd4', color: 'w', moveNumber: 1, piece: 'p' },\n        { square: 'e4', color: 'w', moveNumber: 2, piece: 'p' },\n        { square: 'd5', color: 'w', moveNumber: 3, piece: 'n' },\n        { square: 'e5', color: 'w', moveNumber: 4, piece: 'n' },\n        { square: 'd4', color: 'w', moveNumber: 5, piece: 'b' },\n        { square: 'e4', color: 'w', moveNumber: 6, piece: 'b' },\n        { square: 'd5', color: 'w', moveNumber: 7, piece: 'q' },\n        { square: 'e5', color: 'w', moveNumber: 8, piece: 'r' },\n        { square: 'd4', color: 'w', moveNumber: 9, piece: 'k' },\n        { square: 'e4', color: 'w', moveNumber: 10, piece: 'r' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 10);\n      \n      expect(Math.abs(signature.quadrantProfile.center)).toBeGreaterThan(0);\n    });\n\n    it('should detect queenside expansion pattern', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Queenside activity\n      addVisits(board, [\n        { square: 'a5', color: 'w', moveNumber: 5, piece: 'p' },\n        { square: 'b5', color: 'w', moveNumber: 6, piece: 'p' },\n        { square: 'c5', color: 'w', moveNumber: 7, piece: 'n' },\n        { square: 'a6', color: 'w', moveNumber: 8, piece: 'r' },\n        { square: 'b6', color: 'w', moveNumber: 9, piece: 'b' },\n        { square: 'a7', color: 'w', moveNumber: 10, piece: 'q' },\n        { square: 'b7', color: 'w', moveNumber: 11, piece: 'r' },\n        { square: 'c7', color: 'w', moveNumber: 12, piece: 'n' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 12);\n      \n      expect(Math.abs(signature.quadrantProfile.queensideBlack)).toBeGreaterThan(0);\n    });\n\n    it('should calculate temporal flow across game phases', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Opening moves (1-10)\n      for (let i = 1; i <= 10; i++) {\n        addVisits(board, [\n          { square: `e${Math.min(4, i)}`, color: 'w', moveNumber: i, piece: 'p' },\n        ]);\n      }\n      \n      // Middlegame moves (11-25)\n      for (let i = 11; i <= 25; i++) {\n        addVisits(board, [\n          { square: 'd5', color: 'w', moveNumber: i, piece: 'n' },\n        ]);\n      }\n      \n      // Endgame moves (26+)\n      for (let i = 26; i <= 40; i++) {\n        addVisits(board, [\n          { square: 'a8', color: 'w', moveNumber: i, piece: 'k' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 40);\n      \n      expect(signature.temporalFlow.opening).toBeDefined();\n      expect(signature.temporalFlow.middlegame).toBeDefined();\n      expect(signature.temporalFlow.endgame).toBeDefined();\n      expect(signature.temporalFlow.volatility).toBeGreaterThanOrEqual(0);\n    });\n\n    it('should detect critical moments', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Create a dramatic shift at move 10\n      for (let i = 1; i <= 9; i++) {\n        addVisits(board, [{ square: 'e4', color: 'w', moveNumber: i, piece: 'p' }]);\n      }\n      // Sudden surge of activity\n      for (let i = 10; i <= 12; i++) {\n        addVisits(board, [\n          { square: 'e4', color: 'b', moveNumber: i, piece: 'q' },\n          { square: 'd4', color: 'b', moveNumber: i, piece: 'r' },\n          { square: 'f4', color: 'b', moveNumber: i, piece: 'r' },\n          { square: 'c4', color: 'b', moveNumber: i, piece: 'b' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 12);\n      \n      // Should detect the dramatic shift\n      expect(signature.criticalMoments.length).toBeGreaterThanOrEqual(0);\n    });\n\n    it('should handle empty board', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      const signature = extractColorFlowSignature(board, gameData, 0);\n      \n      expect(signature.fingerprint).toBeDefined();\n      expect(signature.intensity).toBe(0);\n      expect(signature.archetype).toBeDefined();\n    });\n\n    it('should detect closed maneuvering pattern', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Low volatility, many moves, gradual shifts\n      for (let i = 1; i <= 50; i++) {\n        const square = i % 2 === 0 ? 'c3' : 'c4';\n        addVisits(board, [{ square, color: 'w', moveNumber: i, piece: 'n' }]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 50);\n      \n      // Low volatility + many moves = closed maneuvering or similar\n      expect(signature.temporalFlow.volatility).toBeLessThan(50);\n    });\n\n    it('should detect endgame technique pattern', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Minimal activity, late game, low volatility\n      addVisits(board, [\n        { square: 'e1', color: 'w', moveNumber: 30, piece: 'k' },\n        { square: 'e2', color: 'w', moveNumber: 32, piece: 'k' },\n        { square: 'e3', color: 'w', moveNumber: 34, piece: 'k' },\n        { square: 'a7', color: 'w', moveNumber: 36, piece: 'p' },\n        { square: 'a8', color: 'w', moveNumber: 38, piece: 'p' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 45);\n      \n      expect(signature.temporalFlow.endgame).toBeDefined();\n    });\n\n    it('should correctly identify dominant side', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // White dominant\n      for (let i = 1; i <= 20; i++) {\n        addVisits(board, [\n          { square: 'e4', color: 'w', moveNumber: i, piece: 'q' },\n          { square: 'd4', color: 'w', moveNumber: i, piece: 'r' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 20);\n      \n      expect(signature.dominantSide).toBe('white');\n    });\n\n    it('should identify contested games', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Equal activity from both sides\n      for (let i = 1; i <= 20; i++) {\n        addVisits(board, [\n          { square: 'e4', color: 'w', moveNumber: i, piece: 'n' },\n          { square: 'e5', color: 'b', moveNumber: i, piece: 'n' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 20);\n      \n      expect(['contested', 'white', 'black']).toContain(signature.dominantSide);\n    });\n  });\n\n  // ============================================================================\n  // Archetype Classification Edge Cases\n  // ============================================================================\n  describe('archetype classification edge cases', () => {\n    it('should classify unknown for minimal games', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      addVisits(board, [\n        { square: 'e4', color: 'w', moveNumber: 1, piece: 'p' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 1);\n      \n      // Very short games should often be unknown or one of the less specific archetypes\n      expect(ARCHETYPE_DEFINITIONS[signature.archetype]).toBeDefined();\n    });\n\n    it('should handle all-black activity', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      for (let i = 1; i <= 30; i++) {\n        addVisits(board, [\n          { square: 'd5', color: 'b', moveNumber: i, piece: 'q' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 30);\n      \n      expect(signature.dominantSide).toBe('black');\n    });\n\n    it('should classify open tactical for high volatility', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Alternating heavy activity = high volatility\n      for (let i = 1; i <= 20; i++) {\n        const color = i % 2 === 0 ? 'w' : 'b';\n        addVisits(board, [\n          { square: 'e4', color, moveNumber: i, piece: 'q' },\n          { square: 'd4', color, moveNumber: i, piece: 'r' },\n          { square: 'f4', color, moveNumber: i, piece: 'r' },\n          { square: 'c4', color, moveNumber: i, piece: 'n' },\n          { square: 'g4', color, moveNumber: i, piece: 'b' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 20);\n      \n      expect(signature.temporalFlow.volatility).toBeGreaterThan(30);\n    });\n  });\n\n  // ============================================================================\n  // Flow Direction Tests\n  // ============================================================================\n  describe('flow direction detection', () => {\n    it('should detect kingside flow direction', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Heavy kingside (e-h files)\n      for (let i = 1; i <= 20; i++) {\n        addVisits(board, [\n          { square: 'f4', color: 'w', moveNumber: i, piece: 'n' },\n          { square: 'g4', color: 'w', moveNumber: i, piece: 'b' },\n          { square: 'h4', color: 'w', moveNumber: i, piece: 'r' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 20);\n      \n      expect(['kingside', 'balanced']).toContain(signature.flowDirection);\n    });\n\n    it('should detect queenside flow direction', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Heavy queenside (a-d files)\n      for (let i = 1; i <= 20; i++) {\n        addVisits(board, [\n          { square: 'a4', color: 'w', moveNumber: i, piece: 'r' },\n          { square: 'b4', color: 'w', moveNumber: i, piece: 'n' },\n          { square: 'c4', color: 'w', moveNumber: i, piece: 'b' },\n        ]);\n      }\n      \n      const signature = extractColorFlowSignature(board, gameData, 20);\n      \n      expect(['queenside', 'balanced']).toContain(signature.flowDirection);\n    });\n\n    it('should detect balanced flow', () => {\n      const board = createEmptyBoard();\n      const gameData = createMockGameData();\n      \n      // Even distribution\n      addVisits(board, [\n        { square: 'a4', color: 'w', moveNumber: 1, piece: 'n' },\n        { square: 'b4', color: 'w', moveNumber: 2, piece: 'n' },\n        { square: 'g4', color: 'w', moveNumber: 3, piece: 'n' },\n        { square: 'h4', color: 'w', moveNumber: 4, piece: 'n' },\n        { square: 'a5', color: 'b', moveNumber: 5, piece: 'n' },\n        { square: 'b5', color: 'b', moveNumber: 6, piece: 'n' },\n        { square: 'g5', color: 'b', moveNumber: 7, piece: 'n' },\n        { square: 'h5', color: 'b', moveNumber: 8, piece: 'n' },\n      ]);\n      \n      const signature = extractColorFlowSignature(board, gameData, 8);\n      \n      expect(['balanced', 'central', 'diagonal']).toContain(signature.flowDirection);\n    });\n  });\n});\n";export{e as default};
