const n="import { z } from 'zod';\nimport { quickTextCheck } from '@/lib/moderation/contentModeration';\n\n/**\n * Validation schemas for visualization-related inputs\n * Used for client-side validation before database insertion\n */\n\n// Custom refinement for content moderation\nconst contentSafeCheck = (fieldName: string) => (value: string, ctx: z.RefinementCtx) => {\n  const check = quickTextCheck(value);\n  if (!check.safe) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: check.reason || `${fieldName} contains inappropriate content`,\n    });\n  }\n  return value;\n};\n\n// Visualization title validation with content moderation\nexport const visualizationTitleSchema = z.string()\n  .trim()\n  .min(1, 'Title is required')\n  .max(200, 'Title must be 200 characters or less')\n  .regex(/^[^<>]*$/, 'Title cannot contain < or > characters')\n  .superRefine(contentSafeCheck('Title'));\n\n// PGN data validation (chess game notation)\nexport const pgnDataSchema = z.string()\n  .max(100000, 'PGN data is too large (max 100KB)')\n  .optional()\n  .nullable();\n\n// Full visualization save schema\nexport const saveVisualizationSchema = z.object({\n  title: visualizationTitleSchema,\n  pgn: pgnDataSchema,\n});\n\n// Marketplace listing price validation\nexport const listingPriceSchema = z.object({\n  priceCents: z.number()\n    .int('Price must be a whole number of cents')\n    .min(0, 'Price cannot be negative')\n    .max(1000000, 'Maximum price is $10,000'),\n});\n\n// Display name validation (matches database constraints) with content moderation\nexport const displayNameSchema = z.string()\n  .trim()\n  .min(1, 'Display name is required')\n  .max(50, 'Display name must be 50 characters or less')\n  .regex(/^[^\\x00-\\x1F\\x7F]*$/, 'Display name cannot contain control characters')\n  .superRefine(contentSafeCheck('Display name'));\n\n/**\n * Validate visualization title before saving\n * @returns Object with success boolean and either data or error message\n */\nexport function validateVisualizationTitle(title: string): { \n  success: boolean; \n  data?: string; \n  error?: string \n} {\n  const result = visualizationTitleSchema.safeParse(title);\n  if (result.success) {\n    return { success: true, data: result.data };\n  }\n  return { success: false, error: result.error.errors[0]?.message || 'Invalid title' };\n}\n\n/**\n * Validate PGN data before processing\n * @returns Object with success boolean and either data or error message\n */\nexport function validatePgnData(pgn: string | null | undefined): { \n  success: boolean; \n  data?: string | null; \n  error?: string \n} {\n  const result = pgnDataSchema.safeParse(pgn);\n  if (result.success) {\n    return { success: true, data: result.data };\n  }\n  return { success: false, error: result.error.errors[0]?.message || 'Invalid PGN data' };\n}\n\n/**\n * Validate complete visualization save request\n */\nexport function validateVisualizationSave(data: { title: string; pgn?: string | null }): {\n  success: boolean;\n  data?: { title: string; pgn: string | null | undefined };\n  errors?: Record<string, string>;\n} {\n  const result = saveVisualizationSchema.safeParse(data);\n  if (result.success) {\n    return { \n      success: true, \n      data: { \n        title: result.data.title, \n        pgn: result.data.pgn \n      } \n    };\n  }\n  \n  const errors: Record<string, string> = {};\n  result.error.errors.forEach(err => {\n    if (err.path[0]) {\n      errors[err.path[0] as string] = err.message;\n    }\n  });\n  return { success: false, errors };\n}\n";export{n as default};
