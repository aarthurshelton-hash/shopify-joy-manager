const n="/**\n * En Pensent Core SDK - Critical Moment Detector\n * \n * Detects significant changes in value sequences\n */\n\nimport { CriticalMoment } from '../types';\n\nexport interface DetectionOptions {\n  /** Minimum change threshold to detect */\n  threshold?: number;\n  /** Minimum severity to include in results */\n  minSeverity?: number;\n  /** Maximum number of moments to return */\n  maxMoments?: number;\n}\n\nconst DEFAULT_OPTIONS: Required<DetectionOptions> = {\n  threshold: 0.3,\n  minSeverity: 0.5,\n  maxMoments: 10\n};\n\n/**\n * Detect critical moments from a sequence of values\n */\nexport function detectCriticalMoments(\n  values: number[],\n  options: DetectionOptions = {}\n): CriticalMoment[] {\n  const { threshold, minSeverity, maxMoments } = { ...DEFAULT_OPTIONS, ...options };\n  \n  if (values.length < 3) return [];\n  \n  const changes = findSignificantChanges(values, threshold);\n  const filteredMoments = convertToMoments(changes, minSeverity);\n  \n  return sortChronologically(filteredMoments).slice(0, maxMoments);\n}\n\n/**\n * Find changes that exceed the threshold\n */\nfunction findSignificantChanges(\n  values: number[],\n  threshold: number\n): { index: number; change: number; direction: 'up' | 'down' }[] {\n  const changes: { index: number; change: number; direction: 'up' | 'down' }[] = [];\n  \n  for (let i = 1; i < values.length; i++) {\n    const change = values[i] - values[i - 1];\n    if (Math.abs(change) > threshold) {\n      changes.push({\n        index: i,\n        change: Math.abs(change),\n        direction: change > 0 ? 'up' : 'down'\n      });\n    }\n  }\n  \n  return changes;\n}\n\n/**\n * Convert changes to critical moments, filtering by severity\n */\nfunction convertToMoments(\n  changes: { index: number; change: number; direction: 'up' | 'down' }[],\n  minSeverity: number\n): CriticalMoment[] {\n  // Sort by magnitude to get top changes\n  const sorted = [...changes].sort((a, b) => b.change - a.change);\n  \n  const moments: CriticalMoment[] = [];\n  \n  for (const change of sorted) {\n    const severity = Math.min(1, change.change);\n    if (severity >= minSeverity) {\n      moments.push({\n        index: change.index,\n        type: change.direction === 'up' ? 'surge' : 'drop',\n        severity,\n        description: `${change.direction === 'up' ? 'Significant increase' : 'Significant decrease'} at position ${change.index}`\n      });\n    }\n  }\n  \n  return moments;\n}\n\n/**\n * Sort moments chronologically by index\n */\nfunction sortChronologically(moments: CriticalMoment[]): CriticalMoment[] {\n  return [...moments].sort((a, b) => a.index - b.index);\n}\n";export{n as default};
