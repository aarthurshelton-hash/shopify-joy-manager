const n="/**\n * En Pensent Core SDK - Event Bus\n * \n * Reactive event system for signature extraction, pattern matching,\n * and prediction events. Enables loose coupling between SDK components.\n */\n\nimport { TemporalSignature, PatternMatch, TrajectoryPrediction } from './types';\n\n// ===================== EVENT TYPES =====================\n\nexport type PensentEventType = \n  | 'signature:extracted'\n  | 'signature:cached'\n  | 'pattern:matched'\n  | 'pattern:notfound'\n  | 'prediction:generated'\n  | 'prediction:lowconfidence'\n  | 'archetype:classified'\n  | 'milestone:reached'\n  | 'error:extraction'\n  | 'error:matching'\n  | 'error:prediction'\n  | 'batch:started'\n  | 'batch:progress'\n  | 'batch:completed';\n\nexport interface PensentEvent<T = unknown> {\n  type: PensentEventType;\n  timestamp: number;\n  domain: string;\n  payload: T;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface SignatureExtractedPayload {\n  signature: TemporalSignature;\n  inputHash: string;\n  extractionTimeMs: number;\n}\n\nexport interface PatternMatchedPayload {\n  matches: PatternMatch[];\n  targetFingerprint: string;\n  searchTimeMs: number;\n}\n\nexport interface PredictionGeneratedPayload {\n  prediction: TrajectoryPrediction;\n  signature: TemporalSignature;\n  predictionTimeMs: number;\n}\n\nexport interface BatchProgressPayload {\n  current: number;\n  total: number;\n  percentage: number;\n  currentItem?: string;\n}\n\nexport interface ErrorPayload {\n  error: Error;\n  context: string;\n  recoverable: boolean;\n}\n\n// ===================== EVENT HANDLER TYPES =====================\n\nexport type PensentEventHandler<T = unknown> = (event: PensentEvent<T>) => void | Promise<void>;\n\nexport type PensentEventFilter = (event: PensentEvent) => boolean;\n\nexport interface EventSubscription {\n  id: string;\n  unsubscribe: () => void;\n}\n\n// ===================== EVENT BUS IMPLEMENTATION =====================\n\n/**\n * Central event bus for En Pensent SDK\n * Provides pub/sub capabilities for reactive event handling\n */\nexport class PensentEventBus {\n  private handlers: Map<PensentEventType | '*', Set<{ \n    id: string; \n    handler: PensentEventHandler; \n    filter?: PensentEventFilter;\n  }>> = new Map();\n  \n  private eventHistory: PensentEvent[] = [];\n  private maxHistorySize = 100;\n  private domain: string;\n\n  constructor(domain: string = 'default') {\n    this.domain = domain;\n  }\n\n  /**\n   * Subscribe to a specific event type\n   */\n  on<T>(\n    eventType: PensentEventType | '*',\n    handler: PensentEventHandler<T>,\n    filter?: PensentEventFilter\n  ): EventSubscription {\n    const id = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    if (!this.handlers.has(eventType)) {\n      this.handlers.set(eventType, new Set());\n    }\n    \n    const subscription = { id, handler: handler as PensentEventHandler, filter };\n    this.handlers.get(eventType)!.add(subscription);\n    \n    return {\n      id,\n      unsubscribe: () => {\n        this.handlers.get(eventType)?.delete(subscription);\n      }\n    };\n  }\n\n  /**\n   * Subscribe to an event type and automatically unsubscribe after first event\n   */\n  once<T>(\n    eventType: PensentEventType,\n    handler: PensentEventHandler<T>\n  ): EventSubscription {\n    const subscription = this.on<T>(eventType, (event) => {\n      subscription.unsubscribe();\n      handler(event);\n    });\n    return subscription;\n  }\n\n  /**\n   * Emit an event to all subscribers\n   */\n  emit<T>(\n    type: PensentEventType,\n    payload: T,\n    metadata?: Record<string, unknown>\n  ): void {\n    const event: PensentEvent<T> = {\n      type,\n      timestamp: Date.now(),\n      domain: this.domain,\n      payload,\n      metadata\n    };\n    \n    // Store in history\n    this.eventHistory.push(event as PensentEvent);\n    if (this.eventHistory.length > this.maxHistorySize) {\n      this.eventHistory.shift();\n    }\n    \n    // Notify type-specific handlers\n    this.notifyHandlers(type, event as PensentEvent);\n    \n    // Notify wildcard handlers\n    this.notifyHandlers('*', event as PensentEvent);\n  }\n\n  private notifyHandlers(eventType: PensentEventType | '*', event: PensentEvent): void {\n    const handlers = this.handlers.get(eventType);\n    if (!handlers) return;\n    \n    for (const { handler, filter } of handlers) {\n      // Apply filter if present\n      if (filter && !filter(event)) continue;\n      \n      try {\n        handler(event);\n      } catch (error) {\n        console.error(`Event handler error for ${eventType}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get event history (optionally filtered by type)\n   */\n  getHistory(eventType?: PensentEventType): PensentEvent[] {\n    if (!eventType) return [...this.eventHistory];\n    return this.eventHistory.filter(e => e.type === eventType);\n  }\n\n  /**\n   * Clear all subscriptions\n   */\n  clear(): void {\n    this.handlers.clear();\n    this.eventHistory = [];\n  }\n\n  /**\n   * Get the number of active subscriptions\n   */\n  get subscriptionCount(): number {\n    let count = 0;\n    for (const handlers of this.handlers.values()) {\n      count += handlers.size;\n    }\n    return count;\n  }\n}\n\n/**\n * Create a new event bus for a domain\n */\nexport function createEventBus(domain: string): PensentEventBus {\n  return new PensentEventBus(domain);\n}\n\n/**\n * Global event bus instance for cross-domain events\n */\nexport const globalEventBus = new PensentEventBus('global');\n";export{n as default};
