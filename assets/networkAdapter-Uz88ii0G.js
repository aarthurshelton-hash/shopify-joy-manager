const n="/**\n * Network Infrastructure Domain Adapter\n * Converts network traffic patterns to En Pensent temporal signatures\n * \n * Network traffic reveals human behavior patterns at scale.\n * This adapter extracts temporal patterns from:\n * - Packet flow dynamics\n * - Latency fluctuations\n * - Bandwidth utilization\n * - Connection patterns\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\ninterface NetworkData {\n  packetsPerSecond: number;\n  bytesPerSecond: number;\n  latencyMs: number;\n  connectionCount: number;\n  errorRate: number;\n  timestamp: number;\n}\n\nclass NetworkDomainAdapter implements DomainAdapter<NetworkData> {\n  domain = 'network' as const;\n  name = 'Network Flow Analyzer';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 1000;\n  \n  // Network health thresholds\n  private readonly THRESHOLDS = {\n    lowLatency: 20,\n    highLatency: 200,\n    lowPacketRate: 100,\n    highPacketRate: 10000,\n    criticalErrorRate: 0.05,\n  };\n\n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[NetworkAdapter] Initialized - Network pattern recognition active');\n  }\n\n  processRawData(data: NetworkData): UniversalSignal {\n    const { packetsPerSecond, bytesPerSecond, latencyMs, connectionCount, errorRate, timestamp } = data;\n    \n    // Normalize packet rate to frequency (treat as oscillation frequency)\n    const frequency = Math.log10(packetsPerSecond + 1) * 100;\n    \n    // Latency affects intensity inversely\n    const intensity = 1 - Math.min(latencyMs / this.THRESHOLDS.highLatency, 1);\n    \n    // Error rate affects phase (errors create \"noise\" in the signal)\n    const phase = errorRate * Math.PI * 2;\n    \n    // Extract harmonics from multi-dimensional network data\n    const harmonics = this.extractHarmonics(packetsPerSecond, bytesPerSecond, connectionCount);\n    \n    const signal: UniversalSignal = {\n      domain: 'network',\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData: [packetsPerSecond, bytesPerSecond, latencyMs, connectionCount, errorRate],\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.lastUpdate = timestamp;\n    return signal;\n  }\n\n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n\n    const recentSignals = signals.slice(-100);\n    \n    // Calculate quadrant profile from network behavior\n    const quadrantProfile = this.calculateQuadrantFromNetwork(recentSignals);\n    \n    // Temporal flow from traffic patterns\n    const temporalFlow = this.calculateTemporalFlow(recentSignals);\n    \n    // Calculate advanced metrics\n    const avgIntensity = recentSignals.reduce((sum, s) => sum + s.intensity, 0) / recentSignals.length;\n    const intensityVariance = this.calculateVariance(recentSignals.map(s => s.intensity));\n    const dominantFreq = this.findDominantFrequency(recentSignals);\n    const harmonicRes = this.calculateHarmonicResonance(recentSignals);\n    const phaseNoise = this.calculatePhaseNoise(recentSignals);\n    \n    return {\n      domain: 'network',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgIntensity,\n      momentum: this.calculateMomentum(recentSignals),\n      volatility: Math.sqrt(intensityVariance),\n      dominantFrequency: dominantFreq,\n      harmonicResonance: harmonicRes,\n      phaseAlignment: 1 - phaseNoise, // Less noise = more alignment\n      extractedAt: Date.now(),\n    };\n  }\n\n  private extractHarmonics(packets: number, bytes: number, connections: number): number[] {\n    // Create harmonic components from different network metrics\n    const baseFreq = Math.log10(packets + 1);\n    const byteRatio = bytes / (packets || 1);\n    const connDensity = connections / (packets || 1);\n    \n    return [\n      baseFreq,\n      baseFreq * 2 * (byteRatio / 1000),\n      baseFreq * 3 * connDensity,\n      Math.sin(baseFreq),\n      Math.cos(baseFreq * 2),\n      (byteRatio / 1500) * Math.sin(baseFreq * 3),\n      connDensity * Math.cos(baseFreq * 4),\n      Math.sin(baseFreq * 5) * Math.cos(byteRatio / 1000),\n    ];\n  }\n\n  private calculateQuadrantFromNetwork(signals: UniversalSignal[]): DomainSignature['quadrantProfile'] {\n    // Map network behavior to quadrants\n    // High throughput = aggressive (pushing data)\n    // Low latency = defensive (maintaining stability)\n    // High connection count = tactical (many actions)\n    // Low error rate = strategic (quality over quantity)\n    \n    const avgPackets = signals.reduce((sum, s) => sum + s.rawData[0], 0) / signals.length;\n    const avgLatency = signals.reduce((sum, s) => sum + s.rawData[2], 0) / signals.length;\n    const avgConnections = signals.reduce((sum, s) => sum + s.rawData[3], 0) / signals.length;\n    const avgErrors = signals.reduce((sum, s) => sum + s.rawData[4], 0) / signals.length;\n    \n    // Normalize\n    const throughputScore = Math.min(avgPackets / this.THRESHOLDS.highPacketRate, 1);\n    const latencyScore = 1 - Math.min(avgLatency / this.THRESHOLDS.highLatency, 1);\n    const connectionScore = Math.min(avgConnections / 1000, 1);\n    const qualityScore = 1 - Math.min(avgErrors / this.THRESHOLDS.criticalErrorRate, 1);\n    \n    const total = throughputScore + latencyScore + connectionScore + qualityScore || 1;\n    \n    return {\n      aggressive: throughputScore / total,\n      defensive: latencyScore / total,\n      tactical: connectionScore / total,\n      strategic: qualityScore / total,\n    };\n  }\n\n  private calculateTemporalFlow(signals: UniversalSignal[]): DomainSignature['temporalFlow'] {\n    const len = signals.length;\n    const third = Math.floor(len / 3);\n    \n    const earlyIntensity = signals.slice(0, third).reduce((sum, s) => sum + s.intensity, 0) / third || 0;\n    const midIntensity = signals.slice(third, 2 * third).reduce((sum, s) => sum + s.intensity, 0) / third || 0;\n    const lateIntensity = signals.slice(2 * third).reduce((sum, s) => sum + s.intensity, 0) / third || 0;\n    \n    const total = earlyIntensity + midIntensity + lateIntensity || 1;\n    \n    return {\n      early: earlyIntensity / total,\n      mid: midIntensity / total,\n      late: lateIntensity / total,\n    };\n  }\n\n  private calculateVariance(values: number[]): number {\n    if (values.length === 0) return 0;\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n  }\n\n  private calculatePhaseNoise(signals: UniversalSignal[]): number {\n    if (signals.length < 2) return 0;\n    \n    let noiseSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      noiseSum += Math.abs(signals[i].phase - signals[i - 1].phase);\n    }\n    \n    return noiseSum / ((signals.length - 1) * Math.PI * 2);\n  }\n\n  private findDominantFrequency(signals: UniversalSignal[]): number {\n    const freqBuckets = new Map<number, number>();\n    \n    signals.forEach(s => {\n      const bucket = Math.round(s.frequency / 10) * 10;\n      freqBuckets.set(bucket, (freqBuckets.get(bucket) || 0) + s.intensity);\n    });\n    \n    let maxBucket = 0;\n    let maxValue = 0;\n    freqBuckets.forEach((value, bucket) => {\n      if (value > maxValue) {\n        maxValue = value;\n        maxBucket = bucket;\n      }\n    });\n    \n    return maxBucket;\n  }\n\n  private calculateHarmonicResonance(signals: UniversalSignal[]): number {\n    if (signals.length < 2) return 0;\n    \n    let resonanceSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      const h1 = signals[i].harmonics;\n      const h2 = signals[i - 1].harmonics;\n      \n      let dotProduct = 0;\n      let mag1 = 0;\n      let mag2 = 0;\n      \n      for (let j = 0; j < h1.length; j++) {\n        dotProduct += h1[j] * h2[j];\n        mag1 += h1[j] * h1[j];\n        mag2 += h2[j] * h2[j];\n      }\n      \n      const denom = Math.sqrt(mag1) * Math.sqrt(mag2);\n      const cosineSim = denom > 0 ? dotProduct / denom : 0;\n      resonanceSum += (cosineSim + 1) / 2;\n    }\n    \n    return resonanceSum / (signals.length - 1);\n  }\n\n  private calculateMomentum(signals: UniversalSignal[]): number {\n    if (signals.length < 10) return 0;\n    \n    const recent = signals.slice(-10);\n    const older = signals.slice(-20, -10);\n    \n    const recentAvg = recent.reduce((sum, s) => sum + s.intensity, 0) / recent.length;\n    const olderAvg = older.length > 0 \n      ? older.reduce((sum, s) => sum + s.intensity, 0) / older.length \n      : recentAvg;\n    \n    return (recentAvg - olderAvg) / (olderAvg || 1);\n  }\n\n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'network',\n      quadrantProfile: { aggressive: 0.25, defensive: 0.25, tactical: 0.25, strategic: 0.25 },\n      temporalFlow: { early: 0.33, mid: 0.34, late: 0.33 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0,\n      dominantFrequency: 100,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now(),\n    };\n  }\n\n  // Generate network signal correlated with market activity\n  generateMarketCorrelatedSignal(marketVolume: number, marketVolatility: number): NetworkData {\n    // High market activity = high network activity\n    const packetsPerSecond = 1000 + (marketVolume * 5000);\n    const bytesPerSecond = packetsPerSecond * (500 + Math.random() * 500);\n    \n    // Market volatility increases latency (uncertainty)\n    const latencyMs = 20 + (marketVolatility * 180);\n    \n    // Active trading = more connections\n    const connectionCount = 50 + Math.floor(marketVolume * 500);\n    \n    // Volatility can cause errors\n    const errorRate = Math.min(0.001 + (marketVolatility * 0.04), 0.1);\n    \n    return {\n      packetsPerSecond,\n      bytesPerSecond,\n      latencyMs,\n      connectionCount,\n      errorRate,\n      timestamp: Date.now(),\n    };\n  }\n}\n\nexport const networkAdapter = new NetworkDomainAdapter();\nexport type { NetworkData };\n";export{n as default};
