const e="// Encode visualization state into a compact URL parameter for sharing\n// State is encoded as base64 to keep URLs relatively short\n\nimport { GamePhase } from '@/contexts/TimelineContext';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\n\nexport interface ShareableState {\n  // Timeline position\n  move?: number;\n  phase?: GamePhase;\n  // Visual options\n  dark?: boolean;\n  pieces?: boolean;\n  opacity?: number;\n  // Locked pieces for highlighting\n  locked?: Array<{ type: string; color: string }>;\n  // Locked squares for persistent square highlighting\n  lockedSquares?: Array<{ square: string; pieces: Array<{ type: string; color: string }> }>;\n  // Compare mode\n  compare?: boolean;\n  // Territory/heatmap modes\n  territory?: boolean;\n  heatmaps?: boolean;\n}\n\n/**\n * Full visualization state for session storage\n */\nexport interface FullShareableState extends ShareableState {\n  displayMode?: 'art' | 'analysis' | 'minimal';\n  highlightedPiece?: { type: string; color: string } | null;\n  isPlaying?: boolean;\n}\n\n/**\n * Encode visualization state into a compact URL-safe string\n */\nexport function encodeShareState(state: ShareableState): string {\n  // Only include non-default values to keep URL short\n  const compact: Record<string, unknown> = {};\n  \n  if (state.move !== undefined && state.move > 0 && state.move !== Infinity) {\n    compact.m = state.move;\n  }\n  if (state.phase && state.phase !== 'all') {\n    compact.ph = state.phase;\n  }\n  if (state.dark) {\n    compact.d = 1;\n  }\n  if (state.pieces) {\n    compact.p = 1;\n  }\n  if (state.opacity !== undefined && state.opacity !== 0.7) {\n    compact.o = Math.round(state.opacity * 100);\n  }\n  if (state.locked && state.locked.length > 0) {\n    // Encode locked pieces as compact string: \"wK,bQ\" for white King, black Queen\n    compact.l = state.locked.map(p => `${p.color}${p.type}`).join(',');\n  }\n  if (state.lockedSquares && state.lockedSquares.length > 0) {\n    // Encode locked squares as array: [{ s: \"e4\", p: \"wK,bQ\" }, ...]\n    compact.ls = state.lockedSquares.map(sq => ({\n      s: sq.square,\n      p: sq.pieces.map(p => `${p.color}${p.type}`).join(','),\n    }));\n  }\n  if (state.compare) {\n    compact.c = 1;\n  }\n  if (state.territory) {\n    compact.t = 1;\n  }\n  if (state.heatmaps) {\n    compact.h = 1;\n  }\n  \n  // Return empty string if no state to encode\n  if (Object.keys(compact).length === 0) {\n    return '';\n  }\n  \n  try {\n    const json = JSON.stringify(compact);\n    // Use base64 encoding for URL safety\n    return btoa(json).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Decode visualization state from URL parameter\n */\nexport function decodeShareState(encoded: string | null): ShareableState {\n  if (!encoded) return {};\n  \n  try {\n    // Restore base64 padding and characters\n    let base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');\n    while (base64.length % 4) {\n      base64 += '=';\n    }\n    \n    const json = atob(base64);\n    const compact = JSON.parse(json);\n    \n    const state: ShareableState = {};\n    \n    if (compact.m !== undefined) {\n      state.move = compact.m;\n    }\n    if (compact.ph) {\n      state.phase = compact.ph as GamePhase;\n    }\n    if (compact.d) {\n      state.dark = true;\n    }\n    if (compact.p) {\n      state.pieces = true;\n    }\n    if (compact.o !== undefined) {\n      state.opacity = compact.o / 100;\n    }\n    if (compact.l) {\n      state.locked = compact.l.split(',').map((s: string) => ({\n        color: s[0],\n        type: s.slice(1),\n      }));\n    }\n    if (compact.ls && Array.isArray(compact.ls)) {\n      state.lockedSquares = compact.ls.map((sq: { s: string; p: string }) => ({\n        square: sq.s,\n        pieces: sq.p.split(',').map((p: string) => ({\n          color: p[0],\n          type: p.slice(1),\n        })),\n      }));\n    }\n    if (compact.c) {\n      state.compare = true;\n    }\n    if (compact.t) {\n      state.territory = true;\n    }\n    if (compact.h) {\n      state.heatmaps = true;\n    }\n    \n    return state;\n  } catch {\n    return {};\n  }\n}\n\n/**\n * Build a shareable URL with encoded state\n */\nexport function buildShareUrl(baseUrl: string, state: ShareableState): string {\n  const encoded = encodeShareState(state);\n  if (!encoded) return baseUrl;\n  \n  const url = new URL(baseUrl);\n  url.searchParams.set('s', encoded);\n  return url.toString();\n}\n\n/**\n * Extract state from current URL\n */\nexport function getStateFromUrl(): ShareableState {\n  if (typeof window === 'undefined') return {};\n  \n  const url = new URL(window.location.href);\n  const encoded = url.searchParams.get('s');\n  return decodeShareState(encoded);\n}\n\n/**\n * Convert ShareableState to FullVisualizationState format for session storage\n */\nexport function shareableToFullState(\n  state: ShareableState,\n  sourceRoute: string,\n  extras?: {\n    visualizationId?: string;\n    pgn?: string;\n    displayMode?: 'art' | 'analysis' | 'minimal';\n  }\n): {\n  currentMove: number;\n  selectedPhase: GamePhase;\n  isPlaying: boolean;\n  lockedPieces: Array<{ pieceType: PieceType; pieceColor: PieceColor }>;\n  lockedSquares: Array<{ square: string; pieces: Array<{ pieceType: PieceType; pieceColor: PieceColor }> }>;\n  compareMode: boolean;\n  highlightedPiece: null;\n  displayMode: 'art' | 'analysis' | 'minimal';\n  darkMode: boolean;\n  showTerritory: boolean;\n  showHeatmaps: boolean;\n  showPieces: boolean;\n  pieceOpacity: number;\n  capturedAt: number;\n  sourceRoute: string;\n  visualizationId?: string;\n  pgn?: string;\n} {\n  return {\n    currentMove: state.move ?? Infinity,\n    selectedPhase: state.phase ?? 'all',\n    isPlaying: false,\n    lockedPieces: (state.locked ?? []).map(p => ({\n      pieceType: p.type as PieceType,\n      pieceColor: p.color as PieceColor,\n    })),\n    lockedSquares: (state.lockedSquares ?? []).map(sq => ({\n      square: sq.square,\n      pieces: sq.pieces.map(p => ({\n        pieceType: p.type as PieceType,\n        pieceColor: p.color as PieceColor,\n      })),\n    })),\n    compareMode: state.compare ?? false,\n    highlightedPiece: null,\n    displayMode: extras?.displayMode ?? 'art',\n    darkMode: state.dark ?? false,\n    showTerritory: state.territory ?? false,\n    showHeatmaps: state.heatmaps ?? false,\n    showPieces: state.pieces ?? false,\n    pieceOpacity: state.opacity ?? 0.7,\n    capturedAt: Date.now(),\n    sourceRoute,\n    visualizationId: extras?.visualizationId,\n    pgn: extras?.pgn,\n  };\n}\n\n/**\n * Convert FullVisualizationState to ShareableState for URL encoding\n */\nexport function fullStateToShareable(state: {\n  currentMove?: number;\n  selectedPhase?: GamePhase;\n  lockedPieces?: Array<{ pieceType: PieceType; pieceColor: PieceColor }>;\n  lockedSquares?: Array<{ square: string; pieces: Array<{ pieceType: PieceType; pieceColor: PieceColor }> }>;\n  compareMode?: boolean;\n  darkMode?: boolean;\n  showTerritory?: boolean;\n  showHeatmaps?: boolean;\n  showPieces?: boolean;\n  pieceOpacity?: number;\n}): ShareableState {\n  return {\n    move: state.currentMove !== Infinity ? state.currentMove : undefined,\n    phase: state.selectedPhase !== 'all' ? state.selectedPhase : undefined,\n    dark: state.darkMode || undefined,\n    pieces: state.showPieces || undefined,\n    opacity: state.pieceOpacity !== 0.7 ? state.pieceOpacity : undefined,\n    locked: state.lockedPieces?.length ? state.lockedPieces.map(p => ({\n      type: p.pieceType,\n      color: p.pieceColor,\n    })) : undefined,\n    lockedSquares: state.lockedSquares?.length ? state.lockedSquares.map(sq => ({\n      square: sq.square,\n      pieces: sq.pieces.map(p => ({\n        type: p.pieceType,\n        color: p.pieceColor,\n      })),\n    })) : undefined,\n    compare: state.compareMode || undefined,\n    territory: state.showTerritory || undefined,\n    heatmaps: state.showHeatmaps || undefined,\n  };\n}";export{e as default};
