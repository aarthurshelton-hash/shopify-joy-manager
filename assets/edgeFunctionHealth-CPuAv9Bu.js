const n="/**\n * Edge Function Health Monitoring Utilities\n * \n * Provides health check capabilities for Supabase Edge Functions\n * with caching, retry logic, and metrics tracking.\n */\n\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface HealthCheckResult {\n  functionName: string;\n  status: 'healthy' | 'warning' | 'error' | 'unhealthy' | 'unknown';\n  responseTime: number;\n  lastChecked: string;\n  error?: string;\n  details?: Record<string, unknown>;\n}\n\nexport interface FunctionMetrics {\n  functionName: string;\n  totalInvocations: number;\n  successfulInvocations: number;\n  failedInvocations: number;\n  averageResponseTime: number;\n  p95ResponseTime: number;\n  p99ResponseTime: number;\n  errorRate: number;\n  lastInvocation: string;\n}\n\n// Cache for health check results\nconst healthCache = new Map<string, { result: HealthCheckResult; timestamp: number }>();\nconst HEALTH_CACHE_TTL = 30_000; // 30 seconds\n\n// Response time tracking for metrics\nconst responseTimeHistory = new Map<string, number[]>();\nconst MAX_HISTORY_SIZE = 100;\n\n/**\n * Check health of a specific edge function\n */\nexport async function checkEdgeFunctionHealth(\n  functionName: string,\n  timeout: number = 5000\n): Promise<HealthCheckResult> {\n  // Check cache first\n  const cached = healthCache.get(functionName);\n  if (cached && Date.now() - cached.timestamp < HEALTH_CACHE_TTL) {\n    return cached.result;\n  }\n\n  const start = performance.now();\n  let result: HealthCheckResult;\n\n  try {\n    const { data, error } = await supabase.functions.invoke(\n      functionName,\n      {\n        body: { healthCheck: true, timestamp: Date.now() },\n      }\n    );\n\n    const responseTime = performance.now() - start;\n\n    // Track response time for metrics\n    trackResponseTime(functionName, responseTime);\n\n    if (error) {\n      result = {\n        functionName,\n        status: 'error',\n        responseTime,\n        lastChecked: new Date().toISOString(),\n        error: error.message,\n      };\n    } else {\n      // Determine status based on response time\n      let status: HealthCheckResult['status'] = 'healthy';\n      if (responseTime > 3000) status = 'unhealthy';\n      else if (responseTime > 1000) status = 'warning';\n\n      result = {\n        functionName,\n        status,\n        responseTime,\n        lastChecked: new Date().toISOString(),\n        details: data,\n      };\n    }\n  } catch (err) {\n    const responseTime = performance.now() - start;\n    result = {\n      functionName,\n      status: 'unhealthy',\n      responseTime,\n      lastChecked: new Date().toISOString(),\n      error: err instanceof Error ? err.message : 'Unknown error',\n    };\n  }\n\n  // Cache the result\n  healthCache.set(functionName, { result, timestamp: Date.now() });\n\n  return result;\n}\n\n/**\n * Check health of multiple edge functions in parallel\n */\nexport async function checkMultipleFunctions(\n  functionNames: string[],\n  timeout: number = 5000\n): Promise<HealthCheckResult[]> {\n  const promises = functionNames.map(name => checkEdgeFunctionHealth(name, timeout));\n  return Promise.all(promises);\n}\n\n/**\n * Track response time for metrics calculation\n */\nfunction trackResponseTime(functionName: string, responseTime: number): void {\n  if (!responseTimeHistory.has(functionName)) {\n    responseTimeHistory.set(functionName, []);\n  }\n\n  const history = responseTimeHistory.get(functionName)!;\n  history.push(responseTime);\n\n  // Keep only last N entries\n  if (history.length > MAX_HISTORY_SIZE) {\n    history.shift();\n  }\n}\n\n/**\n * Get metrics for a specific function\n */\nexport function getFunctionMetrics(functionName: string): FunctionMetrics | null {\n  const history = responseTimeHistory.get(functionName);\n  if (!history || history.length === 0) return null;\n\n  const sorted = [...history].sort((a, b) => a - b);\n  const total = sorted.length;\n  const sum = sorted.reduce((a, b) => a + b, 0);\n\n  return {\n    functionName,\n    totalInvocations: total,\n    successfulInvocations: total, // Simplified - would track actual success/failure\n    failedInvocations: 0,\n    averageResponseTime: sum / total,\n    p95ResponseTime: sorted[Math.floor(total * 0.95)] || sorted[total - 1],\n    p99ResponseTime: sorted[Math.floor(total * 0.99)] || sorted[total - 1],\n    errorRate: 0, // Would be calculated from actual error tracking\n    lastInvocation: new Date().toISOString(),\n  };\n}\n\n/**\n * Get cached health result without making a new request\n */\nexport function getCachedHealth(functionName: string): HealthCheckResult | null {\n  const cached = healthCache.get(functionName);\n  if (cached && Date.now() - cached.timestamp < HEALTH_CACHE_TTL) {\n    return cached.result;\n  }\n  return null;\n}\n\n/**\n * Clear health check cache\n */\nexport function clearHealthCache(): void {\n  healthCache.clear();\n}\n\n/**\n * Get overall system health status\n */\nexport function getSystemHealthStatus(results: HealthCheckResult[]): {\n  status: 'healthy' | 'warning' | 'critical';\n  healthy: number;\n  warning: number;\n  error: number;\n  total: number;\n} {\n  const healthy = results.filter(r => r.status === 'healthy').length;\n  const warning = results.filter(r => r.status === 'warning').length;\n  const error = results.filter(r => r.status === 'error' || r.status === 'unhealthy').length;\n  const total = results.length;\n\n  let status: 'healthy' | 'warning' | 'critical' = 'healthy';\n  if (error > 0) status = 'critical';\n  else if (warning > 0) status = 'warning';\n\n  return { status, healthy, warning, error, total };\n}\n\n// Standard edge functions to monitor\nexport const STANDARD_EDGE_FUNCTIONS = [\n  'check-subscription',\n  'create-checkout',\n  'customer-portal',\n  'grant-ceo-admin',\n  'stockfish-eval',\n] as const;\n\nexport type EdgeFunctionName = typeof STANDARD_EDGE_FUNCTIONS[number];\n";export{n as default};
