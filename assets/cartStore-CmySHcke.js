const n="import { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\nimport { toast } from 'sonner';\nimport { useCurrencyStore } from './currencyStore';\n\n// Map currency codes to Shopify country codes for checkout localization\nconst CURRENCY_TO_COUNTRY: Record<string, string> = {\n  USD: 'US',\n  CAD: 'CA',\n  EUR: 'DE', // Default to Germany for Euro\n  GBP: 'GB',\n  AUD: 'AU',\n  JPY: 'JP',\n  CHF: 'CH',\n  CNY: 'CN',\n  INR: 'IN',\n  MXN: 'MX',\n  BRL: 'BR',\n  KRW: 'KR',\n};\n\n// Re-export types from API\nexport type { ShopifyProduct } from '@/lib/shopify/api';\n\nexport interface CartItem {\n  product: {\n    node: {\n      id: string;\n      title: string;\n      description: string;\n      handle: string;\n      priceRange: {\n        minVariantPrice: {\n          amount: string;\n          currencyCode: string;\n        };\n      };\n      images: {\n        edges: Array<{\n          node: {\n            url: string;\n            altText: string | null;\n          };\n        }>;\n      };\n      variants: {\n        edges: Array<{\n          node: {\n            id: string;\n            title: string;\n            price: {\n              amount: string;\n              currencyCode: string;\n            };\n            availableForSale: boolean;\n            selectedOptions: Array<{\n              name: string;\n              value: string;\n            }>;\n          };\n        }>;\n      };\n      options: Array<{\n        name: string;\n        values: string[];\n      }>;\n    };\n  };\n  variantId: string;\n  variantTitle: string;\n  price: {\n    amount: string;\n    currencyCode: string;\n  };\n  quantity: number;\n  selectedOptions: Array<{\n    name: string;\n    value: string;\n  }>;\n  customPrintData?: {\n    pgn: string;\n    gameTitle: string;\n    previewImageBase64?: string; // Exact current state image for cart thumbnail\n    printImageUrl?: string; // Public URL for Printify fulfillment\n    frameStyle?: string;\n    includeInfoCard?: boolean;\n    visualizationId?: string; // For tracking and royalties\n    gameId?: string; // For game pool attribution\n    paletteId?: string; // For palette pool attribution\n    // Game data for display in cart\n    gameData?: {\n      white?: string;\n      black?: string;\n      event?: string;\n      date?: string;\n      result?: string;\n    };\n    // Game hash for canonical navigation\n    gameHash?: string;\n    // FEN string for position-only visualizations\n    fen?: string;\n    // Captured visualization state - ensures print matches exactly what user sees\n    capturedState?: {\n      currentMove: number;\n      lockedPieces: Array<{ pieceType: string; pieceColor: string }>;\n      compareMode: boolean;\n      darkMode: boolean;\n      showPieces?: boolean;\n      pieceOpacity?: number;\n    };\n  };\n}\n\n// Shopify config\nconst SHOPIFY_API_VERSION = '2025-07';\nconst SHOPIFY_STORE_PERMANENT_DOMAIN = 'printify-shop-manager-fs4kw.myshopify.com';\nconst SHOPIFY_STOREFRONT_URL = `https://${SHOPIFY_STORE_PERMANENT_DOMAIN}/api/${SHOPIFY_API_VERSION}/graphql.json`;\nconst SHOPIFY_STOREFRONT_TOKEN = 'a0ffa036b52f6150e7e1bfaf4b307ff4';\n\n// Retry configuration for heavy business load\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\nconst CIRCUIT_BREAKER_THRESHOLD = 5;\nconst CIRCUIT_BREAKER_RESET_MS = 60000; // 1 minute\n\n// Circuit breaker state\nlet consecutiveFailures = 0;\nlet circuitBreakerOpen = false;\nlet lastFailureTime = 0;\n\n/**\n * Check if circuit breaker is open\n */\nfunction isCircuitBreakerOpen(): boolean {\n  if (!circuitBreakerOpen) return false;\n  \n  // Check if enough time has passed to try again\n  if (Date.now() - lastFailureTime > CIRCUIT_BREAKER_RESET_MS) {\n    circuitBreakerOpen = false;\n    consecutiveFailures = 0;\n    console.log('[CartStore] Circuit breaker reset');\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Record success - reset failure count\n */\nfunction recordSuccess(): void {\n  consecutiveFailures = 0;\n}\n\n/**\n * Record failure - increment failure count and potentially open circuit breaker\n */\nfunction recordFailure(): void {\n  consecutiveFailures++;\n  lastFailureTime = Date.now();\n  \n  if (consecutiveFailures >= CIRCUIT_BREAKER_THRESHOLD) {\n    circuitBreakerOpen = true;\n    console.error(`[CartStore] Circuit breaker opened after ${consecutiveFailures} failures`);\n  }\n}\n\n/**\n * Delay utility for retries\n */\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Cart creation mutation with buyer identity for currency localization\n// Includes attributes for custom line item properties (print images, viz IDs, etc.)\nconst CART_CREATE_MUTATION = `\n  mutation cartCreate($input: CartInput!, $country: CountryCode) @inContext(country: $country) {\n    cartCreate(input: $input) {\n      cart {\n        id\n        checkoutUrl\n      }\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n`;\n\nasync function createStorefrontCheckoutWithRetry(items: CartItem[], attempt = 1): Promise<string> {\n  // Check circuit breaker\n  if (isCircuitBreakerOpen()) {\n    throw new Error('Payment system temporarily unavailable. Please try again in a minute.');\n  }\n\n  try {\n    const result = await createStorefrontCheckout(items);\n    recordSuccess();\n    return result;\n  } catch (error) {\n    recordFailure();\n    \n    // Retry logic for transient errors\n    if (attempt < MAX_RETRIES) {\n      const isRetryable = error instanceof Error && (\n        error.message.includes('network') ||\n        error.message.includes('timeout') ||\n        error.message.includes('rate limit') ||\n        error.message.includes('502') ||\n        error.message.includes('503') ||\n        error.message.includes('504')\n      );\n      \n      if (isRetryable) {\n        console.log(`[CartStore] Retrying checkout (attempt ${attempt + 1}/${MAX_RETRIES})...`);\n        await delay(RETRY_DELAY_MS * attempt); // Exponential backoff\n        return createStorefrontCheckoutWithRetry(items, attempt + 1);\n      }\n    }\n    \n    throw error;\n  }\n}\n\nasync function createStorefrontCheckout(items: CartItem[]): Promise<string> {\n  const lines = items.map(item => {\n    // Build line item with attributes for custom print data\n    const lineItem: {\n      quantity: number;\n      merchandiseId: string;\n      attributes?: Array<{ key: string; value: string }>;\n    } = {\n      quantity: item.quantity,\n      merchandiseId: item.variantId,\n    };\n    \n    // Add custom attributes for print fulfillment\n    if (item.customPrintData) {\n      const attributes: Array<{ key: string; value: string }> = [];\n      \n      // Add print image URL for Printify\n      if (item.customPrintData.printImageUrl) {\n        attributes.push({ key: '_custom_image_url', value: item.customPrintData.printImageUrl });\n      }\n      \n      // Add game title for order identification\n      if (item.customPrintData.gameTitle) {\n        attributes.push({ key: '_game_title', value: item.customPrintData.gameTitle });\n      }\n      \n      // Add visualization ID for tracking and royalties\n      if (item.customPrintData.visualizationId) {\n        attributes.push({ key: '_visualization_id', value: item.customPrintData.visualizationId });\n      }\n      \n      // Add game ID for game pool attribution\n      if (item.customPrintData.gameId) {\n        attributes.push({ key: '_game_id', value: item.customPrintData.gameId });\n      }\n      \n      // Add palette ID for palette pool attribution\n      if (item.customPrintData.paletteId) {\n        attributes.push({ key: '_palette_id', value: item.customPrintData.paletteId });\n      }\n      \n      // Add frame style if present\n      if (item.customPrintData.frameStyle) {\n        attributes.push({ key: '_frame_style', value: item.customPrintData.frameStyle });\n      }\n      \n      // Add info card flag if present\n      if (item.customPrintData.includeInfoCard) {\n        attributes.push({ key: '_include_info_card', value: 'true' });\n      }\n      \n      if (attributes.length > 0) {\n        lineItem.attributes = attributes;\n      }\n    }\n    \n    return lineItem;\n  });\n\n  // Get user's selected currency and map to country code\n  const selectedCurrency = useCurrencyStore.getState().selectedCurrency;\n  const countryCode = CURRENCY_TO_COUNTRY[selectedCurrency.code] || 'US';\n\n  const response = await fetch(SHOPIFY_STOREFRONT_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Shopify-Storefront-Access-Token': SHOPIFY_STOREFRONT_TOKEN\n    },\n    body: JSON.stringify({\n      query: CART_CREATE_MUTATION,\n      variables: { \n        input: { lines },\n        country: countryCode\n      },\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const data = await response.json();\n  \n  if (data.errors) {\n    throw new Error(`Shopify error: ${data.errors.map((e: { message: string }) => e.message).join(', ')}`);\n  }\n\n  if (data.data.cartCreate.userErrors.length > 0) {\n    throw new Error(`Cart error: ${data.data.cartCreate.userErrors.map((e: { message: string }) => e.message).join(', ')}`);\n  }\n\n  const checkoutUrl = data.data.cartCreate.cart?.checkoutUrl;\n  if (!checkoutUrl) {\n    throw new Error('No checkout URL returned');\n  }\n\n  const url = new URL(checkoutUrl);\n  url.searchParams.set('channel', 'online_store');\n  return url.toString();\n}\n\ninterface CartStore {\n  items: CartItem[];\n  checkoutUrl: string | null;\n  isLoading: boolean;\n  \n  addItem: (item: CartItem) => void;\n  updateQuantity: (variantId: string, quantity: number) => void;\n  removeItem: (variantId: string) => void;\n  clearCart: () => void;\n  setLoading: (loading: boolean) => void;\n  createCheckout: () => Promise<void>;\n}\n\nexport const useCartStore = create<CartStore>()(\n  persist(\n    (set, get) => ({\n      items: [],\n      checkoutUrl: null,\n      isLoading: false,\n\n      addItem: (item) => {\n        const { items } = get();\n        const existingItem = items.find(i => i.variantId === item.variantId);\n        \n        if (existingItem) {\n          set({\n            items: items.map(i =>\n              i.variantId === item.variantId\n                ? { ...i, quantity: i.quantity + item.quantity }\n                : i\n            )\n          });\n        } else {\n          set({ items: [...items, item] });\n        }\n        \n        toast.success('Added to cart!', { \n          duration: 2000,\n          position: 'top-center'\n        });\n      },\n\n      updateQuantity: (variantId, quantity) => {\n        if (quantity <= 0) {\n          get().removeItem(variantId);\n          return;\n        }\n        set({\n          items: get().items.map(item =>\n            item.variantId === variantId ? { ...item, quantity } : item\n          )\n        });\n      },\n\n      removeItem: (variantId) => {\n        set({\n          items: get().items.filter(item => item.variantId !== variantId)\n        });\n      },\n\n      clearCart: () => {\n        set({ items: [], checkoutUrl: null });\n      },\n\n      setLoading: (isLoading) => set({ isLoading }),\n\n      createCheckout: async () => {\n        const { items } = get();\n        if (items.length === 0) {\n          toast.error('Your cart is empty');\n          return;\n        }\n\n        set({ isLoading: true });\n        try {\n          const checkoutUrl = await createStorefrontCheckoutWithRetry(items);\n          set({ checkoutUrl });\n          \n          // Clear cart after successful checkout creation\n          set({ items: [] });\n          \n          toast.success('Checkout ready!', {\n            description: 'Redirecting to secure checkout...'\n          });\n        } catch (error) {\n          console.error('Failed to create checkout:', error);\n          const message = error instanceof Error ? error.message : 'Checkout failed';\n          toast.error('Checkout failed', {\n            description: message.includes('circuit breaker') \n              ? 'Payment system temporarily unavailable. Please try again shortly.'\n              : 'Please try again or contact support if the problem persists.'\n          });\n        } finally {\n          set({ isLoading: false });\n        }\n      }\n    }),\n    {\n      name: 'en-pensent-cart',\n      storage: createJSONStorage(() => localStorage),\n    }\n  )\n);";export{n as default};
