const t="/**\n * Big Picture Metrics Calculator\n */\n\nimport { MarketTick, BigPictureState, AssetClass } from './types';\nimport { calculateTrend, calculateVolatility } from './signalDetector';\n\nexport function calculateMetrics(\n  tickHistory: Map<AssetClass, MarketTick[]>,\n  currentState: BigPictureState\n): Partial<BigPictureState> {\n  const equity = tickHistory.get('equity') || [];\n  const bond = tickHistory.get('bond') || [];\n  const commodity = tickHistory.get('commodity') || [];\n  const crypto = tickHistory.get('crypto') || [];\n\n  // Market sentiment: weighted average of trends\n  const trends = [\n    { weight: 0.4, trend: calculateTrend(equity.slice(-20)) },\n    { weight: 0.2, trend: calculateTrend(commodity.slice(-20)) },\n    { weight: 0.2, trend: calculateTrend(crypto.slice(-20)) },\n    { weight: 0.2, trend: -calculateTrend(bond.slice(-20)) }\n  ];\n\n  const marketSentiment = trends.reduce((sum, t) => sum + t.weight * t.trend, 0);\n\n  // Volatility index\n  const vols = [\n    calculateVolatility(equity.slice(-20)),\n    calculateVolatility(bond.slice(-20)),\n    calculateVolatility(commodity.slice(-20))\n  ].filter(v => v > 0);\n\n  const volatilityIndex = vols.length > 0 \n    ? Math.min(100, vols.reduce((a, b) => a + b, 0) / vols.length * 500)\n    : 20;\n\n  // Risk appetite\n  const riskAppetite = calculateTrend(equity.slice(-10)) - calculateTrend(bond.slice(-10));\n\n  // Trend alignment\n  const allTrends = [\n    calculateTrend(equity.slice(-10)),\n    calculateTrend(commodity.slice(-10)),\n    calculateTrend(crypto.slice(-10))\n  ].filter(t => !isNaN(t));\n\n  let trendAlignment = 0.5;\n  if (allTrends.length >= 2) {\n    const avgTrend = allTrends.reduce((a, b) => a + b, 0) / allTrends.length;\n    const variance = allTrends.reduce((sum, t) => sum + Math.pow(t - avgTrend, 2), 0) / allTrends.length;\n    trendAlignment = Math.max(0, 1 - variance);\n  }\n\n  return {\n    marketSentiment,\n    volatilityIndex,\n    riskAppetite,\n    trendAlignment\n  };\n}\n\nexport function calculatePredictionBoost(state: BigPictureState): number {\n  let boost = 1.0;\n\n  // High alignment increases confidence\n  boost += state.trendAlignment * 0.2;\n\n  // Strong signals increase confidence\n  const strongSignals = state.activeSignals.filter(s => s.strength > 0.5);\n  boost += strongSignals.length * 0.05;\n\n  // High correlation strength increases confidence\n  const avgCorrelationStrength = state.correlations.length > 0\n    ? state.correlations.reduce((sum, c) => sum + c.strength, 0) / state.correlations.length\n    : 0;\n  boost += avgCorrelationStrength * 0.15;\n\n  // Extreme volatility reduces confidence\n  if (state.volatilityIndex > 50) {\n    boost -= (state.volatilityIndex - 50) / 100;\n  }\n\n  return Math.max(0.5, Math.min(1.5, boost));\n}\n";export{t as default};
