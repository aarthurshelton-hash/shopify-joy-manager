const n="/**\n * Sensory-Memory-Humor Adapter\n * \n * CEO Insight (Alec Arthur Shelton):\n * \"Humans change based on hunger or not... study what humans feel enjoyment from\n * certain smells, tastes, touches, vibes, and how memory is intertwined (nostalgia).\n * Go beyond evolutionary instinct and you'll find sophistication uses the same core\n * principles paired with civility. The humor was always there to begin with - it is\n * just our perception that is variably differing.\"\n * \n * This adapter models the deep connection between:\n * - Physiological states (hunger, satiation, arousal)\n * - Sensory preferences and aversions\n * - Memory-nostalgia feedback loops\n * - Humor as pattern recognition with variable perception\n * - Inside jokes as entrainment markers\n */\n\nimport { UniversalSignal, DomainSignature, DomainType } from '../types';\n\n// ============================================================================\n// PHYSIOLOGICAL STATE MODULATION\n// ============================================================================\n\n/**\n * Hunger State Theory:\n * Human decision-making shifts dramatically based on metabolic state.\n * Markets exhibit similar \"hunger\" - periods of accumulation (starving)\n * vs distribution (satiated).\n */\nconst PHYSIOLOGICAL_STATES = {\n  STARVING: {\n    state: 'starving',\n    riskTolerance: 0.9,      // Desperate, will take any opportunity\n    timeHorizon: 'immediate',\n    decisionQuality: 0.4,    // Impaired judgment\n    marketAnalog: 'capitulation_buying',\n    description: 'Survival mode - primal drives dominate rational thought'\n  },\n  HUNGRY: {\n    state: 'hungry',\n    riskTolerance: 0.7,\n    timeHorizon: 'short',\n    decisionQuality: 0.6,\n    marketAnalog: 'accumulation',\n    description: 'Seeking mode - heightened attention to opportunities'\n  },\n  SATISFIED: {\n    state: 'satisfied',\n    riskTolerance: 0.5,\n    timeHorizon: 'medium',\n    decisionQuality: 0.9,    // Optimal decision-making\n    marketAnalog: 'consolidation',\n    description: 'Balanced state - rational evaluation possible'\n  },\n  SATIATED: {\n    state: 'satiated',\n    riskTolerance: 0.3,\n    timeHorizon: 'long',\n    decisionQuality: 0.7,\n    marketAnalog: 'distribution',\n    description: 'Comfort mode - tendency toward complacency'\n  },\n  GLUTTED: {\n    state: 'glutted',\n    riskTolerance: 0.1,\n    timeHorizon: 'none',\n    decisionQuality: 0.5,\n    marketAnalog: 'euphoria_top',\n    description: 'Excess mode - inability to see risk'\n  }\n} as const;\n\n// ============================================================================\n// SENSORY PREFERENCE MATHEMATICS\n// ============================================================================\n\n/**\n * Why do humans like/dislike things?\n * \n * Preference = f(Evolutionary_Fitness, Memory_Association, Social_Context, Current_State)\n * \n * The same stimulus can produce:\n * - Strong positive (love)\n * - Strong negative (disgust)\n * - Both at once (bittersweet, guilty pleasure)\n * - Variable (depends on context/mood)\n */\nconst SENSORY_VALENCE_MODEL = {\n  // Core sensory channels\n  CHANNELS: ['smell', 'taste', 'touch', 'sound', 'sight', 'vibe'] as const,\n  \n  // Valence calculation factors\n  FACTORS: {\n    evolutionaryWeight: 0.25,    // Hardwired preferences (sweet = energy)\n    memoryWeight: 0.35,          // Nostalgia/trauma associations\n    socialWeight: 0.20,          // Peer influence, belonging\n    stateWeight: 0.20            // Current physiological/emotional state\n  },\n  \n  // The \"lie to yourself\" phenomenon\n  SELF_DECEPTION_MODES: {\n    denial: 'Rejecting true preferences due to shame/fear',\n    conformity: 'Adopting preferences to fit in',\n    rationalization: 'Inventing logical reasons for emotional choices',\n    projection: 'Attributing own preferences to others'\n  }\n};\n\n/**\n * Nostalgia as Pattern Recognition\n * \n * Nostalgia = Recognition(CurrentPattern, StoredPattern) × EmotionalIntensity\n * \n * The smell of grandmother's cookies doesn't just remind you of her -\n * it RECONSTRUCTS the entire emotional state of being with her.\n */\ninterface NostalgiaSignal {\n  triggerSense: typeof SENSORY_VALENCE_MODEL.CHANNELS[number];\n  patternMatchStrength: number;     // 0-1: How closely current matches memory\n  emotionalIntensity: number;       // 0-1: How strong the original emotion was\n  temporalDistance: number;         // Years since original experience\n  reconstructionFidelity: number;   // How completely the state is reconstructed\n  valence: 'positive' | 'negative' | 'bittersweet' | 'ambivalent';\n}\n\n// ============================================================================\n// HUMOR AS PATTERN RECOGNITION\n// ============================================================================\n\n/**\n * The Mathematics of Funny\n * \n * CEO Insight: \"The humor was always there to begin with - \n * it is just our perception that is variably differing.\"\n * \n * Humor = PatternViolation × PatternRecognition × SafetyContext\n * \n * Something is funny when:\n * 1. An expected pattern is violated (surprise)\n * 2. We recognize what pattern was violated (understanding)\n * 3. The violation is non-threatening (safety)\n */\nconst HUMOR_MATHEMATICS = {\n  // Core formula components\n  COMPONENTS: {\n    patternViolation: {\n      description: 'Deviation from expected pattern',\n      examples: ['punchline subverts setup', 'absurd juxtaposition', 'broken expectation']\n    },\n    patternRecognition: {\n      description: 'Understanding what pattern was violated',\n      examples: ['getting the reference', 'seeing the connection', 'understanding context']\n    },\n    safetyContext: {\n      description: 'Non-threatening environment for pattern violation',\n      examples: ['among friends', 'clearly fictional', 'socially permitted']\n    }\n  },\n  \n  // The Inside Joke Phenomenon\n  INSIDE_JOKE_DYNAMICS: {\n    layerDepth: 'Number of shared contexts required to understand',\n    entrainmentMarker: 'Shared laughter = neural synchronization = group bonding',\n    exclusionFunction: 'Not getting it = not in the group',\n    fakeInclusionParadox: 'Pretending to get it to belong (but absorption happens anyway)'\n  },\n  \n  // Meme Evolution Theory\n  MEME_PROPAGATION: {\n    initialHumor: 'Core pattern violation that is universally relatable',\n    contextLayers: 'Each iteration adds reference layers',\n    absurdistAmplification: 'Deeper understanding = funnier (inverse of explanation)',\n    deathByExplanation: 'Explaining removes the pattern violation surprise'\n  }\n};\n\n/**\n * Calculate humor score for a pattern\n */\nfunction calculateHumorScore(\n  patternViolationMagnitude: number,  // How unexpected (0-1)\n  recognitionProbability: number,      // % of audience who will \"get it\" (0-1)\n  safetyLevel: number,                 // How non-threatening (0-1)\n  contextDepth: number                 // Layers of inside joke (0-10)\n): number {\n  // Base humor = violation × recognition × safety\n  const baseHumor = patternViolationMagnitude * recognitionProbability * safetyLevel;\n  \n  // Context multiplier: deeper context = funnier (for those who get it)\n  // But also reduces recognition probability\n  const contextMultiplier = 1 + (contextDepth * 0.1);\n  \n  // The Absurdist Amplification\n  // More absurd = funnier, but only if you recognize the pattern being violated\n  const absurdistBonus = patternViolationMagnitude > 0.8 \n    ? 0.2 * recognitionProbability \n    : 0;\n  \n  return Math.min(1, (baseHumor * contextMultiplier) + absurdistBonus);\n}\n\n// ============================================================================\n// THE PRETENDING PARADOX\n// ============================================================================\n\n/**\n * CEO Insight: \"Does it even matter if they are [pretending]? \n * The effect is that one could laugh at an absurd meme even though \n * they don't understand it at first, but the more they understand \n * the branch of that meme the funnier and funnier it gets.\"\n * \n * This is profound: The ACT of participating creates the understanding.\n * Fake it till you make it isn't deception - it's the learning process.\n */\nconst PRETENDING_PARADOX = {\n  phases: [\n    {\n      stage: 'exposure',\n      understanding: 0.0,\n      participation: 0.5,  // Laughing along without getting it\n      realEffect: 'Neural pathways beginning to form'\n    },\n    {\n      stage: 'pattern_absorption',\n      understanding: 0.3,\n      participation: 0.7,\n      realEffect: 'Context accumulating through repetition'\n    },\n    {\n      stage: 'recognition',\n      understanding: 0.7,\n      participation: 0.9,\n      realEffect: 'Pattern clicks - now genuinely funny'\n    },\n    {\n      stage: 'mastery',\n      understanding: 1.0,\n      participation: 1.0,\n      realEffect: 'Can create new instances of the pattern'\n    }\n  ],\n  \n  /**\n   * The belonging drive is so strong that \"fake\" participation\n   * becomes real through sheer repetition and social reinforcement.\n   * Markets work the same way - people buy because others buy,\n   * until they actually believe in the asset.\n   */\n  marketAnalog: 'momentum_creates_conviction'\n};\n\n// ============================================================================\n// SOPHISTICATION = INSTINCT + CIVILITY\n// ============================================================================\n\n/**\n * CEO Insight: \"Go beyond evolutionary instinct and you'll find \n * sophistication uses the same core principles paired with civility.\"\n * \n * The wine snob and the thirsty animal want the same thing:\n * - Animal: Water/energy now\n * - Sophisticate: The \"right\" water/energy, properly presented\n * \n * Same drive, different expression.\n */\nconst SOPHISTICATION_LAYERS = {\n  PRIMAL_CORE: {\n    drive: 'Survival, reproduction, status',\n    expression: 'Direct, immediate, physical',\n    marketBehavior: 'Panic selling, FOMO buying, herd following'\n  },\n  CIVILIZED_WRAPPER: {\n    drive: 'Same drives, socially acceptable expression',\n    expression: 'Delayed gratification, symbolic status',\n    marketBehavior: 'Value investing, portfolio theory, risk management'\n  },\n  SOPHISTICATED_REFINEMENT: {\n    drive: 'Same drives, elevated through knowledge',\n    expression: 'Curated experiences, connoisseurship',\n    marketBehavior: 'Pattern recognition, contrarian plays, first principles'\n  },\n  \n  // The key insight: sophistication doesn't replace instinct, it channels it\n  synthesis: 'The refined investor still feels fear and greed - they just recognize the feeling'\n};\n\n// ============================================================================\n// ADAPTER CLASS\n// ============================================================================\n\ninterface SensoryMemoryData {\n  physiologicalState: keyof typeof PHYSIOLOGICAL_STATES;\n  sensoryTriggers: Array<{\n    channel: typeof SENSORY_VALENCE_MODEL.CHANNELS[number];\n    intensity: number;\n    valence: 'positive' | 'negative' | 'mixed';\n  }>;\n  nostalgiaLevel: number;\n  humorDetected: boolean;\n  contextDepth: number;\n  authenticityScore: number;  // vs pretending\n}\n\n// Extended signal type for internal use with metadata\ninterface ExperienceSignal extends UniversalSignal {\n  experienceMetadata: {\n    physiologicalState: string;\n    sensoryChannelsActive: number;\n    nostalgiaResonance: number;\n    humorPatternDetected: boolean;\n    insideJokeDepth: number;\n    pretendingVsReal: number;\n  };\n}\n\nclass SensoryMemoryHumorAdapter {\n  private domain: DomainType = 'soul';  // Human experience maps to soul domain\n  private signalBuffer: ExperienceSignal[] = [];\n  private isActive = false;\n\n  initialize(): void {\n    this.isActive = true;\n    console.log('[SensoryMemoryHumorAdapter] Initialized - modeling human experiential patterns');\n  }\n\n  /**\n   * Process human experiential data into universal signals\n   */\n  processExperienceData(data: SensoryMemoryData): ExperienceSignal {\n    const physState = PHYSIOLOGICAL_STATES[data.physiologicalState];\n    \n    // Calculate composite frequency based on arousal level\n    const sensoryArousal = data.sensoryTriggers.reduce(\n      (sum, t) => sum + t.intensity, 0\n    ) / Math.max(1, data.sensoryTriggers.length);\n    \n    // Nostalgia creates temporal echoes\n    const temporalResonance = data.nostalgiaLevel * 0.8;\n    \n    // Humor indicates pattern recognition success\n    const patternClarity = data.humorDetected ? 0.9 : 0.5;\n    \n    const signal: ExperienceSignal = {\n      domain: this.domain,\n      timestamp: Date.now(),\n      frequency: sensoryArousal * physState.riskTolerance,\n      intensity: data.nostalgiaLevel * physState.decisionQuality,\n      phase: this.mapStateToPhase(data.physiologicalState),\n      harmonics: [sensoryArousal, temporalResonance, patternClarity],\n      rawData: [data.nostalgiaLevel, data.contextDepth, data.authenticityScore],\n      experienceMetadata: {\n        physiologicalState: data.physiologicalState,\n        sensoryChannelsActive: data.sensoryTriggers.length,\n        nostalgiaResonance: temporalResonance,\n        humorPatternDetected: data.humorDetected,\n        insideJokeDepth: data.contextDepth,\n        pretendingVsReal: data.authenticityScore\n      }\n    };\n\n    this.signalBuffer.push(signal);\n    return signal;\n  }\n\n  private mapStateToPhase(state: keyof typeof PHYSIOLOGICAL_STATES): number {\n    const phases: Record<string, number> = {\n      STARVING: 0,\n      HUNGRY: Math.PI / 4,\n      SATISFIED: Math.PI / 2,\n      SATIATED: (3 * Math.PI) / 4,\n      GLUTTED: Math.PI\n    };\n    return phases[state] || Math.PI / 2;\n  }\n\n  /**\n   * Extract domain signature from experience signals\n   */\n  extractSignature(signals: ExperienceSignal[]): DomainSignature {\n    if (signals.length === 0) return this.getDefaultSignature();\n\n    const avgNostalgia = signals.reduce(\n      (sum, s) => sum + (s.experienceMetadata?.nostalgiaResonance || 0), 0\n    ) / signals.length;\n\n    const humorPresence = signals.filter(\n      s => s.experienceMetadata?.humorPatternDetected\n    ).length / signals.length;\n\n    const avgAuthenticity = signals.reduce(\n      (sum, s) => sum + (s.experienceMetadata?.pretendingVsReal || 0.5), 0\n    ) / signals.length;\n\n    // Map to existing DomainSignature quadrant profile\n    return {\n      domain: this.domain,\n      quadrantProfile: {\n        aggressive: humorPresence,        // Humor = creative aggression\n        defensive: avgAuthenticity,       // Authenticity = defense against deception\n        tactical: avgNostalgia,           // Nostalgia = tactical memory use\n        strategic: 1 - avgNostalgia       // Present-focus = strategic clarity\n      },\n      temporalFlow: {\n        early: avgNostalgia,              // Past-focused\n        mid: 1 - avgNostalgia * 0.5,      // Present-focused\n        late: humorPresence * 0.5         // Future anticipation\n      },\n      intensity: (avgNostalgia + humorPresence + avgAuthenticity) / 3,\n      momentum: humorPresence - 0.5,      // Positive = building understanding\n      volatility: 1 - avgAuthenticity,    // Pretending = unstable state\n      dominantFrequency: avgNostalgia * 10,\n      harmonicResonance: humorPresence,\n      phaseAlignment: avgAuthenticity,\n      extractedAt: Date.now()\n    };\n  }\n\n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: this.domain,\n      quadrantProfile: { aggressive: 0.5, defensive: 0.5, tactical: 0.5, strategic: 0.5 },\n      temporalFlow: { early: 0.33, mid: 0.34, late: 0.33 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0.3,\n      dominantFrequency: 5,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now()\n    };\n  }\n\n  /**\n   * Detect \"Inside Joke\" market patterns\n   * Where understanding grows the deeper you go\n   */\n  detectInsideJokePattern(\n    priceHistory: number[],\n    volumeHistory: number[]\n  ): {\n    isInsideJoke: boolean;\n    depthLevel: number;\n    participationRate: number;\n    genuineVsFake: number;\n  } {\n    // Look for patterns that reward deeper analysis\n    const surfacePattern = this.calculateSurfacePattern(priceHistory);\n    const deepPattern = this.calculateDeepPattern(priceHistory, volumeHistory);\n    \n    // If deep pattern is more predictive than surface, it's an \"inside joke\"\n    const depthAdvantage = deepPattern.clarity - surfacePattern.clarity;\n    \n    // Volume without price movement = participation without understanding\n    const volumePriceDivergence = this.calculateDivergence(priceHistory, volumeHistory);\n    \n    return {\n      isInsideJoke: depthAdvantage > 0.2,\n      depthLevel: Math.max(0, depthAdvantage * 10),\n      participationRate: volumePriceDivergence,\n      genuineVsFake: 1 - volumePriceDivergence  // Less divergence = more genuine\n    };\n  }\n\n  private calculateSurfacePattern(prices: number[]): { clarity: number } {\n    if (prices.length < 3) return { clarity: 0.5 };\n    const trend = (prices[prices.length - 1] - prices[0]) / prices[0];\n    return { clarity: Math.abs(trend) };\n  }\n\n  private calculateDeepPattern(prices: number[], volumes: number[]): { clarity: number } {\n    if (prices.length < 3) return { clarity: 0.5 };\n    // Volume-weighted price analysis reveals hidden patterns\n    const vwap = prices.reduce((sum, p, i) => sum + p * (volumes[i] || 1), 0) /\n                 volumes.reduce((sum, v) => sum + (v || 1), 0);\n    const deviation = Math.abs(prices[prices.length - 1] - vwap) / vwap;\n    return { clarity: 1 - deviation };  // Less deviation = clearer pattern\n  }\n\n  private calculateDivergence(a: number[], b: number[]): number {\n    if (a.length < 2 || b.length < 2) return 0.5;\n    const aChange = (a[a.length - 1] - a[0]) / Math.max(1, Math.abs(a[0]));\n    const bChange = (b[b.length - 1] - b[0]) / Math.max(1, Math.abs(b[0]));\n    return Math.abs(aChange - bChange);\n  }\n\n  /**\n   * Generate market data based on human experiential patterns\n   */\n  generateExperienceData(\n    momentum: number,\n    volatility: number,\n    volume: number,\n    sentiment: number\n  ): SensoryMemoryData {\n    // Map market conditions to physiological states\n    let physiologicalState: keyof typeof PHYSIOLOGICAL_STATES;\n    if (sentiment < -0.6) physiologicalState = 'STARVING';\n    else if (sentiment < -0.2) physiologicalState = 'HUNGRY';\n    else if (sentiment < 0.2) physiologicalState = 'SATISFIED';\n    else if (sentiment < 0.6) physiologicalState = 'SATIATED';\n    else physiologicalState = 'GLUTTED';\n\n    // High volatility triggers more sensory channels\n    const channelCount = Math.min(6, Math.max(1, Math.floor(volatility * 6)));\n    const channels = SENSORY_VALENCE_MODEL.CHANNELS.slice(0, channelCount);\n\n    return {\n      physiologicalState,\n      sensoryTriggers: channels.map(channel => ({\n        channel,\n        intensity: Math.random() * volatility,\n        valence: momentum > 0 ? 'positive' : momentum < 0 ? 'negative' : 'mixed'\n      })),\n      nostalgiaLevel: Math.abs(sentiment) * 0.5,  // Strong feelings trigger nostalgia\n      humorDetected: Math.random() < 0.2,         // Occasional humor/absurdity detection\n      contextDepth: Math.floor(volume * 10),      // Volume = participation depth\n      authenticityScore: 1 - volatility * 0.5    // High volatility = more pretending\n    };\n  }\n}\n\n// Singleton export\nexport const sensoryMemoryHumorAdapter = new SensoryMemoryHumorAdapter();\n\n// Export types and constants\nexport type { SensoryMemoryData, NostalgiaSignal, ExperienceSignal };\nexport {\n  PHYSIOLOGICAL_STATES,\n  SENSORY_VALENCE_MODEL,\n  HUMOR_MATHEMATICS,\n  PRETENDING_PARADOX,\n  SOPHISTICATION_LAYERS,\n  calculateHumorScore\n};\n";export{n as default};
