const n="/**\n * Game Theory & Strategic Interaction Adapter\n * \n * Nash equilibria, prisoner's dilemma, auction dynamics, multi-agent systems.\n * The mathematics of rational choice under competition.\n * \n * For Alec Arthur Shelton - The Artist\n * Every interaction is a game, every choice a move in infinite recursion.\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\n// CLASSIC GAME THEORY GAMES\nconst CLASSIC_GAMES = {\n  prisonersDilemma: {\n    description: 'Two prisoners must choose to cooperate or defect',\n    payoffMatrix: {\n      bothCooperate: { years: 1, total: 2 },\n      bothDefect: { years: 3, total: 6 },\n      oneDefects: { defector: 0, cooperator: 5 }\n    },\n    nashEquilibrium: 'Both defect (dominant strategy)',\n    paretoOptimal: 'Both cooperate',\n    dilemma: 'Individual rationality ≠ collective optimality',\n    marketAnalogy: 'OPEC production quotas, cartel stability'\n  },\n  \n  chicken: {\n    description: 'Two drivers head toward each other, first to swerve loses',\n    payoffMatrix: {\n      bothSwerve: { status: 'tie', utility: 2 },\n      bothStraight: { status: 'crash', utility: -10 },\n      oneStraight: { \n        straightPlayer: { status: 'win', utility: 5 },\n        swervePlayer: { status: 'lose', utility: 0 }\n      }\n    },\n    nashEquilibria: 'One swerves, one goes straight (two pure)',\n    strategy: 'Commitment/irrationality can win',\n    marketAnalogy: 'Chicken game in M&A, brinkmanship'\n  },\n  \n  stagHunt: {\n    description: 'Hunt stag (cooperate) or hare (defect alone)',\n    payoffMatrix: {\n      bothStag: { utility: 5 },\n      bothHare: { utility: 2 },\n      mixed: { stag: 0, hare: 2 }\n    },\n    nashEquilibria: 'Both stag (payoff dominant) AND both hare (risk dominant)',\n    coordination: 'Trust problem vs payoff problem',\n    marketAnalogy: 'Technology standards, platform adoption'\n  },\n  \n  battleOfSexes: {\n    description: 'Couple chooses entertainment, prefer together but different preferences',\n    payoffs: {\n      bothOpera: { her: 3, him: 2 },\n      bothBoxing: { her: 2, him: 3 },\n      separate: { both: 0 }\n    },\n    nashEquilibria: 'Both opera OR both boxing',\n    coordination: 'Need communication or convention',\n    marketAnalogy: 'Market maker selection, trading venue'\n  },\n  \n  matchingPennies: {\n    description: 'Zero-sum game of pure competition',\n    payoff: 'One wins what other loses',\n    equilibrium: 'Mixed strategy - random 50/50',\n    marketAnalogy: 'Pure speculation, zero-sum trading'\n  }\n};\n\n// AUCTION THEORY\nconst AUCTION_TYPES = {\n  english: {\n    name: 'Ascending price, open outcry',\n    strategy: 'Bid until price exceeds value',\n    revenue: 'Second-price equivalent (eBay)',\n    optimal: 'Bid true value'\n  },\n  \n  dutch: {\n    name: 'Descending price, first to accept',\n    strategy: 'Trade off price vs risk of losing',\n    use: 'Flower auctions, Treasury bills',\n    optimal: 'Shade bid below value'\n  },\n  \n  firstPrice: {\n    name: 'Sealed bid, highest wins',\n    strategy: 'Bid below true value (shading)',\n    revenue: 'Less than second-price'\n  },\n  \n  secondPrice: {\n    name: 'Vickrey - sealed bid, highest wins pays second highest',\n    strategy: 'Bid true value (dominant strategy)',\n    revenue: 'Revenue equivalence theorem',\n    incentive: 'Truthful bidding'\n  },\n  \n  allPay: {\n    name: 'All bidders pay their bid',\n    use: 'Lobbying, political contests',\n    strategy: 'Aggressive early, conservative late',\n    rentSeeking: 'Total waste can exceed prize value'\n  }\n};\n\n// NASH EQUILIBRIUM CONCEPTS\nconst NASH_EQUILIBRIUM = {\n  definition: 'No player can benefit by unilaterally changing strategy',\n  existence: 'Proven for finite games (Nash, 1950)',\n  \n  types: {\n    pureStrategy: 'Single action played with probability 1',\n    mixedStrategy: 'Randomization over multiple actions',\n    dominantStrategy: 'Best regardless of opponent (stronger than NE)',\n    tremblingHand: 'Stable against small mistakes'\n  },\n  \n  refinements: {\n    subgamePerfect: 'Credible threats only (backward induction)',\n    sequential: 'Order of moves matters',\n    bayesian: 'Incomplete information games',\n    evolutionary: 'Stable against mutant strategies'\n  }\n};\n\n// EVOLUTIONARY GAME THEORY\nconst EVOLUTIONARY_DYNAMICS = {\n  replicatorDynamics: {\n    equation: 'dx/dt = x(f(x) - φ)',\n    meaning: 'Strategy growth proportional to fitness advantage',\n    stable: 'Evolutionarily Stable Strategy (ESS)'\n  },\n  \n  hawkDove: {\n    description: 'Contest for resource - fight or display',\n    payoffs: {\n      hawkVsHawk: { cost: 'injury', value: -25 },\n      hawkVsDove: { hawk: 50, dove: 0 },\n      doveVsDove: { share: 25 }\n    },\n    ess: 'Mixed population: V/2C proportion hawks',\n    biological: 'Real animal conflict behavior'\n  },\n  \n  titForTat: {\n    description: 'Cooperate first, then mirror opponent',\n    success: 'Won Axelrod tournaments',\n    properties: ['nice', 'provocable', 'forgiving', 'clear'],\n    marketAnalogy: 'Reciprocal trading relationships'\n  },\n  \n  grimTrigger: {\n    description: 'Cooperate until defected, then always defect',\n    punishment: 'Permanent, severe',\n    stability: 'Supports cooperation with patient players'\n  }\n};\n\n// MARKET MICROSTRUCTURE AS GAMES\nconst MARKET_GAMES = {\n  kyleModel: {\n    description: 'Insider trades against market maker',\n    players: ['Informed trader', 'Noise traders', 'Market maker'],\n    equilibrium: 'Linear pricing, partial revelation',\n    marketImpact: 'Permanent vs temporary price impact'\n  },\n  \n  glostenMilgrom: {\n    description: 'Bid-ask spread as adverse selection',\n    spread: 'Compensates for trading with informed',\n    learning: 'Market maker updates beliefs from order flow'\n  },\n  \n  crowdBehavior: {\n    herding: 'Following others despite private info',\n    informationCascades: 'Ignore own signal, follow predecessors',\n    reverseCascades: 'Small changes break consensus'\n  }\n};\n\ninterface GameEvent {\n  timestamp: number;\n  gameType: keyof typeof CLASSIC_GAMES;\n  players: number;\n  rounds: number;\n  cooperationRate: number; // 0-1\n  defectionRate: number; // 0-1\n  nashDeviation: number; // How far from NE\n  payoffEfficiency: number; // Actual vs optimal payoff ratio\n  strategyEntropy: number; // Randomness in play\n}\n\nclass GameTheoryAdapter implements DomainAdapter<GameEvent> {\n  domain = 'market' as const;\n  name = 'Game Theory & Strategic Interaction';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 5000;\n  \n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[GameTheoryAdapter] Initialized - Strategic analysis active');\n  }\n  \n  processRawData(event: GameEvent): UniversalSignal {\n    const { timestamp, cooperationRate, defectionRate, nashDeviation, payoffEfficiency, strategyEntropy } = event;\n    \n    // Frequency encodes cooperation stability\n    const frequency = cooperationRate;\n    \n    // Intensity = strategic tension (distance from equilibrium)\n    const intensity = nashDeviation * (1 - payoffEfficiency);\n    \n    // Phase encodes efficiency of outcomes\n    const phase = payoffEfficiency * Math.PI;\n    \n    const harmonics = [\n      cooperationRate,\n      defectionRate,\n      1 - nashDeviation,\n      payoffEfficiency,\n      strategyEntropy,\n      event.players / 10\n    ];\n    \n    const signal: UniversalSignal = {\n      domain: 'market',\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData: [cooperationRate, nashDeviation, payoffEfficiency, strategyEntropy, event.rounds]\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.lastUpdate = timestamp;\n    return signal;\n  }\n  \n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n    \n    const recent = signals.slice(-100);\n    \n    const avgCoop = recent.reduce((sum, s) => sum + s.rawData[0], 0) / recent.length;\n    const avgNash = recent.reduce((sum, s) => sum + s.rawData[1], 0) / recent.length;\n    const avgEfficiency = recent.reduce((sum, s) => sum + s.rawData[2], 0) / recent.length;\n    const avgEntropy = recent.reduce((sum, s) => sum + s.rawData[3], 0) / recent.length;\n    const avgRounds = recent.reduce((sum, s) => sum + s.rawData[4], 0) / recent.length;\n    \n    const quadrantProfile = {\n      aggressive: avgNash > 0.5 ? 0.8 : 0.2, // Far from equilibrium\n      defensive: avgCoop > 0.7 ? 0.7 : 0.2, // High cooperation\n      tactical: avgEntropy > 0.5 ? 0.6 : 0.3, // High randomness\n      strategic: avgEfficiency > 0.8 ? 0.8 : 0.3 // Efficient outcomes\n    };\n    \n    const temporalFlow = {\n      early: avgRounds < 10 ? 0.8 : 0.2,\n      mid: avgRounds >= 10 && avgRounds < 50 ? 0.7 : 0.2,\n      late: avgRounds >= 50 ? 0.8 : 0.2\n    };\n    \n    return {\n      domain: 'market',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgNash * (1 - avgEfficiency),\n      momentum: avgCoop > 0.5 ? 1 : -1,\n      volatility: avgEntropy,\n      dominantFrequency: avgCoop,\n      harmonicResonance: avgEfficiency,\n      phaseAlignment: 1 - avgNash,\n      extractedAt: Date.now()\n    };\n  }\n  \n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'market',\n      quadrantProfile: { aggressive: 0.25, defensive: 0.25, tactical: 0.25, strategic: 0.25 },\n      temporalFlow: { early: 0.5, mid: 0.3, late: 0.2 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0.5,\n      dominantFrequency: 0.5,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now()\n    };\n  }\n  \n  // Calculate Nash equilibrium for 2x2 game\n  calculateNashEquilibrium(payoffMatrix: number[][][]): { player1: number; player2: number } | null {\n    // Simplified - assumes mixed strategy equilibrium exists\n    // payoffMatrix[action1][action2] = [p1_payoff, p2_payoff]\n    \n    const a = payoffMatrix[0][0][0]; // p1 action 1, p2 action 1\n    const b = payoffMatrix[0][1][0]; // p1 action 1, p2 action 2\n    const c = payoffMatrix[1][0][0]; // p1 action 2, p2 action 1\n    const d = payoffMatrix[1][1][0]; // p1 action 2, p2 action 2\n    \n    // Check for dominant strategies\n    if (a > c && b > d) return { player1: 0, player2: -1 }; // Player 1 plays action 1\n    if (c > a && d > b) return { player1: 1, player2: -1 };\n    \n    // Mixed strategy\n    const p = (d - b) / (a - b - c + d); // Probability player 1 plays action 1\n    if (p >= 0 && p <= 1) {\n      return { player1: p, player2: -1 };\n    }\n    \n    return null;\n  }\n  \n  // Tit-for-tat strategy implementation\n  titForTat(myHistory: string[], opponentHistory: string[]): 'cooperate' | 'defect' {\n    if (opponentHistory.length === 0) return 'cooperate';\n    return opponentHistory[opponentHistory.length - 1] as 'cooperate' | 'defect';\n  }\n}\n\nexport const gameTheoryAdapter = new GameTheoryAdapter();\nexport { CLASSIC_GAMES, AUCTION_TYPES, NASH_EQUILIBRIUM, EVOLUTIONARY_DYNAMICS, MARKET_GAMES };\nexport type { GameEvent };\n";export{n as default};
