const e="import { useState, useCallback, useRef } from 'react';\nimport { SquareVisit } from '@/lib/chess/gameSimulator';\n\nexport interface CreativeState {\n  pieceBoard: (string | null)[][];\n  paintData: Map<string, SquareVisit[]>;\n  moveCounter: number;\n}\n\nconst MAX_HISTORY = 50;\n\n// Serialize Map for comparison/storage\nconst serializeMap = (map: Map<string, SquareVisit[]>): string => {\n  const obj: Record<string, SquareVisit[]> = {};\n  map.forEach((value, key) => {\n    obj[key] = value;\n  });\n  return JSON.stringify(obj);\n};\n\n// Clone state deeply\nconst cloneState = (state: CreativeState): CreativeState => ({\n  pieceBoard: state.pieceBoard.map(row => [...row]),\n  paintData: new Map(Array.from(state.paintData.entries()).map(([k, v]) => [k, [...v]])),\n  moveCounter: state.moveCounter,\n});\n\nexport const useUndoRedo = (initialState: CreativeState) => {\n  const [history, setHistory] = useState<CreativeState[]>([cloneState(initialState)]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const lastSnapshotRef = useRef<string>('');\n\n  // Get current state\n  const currentState = history[currentIndex];\n\n  // Check if state has actually changed\n  const hasStateChanged = useCallback((newState: CreativeState): boolean => {\n    const newSnapshot = JSON.stringify({\n      pieceBoard: newState.pieceBoard,\n      paintData: serializeMap(newState.paintData),\n      moveCounter: newState.moveCounter,\n    });\n    \n    if (newSnapshot === lastSnapshotRef.current) {\n      return false;\n    }\n    \n    lastSnapshotRef.current = newSnapshot;\n    return true;\n  }, []);\n\n  // Push a new state to history\n  const pushState = useCallback((newState: CreativeState) => {\n    if (!hasStateChanged(newState)) return;\n\n    const clonedState = cloneState(newState);\n    \n    setHistory(prev => {\n      // Remove any \"future\" states if we're not at the end\n      const newHistory = prev.slice(0, currentIndex + 1);\n      newHistory.push(clonedState);\n      \n      // Limit history size\n      if (newHistory.length > MAX_HISTORY) {\n        return newHistory.slice(newHistory.length - MAX_HISTORY);\n      }\n      return newHistory;\n    });\n    \n    setCurrentIndex(prev => Math.min(prev + 1, MAX_HISTORY - 1));\n  }, [currentIndex, hasStateChanged]);\n\n  // Undo\n  const undo = useCallback((): CreativeState | null => {\n    if (currentIndex <= 0) return null;\n    \n    const newIndex = currentIndex - 1;\n    setCurrentIndex(newIndex);\n    \n    const restoredState = cloneState(history[newIndex]);\n    lastSnapshotRef.current = JSON.stringify({\n      pieceBoard: restoredState.pieceBoard,\n      paintData: serializeMap(restoredState.paintData),\n      moveCounter: restoredState.moveCounter,\n    });\n    \n    return restoredState;\n  }, [currentIndex, history]);\n\n  // Redo\n  const redo = useCallback((): CreativeState | null => {\n    if (currentIndex >= history.length - 1) return null;\n    \n    const newIndex = currentIndex + 1;\n    setCurrentIndex(newIndex);\n    \n    const restoredState = cloneState(history[newIndex]);\n    lastSnapshotRef.current = JSON.stringify({\n      pieceBoard: restoredState.pieceBoard,\n      paintData: serializeMap(restoredState.paintData),\n      moveCounter: restoredState.moveCounter,\n    });\n    \n    return restoredState;\n  }, [currentIndex, history]);\n\n  // Reset history (for imports/clears)\n  const resetHistory = useCallback((state: CreativeState) => {\n    const clonedState = cloneState(state);\n    setHistory([clonedState]);\n    setCurrentIndex(0);\n    lastSnapshotRef.current = JSON.stringify({\n      pieceBoard: clonedState.pieceBoard,\n      paintData: serializeMap(clonedState.paintData),\n      moveCounter: clonedState.moveCounter,\n    });\n  }, []);\n\n  const canUndo = currentIndex > 0;\n  const canRedo = currentIndex < history.length - 1;\n\n  return {\n    currentState,\n    pushState,\n    undo,\n    redo,\n    resetHistory,\n    canUndo,\n    canRedo,\n    historyLength: history.length,\n    currentIndex,\n  };\n};\n";export{e as default};
