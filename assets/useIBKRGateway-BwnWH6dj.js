const n="/**\n * IB Gateway Hook\n * \n * Manages connection to IB Gateway through local bridge.\n * No simulation - requires actual IB Gateway connection via bridge.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { ibGatewayClient, IBAccount, IBPosition, IBOrder } from '@/lib/trading/ibGatewayClient';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface IBGatewayState {\n  connected: boolean;\n  authenticated: boolean;\n  paperTrading: boolean;\n  accounts: IBAccount[];\n  selectedAccount: IBAccount | null;\n  positions: IBPosition[];\n  orders: IBOrder[];\n  loading: boolean;\n  error: string | null;\n}\n\nexport function useIBKRGateway() {\n  const [state, setState] = useState<IBGatewayState>({\n    connected: false,\n    authenticated: false,\n    paperTrading: false,\n    accounts: [],\n    selectedAccount: null,\n    positions: [],\n    orders: [],\n    loading: true,\n    error: null,\n  });\n\n  const refreshInterval = useRef<NodeJS.Timeout | null>(null);\n  const { toast } = useToast();\n\n  // Check bridge and gateway connection\n  const checkConnection = useCallback(async () => {\n    console.log('[IB Gateway] Checking connection...');\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    \n    const timeoutId = setTimeout(() => {\n      console.warn('[IB Gateway] Connection check timed out');\n      setState(prev => ({\n        ...prev,\n        connected: false,\n        authenticated: false,\n        loading: false,\n        error: 'Connection timed out. Ensure the bridge server is running.',\n      }));\n    }, 8000);\n    \n    try {\n      const status = await ibGatewayClient.checkConnection();\n      clearTimeout(timeoutId);\n      \n      console.log('[IB Gateway] Status:', status);\n      \n      setState(prev => ({\n        ...prev,\n        connected: status.connected,\n        authenticated: status.authenticated,\n        paperTrading: status.paperTrading,\n        loading: false,\n        error: status.connected \n          ? (status.authenticated ? null : 'Bridge running but not connected to IB Gateway. Click \"Connect to Gateway\".')\n          : 'Bridge not running. Start the local bridge server first.',\n      }));\n\n      return status;\n    } catch (err) {\n      clearTimeout(timeoutId);\n      console.error('[IB Gateway] Connection error:', err);\n      \n      setState(prev => ({\n        ...prev,\n        connected: false,\n        authenticated: false,\n        loading: false,\n        error: `Failed to connect: ${(err as Error).message}`,\n      }));\n      return { connected: false, authenticated: false, paperTrading: false };\n    }\n  }, []);\n\n  // Connect bridge to IB Gateway\n  const connectToGateway = useCallback(async () => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    \n    try {\n      const success = await ibGatewayClient.connect();\n      \n      if (success) {\n        toast({\n          title: 'Connected',\n          description: 'Successfully connected to IB Gateway',\n        });\n        await checkConnection();\n        await loadAccounts();\n      } else {\n        setState(prev => ({\n          ...prev,\n          loading: false,\n          error: 'Failed to connect. Ensure IB Gateway is running and API is enabled.',\n        }));\n      }\n      \n      return success;\n    } catch (err) {\n      setState(prev => ({\n        ...prev,\n        loading: false,\n        error: `Connection failed: ${(err as Error).message}`,\n      }));\n      return false;\n    }\n  }, [toast, checkConnection]);\n\n  // Load accounts\n  const loadAccounts = useCallback(async () => {\n    const accounts = await ibGatewayClient.getAccounts();\n    \n    const paperAccount = accounts.find(\n      a => a.accountId.startsWith('DU') || \n           a.accountType.toLowerCase().includes('paper')\n    );\n    \n    setState(prev => ({\n      ...prev,\n      accounts,\n      selectedAccount: paperAccount || accounts[0] || null,\n    }));\n\n    return accounts;\n  }, []);\n\n  // Load positions\n  const loadPositions = useCallback(async () => {\n    if (!state.selectedAccount) return [];\n    \n    const positions = await ibGatewayClient.getPositions(state.selectedAccount.accountId);\n    setState(prev => ({ ...prev, positions }));\n    return positions;\n  }, [state.selectedAccount]);\n\n  // Load orders\n  const loadOrders = useCallback(async () => {\n    const orders = await ibGatewayClient.getOrders();\n    setState(prev => ({ ...prev, orders }));\n    return orders;\n  }, []);\n\n  // Refresh all data\n  const refreshData = useCallback(async () => {\n    if (!state.authenticated) return;\n    \n    await Promise.all([\n      loadAccounts(),\n      loadPositions(),\n      loadOrders(),\n    ]);\n  }, [state.authenticated, loadAccounts, loadPositions, loadOrders]);\n\n  // Place order\n  const placeOrder = useCallback(async (params: {\n    symbol: string;\n    side: 'BUY' | 'SELL';\n    quantity: number;\n    orderType: 'MKT' | 'LMT';\n    price?: number;\n  }) => {\n    if (!state.selectedAccount) {\n      toast({\n        title: 'No Account Selected',\n        description: 'Please select an account first.',\n        variant: 'destructive',\n      });\n      return null;\n    }\n\n    // Search for contract\n    const contracts = await ibGatewayClient.searchContract(params.symbol);\n    if (contracts.length === 0) {\n      toast({\n        title: 'Symbol Not Found',\n        description: `Could not find contract for ${params.symbol}`,\n        variant: 'destructive',\n      });\n      return null;\n    }\n\n    const contract = contracts[0];\n\n    const result = await ibGatewayClient.placeOrder({\n      accountId: state.selectedAccount.accountId,\n      conid: contract.conid,\n      symbol: params.symbol,\n      side: params.side,\n      quantity: params.quantity,\n      orderType: params.orderType,\n      price: params.price,\n    });\n\n    if (result) {\n      toast({\n        title: 'Order Placed',\n        description: `${params.side} ${params.quantity} ${params.symbol} - ${result.status}`,\n      });\n      await loadOrders();\n    } else {\n      toast({\n        title: 'Order Failed',\n        description: 'Could not place order. Check gateway connection.',\n        variant: 'destructive',\n      });\n    }\n\n    return result;\n  }, [state.selectedAccount, toast, loadOrders]);\n\n  // Cancel order\n  const cancelOrder = useCallback(async (orderId: string) => {\n    const success = await ibGatewayClient.cancelOrder(orderId);\n    \n    if (success) {\n      toast({\n        title: 'Order Cancelled',\n        description: `Order ${orderId} has been cancelled.`,\n      });\n      await loadOrders();\n    }\n    \n    return success;\n  }, [toast, loadOrders]);\n\n  // Select account\n  const selectAccount = useCallback((accountId: string) => {\n    const account = state.accounts.find(a => a.accountId === accountId);\n    if (account) {\n      setState(prev => ({ ...prev, selectedAccount: account }));\n    }\n  }, [state.accounts]);\n\n  // Initialize\n  useEffect(() => {\n    const init = async () => {\n      const status = await checkConnection();\n      \n      if (status.authenticated) {\n        await loadAccounts();\n        await loadPositions();\n        await loadOrders();\n        \n        // Refresh data every 10 seconds\n        refreshInterval.current = setInterval(() => {\n          refreshData();\n        }, 10000);\n      }\n    };\n\n    init();\n\n    return () => {\n      if (refreshInterval.current) clearInterval(refreshInterval.current);\n    };\n  }, []);\n\n  // Reload positions when account changes\n  useEffect(() => {\n    if (state.selectedAccount && state.authenticated) {\n      loadPositions();\n    }\n  }, [state.selectedAccount?.accountId]);\n\n  return {\n    ...state,\n    checkConnection,\n    connectToGateway,\n    loadAccounts,\n    loadPositions,\n    loadOrders,\n    refreshData,\n    placeOrder,\n    cancelOrder,\n    selectAccount,\n  };\n}\n";export{n as default};
