const n="import { supabase } from '@/integrations/supabase/client';\n\nexport interface FlaggedContent {\n  id: string;\n  content_type: string;\n  content_id: string | null;\n  content_text: string | null;\n  content_image_url: string | null;\n  user_id: string;\n  reason: string;\n  severity: 'low' | 'medium' | 'high';\n  status: 'pending' | 'approved' | 'rejected' | 'banned';\n  reviewed_by: string | null;\n  reviewed_at: string | null;\n  review_notes: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface BannedUser {\n  id: string;\n  user_id: string;\n  reason: string;\n  banned_by: string;\n  banned_at: string;\n  expires_at: string | null;\n  offense_count: number;\n}\n\nexport interface UserOffense {\n  id: string;\n  user_id: string;\n  flagged_content_id: string | null;\n  offense_type: 'warning' | 'temp_ban' | 'permanent_ban';\n  notes: string | null;\n  created_by: string;\n  created_at: string;\n}\n\n/**\n * Flag content for admin review\n */\nexport async function flagContent(\n  contentType: string,\n  userId: string,\n  reason: string,\n  options?: {\n    contentId?: string;\n    contentText?: string;\n    contentImageUrl?: string;\n    severity?: 'low' | 'medium' | 'high';\n  }\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const { error } = await supabase\n      .from('flagged_content')\n      .insert({\n        content_type: contentType,\n        content_id: options?.contentId || null,\n        content_text: options?.contentText || null,\n        content_image_url: options?.contentImageUrl || null,\n        user_id: userId,\n        reason,\n        severity: options?.severity || 'medium',\n        status: 'pending',\n      });\n\n    if (error) throw error;\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error flagging content:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Check if user is currently banned\n */\nexport async function checkUserBanStatus(userId: string): Promise<{\n  isBanned: boolean;\n  reason?: string;\n  expiresAt?: string | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('banned_users')\n      .select('*')\n      .eq('user_id', userId)\n      .maybeSingle();\n\n    if (error) throw error;\n\n    if (!data) {\n      return { isBanned: false };\n    }\n\n    // Check if ban has expired\n    if (data.expires_at && new Date(data.expires_at) < new Date()) {\n      return { isBanned: false };\n    }\n\n    return {\n      isBanned: true,\n      reason: data.reason,\n      expiresAt: data.expires_at,\n    };\n  } catch (error) {\n    console.error('Error checking ban status:', error);\n    return { isBanned: false };\n  }\n}\n\n/**\n * Get user's offense count\n */\nexport async function getUserOffenseCount(userId: string): Promise<number> {\n  try {\n    const { count, error } = await supabase\n      .from('user_offenses')\n      .select('*', { count: 'exact', head: true })\n      .eq('user_id', userId);\n\n    if (error) throw error;\n    return count || 0;\n  } catch (error) {\n    console.error('Error getting offense count:', error);\n    return 0;\n  }\n}\n\n/**\n * Get pending flagged content for admin review\n */\nexport async function getPendingFlaggedContent(): Promise<FlaggedContent[]> {\n  try {\n    const { data, error } = await supabase\n      .from('flagged_content')\n      .select('*')\n      .eq('status', 'pending')\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n    return (data || []) as FlaggedContent[];\n  } catch (error) {\n    console.error('Error getting flagged content:', error);\n    return [];\n  }\n}\n\n/**\n * Review flagged content (admin action)\n */\nexport async function reviewFlaggedContent(\n  flagId: string,\n  decision: 'approved' | 'rejected' | 'banned',\n  reviewerId: string,\n  notes?: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const { error } = await supabase\n      .from('flagged_content')\n      .update({\n        status: decision,\n        reviewed_by: reviewerId,\n        reviewed_at: new Date().toISOString(),\n        review_notes: notes || null,\n      })\n      .eq('id', flagId);\n\n    if (error) throw error;\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error reviewing content:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Ban a user (admin action)\n */\nexport async function banUser(\n  userId: string,\n  reason: string,\n  bannedBy: string,\n  options?: {\n    expiresAt?: Date; // null = permanent\n    offenseCount?: number;\n  }\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Check if already banned\n    const { data: existing } = await supabase\n      .from('banned_users')\n      .select('id, offense_count')\n      .eq('user_id', userId)\n      .maybeSingle();\n\n    if (existing) {\n      // Update existing ban\n      const { error } = await supabase\n        .from('banned_users')\n        .update({\n          reason,\n          banned_by: bannedBy,\n          banned_at: new Date().toISOString(),\n          expires_at: options?.expiresAt?.toISOString() || null,\n          offense_count: (existing.offense_count || 1) + 1,\n        })\n        .eq('id', existing.id);\n\n      if (error) throw error;\n    } else {\n      // Create new ban\n      const { error } = await supabase\n        .from('banned_users')\n        .insert({\n          user_id: userId,\n          reason,\n          banned_by: bannedBy,\n          expires_at: options?.expiresAt?.toISOString() || null,\n          offense_count: options?.offenseCount || 1,\n        });\n\n      if (error) throw error;\n    }\n\n    // Record the offense\n    await supabase.from('user_offenses').insert({\n      user_id: userId,\n      offense_type: options?.expiresAt ? 'temp_ban' : 'permanent_ban',\n      notes: reason,\n      created_by: bannedBy,\n    });\n\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error banning user:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Unban a user (admin action)\n */\nexport async function unbanUser(userId: string): Promise<{ success: boolean; error?: string }> {\n  try {\n    const { error } = await supabase\n      .from('banned_users')\n      .delete()\n      .eq('user_id', userId);\n\n    if (error) throw error;\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error unbanning user:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Get all banned users (admin)\n */\nexport async function getBannedUsers(): Promise<BannedUser[]> {\n  try {\n    const { data, error } = await supabase\n      .from('banned_users')\n      .select('*')\n      .order('banned_at', { ascending: false });\n\n    if (error) throw error;\n    return (data || []) as BannedUser[];\n  } catch (error) {\n    console.error('Error getting banned users:', error);\n    return [];\n  }\n}\n\n/**\n * Issue a warning (admin action)\n */\nexport async function issueWarning(\n  userId: string,\n  flaggedContentId: string | null,\n  notes: string,\n  adminId: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const { error } = await supabase.from('user_offenses').insert({\n      user_id: userId,\n      flagged_content_id: flaggedContentId,\n      offense_type: 'warning',\n      notes,\n      created_by: adminId,\n    });\n\n    if (error) throw error;\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error issuing warning:', error);\n    return { success: false, error: error.message };\n  }\n}\n";export{n as default};
