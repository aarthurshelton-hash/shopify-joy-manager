const n='import { useState, useEffect, useCallback } from "react";\nimport { supabase } from "@/integrations/supabase/client";\nimport { toast } from "sonner";\n\ninterface CachedScan {\n  id: string;\n  matched: boolean;\n  visualizationId?: string;\n  confidence?: number;\n  imagePreview?: string;\n  timestamp: number;\n}\n\nconst CACHE_KEY = "enpensent_offline_scans";\n\nexport function useOfflineScanCache(userId: string | undefined) {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [pendingScans, setPendingScans] = useState<CachedScan[]>([]);\n  const [syncing, setSyncing] = useState(false);\n\n  // Load cached scans from localStorage\n  useEffect(() => {\n    const cached = localStorage.getItem(CACHE_KEY);\n    if (cached) {\n      try {\n        setPendingScans(JSON.parse(cached));\n      } catch {\n        localStorage.removeItem(CACHE_KEY);\n      }\n    }\n  }, []);\n\n  // Monitor online status\n  useEffect(() => {\n    const handleOnline = () => {\n      setIsOnline(true);\n      toast.success("Back online! Syncing scans...");\n    };\n    \n    const handleOffline = () => {\n      setIsOnline(false);\n      toast.warning("You\'re offline. Scans will be saved locally.");\n    };\n\n    window.addEventListener("online", handleOnline);\n    window.addEventListener("offline", handleOffline);\n\n    return () => {\n      window.removeEventListener("online", handleOnline);\n      window.removeEventListener("offline", handleOffline);\n    };\n  }, []);\n\n  // Sync when coming back online\n  useEffect(() => {\n    if (isOnline && userId && pendingScans.length > 0 && !syncing) {\n      syncPendingScans();\n    }\n  }, [isOnline, userId, pendingScans.length]);\n\n  // Cache a scan locally\n  const cacheScan = useCallback((scan: Omit<CachedScan, "id" | "timestamp">) => {\n    const newScan: CachedScan = {\n      ...scan,\n      id: crypto.randomUUID(),\n      timestamp: Date.now(),\n    };\n    \n    setPendingScans((prev) => {\n      const updated = [...prev, newScan];\n      localStorage.setItem(CACHE_KEY, JSON.stringify(updated));\n      return updated;\n    });\n    \n    return newScan.id;\n  }, []);\n\n  // Sync pending scans to database\n  const syncPendingScans = useCallback(async () => {\n    if (!userId || pendingScans.length === 0 || syncing) return;\n    \n    setSyncing(true);\n    let syncedCount = 0;\n    const failedScans: CachedScan[] = [];\n\n    for (const scan of pendingScans) {\n      try {\n        const { error } = await supabase\n          .from("scan_history")\n          .insert({\n            user_id: userId,\n            visualization_id: scan.visualizationId || null,\n            matched: scan.matched,\n            confidence: scan.confidence ? Math.round(scan.confidence) : null,\n            image_preview: scan.imagePreview?.substring(0, 500) || null,\n            scanned_at: new Date(scan.timestamp).toISOString(),\n          });\n\n        if (error) {\n          console.error("Failed to sync scan:", error);\n          failedScans.push(scan);\n        } else {\n          syncedCount++;\n        }\n      } catch (error) {\n        console.error("Sync error:", error);\n        failedScans.push(scan);\n      }\n    }\n\n    // Update cache with only failed scans\n    setPendingScans(failedScans);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(failedScans));\n    \n    setSyncing(false);\n\n    if (syncedCount > 0) {\n      toast.success(`Synced ${syncedCount} offline scan${syncedCount > 1 ? "s" : ""}`);\n      \n      // Check for achievements after sync\n      try {\n        await supabase.rpc("check_scan_achievements", { p_user_id: userId });\n      } catch (error) {\n        console.error("Achievement check failed:", error);\n      }\n    }\n\n    if (failedScans.length > 0) {\n      toast.error(`Failed to sync ${failedScans.length} scan${failedScans.length > 1 ? "s" : ""}`);\n    }\n  }, [userId, pendingScans, syncing]);\n\n  // Clear all cached scans\n  const clearCache = useCallback(() => {\n    setPendingScans([]);\n    localStorage.removeItem(CACHE_KEY);\n  }, []);\n\n  return {\n    isOnline,\n    pendingScans,\n    pendingCount: pendingScans.length,\n    syncing,\n    cacheScan,\n    syncPendingScans,\n    clearCache,\n  };\n}\n';export{n as default};
