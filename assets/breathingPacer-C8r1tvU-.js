const n="/**\n * v7.93-SMOOTH-FLOW: Adaptive Breathing Pacer\n * \n * Prevents rate limiting and UI glitching by enforcing ADAPTIVE processing gaps.\n * v7.93: Smooth flow with burst detection and dynamic cooldowns.\n */\n\nexport const BREATHING_VERSION = \"8.01\";\nexport const RATE_LIMIT_BREATHING_MS = 200; // v8.01: 200ms base (optimized for smooth flow)\n\nlet lastBreathTime = 0;\nlet processingCount = 0;\nlet burstCounter = 0;\nlet lastBurstCheck = Date.now();\nlet adaptiveCooldown = RATE_LIMIT_BREATHING_MS;\n\n// v7.93: Track recent operation times for burst detection\nconst recentOperations: number[] = [];\nconst BURST_WINDOW_MS = 5000; // 5 second window\nconst MAX_OPS_PER_WINDOW = 10; // Max 10 ops per 5 seconds = 2/sec\n\n/**\n * Detect if we're in a burst pattern (too many ops too fast)\n */\nfunction detectBurst(): boolean {\n  const now = Date.now();\n  const windowStart = now - BURST_WINDOW_MS;\n  \n  // Clean old entries\n  while (recentOperations.length > 0 && recentOperations[0] < windowStart) {\n    recentOperations.shift();\n  }\n  \n  return recentOperations.length >= MAX_OPS_PER_WINDOW;\n}\n\n/**\n * Calculate adaptive cooldown based on recent activity\n */\nfunction calculateAdaptiveCooldown(): number {\n  const now = Date.now();\n  \n  // Reset burst counter every 30 seconds\n  if (now - lastBurstCheck > 30000) {\n    burstCounter = Math.max(0, burstCounter - 2);\n    lastBurstCheck = now;\n  }\n  \n  if (detectBurst()) {\n    burstCounter++;\n    // Progressive backoff: 300ms -> 500ms -> 800ms -> 1200ms max\n    adaptiveCooldown = Math.min(RATE_LIMIT_BREATHING_MS * (1 + burstCounter * 0.5), 1200);\n    console.log(`[v7.93-SMOOTH] Burst detected, cooldown: ${adaptiveCooldown}ms`);\n  } else if (burstCounter > 0 && recentOperations.length < MAX_OPS_PER_WINDOW / 2) {\n    // Gradually reduce cooldown when activity is low\n    burstCounter = Math.max(0, burstCounter - 0.5);\n    adaptiveCooldown = Math.max(RATE_LIMIT_BREATHING_MS, adaptiveCooldown * 0.9);\n  }\n  \n  return adaptiveCooldown;\n}\n\n/**\n * Enforce stable breathing pause after each prediction\n * Marks game as known, then applies adaptive delay\n */\nexport async function breathe(\n  gameId: string,\n  markKnownFn: (id: string) => void,\n  baseDelayMs: number = 0\n): Promise<void> {\n  // Mark known BEFORE delay to prevent re-processing\n  markKnownFn(gameId);\n  processingCount++;\n  recentOperations.push(Date.now());\n  \n  // v7.93: Calculate adaptive cooldown based on recent activity\n  const currentCooldown = calculateAdaptiveCooldown();\n  const timeSinceLast = Date.now() - lastBreathTime;\n  const requiredDelay = Math.max(currentCooldown, baseDelayMs);\n  const actualDelay = Math.max(0, requiredDelay - timeSinceLast);\n  \n  if (actualDelay > 0) {\n    await new Promise(resolve => setTimeout(resolve, actualDelay));\n  }\n  \n  lastBreathTime = Date.now();\n}\n\n/**\n * Get time since last breath (for diagnostics)\n */\nexport function timeSinceLastBreath(): number {\n  return Date.now() - lastBreathTime;\n}\n\n/**\n * Get processing count (for diagnostics)\n */\nexport function getProcessingCount(): number {\n  return processingCount;\n}\n\n/**\n * Get current adaptive cooldown (for diagnostics)\n */\nexport function getCurrentCooldown(): number {\n  return adaptiveCooldown;\n}\n\n/**\n * Reset pacer state (for testing or manual reset)\n */\nexport function resetPacer(): void {\n  burstCounter = 0;\n  adaptiveCooldown = RATE_LIMIT_BREATHING_MS;\n  recentOperations.length = 0;\n  console.log('[v7.98-SMOOTH] Pacer reset');\n}\n\nconsole.log(`[v${BREATHING_VERSION}-SMOOTH-AUDIT] breathingPacer.ts LOADED - Base cooldown: ${RATE_LIMIT_BREATHING_MS}ms (adaptive)`);\n";export{n as default};
