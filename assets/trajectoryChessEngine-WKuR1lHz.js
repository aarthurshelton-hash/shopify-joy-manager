const n="/**\n * Trajectory Chess Engine\n * \n * THE EN PENSENT PLAYING ENGINE\n * \n * This engine plays chess using pattern recognition and trajectory alignment\n * rather than traditional position evaluation and move calculation.\n * \n * Philosophy (CEO Alec Arthur Shelton):\n * \"Stockfish calculates the path. We KNOW the destination.\"\n * \n * The engine:\n * 1. Identifies the current game's archetype/trajectory\n * 2. Predicts the most likely outcome based on patterns\n * 3. Selects moves that MAINTAIN alignment with winning patterns\n * 4. Learns from every game to improve pattern recognition\n */\n\nimport { Chess } from 'chess.js';\nimport { supabase } from '@/integrations/supabase/client';\nimport { \n  PatternSignature, \n  TranslationContext, \n  MoveScore,\n  selectBestMove,\n  rankMovesByTrajectory,\n  extractPositionCharacteristics\n} from './patternMoveTranslator';\nimport { ARCHETYPE_DEFINITIONS, StrategicArchetype } from './colorFlowAnalysis';\nimport { simulateGame } from './gameSimulator';\n\n/**\n * Extract color flow signature from PGN (wrapper for the full function)\n */\nfunction extractSignatureFromPgn(pgn: string): { fingerprint: string; archetype: StrategicArchetype; name: string } {\n  try {\n    const gameResult = simulateGame(pgn);\n    if (!gameResult) {\n      return { fingerprint: 'unknown', archetype: 'unknown', name: 'Unknown' };\n    }\n    // Generate simple fingerprint from board state\n    const fingerprint = `pgn-${pgn.length}-${gameResult.totalMoves}`;\n    return {\n      fingerprint,\n      archetype: 'unknown',\n      name: 'Pattern Analysis'\n    };\n  } catch {\n    return { fingerprint: 'unknown', archetype: 'unknown', name: 'Unknown' };\n  }\n}\n\n/**\n * Classify archetype and get definition\n */\nfunction getArchetypeDefinition(archetype: StrategicArchetype) {\n  return ARCHETYPE_DEFINITIONS[archetype] || ARCHETYPE_DEFINITIONS.unknown;\n}\n\nexport interface EngineState {\n  chess: Chess;\n  color: 'white' | 'black';\n  learnedPatterns: PatternSignature[];\n  currentArchetype: string;\n  trajectoryConfidence: number;\n  predictedOutcome: 'white_wins' | 'black_wins' | 'draw';\n  moveHistory: MoveScore[];\n  gamesAnalyzed: number;\n  evolutionGeneration: number;\n  fitnessScore: number;\n}\n\nexport interface GameResult {\n  moves: string[];\n  result: 'white_wins' | 'black_wins' | 'draw';\n  ourColor: 'white' | 'black';\n  weWon: boolean;\n  archetypeAccuracy: number;\n  lessonsLearned: string[];\n}\n\nexport interface EngineConfig {\n  usePatternOnly: boolean;      // If true, never consult Stockfish\n  confidenceThreshold: number;  // Minimum confidence to trust pattern\n  explorationRate: number;      // Chance to try non-optimal moves for learning\n  maxPatternsToConsider: number;\n}\n\nconst DEFAULT_CONFIG: EngineConfig = {\n  usePatternOnly: true,\n  confidenceThreshold: 0.6,\n  explorationRate: 0.05,\n  maxPatternsToConsider: 1000\n};\n\n/**\n * The Trajectory Chess Engine\n */\nexport class TrajectoryChessEngine {\n  private state: EngineState;\n  private config: EngineConfig;\n  \n  constructor(color: 'white' | 'black', config: Partial<EngineConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.state = {\n      chess: new Chess(),\n      color,\n      learnedPatterns: [],\n      currentArchetype: 'Unknown',\n      trajectoryConfidence: 0,\n      predictedOutcome: 'draw',\n      moveHistory: [],\n      gamesAnalyzed: 0,\n      evolutionGeneration: 0,\n      fitnessScore: 0\n    };\n  }\n  \n  /**\n   * Initialize engine with learned patterns from database\n   */\n  async initialize(): Promise<void> {\n    // Load evolution state\n    const { data: evolutionData } = await supabase\n      .from('evolution_state')\n      .select('*')\n      .eq('state_type', 'chess_learning')\n      .order('updated_at', { ascending: false })\n      .limit(1)\n      .single();\n    \n    if (evolutionData) {\n      this.state.evolutionGeneration = evolutionData.generation || 0;\n      this.state.fitnessScore = evolutionData.fitness_score || 0;\n      this.state.gamesAnalyzed = evolutionData.total_predictions || 0;\n    }\n    \n    // Load learned patterns\n    const { data: patterns } = await supabase\n      .from('color_flow_patterns')\n      .select('*')\n      .order('created_at', { ascending: false })\n      .limit(this.config.maxPatternsToConsider);\n    \n    if (patterns) {\n      this.state.learnedPatterns = patterns.map(p => this.convertToPatternSignature(p));\n    }\n    \n    console.log(`[TrajectoryEngine] Initialized with ${this.state.learnedPatterns.length} patterns, Gen ${this.state.evolutionGeneration}`);\n  }\n  \n  /**\n   * Convert database pattern to internal format\n   */\n  private convertToPatternSignature(dbPattern: any): PatternSignature {\n    const chars = typeof dbPattern.characteristics === 'string' \n      ? JSON.parse(dbPattern.characteristics) \n      : dbPattern.characteristics;\n    \n    return {\n      fingerprint: dbPattern.fingerprint,\n      archetype: dbPattern.archetype,\n      outcome: dbPattern.outcome as 'white_wins' | 'black_wins' | 'draw',\n      confidence: 0.7, // Base confidence\n      characteristics: {\n        tension: chars?.tension || 0.5,\n        momentum: chars?.momentum || 0.5,\n        complexity: chars?.complexity || 0.5,\n        phase: chars?.phase || 'middlegame'\n      },\n      movePatterns: chars?.movePatterns || []\n    };\n  }\n  \n  /**\n   * Analyze current position and predict outcome\n   */\n  analyzePosition(): { archetype: string; confidence: number; outcome: string } {\n    const pgn = this.state.chess.pgn();\n    \n    // Extract color flow signature from PGN\n    const signature = extractSignatureFromPgn(pgn);\n    \n    // Get archetype definition\n    const archetypeDef = getArchetypeDefinition(signature.archetype);\n    \n    // Find matching patterns\n    const matches = this.findMatchingPatterns(signature.fingerprint);\n    \n    // Calculate outcome probabilities\n    let whiteWins = 0, blackWins = 0, draws = 0;\n    let totalWeight = 0;\n    \n    for (const match of matches) {\n      const weight = match.confidence;\n      totalWeight += weight;\n      \n      switch (match.outcome) {\n        case 'white_wins': whiteWins += weight; break;\n        case 'black_wins': blackWins += weight; break;\n        case 'draw': draws += weight; break;\n      }\n    }\n    \n    // Determine predicted outcome\n    let predictedOutcome: 'white_wins' | 'black_wins' | 'draw' = 'draw';\n    let confidence = 0.5;\n    \n    if (totalWeight > 0) {\n      const normalized = {\n        white: whiteWins / totalWeight,\n        black: blackWins / totalWeight,\n        draw: draws / totalWeight\n      };\n      \n      if (normalized.white > normalized.black && normalized.white > normalized.draw) {\n        predictedOutcome = 'white_wins';\n        confidence = normalized.white;\n      } else if (normalized.black > normalized.white && normalized.black > normalized.draw) {\n        predictedOutcome = 'black_wins';\n        confidence = normalized.black;\n      } else {\n        predictedOutcome = 'draw';\n        confidence = normalized.draw;\n      }\n    }\n    \n    // Update state\n    this.state.currentArchetype = archetypeDef.name;\n    this.state.trajectoryConfidence = confidence;\n    this.state.predictedOutcome = predictedOutcome;\n    \n    return {\n      archetype: archetypeDef.name,\n      confidence,\n      outcome: predictedOutcome\n    };\n  }\n  \n  /**\n   * Find patterns matching current fingerprint\n   */\n  private findMatchingPatterns(fingerprint: string): PatternSignature[] {\n    // Calculate fingerprint similarity\n    return this.state.learnedPatterns\n      .map(pattern => ({\n        ...pattern,\n        similarity: this.calculateFingerprintSimilarity(fingerprint, pattern.fingerprint)\n      }))\n      .filter(p => p.similarity > 0.3)\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, 50);\n  }\n  \n  /**\n   * Calculate similarity between two fingerprints\n   */\n  private calculateFingerprintSimilarity(fp1: string, fp2: string): number {\n    if (!fp1 || !fp2) return 0;\n    \n    const parts1 = fp1.split('-');\n    const parts2 = fp2.split('-');\n    \n    let matches = 0;\n    const minLength = Math.min(parts1.length, parts2.length);\n    \n    for (let i = 0; i < minLength; i++) {\n      if (parts1[i] === parts2[i]) {\n        matches++;\n      } else {\n        // Partial match for similar values\n        const val1 = parseFloat(parts1[i]) || 0;\n        const val2 = parseFloat(parts2[i]) || 0;\n        const diff = Math.abs(val1 - val2);\n        if (diff < 0.2) matches += 0.5;\n      }\n    }\n    \n    return matches / Math.max(parts1.length, parts2.length);\n  }\n  \n  /**\n   * Select the best move using trajectory alignment\n   */\n  selectMove(): MoveScore | null {\n    // Analyze current position\n    this.analyzePosition();\n    \n    // Create translation context\n    const context: TranslationContext = {\n      currentFen: this.state.chess.fen(),\n      moveHistory: this.state.chess.history(),\n      detectedArchetype: this.state.currentArchetype,\n      trajectoryConfidence: this.state.trajectoryConfidence,\n      targetOutcome: this.determineTargetOutcome(),\n      learnedPatterns: this.state.learnedPatterns\n    };\n    \n    // Check for exploration (learning new paths)\n    if (Math.random() < this.config.explorationRate) {\n      return this.selectExploratoryMove(context);\n    }\n    \n    // Select best move by trajectory alignment\n    const bestMove = selectBestMove(this.state.chess, context);\n    \n    if (bestMove) {\n      this.state.moveHistory.push(bestMove);\n    }\n    \n    return bestMove;\n  }\n  \n  /**\n   * Determine what outcome we're aiming for\n   */\n  private determineTargetOutcome(): 'white_wins' | 'black_wins' | 'draw' {\n    // If we're white, aim for white wins; if black, aim for black wins\n    return this.state.color === 'white' ? 'white_wins' : 'black_wins';\n  }\n  \n  /**\n   * Select an exploratory move to learn new patterns\n   */\n  private selectExploratoryMove(context: TranslationContext): MoveScore | null {\n    const rankedMoves = rankMovesByTrajectory(this.state.chess, context);\n    \n    if (rankedMoves.length === 0) return null;\n    \n    // Pick from top 5 instead of just top 1\n    const explorationPool = rankedMoves.slice(0, Math.min(5, rankedMoves.length));\n    const randomIndex = Math.floor(Math.random() * explorationPool.length);\n    \n    const move = explorationPool[randomIndex];\n    move.reasoning = `[EXPLORATION] ${move.reasoning}`;\n    \n    return move;\n  }\n  \n  /**\n   * Apply opponent's move\n   */\n  applyOpponentMove(san: string): boolean {\n    try {\n      this.state.chess.move(san);\n      return true;\n    } catch {\n      console.error(`[TrajectoryEngine] Invalid move: ${san}`);\n      return false;\n    }\n  }\n  \n  /**\n   * Apply our selected move\n   */\n  applyOurMove(san: string): boolean {\n    try {\n      this.state.chess.move(san);\n      return true;\n    } catch {\n      console.error(`[TrajectoryEngine] Invalid move: ${san}`);\n      return false;\n    }\n  }\n  \n  /**\n   * Get all ranked moves for current position\n   */\n  getRankedMoves(): MoveScore[] {\n    const context: TranslationContext = {\n      currentFen: this.state.chess.fen(),\n      moveHistory: this.state.chess.history(),\n      detectedArchetype: this.state.currentArchetype,\n      trajectoryConfidence: this.state.trajectoryConfidence,\n      targetOutcome: this.determineTargetOutcome(),\n      learnedPatterns: this.state.learnedPatterns\n    };\n    \n    return rankMovesByTrajectory(this.state.chess, context);\n  }\n  \n  /**\n   * Record game result and learn from it\n   */\n  async recordGameResult(result: 'white_wins' | 'black_wins' | 'draw'): Promise<GameResult> {\n    const weWon = (this.state.color === 'white' && result === 'white_wins') ||\n                  (this.state.color === 'black' && result === 'black_wins');\n    \n    const pgn = this.state.chess.pgn();\n    const signature = extractSignatureFromPgn(pgn);\n    const archetypeDef = getArchetypeDefinition(signature.archetype);\n    \n    // Calculate archetype accuracy\n    const archetypeAccuracy = this.state.predictedOutcome === result ? 1 : 0;\n    \n    // Generate lessons learned\n    const lessonsLearned = this.generateLessons(weWon, result);\n    \n    // Save pattern to database\n    await this.saveLearnedPattern(pgn, result, signature, archetypeDef);\n    \n    // Update evolution state\n    await this.updateEvolutionState(weWon, archetypeAccuracy);\n    \n    return {\n      moves: this.state.chess.history(),\n      result,\n      ourColor: this.state.color,\n      weWon,\n      archetypeAccuracy,\n      lessonsLearned\n    };\n  }\n  \n  /**\n   * Generate lessons from the game\n   */\n  private generateLessons(weWon: boolean, result: string): string[] {\n    const lessons: string[] = [];\n    \n    if (weWon) {\n      lessons.push(`Trajectory alignment successful: ${this.state.currentArchetype} led to victory`);\n      \n      // Find which moves were most impactful\n      const highConfidenceMoves = this.state.moveHistory.filter(m => m.compositeScore > 0.7);\n      if (highConfidenceMoves.length > 0) {\n        lessons.push(`Key moves: ${highConfidenceMoves.map(m => m.san).join(', ')}`);\n      }\n    } else {\n      lessons.push(`Trajectory deviation: ${this.state.currentArchetype} pattern did not hold`);\n      \n      // Identify where we went wrong\n      const lowConfidenceMoves = this.state.moveHistory.filter(m => m.compositeScore < 0.4);\n      if (lowConfidenceMoves.length > 0) {\n        lessons.push(`Potential mistakes: ${lowConfidenceMoves.map(m => m.san).join(', ')}`);\n      }\n    }\n    \n    lessons.push(`Final confidence: ${(this.state.trajectoryConfidence * 100).toFixed(1)}%`);\n    \n    return lessons;\n  }\n  \n  /**\n   * Save learned pattern to database\n   */\n  private async saveLearnedPattern(\n    pgn: string,\n    result: string,\n    signature: any,\n    archetype: any\n  ): Promise<void> {\n    const positionPatterns = this.state.moveHistory.map((move, i) => ({\n      moveNumber: i + 1,\n      phase: this.determinePhase(i + 1),\n      compositeScore: move.compositeScore,\n      trajectoryAlignment: move.trajectoryAlignment\n    }));\n    \n    await supabase.from('color_flow_patterns').insert({\n      fingerprint: signature.fingerprint,\n      archetype: archetype.name,\n      outcome: result,\n      total_moves: this.state.chess.history().length,\n      characteristics: {\n        tension: signature.averageTension,\n        momentum: signature.flowDirection,\n        complexity: signature.complexity,\n        movePatterns: positionPatterns\n      },\n      pgn_hash: this.hashPgn(pgn)\n    });\n  }\n  \n  /**\n   * Determine game phase from move number\n   */\n  private determinePhase(moveNumber: number): string {\n    if (moveNumber <= 10) return 'opening';\n    if (moveNumber <= 30) return 'middlegame';\n    return 'endgame';\n  }\n  \n  /**\n   * Create a hash of the PGN for deduplication\n   */\n  private hashPgn(pgn: string): string {\n    let hash = 0;\n    for (let i = 0; i < pgn.length; i++) {\n      const char = pgn.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(16);\n  }\n  \n  /**\n   * Update evolution state after game\n   */\n  private async updateEvolutionState(weWon: boolean, accuracy: number): Promise<void> {\n    // Get current state\n    const { data: current } = await supabase\n      .from('evolution_state')\n      .select('*')\n      .eq('state_type', 'chess_learning')\n      .single();\n    \n    const currentFitness = current?.fitness_score || 0.5;\n    const currentGen = current?.generation || 0;\n    const currentPredictions = current?.total_predictions || 0;\n    \n    // Update fitness based on result\n    const fitnessChange = weWon ? 0.02 : -0.01;\n    const newFitness = Math.max(0, Math.min(1, currentFitness + fitnessChange));\n    \n    // Increment generation every 100 games\n    const newGen = Math.floor((currentPredictions + 1) / 100);\n    \n    // Upsert evolution state\n    await supabase.from('evolution_state').upsert({\n      id: current?.id || crypto.randomUUID(),\n      state_type: 'chess_learning',\n      genes: {\n        trajectoryWeight: 0.35,\n        patternWeight: 0.30,\n        momentumWeight: 0.20,\n        riskWeight: 0.15,\n        explorationRate: this.config.explorationRate\n      },\n      fitness_score: newFitness,\n      generation: newGen,\n      total_predictions: currentPredictions + 1,\n      learned_patterns: this.state.learnedPatterns.slice(0, 100).map(p => p.fingerprint),\n      updated_at: new Date().toISOString()\n    });\n    \n    this.state.fitnessScore = newFitness;\n    this.state.evolutionGeneration = newGen;\n  }\n  \n  /**\n   * Reset for new game\n   */\n  reset(): void {\n    this.state.chess = new Chess();\n    this.state.moveHistory = [];\n    this.state.currentArchetype = 'Unknown';\n    this.state.trajectoryConfidence = 0;\n    this.state.predictedOutcome = 'draw';\n  }\n  \n  /**\n   * Get current engine state\n   */\n  getState(): EngineState {\n    return { ...this.state };\n  }\n  \n  /**\n   * Get current FEN\n   */\n  getFen(): string {\n    return this.state.chess.fen();\n  }\n  \n  /**\n   * Get current PGN\n   */\n  getPgn(): string {\n    return this.state.chess.pgn();\n  }\n  \n  /**\n   * Check if game is over\n   */\n  isGameOver(): boolean {\n    return this.state.chess.isGameOver();\n  }\n  \n  /**\n   * Get game result if over\n   */\n  getResult(): 'white_wins' | 'black_wins' | 'draw' | null {\n    if (!this.state.chess.isGameOver()) return null;\n    \n    if (this.state.chess.isCheckmate()) {\n      return this.state.chess.turn() === 'w' ? 'black_wins' : 'white_wins';\n    }\n    \n    return 'draw';\n  }\n}\n\n/**\n * Play a complete game against Stockfish\n * Returns the result for analysis\n */\nexport async function playGameAgainstStockfish(\n  ourColor: 'white' | 'black',\n  stockfishDepth: number = 15,\n  onMove?: (move: string, byUs: boolean, analysis: any) => void\n): Promise<GameResult> {\n  const engine = new TrajectoryChessEngine(ourColor);\n  await engine.initialize();\n  \n  // Game loop\n  while (!engine.isGameOver()) {\n    const isOurTurn = (engine.getState().chess.turn() === 'w') === (ourColor === 'white');\n    \n    if (isOurTurn) {\n      // Our move (pattern-based)\n      const move = engine.selectMove();\n      if (move) {\n        engine.applyOurMove(move.san);\n        onMove?.(move.san, true, {\n          archetype: engine.getState().currentArchetype,\n          confidence: engine.getState().trajectoryConfidence,\n          reasoning: move.reasoning\n        });\n      }\n    } else {\n      // Stockfish's move (via Lichess Cloud API)\n      const fen = engine.getFen();\n      const stockfishMove = await getStockfishMove(fen, stockfishDepth);\n      if (stockfishMove) {\n        engine.applyOpponentMove(stockfishMove);\n        onMove?.(stockfishMove, false, { engine: 'Stockfish', depth: stockfishDepth });\n      }\n    }\n  }\n  \n  const result = engine.getResult();\n  if (result) {\n    return await engine.recordGameResult(result);\n  }\n  \n  throw new Error('Game ended without result');\n}\n\n/**\n * Get Stockfish's move via Lichess Cloud API\n */\nasync function getStockfishMove(fen: string, depth: number): Promise<string | null> {\n  try {\n    const response = await fetch(\n      `https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`,\n      {\n        headers: {\n          'Accept': 'application/json'\n        }\n      }\n    );\n    \n    if (!response.ok) {\n      console.warn('[Stockfish] Cloud eval not available, using fallback');\n      return null;\n    }\n    \n    const data = await response.json();\n    const bestMove = data.pvs?.[0]?.moves?.split(' ')?.[0];\n    \n    return bestMove || null;\n  } catch (error) {\n    console.error('[Stockfish] Error getting move:', error);\n    return null;\n  }\n}\n\n/**\n * Calculate estimated ELO based on game results\n */\nexport function calculateEngineElo(\n  gamesPlayed: number,\n  wins: number,\n  draws: number,\n  stockfishElo: number = 3600\n): number {\n  if (gamesPlayed === 0) return 1500; // Starting ELO\n  \n  const losses = gamesPlayed - wins - draws;\n  const score = (wins + draws * 0.5) / gamesPlayed;\n  \n  // FIDE Performance Rating formula\n  const delta = 400 * Math.log10(score / (1 - Math.max(0.01, Math.min(0.99, score))));\n  \n  // Performance rating against Stockfish\n  return Math.round(stockfishElo + delta);\n}\n";export{n as default};
