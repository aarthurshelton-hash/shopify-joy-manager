const e="import { supabase } from '@/integrations/supabase/client';\nimport { SimulationResult, GameData, SquareData } from '@/lib/chess/gameSimulator';\nimport { Json } from '@/integrations/supabase/types';\nimport { \n  checkVisualizationSimilarity, \n  PaletteColors,\n  getFeaturedPaletteForColors\n} from './similarityDetection';\nimport { colorPalettes, PaletteId } from '@/lib/chess/pieceColors';\nimport { validateVisualizationTitle, validatePgnData } from '@/lib/validations/visualizationSchemas';\nimport { moderateText } from '@/lib/moderation/contentModeration';\n\nexport interface VisualizationState {\n  paletteId?: string;\n  darkMode?: boolean;\n  currentMove?: number;\n  lockedPieces?: Array<{ pieceType: string; pieceColor: string }>;\n  showLegend?: boolean;\n  customColors?: PaletteColors; // Store custom colors for similarity detection\n  linkedPaletteId?: string; // If custom colors match a featured palette, link to it\n}\n\nexport interface SavedVisualization {\n  id: string;\n  user_id: string;\n  title: string;\n  pgn: string | null;\n  game_data: GameData & { \n    board?: SquareData[][]; \n    totalMoves?: number;\n    visualizationState?: VisualizationState;\n  };\n  image_path: string;\n  public_share_id: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Generate a hash/fingerprint of the visualization state for duplicate detection\n */\nfunction generateVisualizationFingerprint(\n  pgn: string | undefined,\n  gameData: GameData,\n  state?: VisualizationState\n): string {\n  // Create a normalized string representation of the key visualization attributes\n  const pgnNormalized = (pgn || gameData.pgn || '').trim().replace(/\\s+/g, ' ');\n  const stateStr = state ? JSON.stringify({\n    palette: state.paletteId || 'modern',\n    darkMode: state.darkMode || false,\n    currentMove: state.currentMove === Infinity ? 'all' : state.currentMove,\n    lockedPieces: (state.lockedPieces || []).sort((a, b) => \n      `${a.pieceColor}-${a.pieceType}`.localeCompare(`${b.pieceColor}-${b.pieceType}`)\n    ),\n  }) : '{}';\n  \n  return `${pgnNormalized}::${stateStr}`;\n}\n\n/**\n * Result of duplicate/similarity check\n */\nexport interface DuplicateCheckResult {\n  isDuplicate: boolean;\n  isTooSimilar: boolean;\n  existingId?: string;\n  ownedByCurrentUser?: boolean;\n  ownerDisplayName?: string;\n  colorSimilarity?: number;\n  reason?: string;\n  linkedPaletteId?: PaletteId;\n  existingColors?: PaletteColors; // For color comparison preview\n  isIntrinsicPalette?: boolean; // True if using a featured En Pensent palette\n  isIntrinsicGame?: boolean; // True if the game matches a famous game card\n  matchedGameCard?: { id: string; title: string; similarity?: number; matchType?: 'exact' | 'partial' | 'none' }; // The matched famous game\n  matchedPaletteId?: PaletteId; // The matched featured palette\n  matchedPaletteSimilarity?: number; // How close to the featured palette\n}\n\n/**\n * Check if a similar visualization already exists globally (any user)\n * Uses advanced similarity detection:\n * - Exact fingerprint matching for duplicates\n * - Color similarity (30%+ threshold) + move matching for \"too similar\"\n */\nexport async function checkDuplicateVisualization(\n  userId: string,\n  pgn: string | undefined,\n  gameData: GameData,\n  state?: VisualizationState\n): Promise<DuplicateCheckResult> {\n  try {\n    const fingerprint = generateVisualizationFingerprint(pgn, gameData, state);\n    \n    // First check for exact duplicates\n    const { data, error } = await supabase\n      .from('saved_visualizations')\n      .select('id, user_id, pgn, game_data');\n    \n    if (error) {\n      console.error('Error checking duplicates:', error);\n      return { isDuplicate: false, isTooSimilar: false };\n    }\n    \n    // Check each existing visualization for an exact match\n    for (const viz of data || []) {\n      const existingGameData = viz.game_data as unknown as GameData & { visualizationState?: VisualizationState };\n      const existingFingerprint = generateVisualizationFingerprint(\n        viz.pgn || undefined,\n        existingGameData,\n        existingGameData.visualizationState\n      );\n      \n      if (fingerprint === existingFingerprint) {\n        const ownedByCurrentUser = viz.user_id === userId;\n        \n        let ownerDisplayName: string | undefined;\n        if (!ownedByCurrentUser) {\n          const { data: profileData } = await supabase\n            .from('profiles')\n            .select('display_name')\n            .eq('user_id', viz.user_id)\n            .single();\n          ownerDisplayName = profileData?.display_name || 'Another collector';\n        }\n        \n        return { \n          isDuplicate: true,\n          isTooSimilar: true,\n          existingId: viz.id,\n          ownedByCurrentUser,\n          ownerDisplayName,\n          colorSimilarity: 100,\n          reason: 'Exact duplicate exists',\n        };\n      }\n    }\n    \n    // Now check for similarity (30%+ color match with identical moves)\n    const paletteId = (state?.paletteId || 'modern') as PaletteId;\n    \n    // Build custom colors if using custom palette\n    let customColors: PaletteColors | undefined;\n    if (state?.customColors) {\n      customColors = state.customColors;\n    } else if (paletteId === 'custom') {\n      // Get from current custom palette\n      const customPalette = colorPalettes.find(p => p.id === 'custom');\n      if (customPalette) {\n        customColors = {\n          white: customPalette.white,\n          black: customPalette.black,\n        };\n      }\n    }\n    \n    const similarityResult = await checkVisualizationSimilarity(\n      userId,\n      pgn,\n      gameData,\n      paletteId,\n      customColors\n    );\n    \n    if (similarityResult.isTooSimilar) {\n      return {\n        isDuplicate: false,\n        isTooSimilar: true,\n        existingId: similarityResult.existingVisualizationId,\n        ownedByCurrentUser: similarityResult.ownedByCurrentUser,\n        ownerDisplayName: similarityResult.ownerDisplayName,\n        colorSimilarity: similarityResult.colorSimilarity,\n        reason: similarityResult.reason,\n        existingColors: similarityResult.existingColors, // For comparison preview\n        isIntrinsicPalette: similarityResult.isIntrinsicPalette,\n        isIntrinsicGame: similarityResult.isIntrinsicGame,\n        matchedGameCard: similarityResult.matchedGameCard,\n        matchedPaletteId: similarityResult.matchedPaletteId,\n        matchedPaletteSimilarity: similarityResult.matchedPaletteSimilarity,\n      };\n    }\n    \n    // Check if custom colors should link to a featured palette\n    let linkedPaletteId: PaletteId | undefined;\n    if (customColors) {\n      linkedPaletteId = getFeaturedPaletteForColors(customColors) || undefined;\n    }\n    \n    return { \n      isDuplicate: false, \n      isTooSimilar: false,\n      linkedPaletteId,\n      colorSimilarity: similarityResult.colorSimilarity,\n      isIntrinsicPalette: similarityResult.isIntrinsicPalette,\n      isIntrinsicGame: similarityResult.isIntrinsicGame,\n      matchedGameCard: similarityResult.matchedGameCard,\n      matchedPaletteId: similarityResult.matchedPaletteId,\n      matchedPaletteSimilarity: similarityResult.matchedPaletteSimilarity,\n    };\n  } catch (error) {\n    console.error('Error in duplicate check:', error);\n    return { isDuplicate: false, isTooSimilar: false };\n  }\n}\n\nexport interface SaveVisualizationResult {\n  data: SavedVisualization | null;\n  error: Error | null;\n  isDuplicate?: boolean;\n  isTooSimilar?: boolean;\n  ownedByCurrentUser?: boolean;\n  ownerDisplayName?: string;\n  colorSimilarity?: number;\n  reason?: string;\n}\n\nexport async function saveVisualization(\n  userId: string,\n  title: string,\n  simulation: SimulationResult,\n  imageBlob: Blob,\n  pgn?: string,\n  visualizationState?: VisualizationState\n): Promise<SaveVisualizationResult> {\n  try {\n    // Validate title\n    const titleValidation = validateVisualizationTitle(title);\n    if (!titleValidation.success) {\n      return { data: null, error: new Error(titleValidation.error || 'Invalid title') };\n    }\n\n    // Server-side content moderation for title\n    const titleModeration = await moderateText(title);\n    if (!titleModeration.safe) {\n      return { \n        data: null, \n        error: new Error(titleModeration.reason || 'Title contains inappropriate content') \n      };\n    }\n\n    // Validate PGN data\n    const pgnValidation = validatePgnData(pgn);\n    if (!pgnValidation.success) {\n      return { data: null, error: new Error(pgnValidation.error || 'Invalid PGN data') };\n    }\n\n    // Check for duplicates and similarity first (globally)\n    const checkResult = await checkDuplicateVisualization(\n      userId,\n      pgn,\n      simulation.gameData,\n      visualizationState\n    );\n    \n    // Block if exact duplicate\n    if (checkResult.isDuplicate) {\n      const message = checkResult.ownedByCurrentUser \n        ? 'This visualization is already in your gallery'\n        : `This visualization is owned by ${checkResult.ownerDisplayName || 'another collector'}`;\n      return { \n        data: null, \n        error: new Error(message),\n        isDuplicate: true,\n        ownedByCurrentUser: checkResult.ownedByCurrentUser,\n        ownerDisplayName: checkResult.ownerDisplayName,\n        colorSimilarity: 100,\n      };\n    }\n    \n    // Block if too similar (30%+ color match with same moves)\n    if (checkResult.isTooSimilar) {\n      const message = checkResult.ownedByCurrentUser \n        ? 'You have a very similar visualization - try changing at least 8 colors for uniqueness'\n        : `This is ${Math.round(checkResult.colorSimilarity || 30)}% similar to a vision by ${checkResult.ownerDisplayName || 'another collector'}`;\n      return { \n        data: null, \n        error: new Error(message),\n        isTooSimilar: true,\n        ownedByCurrentUser: checkResult.ownedByCurrentUser,\n        ownerDisplayName: checkResult.ownerDisplayName,\n        colorSimilarity: checkResult.colorSimilarity,\n        reason: checkResult.reason,\n      };\n    }\n    \n    // If custom colors match a featured palette, link to it for inheritance\n    const stateWithLink: VisualizationState = {\n      ...visualizationState,\n      linkedPaletteId: checkResult.linkedPaletteId,\n    };\n    \n    // Generate unique filename\n    const timestamp = Date.now();\n    const filename = `${userId}/${timestamp}-${title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.png`;\n    \n    // Upload image to storage\n    const { error: uploadError } = await supabase.storage\n      .from('visualizations')\n      .upload(filename, imageBlob, {\n        contentType: 'image/png',\n        upsert: false,\n      });\n    \n    if (uploadError) {\n      throw new Error(`Failed to upload image: ${uploadError.message}`);\n    }\n    \n    // Get public URL for the image\n    const { data: urlData } = supabase.storage\n      .from('visualizations')\n      .getPublicUrl(filename);\n    \n    // Prepare game_data as Json type - INCLUDE FULL BOARD DATA for reconstruction\n    const gameDataJson: Json = {\n      white: simulation.gameData.white,\n      black: simulation.gameData.black,\n      event: simulation.gameData.event,\n      date: simulation.gameData.date,\n      result: simulation.gameData.result,\n      pgn: simulation.gameData.pgn,\n      moves: simulation.gameData.moves,\n      // Include full board data for proper reconstruction\n      board: simulation.board as unknown as Json,\n      totalMoves: simulation.totalMoves,\n      // Include visualization state with palette linking for duplicate detection and inheritance\n      visualizationState: stateWithLink as unknown as Json,\n    };\n    \n    // Save visualization record to database\n    const { data, error } = await supabase\n      .from('saved_visualizations')\n      .insert({\n        user_id: userId,\n        title,\n        pgn: pgn || null,\n        game_data: gameDataJson,\n        image_path: urlData.publicUrl,\n      })\n      .select()\n      .single();\n    \n    if (error) {\n      // Clean up uploaded image if database insert fails\n      await supabase.storage.from('visualizations').remove([filename]);\n      throw new Error(`Failed to save visualization: ${error.message}`);\n    }\n    \n    return { data: data as unknown as SavedVisualization, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n\nexport async function getUserVisualizations(userId: string): Promise<{\n  data: SavedVisualization[];\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('saved_visualizations')\n      .select('*')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false });\n    \n    if (error) {\n      throw new Error(`Failed to fetch visualizations: ${error.message}`);\n    }\n    \n    return { data: (data || []) as unknown as SavedVisualization[], error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\nexport async function deleteVisualization(\n  id: string,\n  imagePath: string\n): Promise<{ error: Error | null }> {\n  try {\n    // Extract filename from URL for deletion\n    const url = new URL(imagePath);\n    const pathParts = url.pathname.split('/');\n    const bucketIndex = pathParts.findIndex(p => p === 'visualizations');\n    const filename = pathParts.slice(bucketIndex + 1).join('/');\n    \n    // Delete from storage\n    if (filename) {\n      await supabase.storage.from('visualizations').remove([filename]);\n    }\n    \n    // Delete from database\n    const { error } = await supabase\n      .from('saved_visualizations')\n      .delete()\n      .eq('id', id);\n    \n    if (error) {\n      throw new Error(`Failed to delete visualization: ${error.message}`);\n    }\n    \n    return { error: null };\n  } catch (error) {\n    return { error: error as Error };\n  }\n}\n\n/**\n * Get a single visualization by ID - used for detail pages\n */\nexport async function getVisualizationById(id: string): Promise<{\n  data: SavedVisualization | null;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('saved_visualizations')\n      .select('*')\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      if (error.code === 'PGRST116') {\n        return { data: null, error: new Error('Visualization not found') };\n      }\n      throw new Error(`Failed to fetch visualization: ${error.message}`);\n    }\n    \n    return { data: data as unknown as SavedVisualization, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n";export{e as default};
