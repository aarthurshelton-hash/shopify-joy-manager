const n="import { useState, useEffect, createContext, useContext, ReactNode, useCallback } from 'react';\nimport { User, Session, AuthError } from '@supabase/supabase-js';\nimport { supabase } from '@/integrations/supabase/client';\nimport { recordFunnelEvent } from '@/lib/analytics/membershipFunnel';\nimport { SecurityEvents } from '@/lib/security/auditLog';\nimport { trackUserLocation } from '@/lib/security/trackLocation';\ninterface Profile {\n  id: string;\n  user_id: string;\n  display_name: string | null;\n  avatar_url: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface SubscriptionStatus {\n  subscribed: boolean;\n  productId: string | null;\n  subscriptionEnd: string | null;\n}\n\ninterface MFAStatus {\n  enabled: boolean;\n  factorId: string | null;\n}\n\ninterface SignInResult {\n  error: Error | null;\n  requiresMFA?: boolean;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  session: Session | null;\n  profile: Profile | null;\n  isLoading: boolean;\n  isPremium: boolean;\n  isFreeAccount: boolean; // Has account but no premium subscription\n  isAdmin: boolean;\n  isCheckingAdmin: boolean;\n  subscriptionStatus: SubscriptionStatus | null;\n  isCheckingSubscription: boolean;\n  mfaStatus: MFAStatus;\n  signUp: (email: string, password: string, displayName?: string, phone?: string) => Promise<{ error: Error | null }>;\n  signIn: (email: string, password: string) => Promise<SignInResult>;\n  signOut: () => Promise<void>;\n  updateProfile: (updates: Partial<Pick<Profile, 'display_name' | 'avatar_url'>>) => Promise<{ error: Error | null }>;\n  checkSubscription: () => Promise<void>;\n  openCheckout: () => Promise<void>;\n  openCustomerPortal: () => Promise<void>;\n  checkMFAStatus: () => Promise<MFAStatus>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Premium product ID from Stripe\nconst PREMIUM_PRODUCT_ID = \"prod_TldXgoRfEQn0lX\";\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [session, setSession] = useState<Session | null>(null);\n  const [profile, setProfile] = useState<Profile | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [subscriptionStatus, setSubscriptionStatus] = useState<SubscriptionStatus | null>(null);\n  // Start as true to indicate we haven't finished initial check yet\n  const [isCheckingSubscription, setIsCheckingSubscription] = useState(true);\n  const [hasCompletedInitialCheck, setHasCompletedInitialCheck] = useState(false);\n  const [mfaStatus, setMfaStatus] = useState<MFAStatus>({ enabled: false, factorId: null });\n  const [isAdmin, setIsAdmin] = useState(false);\n  const [isCheckingAdmin, setIsCheckingAdmin] = useState(true);\n\n  const isPremium = subscriptionStatus?.subscribed && subscriptionStatus?.productId === PREMIUM_PRODUCT_ID;\n  // User has an account but no active premium subscription\n  const isFreeAccount = !!user && !isPremium;\n\n  // CEO email - hardcoded for guaranteed access\n  const CEO_EMAIL = 'a.arthur.shelton@gmail.com';\n\n  // Check admin role (with CEO email fallback)\n  const checkAdminRole = useCallback(async (userId: string, userEmail?: string | null) => {\n    setIsCheckingAdmin(true);\n    try {\n      // CEO email gets automatic admin access\n      if (userEmail?.toLowerCase() === CEO_EMAIL.toLowerCase()) {\n        setIsAdmin(true);\n        setIsCheckingAdmin(false);\n        \n        // Also ensure the admin role exists in database (fire and forget)\n        supabase.functions.invoke('grant-ceo-admin').catch(() => {});\n        return;\n      }\n      \n      // Check database for admin role\n      const { data, error } = await supabase\n        .from('user_roles')\n        .select('role')\n        .eq('user_id', userId)\n        .eq('role', 'admin')\n        .maybeSingle();\n      \n      setIsAdmin(!error && !!data);\n    } catch {\n      setIsAdmin(false);\n    } finally {\n      setIsCheckingAdmin(false);\n    }\n  }, []);\n\n  // Check MFA status\n  const checkMFAStatus = useCallback(async (): Promise<MFAStatus> => {\n    try {\n      const { data, error } = await supabase.auth.mfa.listFactors();\n      if (error) throw error;\n\n      const verifiedTOTP = data.totp?.find(factor => factor.status === 'verified');\n      const status = {\n        enabled: !!verifiedTOTP,\n        factorId: verifiedTOTP?.id || null,\n      };\n      setMfaStatus(status);\n      return status;\n    } catch (error) {\n      console.error('Error checking MFA status:', error);\n      return { enabled: false, factorId: null };\n    }\n  }, []);\n\n  // Fetch user profile\n  const fetchProfile = async (userId: string) => {\n    const { data, error } = await supabase\n      .from('profiles')\n      .select('*')\n      .eq('user_id', userId)\n      .single();\n    \n    if (!error && data) {\n      setProfile(data);\n    }\n  };\n\n  // Check subscription status\n  const checkSubscription = useCallback(async () => {\n    if (!session?.access_token) {\n      setSubscriptionStatus(null);\n      setIsCheckingSubscription(false);\n      setHasCompletedInitialCheck(true);\n      return;\n    }\n\n    setIsCheckingSubscription(true);\n    try {\n      const { data, error } = await supabase.functions.invoke('check-subscription', {\n        headers: {\n          Authorization: `Bearer ${session.access_token}`,\n        },\n      });\n\n      if (error) {\n        console.error('Error checking subscription:', error);\n        setSubscriptionStatus(null);\n      } else {\n        setSubscriptionStatus({\n          subscribed: data.subscribed,\n          productId: data.product_id,\n          subscriptionEnd: data.subscription_end,\n        });\n      }\n    } catch (err) {\n      console.error('Error checking subscription:', err);\n      setSubscriptionStatus(null);\n    } finally {\n      setIsCheckingSubscription(false);\n      setHasCompletedInitialCheck(true);\n    }\n  }, [session?.access_token]);\n\n  // Open Stripe checkout\n  const openCheckout = async () => {\n    if (!session?.access_token) {\n      throw new Error('Not authenticated');\n    }\n\n    const { data, error } = await supabase.functions.invoke('create-checkout', {\n      headers: {\n        Authorization: `Bearer ${session.access_token}`,\n      },\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to create checkout session');\n    }\n\n    if (data?.url) {\n      window.open(data.url, '_blank');\n    }\n  };\n\n  // Open Stripe customer portal\n  const openCustomerPortal = async () => {\n    if (!session?.access_token) {\n      throw new Error('Not authenticated');\n    }\n\n    const { data, error } = await supabase.functions.invoke('customer-portal', {\n      headers: {\n        Authorization: `Bearer ${session.access_token}`,\n      },\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to create portal session');\n    }\n\n    if (data?.url) {\n      window.open(data.url, '_blank');\n    }\n  };\n\n  useEffect(() => {\n    // Set up auth state listener FIRST\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      async (event, currentSession) => {\n        setSession(currentSession);\n        setUser(currentSession?.user ?? null);\n        \n        if (currentSession?.user) {\n          // Use setTimeout to avoid potential deadlock with Supabase client\n          setTimeout(() => {\n            fetchProfile(currentSession.user.id);\n            checkAdminRole(currentSession.user.id, currentSession.user.email);\n          }, 0);\n        } else {\n          setProfile(null);\n          setSubscriptionStatus(null);\n          setIsAdmin(false);\n          setIsCheckingAdmin(false);\n        }\n        \n        setIsLoading(false);\n      }\n    );\n\n    // THEN check for existing session\n    supabase.auth.getSession().then(({ data: { session: currentSession } }) => {\n      setSession(currentSession);\n      setUser(currentSession?.user ?? null);\n      \n      if (currentSession?.user) {\n        fetchProfile(currentSession.user.id);\n        checkAdminRole(currentSession.user.id, currentSession.user.email);\n      } else {\n        setIsCheckingAdmin(false);\n      }\n      \n      setIsLoading(false);\n    });\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  // Check subscription when session changes\n  useEffect(() => {\n    if (session?.access_token) {\n      checkSubscription();\n    }\n  }, [session?.access_token, checkSubscription]);\n\n  // Auto-refresh subscription status every minute\n  useEffect(() => {\n    if (!session?.access_token) return;\n\n    const interval = setInterval(() => {\n      checkSubscription();\n    }, 60000); // Check every minute\n\n    return () => clearInterval(interval);\n  }, [session?.access_token, checkSubscription]);\n\n  // Check for subscription success in URL\n  useEffect(() => {\n    const urlParams = new URLSearchParams(window.location.search);\n    if (urlParams.get('subscription') === 'success') {\n      // Clear the URL parameter\n      window.history.replaceState({}, '', window.location.pathname);\n      // Refresh subscription status\n      checkSubscription();\n    }\n  }, [checkSubscription]);\n\n  const signUp = async (email: string, password: string, displayName?: string, phone?: string) => {\n    const { error, data } = await supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        emailRedirectTo: window.location.origin,\n        data: {\n          display_name: displayName,\n          phone: phone,\n        },\n      },\n    });\n    \n    // Track successful signup - now tracking as free_account_created\n    if (!error && data.user) {\n      recordFunnelEvent('signup_completed', {\n        trigger_source: 'auth_modal',\n        account_type: 'free',\n        has_phone: !!phone,\n      });\n      \n      // Log security event and track location\n      SecurityEvents.userSignUp(data.user.id, {\n        email: email,\n        has_phone: !!phone,\n        has_display_name: !!displayName,\n      });\n      \n      // Track geolocation in background\n      trackUserLocation(data.user.id);\n    }\n    \n    return { error };\n  };\n\n  const signIn = async (email: string, password: string): Promise<SignInResult> => {\n    const { data, error } = await supabase.auth.signInWithPassword({\n      email,\n      password,\n    });\n\n    if (error) {\n      // Log failed sign-in attempt\n      SecurityEvents.signInFailed(email, error.message);\n      return { error };\n    }\n\n    // Log successful sign-in and track location\n    if (data.user) {\n      SecurityEvents.userSignIn(data.user.id, { email });\n      trackUserLocation(data.user.id);\n    }\n\n    // Check if MFA is required (user has factors enrolled)\n    const { data: factorsData } = await supabase.auth.mfa.listFactors();\n    const hasVerifiedTOTP = factorsData?.totp?.some(factor => factor.status === 'verified');\n\n    if (hasVerifiedTOTP) {\n      // Check the assurance level to see if MFA verification is needed\n      const { data: aalData } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel();\n      \n      if (aalData?.currentLevel === 'aal1' && aalData?.nextLevel === 'aal2') {\n        return { error: null, requiresMFA: true };\n      }\n    }\n\n    return { error: null, requiresMFA: false };\n  };\n\n  const signOut = async () => {\n    // Log sign-out before clearing state\n    if (user) {\n      SecurityEvents.userSignOut(user.id);\n    }\n    \n    await supabase.auth.signOut();\n    setUser(null);\n    setSession(null);\n    setProfile(null);\n    setSubscriptionStatus(null);\n    setMfaStatus({ enabled: false, factorId: null });\n    setIsAdmin(false);\n    setIsCheckingAdmin(false);\n    setHasCompletedInitialCheck(false);\n    setIsCheckingSubscription(false);\n  };\n\n  const updateProfile = async (updates: Partial<Pick<Profile, 'display_name' | 'avatar_url'>>) => {\n    if (!user) return { error: new Error('Not authenticated') };\n    \n    const { error } = await supabase\n      .from('profiles')\n      .update(updates)\n      .eq('user_id', user.id);\n    \n    if (!error) {\n      setProfile(prev => prev ? { ...prev, ...updates } : null);\n    }\n    \n    return { error };\n  };\n\n  return (\n    <AuthContext.Provider value={{\n      user,\n      session,\n      profile,\n      isLoading,\n      isPremium,\n      isFreeAccount,\n      isAdmin,\n      isCheckingAdmin,\n      subscriptionStatus,\n      isCheckingSubscription,\n      mfaStatus,\n      signUp,\n      signIn,\n      signOut,\n      updateProfile,\n      checkSubscription,\n      openCheckout,\n      openCustomerPortal,\n      checkMFAStatus,\n    }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n";export{n as default};
