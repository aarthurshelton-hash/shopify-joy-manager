const n="/**\n * En Pensent Core SDK - Pattern Matching\n * \n * Universal algorithms for finding similar patterns and calculating similarity\n */\n\nimport { \n  TemporalSignature, \n  PatternMatch, \n  PatternSearchCriteria,\n  QuadrantProfile,\n  TemporalFlow\n} from './types';\n\n/**\n * Calculate similarity between two quadrant profiles\n */\nexport function quadrantSimilarity(a: QuadrantProfile, b: QuadrantProfile): number {\n  const diff = \n    Math.abs(a.q1 - b.q1) +\n    Math.abs(a.q2 - b.q2) +\n    Math.abs(a.q3 - b.q3) +\n    Math.abs(a.q4 - b.q4);\n  \n  // Maximum possible difference is 4 (each quadrant can differ by 1)\n  return 1 - (diff / 4);\n}\n\n/**\n * Calculate similarity between two temporal flows\n */\nexport function temporalFlowSimilarity(a: TemporalFlow, b: TemporalFlow): number {\n  const phaseDiff = \n    Math.abs(a.opening - b.opening) +\n    Math.abs(a.middle - b.middle) +\n    Math.abs(a.ending - b.ending);\n  \n  const phaseSimilarity = 1 - (phaseDiff / 3);\n  \n  // Trend matching bonus\n  const trendBonus = a.trend === b.trend ? 0.2 : 0;\n  \n  // Momentum similarity\n  const momentumSimilarity = 1 - Math.abs(a.momentum - b.momentum) / 2;\n  \n  return Math.min(1, (phaseSimilarity * 0.5) + (momentumSimilarity * 0.3) + trendBonus);\n}\n\n/**\n * Calculate overall similarity between two signatures\n */\nexport function calculateSignatureSimilarity(\n  a: TemporalSignature,\n  b: TemporalSignature,\n  weights: {\n    archetype?: number;\n    quadrant?: number;\n    temporal?: number;\n    intensity?: number;\n    flow?: number;\n  } = {}\n): number {\n  const {\n    archetype: archetypeWeight = 0.25,\n    quadrant: quadrantWeight = 0.25,\n    temporal: temporalWeight = 0.25,\n    intensity: intensityWeight = 0.15,\n    flow: flowWeight = 0.10\n  } = weights;\n  \n  // Archetype similarity (exact match or related)\n  const archetypeSimilarity = a.archetype === b.archetype ? 1 : 0.5;\n  \n  // Quadrant profile similarity\n  const quadrantSim = quadrantSimilarity(a.quadrantProfile, b.quadrantProfile);\n  \n  // Temporal flow similarity\n  const temporalSim = temporalFlowSimilarity(a.temporalFlow, b.temporalFlow);\n  \n  // Intensity similarity\n  const intensitySim = 1 - Math.abs(a.intensity - b.intensity);\n  \n  // Flow direction similarity\n  const flowSim = a.flowDirection === b.flowDirection ? 1 : \n                  (a.flowDirection === 'chaotic' || b.flowDirection === 'chaotic') ? 0.3 : 0.5;\n  \n  // Weighted combination\n  const similarity = \n    (archetypeSimilarity * archetypeWeight) +\n    (quadrantSim * quadrantWeight) +\n    (temporalSim * temporalWeight) +\n    (intensitySim * intensityWeight) +\n    (flowSim * flowWeight);\n  \n  return Math.min(1, Math.max(0, similarity));\n}\n\n/**\n * Find similar patterns from a collection\n */\nexport function findSimilarPatterns(\n  targetSignature: TemporalSignature,\n  patterns: { id: string; signature: TemporalSignature; outcome: string; metadata?: Record<string, unknown> }[],\n  criteria: Partial<PatternSearchCriteria> = {}\n): PatternMatch[] {\n  const {\n    minSimilarity = 0.5,\n    limit = 10,\n    archetypeFilter,\n    outcomeFilter\n  } = criteria;\n  \n  const matches: PatternMatch[] = [];\n  \n  for (const pattern of patterns) {\n    // Apply filters\n    if (archetypeFilter && archetypeFilter.length > 0) {\n      if (!archetypeFilter.includes(pattern.signature.archetype)) {\n        continue;\n      }\n    }\n    \n    if (outcomeFilter && outcomeFilter.length > 0) {\n      if (!outcomeFilter.includes(pattern.outcome)) {\n        continue;\n      }\n    }\n    \n    // Calculate similarity\n    const similarity = calculateSignatureSimilarity(targetSignature, pattern.signature);\n    \n    if (similarity >= minSimilarity) {\n      matches.push({\n        patternId: pattern.id,\n        similarity,\n        signature: pattern.signature,\n        outcome: pattern.outcome,\n        sourceMetadata: pattern.metadata\n      });\n    }\n  }\n  \n  // Sort by similarity descending\n  matches.sort((a, b) => b.similarity - a.similarity);\n  \n  // Limit results\n  return matches.slice(0, limit);\n}\n\n/**\n * Calculate outcome probabilities from pattern matches\n */\nexport function calculateOutcomeProbabilities(\n  matches: PatternMatch[]\n): Record<string, number> {\n  if (matches.length === 0) {\n    return {};\n  }\n  \n  const outcomeCounts: Record<string, { count: number; weightedCount: number }> = {};\n  let totalWeight = 0;\n  \n  for (const match of matches) {\n    if (!outcomeCounts[match.outcome]) {\n      outcomeCounts[match.outcome] = { count: 0, weightedCount: 0 };\n    }\n    \n    outcomeCounts[match.outcome].count++;\n    outcomeCounts[match.outcome].weightedCount += match.similarity;\n    totalWeight += match.similarity;\n  }\n  \n  const probabilities: Record<string, number> = {};\n  \n  for (const [outcome, data] of Object.entries(outcomeCounts)) {\n    probabilities[outcome] = totalWeight > 0 ? data.weightedCount / totalWeight : 0;\n  }\n  \n  return probabilities;\n}\n\n/**\n * Get the most likely outcome from pattern matches\n */\nexport function getMostLikelyOutcome(\n  matches: PatternMatch[]\n): { outcome: string; probability: number } | null {\n  const probabilities = calculateOutcomeProbabilities(matches);\n  \n  let bestOutcome: string | null = null;\n  let bestProbability = 0;\n  \n  for (const [outcome, probability] of Object.entries(probabilities)) {\n    if (probability > bestProbability) {\n      bestOutcome = outcome;\n      bestProbability = probability;\n    }\n  }\n  \n  if (bestOutcome === null) {\n    return null;\n  }\n  \n  return { outcome: bestOutcome, probability: bestProbability };\n}\n\n/**\n * Calculate pattern diversity score (how varied the matches are)\n */\nexport function calculatePatternDiversity(matches: PatternMatch[]): number {\n  if (matches.length <= 1) return 0;\n  \n  const uniqueArchetypes = new Set(matches.map(m => m.signature.archetype));\n  const uniqueOutcomes = new Set(matches.map(m => m.outcome));\n  \n  const archetypeDiversity = uniqueArchetypes.size / matches.length;\n  const outcomeDiversity = uniqueOutcomes.size / matches.length;\n  \n  return (archetypeDiversity + outcomeDiversity) / 2;\n}\n\n/**\n * Calculate confidence based on pattern matches\n */\nexport function calculateMatchConfidence(\n  matches: PatternMatch[],\n  minSampleSize: number = 5\n): number {\n  if (matches.length === 0) return 0;\n  \n  // Factor 1: Sample size\n  const sampleSizeConfidence = Math.min(1, matches.length / minSampleSize);\n  \n  // Factor 2: Average similarity\n  const avgSimilarity = matches.reduce((sum, m) => sum + m.similarity, 0) / matches.length;\n  \n  // Factor 3: Outcome consensus (low diversity = high confidence)\n  const diversity = calculatePatternDiversity(matches);\n  const consensusConfidence = 1 - diversity;\n  \n  // Weighted combination\n  return (sampleSizeConfidence * 0.3) + (avgSimilarity * 0.4) + (consensusConfidence * 0.3);\n}\n";export{n as default};
