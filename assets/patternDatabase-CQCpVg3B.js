const t="/**\n * Pattern Database\n */\n\nimport { ColorFlowSignature, StrategicArchetype } from '../colorFlowAnalysis';\nimport { GameData } from '../gameSimulator';\nimport { PatternRecord, PatternMatch } from './types';\nimport { calculateSimilarity, getMatchingFactors, getRelatedArchetypes } from './similarityCalculator';\n\nexport class PatternDatabase {\n  private patterns: Map<string, PatternRecord> = new Map();\n  private archetypeIndex: Map<StrategicArchetype, PatternRecord[]> = new Map();\n\n  addPattern(\n    signature: ColorFlowSignature,\n    outcome: 'white_wins' | 'black_wins' | 'draw',\n    gameData: GameData,\n    totalMoves: number\n  ): PatternRecord {\n    const record: PatternRecord = {\n      id: `pat-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n      fingerprint: signature.fingerprint,\n      archetype: signature.archetype,\n      outcome,\n      totalMoves,\n      characteristics: {\n        flowDirection: signature.flowDirection,\n        intensity: signature.intensity,\n        volatility: signature.temporalFlow.volatility,\n        dominantSide: signature.dominantSide,\n        centerControl: signature.quadrantProfile.center,\n        kingsideActivity: (signature.quadrantProfile.kingsideWhite + signature.quadrantProfile.kingsideBlack) / 2,\n        queensideActivity: (signature.quadrantProfile.queensideWhite + signature.quadrantProfile.queensideBlack) / 2,\n      },\n      gameMetadata: {\n        event: gameData.event,\n        white: gameData.white,\n        black: gameData.black,\n        date: gameData.date,\n      },\n    };\n\n    this.patterns.set(record.id, record);\n\n    const existing = this.archetypeIndex.get(signature.archetype) || [];\n    existing.push(record);\n    this.archetypeIndex.set(signature.archetype, existing);\n\n    return record;\n  }\n\n  findSimilar(signature: ColorFlowSignature, limit: number = 5): PatternMatch[] {\n    const matches: PatternMatch[] = [];\n\n    // First, look at same archetype\n    const sameArchetype = this.archetypeIndex.get(signature.archetype) || [];\n\n    for (const pattern of sameArchetype) {\n      const similarity = calculateSimilarity(signature, pattern);\n      if (similarity > 30) {\n        matches.push({\n          pattern,\n          similarity,\n          matchingFactors: getMatchingFactors(signature, pattern),\n          predictedOutcome: pattern.outcome,\n          confidence: similarity * 0.9,\n        });\n      }\n    }\n\n    // Also check related archetypes\n    const relatedArchetypes = getRelatedArchetypes(signature.archetype);\n    for (const archetype of relatedArchetypes) {\n      const related = this.archetypeIndex.get(archetype) || [];\n      for (const pattern of related) {\n        const similarity = calculateSimilarity(signature, pattern) * 0.8;\n        if (similarity > 30) {\n          matches.push({\n            pattern,\n            similarity,\n            matchingFactors: getMatchingFactors(signature, pattern),\n            predictedOutcome: pattern.outcome,\n            confidence: similarity * 0.7,\n          });\n        }\n      }\n    }\n\n    return matches\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, limit);\n  }\n\n  getStats(): { totalPatterns: number; byArchetype: Record<string, number> } {\n    const byArchetype: Record<string, number> = {};\n    for (const [archetype, patterns] of this.archetypeIndex) {\n      byArchetype[archetype] = patterns.length;\n    }\n    return {\n      totalPatterns: this.patterns.size,\n      byArchetype,\n    };\n  }\n\n  /**\n   * Inject a learned pattern from the database (for persistent knowledge loading)\n   */\n  injectLearnedPattern(record: PatternRecord): void {\n    // Skip if already exists\n    if (this.patterns.has(record.id)) return;\n    \n    this.patterns.set(record.id, record);\n    \n    const existing = this.archetypeIndex.get(record.archetype) || [];\n    existing.push(record);\n    this.archetypeIndex.set(record.archetype, existing);\n  }\n\n  clear(): void {\n    this.patterns.clear();\n    this.archetypeIndex.clear();\n  }\n}\n\nexport const patternDatabase = new PatternDatabase();\n";export{t as default};
