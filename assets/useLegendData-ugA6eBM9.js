const n="/**\n * Legend Data Hook\n * Extracted from LiveColorLegend for separation of concerns\n */\n\nimport { useMemo } from 'react';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { MoveHistoryEntry } from '../EnPensentOverlay';\nimport { TemporalSignature, QuadrantProfile, TemporalFlow } from '@/lib/pensent-core/types';\nimport { classifyUniversalArchetype } from '@/lib/pensent-core/archetype/universalClassifier';\n\nexport interface TerritoryData {\n  whiteControl: number[][];\n  blackControl: number[][];\n  maxWhite: number;\n  maxBlack: number;\n  whitePercent: number;\n  blackPercent: number;\n}\n\n/**\n * Calculate piece activity from move history\n */\nexport function usePieceActivity(moveHistory: MoveHistoryEntry[]) {\n  return useMemo(() => {\n    const activity = new Map<string, number>();\n    const pieceTypes: PieceType[] = ['k', 'q', 'r', 'b', 'n', 'p'];\n    const colors: PieceColor[] = ['w', 'b'];\n    \n    // Initialize\n    for (const color of colors) {\n      for (const piece of pieceTypes) {\n        activity.set(`${color}-${piece}`, 0);\n      }\n    }\n    \n    // Count from move history\n    for (const move of moveHistory) {\n      const key = `${move.color}-${move.piece}`;\n      activity.set(key, (activity.get(key) || 0) + 1);\n    }\n    \n    return activity;\n  }, [moveHistory]);\n}\n\n/**\n * Calculate territory heatmap data\n */\nexport function useTerritoryData(moveHistory: MoveHistoryEntry[]): TerritoryData {\n  return useMemo(() => {\n    const whiteControl: number[][] = Array(8).fill(null).map(() => Array(8).fill(0));\n    const blackControl: number[][] = Array(8).fill(null).map(() => Array(8).fill(0));\n    let maxWhite = 0;\n    let maxBlack = 0;\n    \n    for (const move of moveHistory) {\n      const file = move.square.charCodeAt(0) - 97;\n      const rank = parseInt(move.square[1]) - 1;\n      \n      if (file >= 0 && file < 8 && rank >= 0 && rank < 8) {\n        if (move.color === 'w') {\n          whiteControl[7 - rank][file]++;\n          maxWhite = Math.max(maxWhite, whiteControl[7 - rank][file]);\n        } else {\n          blackControl[7 - rank][file]++;\n          maxBlack = Math.max(maxBlack, blackControl[7 - rank][file]);\n        }\n      }\n    }\n    \n    let whiteTotal = 0;\n    let blackTotal = 0;\n    for (let r = 0; r < 8; r++) {\n      for (let f = 0; f < 8; f++) {\n        whiteTotal += whiteControl[r][f];\n        blackTotal += blackControl[r][f];\n      }\n    }\n    const total = whiteTotal + blackTotal || 1;\n    \n    return {\n      whiteControl,\n      blackControl,\n      maxWhite: maxWhite || 1,\n      maxBlack: maxBlack || 1,\n      whitePercent: Math.round((whiteTotal / total) * 100),\n      blackPercent: Math.round((blackTotal / total) * 100),\n    };\n  }, [moveHistory]);\n}\n\n/**\n * Extract temporal signature from move history (En Pensent integration)\n */\nexport function useTemporalSignature(\n  moveHistory: MoveHistoryEntry[],\n  territoryData: TerritoryData\n): TemporalSignature | null {\n  return useMemo((): TemporalSignature | null => {\n    if (moveHistory.length === 0) return null;\n    \n    const quadrantProfile: QuadrantProfile = { q1: 0, q2: 0, q3: 0, q4: 0 };\n    const totalMoves = moveHistory.length;\n    \n    for (const move of moveHistory) {\n      const file = move.square.charCodeAt(0) - 97;\n      const rank = parseInt(move.square[1]) - 1;\n      \n      if (file >= 0 && file < 8 && rank >= 0 && rank < 8) {\n        if (rank >= 4 && file < 4) quadrantProfile.q1++;\n        else if (rank >= 4 && file >= 4) quadrantProfile.q2++;\n        else if (rank < 4 && file < 4) quadrantProfile.q3++;\n        else quadrantProfile.q4++;\n      }\n    }\n    \n    if (totalMoves > 0) {\n      quadrantProfile.q1 /= totalMoves;\n      quadrantProfile.q2 /= totalMoves;\n      quadrantProfile.q3 /= totalMoves;\n      quadrantProfile.q4 /= totalMoves;\n    }\n    \n    const whitePercent = territoryData.whitePercent / 100;\n    \n    const temporalFlow: TemporalFlow = {\n      opening: Math.min(1, 10 / totalMoves),\n      middle: totalMoves > 10 ? Math.min(1, (totalMoves - 10) / 30) : 0,\n      ending: totalMoves > 40 ? Math.min(1, (totalMoves - 40) / 20) : 0,\n      trend: whitePercent > 0.55 ? 'accelerating' : whitePercent < 0.45 ? 'declining' : 'stable',\n      momentum: (whitePercent - 0.5) * 2,\n    };\n    \n    const intensity = Math.min(1, totalMoves / 80);\n    const dominantForce = whitePercent > 0.55 ? 'primary' : whitePercent < 0.45 ? 'secondary' : 'balanced';\n    \n    return {\n      fingerprint: `live-${Date.now()}`,\n      archetype: 'unknown',\n      dominantForce,\n      flowDirection: temporalFlow.momentum > 0 ? 'forward' : temporalFlow.momentum < 0 ? 'backward' : 'lateral',\n      intensity,\n      quadrantProfile,\n      temporalFlow,\n      criticalMoments: [],\n    };\n  }, [moveHistory, territoryData]);\n}\n\n/**\n * Classify game archetype from temporal signature\n */\nexport function useGameArchetype(signature: TemporalSignature | null): string | null {\n  return useMemo(() => {\n    if (!signature) return null;\n    return classifyUniversalArchetype(signature);\n  }, [signature]);\n}\n";export{n as default};
