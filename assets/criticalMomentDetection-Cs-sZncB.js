const n="/**\n * Critical Moment Detection - v7.53-ACCURACY\n * \n * Identifies positions where the game outcome is most influenced.\n * Predictions near critical moments should be weighted higher.\n */\n\nexport type CriticalMomentType = \n  | 'tension_break'      // When a pawn tension resolves\n  | 'piece_exchange'     // Major piece trade decision\n  | 'king_safety'        // Castling or king exposure decision\n  | 'pawn_structure'     // Irreversible pawn move\n  | 'material_imbalance' // Sacrifice or winning material\n  | 'time_pressure'      // Critical time management moment\n  | 'breakthrough'       // Breaking through defensive structure\n  | 'transition';        // Phase transition (opening->middle, middle->end)\n\nexport interface CriticalMoment {\n  moveNumber: number;\n  type: CriticalMomentType;\n  severity: number;  // 0-1, how critical\n  description: string;\n  predictiveValue: number;  // How much this moment affects outcome\n  expectedOutcome?: 'white_advantage' | 'black_advantage' | 'unclear';\n}\n\nexport interface TensionPoint {\n  square: string;\n  attackers: number;\n  defenders: number;\n  value: number;  // Material value at stake\n}\n\n/**\n * Severity weights for different critical moment types\n */\nexport const MOMENT_WEIGHTS: Record<CriticalMomentType, number> = {\n  tension_break: 0.7,\n  piece_exchange: 0.65,\n  king_safety: 0.9,\n  pawn_structure: 0.5,\n  material_imbalance: 0.85,\n  time_pressure: 0.6,\n  breakthrough: 0.8,\n  transition: 0.55,\n};\n\n/**\n * Detect if a position is near a critical moment\n */\nexport function detectCriticalMoment(\n  currentEval: number,\n  previousEval: number,\n  moveNumber: number,\n  pieceCount: number,\n  previousPieceCount: number\n): CriticalMoment | null {\n  const evalSwing = Math.abs(currentEval - previousEval);\n  const pieceChange = previousPieceCount - pieceCount;\n  \n  // Large evaluation swing = something critical happened\n  if (evalSwing > 100) {\n    return {\n      moveNumber,\n      type: 'material_imbalance',\n      severity: Math.min(1, evalSwing / 300),\n      description: `Evaluation swing of ${evalSwing}cp`,\n      predictiveValue: 0.85,\n      expectedOutcome: currentEval > 100 ? 'white_advantage' : \n                       currentEval < -100 ? 'black_advantage' : 'unclear',\n    };\n  }\n  \n  // Major piece trade\n  if (pieceChange >= 2) {\n    return {\n      moveNumber,\n      type: 'piece_exchange',\n      severity: pieceChange / 4,\n      description: `${pieceChange} pieces exchanged`,\n      predictiveValue: 0.7,\n    };\n  }\n  \n  // Transition detection\n  if (pieceCount <= 14 && previousPieceCount > 14) {\n    return {\n      moveNumber,\n      type: 'transition',\n      severity: 0.6,\n      description: 'Entering endgame phase',\n      predictiveValue: 0.75,\n    };\n  }\n  \n  // Phase transitions\n  if (moveNumber === 12 || moveNumber === 25) {\n    return {\n      moveNumber,\n      type: 'transition',\n      severity: 0.5,\n      description: moveNumber === 12 ? 'Opening to middlegame' : 'Middlegame deepening',\n      predictiveValue: 0.55,\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Calculate tension level in position\n */\nexport function calculatePositionTension(\n  attackedSquares: number,\n  defendedSquares: number,\n  hangingPieces: number\n): number {\n  // High attacked/defended ratio = high tension\n  const attackRatio = defendedSquares > 0 ? attackedSquares / defendedSquares : attackedSquares;\n  const hangingFactor = hangingPieces * 0.2;\n  \n  return Math.min(1, (attackRatio * 0.3) + hangingFactor);\n}\n\n/**\n * Detect if we're approaching a tension break\n */\nexport function detectTensionBreakPoint(\n  tensions: number[],\n  threshold: number = 0.3\n): { isBreakPoint: boolean; confidence: number } {\n  if (tensions.length < 3) {\n    return { isBreakPoint: false, confidence: 0 };\n  }\n  \n  const recentTensions = tensions.slice(-5);\n  const avgTension = recentTensions.reduce((a, b) => a + b, 0) / recentTensions.length;\n  const currentTension = tensions[tensions.length - 1];\n  \n  // Tension dropping suddenly = break point\n  if (avgTension > 0.5 && currentTension < threshold) {\n    return { \n      isBreakPoint: true, \n      confidence: (avgTension - currentTension) / avgTension,\n    };\n  }\n  \n  // Tension building = approaching break\n  const tensionTrend = recentTensions[recentTensions.length - 1] - recentTensions[0];\n  if (tensionTrend > 0.2 && currentTension > 0.7) {\n    return { \n      isBreakPoint: true, \n      confidence: currentTension * 0.8,\n    };\n  }\n  \n  return { isBreakPoint: false, confidence: 0 };\n}\n\n/**\n * Aggregate critical moments for prediction weighting\n */\nexport function aggregateCriticalMoments(\n  moments: CriticalMoment[]\n): { \n  overallCriticality: number; \n  dominantType: CriticalMomentType | null;\n  predictionBoost: number;\n} {\n  if (moments.length === 0) {\n    return { overallCriticality: 0, dominantType: null, predictionBoost: 1.0 };\n  }\n  \n  // Calculate weighted criticality\n  const totalCriticality = moments.reduce((sum, m) => \n    sum + (m.severity * MOMENT_WEIGHTS[m.type]), 0\n  );\n  const overallCriticality = Math.min(1, totalCriticality / moments.length);\n  \n  // Find dominant moment type\n  const typeCounts = moments.reduce((acc, m) => {\n    acc[m.type] = (acc[m.type] || 0) + m.severity;\n    return acc;\n  }, {} as Record<string, number>);\n  \n  const dominantType = Object.entries(typeCounts)\n    .sort((a, b) => b[1] - a[1])[0]?.[0] as CriticalMomentType | undefined;\n  \n  // Prediction boost - predictions near critical moments are more valuable\n  const avgPredictiveValue = moments.reduce((sum, m) => sum + m.predictiveValue, 0) / moments.length;\n  const predictionBoost = 1.0 + (avgPredictiveValue * 0.5);\n  \n  return {\n    overallCriticality,\n    dominantType: dominantType || null,\n    predictionBoost,\n  };\n}\n\n/**\n * Score a position's proximity to decision point\n */\nexport function scoreDecisionProximity(\n  evalHistory: number[],\n  moveNumber: number,\n  recentMoments: CriticalMoment[]\n): number {\n  if (evalHistory.length < 2) return 0.5;\n  \n  // Volatility in recent evaluations\n  const recentEvals = evalHistory.slice(-5);\n  const evalVariance = calculateVariance(recentEvals);\n  const volatilityScore = Math.min(1, evalVariance / 10000);\n  \n  // Recent critical moments boost\n  const recentMomentScore = recentMoments.length > 0 ?\n    recentMoments.slice(-2).reduce((sum, m) => sum + m.severity, 0) / 2 : 0;\n  \n  return (volatilityScore * 0.6) + (recentMomentScore * 0.4);\n}\n\n/**\n * Helper: Calculate variance\n */\nfunction calculateVariance(values: number[]): number {\n  if (values.length === 0) return 0;\n  const mean = values.reduce((a, b) => a + b, 0) / values.length;\n  return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n}\n";export{n as default};
