const n="import { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useUnifiedEvolution } from './useUnifiedEvolution';\nimport { toast } from 'sonner';\n\nexport interface CodeIssue {\n  id?: string;\n  file_path: string;\n  issue_type: string;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  description: string;\n  confidence: number;\n  line_start?: number;\n  line_end?: number;\n  auto_fixable: boolean;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface PendingFix {\n  id: string;\n  issue_id: string;\n  file_path: string;\n  fix_prompt: string;\n  fixed_code?: string;\n  confidence: number;\n  status: string;\n  generated_at: string;\n}\n\nexport interface AutoHealStats {\n  total_issues: number;\n  unresolved_issues: number;\n  auto_fixable: number;\n  critical_issues: number;\n  pending_fixes: number;\n  applied_fixes: number;\n  high_confidence_fixes: number;\n  recent_runs: Array<{\n    id: string;\n    started_at: string;\n    status: string;\n    issues_detected: number;\n    fixes_generated: number;\n  }>;\n}\n\nexport interface AutoHealConfig {\n  enabled: boolean;\n  autoApplyThreshold: number; // 0-1, default 0.9 for high confidence\n  scanIntervalMs: number; // default 30000 (30 seconds)\n  maxAutoFixesPerRun: number; // default 3\n}\n\nconst DEFAULT_CONFIG: AutoHealConfig = {\n  enabled: false,\n  autoApplyThreshold: 0.9,\n  scanIntervalMs: 30000,\n  maxAutoFixesPerRun: 3\n};\n\nexport function useAutoHealSystem() {\n  const [config, setConfig] = useState<AutoHealConfig>(() => {\n    const saved = localStorage.getItem('autoHealConfig');\n    return saved ? JSON.parse(saved) : DEFAULT_CONFIG;\n  });\n  \n  const [stats, setStats] = useState<AutoHealStats | null>(null);\n  const [isRunning, setIsRunning] = useState(false);\n  const [lastScan, setLastScan] = useState<Date | null>(null);\n  const [pendingFixes, setPendingFixes] = useState<PendingFix[]>([]);\n  \n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const evolution = useUnifiedEvolution();\n\n  // Save config to localStorage\n  useEffect(() => {\n    localStorage.setItem('autoHealConfig', JSON.stringify(config));\n  }, [config]);\n\n  // Fetch stats\n  const fetchStats = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('auto-heal-codebase', {\n        body: { action: 'get_stats' }\n      });\n      \n      if (error) throw error;\n      if (data?.success) {\n        setStats(data.stats);\n      }\n    } catch (error) {\n      console.error('[AutoHeal] Failed to fetch stats:', error);\n    }\n  }, []);\n\n  // Detect and store issues from frontend analysis\n  const detectIssues = useCallback(async (issues: CodeIssue[]) => {\n    try {\n      setIsRunning(true);\n      \n      const { data, error } = await supabase.functions.invoke('auto-heal-codebase', {\n        body: { \n          action: 'detect_issues',\n          issues \n        }\n      });\n      \n      if (error) throw error;\n      \n      console.log(`[AutoHeal] Stored ${data.issues_stored} issues`);\n      setLastScan(new Date());\n      \n      // Emit evolution event\n      await evolution.onCodeAnalyzed({\n        archetype: 'self-healing',\n        health: 100 - (issues.filter(i => i.severity === 'critical').length * 10),\n        recommendations: issues.slice(0, 3).map(i => i.description)\n      });\n      \n      await fetchStats();\n      return data;\n    } catch (error) {\n      console.error('[AutoHeal] Failed to detect issues:', error);\n      toast.error('Failed to analyze codebase');\n    } finally {\n      setIsRunning(false);\n    }\n  }, [evolution, fetchStats]);\n\n  // Generate fix for an issue\n  const generateFix = useCallback(async (issue: CodeIssue & { id: string }) => {\n    try {\n      const { data, error } = await supabase.functions.invoke('auto-heal-codebase', {\n        body: {\n          action: 'generate_fix',\n          fix_request: {\n            issue_id: issue.id,\n            file_path: issue.file_path,\n            issue_description: issue.description,\n            confidence: issue.confidence\n          }\n        }\n      });\n      \n      if (error) throw error;\n      \n      if (data.requires_manual_application) {\n        toast.info('Fix prompt generated - manual application required');\n      } else {\n        toast.success('AI fix generated successfully');\n      }\n      \n      await fetchStats();\n      return data;\n    } catch (error) {\n      console.error('[AutoHeal] Failed to generate fix:', error);\n      toast.error('Failed to generate fix');\n    }\n  }, [fetchStats]);\n\n  // Get pending high-confidence fixes\n  const getPendingFixes = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.functions.invoke('auto-heal-codebase', {\n        body: {\n          action: 'get_pending_fixes',\n          auto_apply_threshold: config.autoApplyThreshold\n        }\n      });\n      \n      if (error) throw error;\n      setPendingFixes(data.fixes || []);\n      return data.fixes;\n    } catch (error) {\n      console.error('[AutoHeal] Failed to get pending fixes:', error);\n    }\n  }, [config.autoApplyThreshold]);\n\n  // Apply a fix\n  const applyFix = useCallback(async (fixId: string, approvedBy?: string) => {\n    try {\n      const { data, error } = await supabase.functions.invoke('auto-heal-codebase', {\n        body: {\n          action: 'apply_fix',\n          fix_request: {\n            fix_id: fixId,\n            approved_by: approvedBy || 'manual'\n          }\n        }\n      });\n      \n      if (error) throw error;\n      \n      toast.success('Fix applied successfully');\n      \n      // Emit evolution event\n      await evolution.onCodeFixed({\n        file: 'auto-healed',\n        issue: 'Code issue',\n        resolution: 'Auto-applied fix'\n      });\n      \n      await fetchStats();\n      await getPendingFixes();\n      return data;\n    } catch (error) {\n      console.error('[AutoHeal] Failed to apply fix:', error);\n      toast.error('Failed to apply fix');\n    }\n  }, [evolution, fetchStats, getPendingFixes]);\n\n  // Auto-heal loop\n  const runAutoHealCycle = useCallback(async () => {\n    if (!config.enabled || isRunning) return;\n    \n    console.log('[AutoHeal] Running auto-heal cycle...');\n    \n    // Check for high-confidence fixes that can be auto-applied\n    const fixes = await getPendingFixes();\n    \n    if (fixes && fixes.length > 0) {\n      const toApply = fixes\n        .filter((f: PendingFix) => f.confidence >= config.autoApplyThreshold)\n        .slice(0, config.maxAutoFixesPerRun);\n      \n      for (const fix of toApply) {\n        console.log(`[AutoHeal] Auto-applying fix ${fix.id} (confidence: ${fix.confidence})`);\n        await applyFix(fix.id, 'auto-heal-system');\n      }\n      \n      if (toApply.length > 0) {\n        toast.success(`Auto-applied ${toApply.length} high-confidence fixes`);\n      }\n    }\n  }, [config.enabled, config.autoApplyThreshold, config.maxAutoFixesPerRun, isRunning, getPendingFixes, applyFix]);\n\n  // Start/stop auto-heal loop\n  useEffect(() => {\n    if (config.enabled) {\n      console.log('[AutoHeal] Starting auto-heal system...');\n      intervalRef.current = setInterval(runAutoHealCycle, config.scanIntervalMs);\n      runAutoHealCycle(); // Run immediately\n    } else {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    }\n    \n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, [config.enabled, config.scanIntervalMs, runAutoHealCycle]);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchStats();\n    getPendingFixes();\n  }, [fetchStats, getPendingFixes]);\n\n  return {\n    config,\n    setConfig,\n    stats,\n    isRunning,\n    lastScan,\n    pendingFixes,\n    detectIssues,\n    generateFix,\n    getPendingFixes,\n    applyFix,\n    fetchStats,\n    toggleEnabled: () => setConfig(c => ({ ...c, enabled: !c.enabled }))\n  };\n}\n";export{n as default};
