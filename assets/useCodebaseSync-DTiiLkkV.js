const e="/**\n * Codebase Synchronization Hook\n * \n * Ensures all code readers and analyzers evaluate the precise CURRENT state\n * with cache invalidation, version tracking, and future-state awareness.\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface CodebaseState {\n  version: string;\n  timestamp: Date;\n  fileCount: number;\n  totalLines: number;\n  lastModified: Date;\n  checksum: string;\n}\n\nexport interface SyncStatus {\n  isSynced: boolean;\n  isStale: boolean;\n  staleDuration: number; // seconds\n  pendingChanges: number;\n  lastSync: Date | null;\n  nextScheduledSync: Date | null;\n}\n\nexport interface FutureStateProjection {\n  predictedChanges: string[];\n  confidenceScore: number;\n  estimatedImpact: 'low' | 'medium' | 'high';\n  suggestedPreemptiveActions: string[];\n}\n\n// Generate a checksum from file content to detect changes\nfunction generateChecksum(content: string): string {\n  let hash = 0;\n  for (let i = 0; i < content.length; i++) {\n    const char = content.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36).toUpperCase();\n}\n\n// File cache with invalidation support\nconst fileCache = new Map<string, {\n  content: string;\n  timestamp: number;\n  version: number;\n}>();\n\n// Global version counter for cache invalidation\nlet globalVersion = 0;\n\nexport function useCodebaseSync() {\n  const [codebaseState, setCodebaseState] = useState<CodebaseState | null>(null);\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    isSynced: false,\n    isStale: false,\n    staleDuration: 0,\n    pendingChanges: 0,\n    lastSync: null,\n    nextScheduledSync: null\n  });\n  const [futureProjection, setFutureProjection] = useState<FutureStateProjection | null>(null);\n  \n  const syncIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const staleCheckRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Invalidate all cached files to force fresh reads\n  const invalidateCache = useCallback(() => {\n    globalVersion++;\n    fileCache.clear();\n    console.log('[CodebaseSync] Cache invalidated, version:', globalVersion);\n    \n    setSyncStatus(prev => ({\n      ...prev,\n      isStale: true,\n      pendingChanges: prev.pendingChanges + 1\n    }));\n  }, []);\n  \n  // Get fresh file content with cache-busting\n  const getFreshFileContent = useCallback(async (\n    path: string,\n    loader: () => Promise<string>\n  ): Promise<string> => {\n    const cached = fileCache.get(path);\n    \n    // Use cache only if version matches and within 5-second window\n    if (cached && cached.version === globalVersion && Date.now() - cached.timestamp < 5000) {\n      return cached.content;\n    }\n    \n    // Force fresh load\n    const content = await loader();\n    \n    fileCache.set(path, {\n      content,\n      timestamp: Date.now(),\n      version: globalVersion\n    });\n    \n    return content;\n  }, []);\n  \n  // Synchronize codebase state\n  const syncCodebaseState = useCallback(async (\n    files: Map<string, string>\n  ): Promise<CodebaseState> => {\n    const allContent = Array.from(files.values()).join('\\n');\n    const checksum = generateChecksum(allContent);\n    const totalLines = allContent.split('\\n').length;\n    \n    const state: CodebaseState = {\n      version: `v${globalVersion}.${Date.now().toString(36)}`,\n      timestamp: new Date(),\n      fileCount: files.size,\n      totalLines,\n      lastModified: new Date(),\n      checksum\n    };\n    \n    setCodebaseState(state);\n    setSyncStatus(prev => ({\n      ...prev,\n      isSynced: true,\n      isStale: false,\n      staleDuration: 0,\n      lastSync: new Date(),\n      nextScheduledSync: new Date(Date.now() + 60000)\n    }));\n    \n    return state;\n  }, []);\n  \n  // Analyze and project future state changes\n  const projectFutureState = useCallback((\n    currentIssues: Array<{ type: string; severity: string; file?: string }>\n  ): FutureStateProjection => {\n    const predictedChanges: string[] = [];\n    const suggestedPreemptiveActions: string[] = [];\n    \n    // Analyze current issues to predict future changes\n    const criticalIssues = currentIssues.filter(i => i.severity === 'critical' || i.severity === 'high');\n    const complexityIssues = currentIssues.filter(i => i.type === 'complexity-hotspot');\n    const densityIssues = currentIssues.filter(i => i.type === 'low-density');\n    \n    if (criticalIssues.length > 0) {\n      predictedChanges.push(`${criticalIssues.length} critical fixes will trigger cascade updates`);\n      suggestedPreemptiveActions.push('Address critical issues before other changes to prevent merge conflicts');\n    }\n    \n    if (complexityIssues.length > 0) {\n      predictedChanges.push(`${complexityIssues.length} files likely to be refactored into smaller modules`);\n      suggestedPreemptiveActions.push('Pre-create modular folder structure for complex files');\n    }\n    \n    if (densityIssues.length > 0) {\n      predictedChanges.push(`${densityIssues.length} files will receive En Pensent pattern integration`);\n      suggestedPreemptiveActions.push('Import core SDK types in low-density files');\n    }\n    \n    // Calculate confidence based on issue patterns\n    const confidenceScore = Math.min(0.95, 0.6 + (currentIssues.length * 0.05));\n    \n    // Estimate impact\n    const estimatedImpact = criticalIssues.length > 2 ? 'high' \n      : criticalIssues.length > 0 || complexityIssues.length > 1 ? 'medium' \n      : 'low';\n    \n    const projection: FutureStateProjection = {\n      predictedChanges,\n      confidenceScore,\n      estimatedImpact,\n      suggestedPreemptiveActions\n    };\n    \n    setFutureProjection(projection);\n    return projection;\n  }, []);\n  \n  // Register with evolution system\n  const registerWithEvolution = useCallback(async (\n    analysisResult: {\n      archetype: string;\n      intensity: number;\n      issues: number;\n      fingerprint: string;\n    }\n  ) => {\n    try {\n      await supabase.from('evolution_state').insert({\n        state_type: 'codebase_sync',\n        genes: {\n          archetype: analysisResult.archetype,\n          intensity: analysisResult.intensity,\n          issue_count: analysisResult.issues,\n          fingerprint: analysisResult.fingerprint,\n          global_version: globalVersion\n        },\n        generation: globalVersion,\n        fitness_score: analysisResult.intensity * 100,\n        last_mutation_at: new Date().toISOString()\n      } as any);\n      \n      console.log('[CodebaseSync] Registered with evolution system');\n    } catch (err) {\n      console.warn('[CodebaseSync] Evolution registration failed:', err);\n    }\n  }, []);\n  \n  // Check for staleness periodically\n  useEffect(() => {\n    staleCheckRef.current = setInterval(() => {\n      if (syncStatus.lastSync) {\n        const staleDuration = Math.floor((Date.now() - syncStatus.lastSync.getTime()) / 1000);\n        setSyncStatus(prev => ({\n          ...prev,\n          staleDuration,\n          isStale: staleDuration > 120 // Stale after 2 minutes\n        }));\n      }\n    }, 10000);\n    \n    return () => {\n      if (staleCheckRef.current) {\n        clearInterval(staleCheckRef.current);\n      }\n    };\n  }, [syncStatus.lastSync]);\n  \n  // Get global version for external consumers\n  const getGlobalVersion = useCallback(() => globalVersion, []);\n  \n  // Force a complete refresh\n  const forceRefresh = useCallback(() => {\n    invalidateCache();\n    return globalVersion;\n  }, [invalidateCache]);\n  \n  return {\n    codebaseState,\n    syncStatus,\n    futureProjection,\n    invalidateCache,\n    getFreshFileContent,\n    syncCodebaseState,\n    projectFutureState,\n    registerWithEvolution,\n    getGlobalVersion,\n    forceRefresh\n  };\n}\n\n// Export singleton for cross-component access\nexport const codebaseSyncManager = {\n  invalidateCache: () => {\n    globalVersion++;\n    fileCache.clear();\n  },\n  getVersion: () => globalVersion,\n  clearCache: () => fileCache.clear()\n};\n";export{e as default};
