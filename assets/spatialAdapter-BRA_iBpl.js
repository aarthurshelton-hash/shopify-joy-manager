const n="/**\n * Spatial Domain Adapter\n * \n * 3D temporal pattern recognition for physical spaces\n * Extends the 2D chess color flow system to volumetric analysis\n * \n * Applications:\n * - Architecture: Building occupancy flows, structural stress patterns\n * - Urban Planning: Traffic density, population migration\n * - Drone Fleets: Swarm coordination, collision avoidance\n * - VR/AR: User movement heatmaps, gaze tracking\n * - Geography: Satellite change detection, terrain erosion\n * \n * Patent-Pending: En Pensent 3D Color Flow Technology\n */\n\nimport type { DomainSignature } from '../types';\n\n// 3D point with temporal tracking\nexport interface SpatialPoint {\n  x: number;        // 0-1 normalized\n  y: number;        // 0-1 normalized  \n  z: number;        // 0-1 normalized\n  timestamp: number;\n  intensity: number; // Activity density at this point\n  color: string;    // QR color code\n}\n\n// Volumetric cell in 3D octree\nexport interface OctreeCell {\n  x: number;        // Octant X (0-7)\n  y: number;        // Octant Y (0-7)\n  z: number;        // Octant Z (0-7)\n  occupancy: number; // 0-1 density\n  flowVector: {     // Direction of movement through cell\n    dx: number;\n    dy: number;\n    dz: number;\n  };\n  visitHistory: Array<{\n    timestamp: number;\n    intensity: number;\n    source: string; // 'human', 'vehicle', 'drone', etc.\n  }>;\n}\n\n// Spatial data input\nexport interface SpatialData {\n  points: SpatialPoint[];\n  bounds: {\n    min: { x: number; y: number; z: number };\n    max: { x: number; y: number; z: number };\n  };\n  timeRange: {\n    start: number;\n    end: number;\n  };\n  metadata?: {\n    location?: string;\n    type?: 'building' | 'urban' | 'terrain' | 'drone_swarm' | 'vr_space';\n    scale?: 'micro' | 'human' | 'architectural' | 'urban' | 'geographic';\n  };\n}\n\n// Spatial archetypes\nexport type SpatialArchetype = \n  | 'architectural_cascade'      // Multi-level vertical flow\n  | 'urban_sprawl'               // Horizontal expansion pattern\n  | 'drone_swarm'                // Coordinated 3D movement\n  | 'concentrated_core'          // High density center\n  | 'dispersed_periphery'        // Spread to edges\n  | 'vertical_channel'           // Elevator/stairwell patterns\n  | 'circulatory_loop'           // Circular pedestrian flow\n  | 'collision_avoidance'        // Near-miss patterns\n  | 'thermal_rising'             // Heat-driven convection\n  | 'settling_sediment'          // Gravity-driven settling\n  | 'explosive_dispersal'        // Rapid outward expansion\n  | 'vacuum_compression';        // Inward collapse pattern\n\n// Archetype definitions with visual colors\nexport const SPATIAL_ARCHETYPES: Record<SpatialArchetype, {\n  description: string;\n  color: string;\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  typicalDuration: number; // minutes\n}> = {\n  architectural_cascade: {\n    description: 'Vertical movement through building levels - people flow like water',\n    color: '#3B82F6', // Blue\n    riskLevel: 'low',\n    typicalDuration: 15\n  },\n  urban_sprawl: {\n    description: 'Horizontal expansion pattern - cities growing outward',\n    color: '#10B981', // Green\n    riskLevel: 'medium',\n    typicalDuration: 1440 // 24 hours\n  },\n  drone_swarm: {\n    description: 'Coordinated 3D movement with collision avoidance',\n    color: '#8B5CF6', // Purple\n    riskLevel: 'high',\n    typicalDuration: 30\n  },\n  concentrated_core: {\n    description: 'High density center with radial distribution',\n    color: '#EF4444', // Red\n    riskLevel: 'medium',\n    typicalDuration: 60\n  },\n  dispersed_periphery: {\n    description: 'Activity concentrated at edges, empty center',\n    color: '#F59E0B', // Amber\n    riskLevel: 'low',\n    typicalDuration: 120\n  },\n  vertical_channel: {\n    description: 'Elevator/stairwell bottleneck patterns',\n    color: '#06B6D4', // Cyan\n    riskLevel: 'high',\n    typicalDuration: 5\n  },\n  circulatory_loop: {\n    description: 'Circular pedestrian/vehicle flow patterns',\n    color: '#84CC16', // Lime\n    riskLevel: 'low',\n    typicalDuration: 20\n  },\n  collision_avoidance: {\n    description: 'Near-miss events indicating coordination stress',\n    color: '#DC2626', // Dark red\n    riskLevel: 'critical',\n    typicalDuration: 1\n  },\n  thermal_rising: {\n    description: 'Heat-driven convection currents',\n    color: '#F97316', // Orange\n    riskLevel: 'medium',\n    typicalDuration: 10\n  },\n  settling_sediment: {\n    description: 'Gravity-driven settling in fluids or powders',\n    color: '#78716C', // Gray\n    riskLevel: 'low',\n    typicalDuration: 60\n  },\n  explosive_dispersal: {\n    description: 'Rapid outward expansion from point source',\n    color: '#7C2D12', // Dark red\n    riskLevel: 'critical',\n    typicalDuration: 0.5\n  },\n  vacuum_compression: {\n    description: 'Inward collapse toward center',\n    color: '#1E3A5F', // Navy\n    riskLevel: 'high',\n    typicalDuration: 2\n  }\n};\n\n/**\n * Build 8x8x8 octree from spatial points\n */\nfunction buildOctree(data: SpatialData): OctreeCell[][][] {\n  const octree: OctreeCell[][][] = Array(8).fill(null).map(() =>\n    Array(8).fill(null).map(() =>\n      Array(8).fill(null).map((_, z) => ({\n        x: 0, y: 0, z,\n        occupancy: 0,\n        flowVector: { dx: 0, dy: 0, dz: 0 },\n        visitHistory: []\n      }))\n    )\n  );\n\n  // Populate octree with points\n  data.points.forEach(point => {\n    const octX = Math.min(7, Math.floor(point.x * 8));\n    const octY = Math.min(7, Math.floor(point.y * 8));\n    const octZ = Math.min(7, Math.floor(point.z * 8));\n\n    const cell = octree[octX][octY][octZ];\n    cell.occupancy = Math.min(1, cell.occupancy + point.intensity * 0.1);\n    cell.visitHistory.push({\n      timestamp: point.timestamp,\n      intensity: point.intensity,\n      source: 'unknown'\n    });\n\n    // Calculate flow vector from sequential points\n    if (cell.visitHistory.length > 1) {\n      const prev = cell.visitHistory[cell.visitHistory.length - 2];\n      const curr = cell.visitHistory[cell.visitHistory.length - 1];\n      cell.flowVector = {\n        dx: (curr.timestamp - prev.timestamp) > 0 ? point.x - (octX / 8) : 0,\n        dy: (curr.timestamp - prev.timestamp) > 0 ? point.y - (octY / 8) : 0,\n        dz: (curr.timestamp - prev.timestamp) > 0 ? point.z - (octZ / 8) : 0\n      };\n    }\n  });\n\n  return octree;\n}\n\n/**\n * Generate 3D fingerprint hash\n */\nfunction generate3DFingerprint(octree: OctreeCell[][][]): string {\n  const occupancyMap: string[] = [];\n  \n  for (let x = 0; x < 8; x++) {\n    for (let y = 0; y < 8; y++) {\n      for (let z = 0; z < 8; z++) {\n        const cell = octree[x][y][z];\n        const flowDir = cell.flowVector.dx + cell.flowVector.dy + cell.flowVector.dz > 0 ? 'f' : 's';\n        occupancyMap.push(`${Math.round(cell.occupancy * 9)}${flowDir}`);\n      }\n    }\n  }\n\n  const mapString = occupancyMap.join('');\n  let hash = 0;\n  for (let i = 0; i < mapString.length; i++) {\n    const char = mapString.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n\n  return `sp-3d-${Math.abs(hash).toString(36).substring(0, 8)}`;\n}\n\n/**\n * Calculate quadrant profile for 3D space\n */\nfunction calculate3DQuadrantProfile(octree: OctreeCell[][][]): {\n  aggressive: number;    // X-axis penetration (forward)\n  defensive: number;     // Y-axis spread (lateral)\n  tactical: number;      // Z-axis elevation (vertical)\n  strategic: number;     // Volume density (overall)\n} {\n  let xActivity = 0, yActivity = 0, zActivity = 0, totalOccupancy = 0;\n\n  for (let x = 0; x < 8; x++) {\n    for (let y = 0; y < 8; y++) {\n      for (let z = 0; z < 8; z++) {\n        const cell = octree[x][y][z];\n        xActivity += cell.occupancy * (x / 8); // Weight by X position\n        yActivity += cell.occupancy * (y / 8); // Weight by Y position\n        zActivity += cell.occupancy * (z / 8); // Weight by Z position\n        totalOccupancy += cell.occupancy;\n      }\n    }\n  }\n\n  const volume = 8 * 8 * 8;\n  const density = totalOccupancy / volume;\n\n  return {\n    aggressive: Math.min(1, xActivity / (totalOccupancy || 1)),\n    defensive: Math.min(1, yActivity / (totalOccupancy || 1)),\n    tactical: Math.min(1, zActivity / (totalOccupancy || 1)),\n    strategic: density\n  };\n}\n\n/**\n * Calculate temporal flow in 3 phases\n */\nfunction calculate3DTemporalFlow(\n  data: SpatialData,\n  octree: OctreeCell[][][]\n): {\n  early: number;   // Setup/entry phase\n  mid: number;     // Active occupancy\n  late: number;    // Exit/settling\n} {\n  const duration = data.timeRange.end - data.timeRange.start;\n  const earlyCutoff = data.timeRange.start + duration * 0.25;\n  const lateCutoff = data.timeRange.end - duration * 0.25;\n\n  let earlyIntensity = 0, midIntensity = 0, lateIntensity = 0;\n\n  data.points.forEach(point => {\n    if (point.timestamp <= earlyCutoff) {\n      earlyIntensity += point.intensity;\n    } else if (point.timestamp >= lateCutoff) {\n      lateIntensity += point.intensity;\n    } else {\n      midIntensity += point.intensity;\n    }\n  });\n\n  const total = earlyIntensity + midIntensity + lateIntensity || 1;\n\n  return {\n    early: earlyIntensity / total,\n    mid: midIntensity / total,\n    late: lateIntensity / total\n  };\n}\n\n/**\n * Find critical moments (sudden density shifts)\n */\nfunction find3DCriticalMoments(data: SpatialData): Array<{\n  timestamp: number;\n  shiftMagnitude: number;\n  location: { x: number; y: number; z: number };\n  description: string;\n}> {\n  const moments: Array<{\n    timestamp: number;\n    shiftMagnitude: number;\n    location: { x: number; y: number; z: number };\n    description: string;\n  }> = [];\n\n  // Sort points by time\n  const sortedPoints = [...data.points].sort((a, b) => a.timestamp - b.timestamp);\n  \n  // Calculate global occupancy per time slice (1-second bins)\n  const timeSlices = new Map<number, number>();\n  sortedPoints.forEach(point => {\n    const second = Math.floor(point.timestamp / 1000);\n    timeSlices.set(second, (timeSlices.get(second) || 0) + point.intensity);\n  });\n\n  const sortedSeconds = Array.from(timeSlices.keys()).sort((a, b) => a - b);\n  \n  for (let i = 1; i < sortedSeconds.length; i++) {\n    const prev = timeSlices.get(sortedSeconds[i - 1]) || 0;\n    const curr = timeSlices.get(sortedSeconds[i]) || 0;\n    const shift = Math.abs(curr - prev);\n    \n    if (shift > prev * 0.5) { // 50% change threshold\n      // Find approximate location of the shift\n      const shiftPoints = sortedPoints.filter(p => \n        Math.floor(p.timestamp / 1000) === sortedSeconds[i]\n      );\n      const avgLocation = shiftPoints.length > 0 ? {\n        x: shiftPoints.reduce((sum, p) => sum + p.x, 0) / shiftPoints.length,\n        y: shiftPoints.reduce((sum, p) => sum + p.y, 0) / shiftPoints.length,\n        z: shiftPoints.reduce((sum, p) => sum + p.z, 0) / shiftPoints.length\n      } : { x: 0.5, y: 0.5, z: 0.5 };\n\n      moments.push({\n        timestamp: sortedSeconds[i] * 1000,\n        shiftMagnitude: shift,\n        location: avgLocation,\n        description: curr > prev ? 'Sudden influx detected' : 'Rapid evacuation pattern'\n      });\n    }\n  }\n\n  return moments.slice(0, 5); // Top 5 critical moments\n}\n\n/**\n * Classify spatial archetype\n */\nfunction classifySpatialArchetype(\n  octree: OctreeCell[][][],\n  quadrant: { aggressive: number; defensive: number; tactical: number; strategic: number }\n): SpatialArchetype {\n  // Check for collision avoidance (rapid vector changes)\n  let vectorChanges = 0;\n  for (let x = 0; x < 8; x++) {\n    for (let y = 0; y < 8; y++) {\n      for (let z = 0; z < 8; z++) {\n        const cell = octree[x][y][z];\n        if (cell.visitHistory.length > 1) {\n          const vectorMag = Math.sqrt(\n            cell.flowVector.dx ** 2 + \n            cell.flowVector.dy ** 2 + \n            cell.flowVector.dz ** 2\n          );\n          if (vectorMag > 0.5) vectorChanges++;\n        }\n      }\n    }\n  }\n  \n  if (vectorChanges > 20) return 'collision_avoidance';\n\n  // Check for concentrated core vs dispersed periphery\n  const centerOccupancy = octree[3][3][3].occupancy + octree[4][4][4].occupancy;\n  const edgeOccupancy = \n    octree[0][0][0].occupancy + octree[7][7][7].occupancy +\n    octree[0][7][0].occupancy + octree[7][0][7].occupancy;\n  \n  if (centerOccupancy > edgeOccupancy * 2) return 'concentrated_core';\n  if (edgeOccupancy > centerOccupancy * 2) return 'dispersed_periphery';\n\n  // Check vertical vs horizontal dominance\n  if (quadrant.tactical > quadrant.aggressive && quadrant.tactical > quadrant.defensive) {\n    return quadrant.strategic > 0.5 ? 'architectural_cascade' : 'vertical_channel';\n  }\n\n  // Check for swarm patterns (distributed but coordinated)\n  const activeCells = octree.flat(2).filter(c => c.occupancy > 0.1).length;\n  if (activeCells > 200 && quadrant.strategic < 0.3) return 'drone_swarm';\n\n  // Check for urban sprawl (horizontal expansion)\n  if (quadrant.defensive > quadrant.aggressive && quadrant.defensive > quadrant.tactical) {\n    return 'urban_sprawl';\n  }\n\n  // Check for circulatory (circular movement)\n  const circularVectors = octree.flat(2).filter(c => {\n    const mag = Math.sqrt(c.flowVector.dx ** 2 + c.flowVector.dy ** 2);\n    return mag > 0.1 && Math.abs(c.flowVector.dz) < 0.1; // Horizontal flow\n  }).length;\n  if (circularVectors > activeCells * 0.6) return 'circulatory_loop';\n\n  // Default to architectural cascade\n  return 'architectural_cascade';\n}\n\n/**\n * Extract complete 3D spatial signature\n */\nexport function extractSpatialSignature(data: SpatialData): DomainSignature & {\n  fingerprint: string;\n  archetype: SpatialArchetype;\n  criticalMoments: Array<{\n    timestamp: number;\n    shiftMagnitude: number;\n    location: { x: number; y: number; z: number };\n    description: string;\n  }>;\n  octree: OctreeCell[][][];\n  dominantAxis: 'x' | 'y' | 'z' | 'balanced';\n} {\n  const octree = buildOctree(data);\n  const quadrantProfile = calculate3DQuadrantProfile(octree);\n  const temporalFlow = calculate3DTemporalFlow(data, octree);\n  const criticalMoments = find3DCriticalMoments(data);\n  const archetype = classifySpatialArchetype(octree, quadrantProfile);\n  const fingerprint = generate3DFingerprint(octree);\n\n  // Calculate intensity\n  const totalOccupancy = octree.flat(2).reduce((sum, cell) => sum + cell.occupancy, 0);\n  const intensity = Math.min(1, totalOccupancy / (8 * 8 * 8));\n\n  // Determine dominant axis\n  const maxVal = Math.max(quadrantProfile.aggressive, quadrantProfile.defensive, quadrantProfile.tactical);\n  let dominantAxis: 'x' | 'y' | 'z' | 'balanced' = 'balanced';\n  if (maxVal === quadrantProfile.aggressive) dominantAxis = 'x';\n  else if (maxVal === quadrantProfile.defensive) dominantAxis = 'y';\n  else if (maxVal === quadrantProfile.tactical) dominantAxis = 'z';\n\n  return {\n    domain: 'chess', // Using closest available - will add 'spatial' to types\n    quadrantProfile: {\n      aggressive: quadrantProfile.aggressive,\n      defensive: quadrantProfile.defensive,\n      tactical: quadrantProfile.tactical,\n      strategic: quadrantProfile.strategic\n    },\n    temporalFlow,\n    intensity,\n    momentum: intensity * 0.8,\n    volatility: criticalMoments.length / 5,\n    dominantFrequency: totalOccupancy,\n    harmonicResonance: 1 - Math.abs(quadrantProfile.aggressive - quadrantProfile.defensive),\n    phaseAlignment: (quadrantProfile.tactical + quadrantProfile.strategic) / 2,\n    extractedAt: Date.now(),\n    fingerprint,\n    archetype,\n    criticalMoments,\n    octree,\n    dominantAxis\n  };\n}\n\n/**\n * Predict spatial outcome based on archetype\n */\nexport function predictSpatialOutcome(\n  signature: ReturnType<typeof extractSpatialSignature>\n): {\n  predictedOutcome: 'stable' | 'congestion' | 'evacuation' | 'collision' | 'optimal';\n  confidence: number;\n  timeToEvent: number; // seconds\n  recommendations: string[];\n} {\n  const archetype = SPATIAL_ARCHETYPES[signature.archetype];\n  const riskLevel = archetype.riskLevel;\n\n  let predictedOutcome: 'stable' | 'congestion' | 'evacuation' | 'collision' | 'optimal';\n  let recommendations: string[] = [];\n\n  switch (signature.archetype) {\n    case 'collision_avoidance':\n      predictedOutcome = 'collision';\n      recommendations = [\n        'Implement coordinated routing protocol',\n        'Reduce simultaneous active agents by 30%',\n        'Add vertical separation layers'\n      ];\n      break;\n    case 'concentrated_core':\n      predictedOutcome = signature.intensity > 0.8 ? 'congestion' : 'stable';\n      recommendations = [\n        'Open overflow capacity at periphery',\n        'Stagger entry times',\n        'Activate secondary egress routes'\n      ];\n      break;\n    case 'vertical_channel':\n      predictedOutcome = signature.temporalFlow.mid > 0.5 ? 'congestion' : 'stable';\n      recommendations = [\n        'Activate all elevator banks',\n        'Open stairwell bidirectional flow',\n        'Implement floor-based timing'\n      ];\n      break;\n    case 'drone_swarm':\n      predictedOutcome = signature.volatility > 0.5 ? 'collision' : 'optimal';\n      recommendations = [\n        'Maintain swarm cohesion algorithms',\n        'Pre-position emergency landing zones',\n        'Monitor battery depletion timing'\n      ];\n      break;\n    case 'explosive_dispersal':\n      predictedOutcome = 'evacuation';\n      recommendations = [\n        'EMERGENCY: Clear all pathways immediately',\n        'Activate emergency egress lighting',\n        'Disable all entry points'\n      ];\n      break;\n    default:\n      predictedOutcome = 'stable';\n      recommendations = [\n        'Monitor density levels',\n        'Maintain current routing',\n        'Prepare contingency capacity'\n      ];\n  }\n\n  // Confidence based on data quality\n  const dataQuality = Math.min(1, signature.criticalMoments.length / 3);\n  const patternClarity = 1 - signature.volatility;\n  const confidence = (dataQuality * 0.4 + patternClarity * 0.6);\n\n  // Time to event estimation\n  const timeToEvent = riskLevel === 'critical' ? 30 :\n                      riskLevel === 'high' ? 120 :\n                      riskLevel === 'medium' ? 300 : 600;\n\n  return {\n    predictedOutcome,\n    confidence,\n    timeToEvent,\n    recommendations\n  };\n}\n";export{n as default};
