const n="import React, { useMemo, useState, useEffect } from 'react';\nimport { Chess, Square, Move } from 'chess.js';\nimport { boardColors, getPieceColor, PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { \n  TemporalSignature, \n  QuadrantProfile, \n  TemporalFlow \n} from '@/lib/pensent-core/types';\nimport { classifyUniversalArchetype } from '@/lib/pensent-core/archetype';\n\ninterface SquareVisit {\n  piece: PieceType;\n  color: PieceColor;\n  moveNumber: number;\n  hexColor: string;\n}\n\ninterface SquareData {\n  file: number;\n  rank: number;\n  visits: SquareVisit[];\n  isLight: boolean;\n}\n\ninterface AnimatedVisualizationPreviewProps {\n  pgn: string;\n  size?: number;\n  className?: string;\n  animationSpeed?: number;\n}\n\nfunction squareToIndices(square: Square): { file: number; rank: number } {\n  const file = square.charCodeAt(0) - 'a'.charCodeAt(0);\n  const rank = parseInt(square[1]) - 1;\n  return { file, rank };\n}\n\nfunction getPathSquares(from: Square, to: Square, pieceType: string): Square[] {\n  const squares: Square[] = [];\n  const fromIndices = squareToIndices(from);\n  const toIndices = squareToIndices(to);\n\n  const fileDir = Math.sign(toIndices.file - fromIndices.file);\n  const rankDir = Math.sign(toIndices.rank - fromIndices.rank);\n\n  if (pieceType.toLowerCase() === 'n') {\n    squares.push(to);\n    return squares;\n  }\n\n  let currentFile = fromIndices.file + fileDir;\n  let currentRank = fromIndices.rank + rankDir;\n\n  while (currentFile !== toIndices.file || currentRank !== toIndices.rank) {\n    const file = String.fromCharCode('a'.charCodeAt(0) + currentFile);\n    const rank = (currentRank + 1).toString();\n    squares.push((file + rank) as Square);\n    currentFile += fileDir;\n    currentRank += rankDir;\n  }\n\n  squares.push(to);\n  return squares;\n}\n\nfunction parseMovesFromPgn(pgn: string): Move[] {\n  const chess = new Chess();\n  try {\n    chess.loadPgn(pgn);\n    return chess.history({ verbose: true });\n  } catch {\n    return [];\n  }\n}\n\n// Extract temporal signature from animation state\nfunction extractAnimationSignature(\n  board: SquareData[][],\n  currentMoveIndex: number,\n  totalMoves: number\n): TemporalSignature {\n  let q1 = 0, q2 = 0, q3 = 0, q4 = 0;\n  let totalVisits = 0;\n\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const visits = board[rank][file].visits.length;\n      totalVisits += visits;\n      \n      if (file < 4 && rank >= 4) q1 += visits;\n      else if (file >= 4 && rank >= 4) q2 += visits;\n      else if (file < 4 && rank < 4) q3 += visits;\n      else q4 += visits;\n    }\n  }\n\n  const normalize = (v: number) => Math.min(100, (v / Math.max(totalVisits, 1)) * 400);\n\n  const quadrantProfile: QuadrantProfile = {\n    q1: normalize(q1),\n    q2: normalize(q2),\n    q3: normalize(q3),\n    q4: normalize(q4),\n  };\n\n  const progress = totalMoves > 0 ? currentMoveIndex / totalMoves : 0;\n  const temporalFlow: TemporalFlow = {\n    opening: progress < 0.3 ? 0.8 : 0.3,\n    middle: progress >= 0.3 && progress < 0.7 ? 0.8 : 0.3,\n    ending: progress >= 0.7 ? 0.8 : 0.3,\n    trend: progress < 0.5 ? 'accelerating' : 'stable',\n    momentum: progress < 0.5 ? 0.5 : 0,\n  };\n\n  return {\n    fingerprint: `anim-${currentMoveIndex}-${totalMoves}`,\n    archetype: 'animated_preview',\n    quadrantProfile,\n    temporalFlow,\n    intensity: Math.min(1, (totalVisits / 64) * 0.5),\n    dominantForce: q1 + q2 > q3 + q4 ? 'primary' : 'secondary',\n    flowDirection: 'forward',\n    criticalMoments: [],\n  };\n}\n\nconst renderNestedSquares = (\n  visits: SquareVisit[],\n  x: number,\n  y: number,\n  squareSize: number,\n  baseColor: string\n): React.ReactNode[] => {\n  const elements: React.ReactNode[] = [];\n  const padding = squareSize * 0.08;\n\n  elements.push(\n    <rect\n      key={`base-${x}-${y}`}\n      x={x}\n      y={y}\n      width={squareSize}\n      height={squareSize}\n      fill={baseColor}\n    />\n  );\n\n  if (visits.length === 0) return elements;\n\n  const uniqueColors: string[] = [];\n  for (const visit of visits) {\n    if (!uniqueColors.includes(visit.hexColor)) {\n      uniqueColors.push(visit.hexColor);\n    }\n  }\n\n  const maxNesting = Math.min(uniqueColors.length, 6);\n  const layers: { color: string; layerSize: number }[] = [];\n\n  let currentSize = squareSize - padding * 2;\n  const sizeReduction = (currentSize * 0.7) / maxNesting;\n\n  for (let i = 0; i < maxNesting; i++) {\n    layers.push({ color: uniqueColors[i], layerSize: currentSize });\n    currentSize -= sizeReduction;\n    if (currentSize < squareSize * 0.1) break;\n  }\n\n  for (let i = 0; i < layers.length; i++) {\n    const layer = layers[i];\n    const offset = (squareSize - layer.layerSize) / 2;\n\n    elements.push(\n      <rect\n        key={`layer-${x}-${y}-${i}`}\n        x={x + offset}\n        y={y + offset}\n        width={layer.layerSize}\n        height={layer.layerSize}\n        fill={layer.color}\n        style={{\n          transition: 'all 0.15s ease-out',\n        }}\n      />\n    );\n  }\n\n  return elements;\n};\n\nconst AnimatedVisualizationPreview: React.FC<AnimatedVisualizationPreviewProps> = ({\n  pgn,\n  size = 300,\n  className = '',\n  animationSpeed = 150,\n}) => {\n  const moves = useMemo(() => parseMovesFromPgn(pgn), [pgn]);\n  const [currentMoveIndex, setCurrentMoveIndex] = useState(0);\n\n  useEffect(() => {\n    if (moves.length === 0) return;\n\n    const interval = setInterval(() => {\n      setCurrentMoveIndex((prev) => {\n        if (prev >= moves.length) {\n          return 0;\n        }\n        return prev + 1;\n      });\n    }, animationSpeed);\n\n    return () => clearInterval(interval);\n  }, [moves.length, animationSpeed]);\n\n  const board = useMemo(() => {\n    const boardState: SquareData[][] = [];\n    for (let rank = 0; rank < 8; rank++) {\n      boardState[rank] = [];\n      for (let file = 0; file < 8; file++) {\n        const isLight = (rank + file) % 2 === 1;\n        boardState[rank][file] = {\n          file,\n          rank,\n          visits: [],\n          isLight,\n        };\n      }\n    }\n\n    for (let i = 0; i < Math.min(currentMoveIndex, moves.length); i++) {\n      const move = moves[i];\n      const pieceType = move.piece as PieceType;\n      const pieceColor = move.color as PieceColor;\n      const hexColor = getPieceColor(pieceType, pieceColor);\n\n      const pathSquares = getPathSquares(move.from, move.to, move.piece);\n\n      for (const square of pathSquares) {\n        const { file, rank } = squareToIndices(square);\n        boardState[rank][file].visits.push({\n          piece: pieceType,\n          color: pieceColor,\n          moveNumber: i + 1,\n          hexColor,\n        });\n      }\n    }\n\n    return boardState;\n  }, [currentMoveIndex, moves]);\n\n  // Extract En Pensent signature for current animation state\n  const { archetype } = useMemo(() => {\n    const sig = extractAnimationSignature(board, currentMoveIndex, moves.length);\n    const arch = classifyUniversalArchetype(sig);\n    return { signature: sig, archetype: arch };\n  }, [board, currentMoveIndex, moves.length]);\n\n  const squareSize = size / 8;\n  const borderWidth = size * 0.02;\n  const totalSize = size + borderWidth * 2;\n\n  const boardElements = useMemo(() => {\n    return [...Array(8)].map((_, rowIndex) => {\n      const rank = 7 - rowIndex;\n      return [...Array(8)].map((_, file) => {\n        const square = board[rank][file];\n        const baseColor = square.isLight ? boardColors.light : boardColors.dark;\n        const x = borderWidth + file * squareSize;\n        const y = borderWidth + rowIndex * squareSize;\n\n        return renderNestedSquares(\n          square.visits,\n          x,\n          y,\n          squareSize,\n          baseColor\n        );\n      });\n    });\n  }, [board, borderWidth, squareSize]);\n\n  return (\n    <svg\n      width={totalSize}\n      height={totalSize}\n      viewBox={`0 0 ${totalSize} ${totalSize}`}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={className}\n      style={{ display: 'block' }}\n      data-archetype={archetype}\n      data-move={currentMoveIndex}\n    >\n      <rect\n        x={0}\n        y={0}\n        width={totalSize}\n        height={totalSize}\n        fill={boardColors.border}\n      />\n      {boardElements}\n    </svg>\n  );\n};\n\nexport default AnimatedVisualizationPreview;\n";export{n as default};
