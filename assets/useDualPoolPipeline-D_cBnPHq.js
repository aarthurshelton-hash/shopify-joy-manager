const n="/**\n * React Hook for Dual-Pool Benchmark Pipeline\n * \n * Provides easy integration of the dual-pool system:\n * - CLOUD-VOLUME: 100+ games/hour via Lichess Cloud API\n * - LOCAL-DEEP: 5 games/hour with Stockfish D30\n */\n\nimport { useState, useCallback, useRef } from 'react';\nimport { \n  runDualPoolPipeline,\n  runCloudPoolBatch,\n  runLocalPoolBatch,\n  savePoolPredictions,\n  type PoolPrediction,\n  type PoolProgress,\n  type DualPoolResult,\n  CLOUD_POOL_CONFIG,\n  LOCAL_POOL_CONFIG,\n} from '@/lib/chess/dualPoolPipeline';\n\nexport interface UseDualPoolReturn {\n  // State\n  isRunning: boolean;\n  cloudProgress: PoolProgress | null;\n  localProgress: PoolProgress | null;\n  lastResult: DualPoolResult | null;\n  error: string | null;\n  \n  // Actions\n  runFullPipeline: (options?: {\n    cloudTarget?: number;\n    localTarget?: number;\n    runCloud?: boolean;\n    runLocal?: boolean;\n  }) => Promise<DualPoolResult | null>;\n  \n  runCloudOnly: (target?: number) => Promise<PoolPrediction[]>;\n  runLocalOnly: (target?: number) => Promise<PoolPrediction[]>;\n  \n  stopPipeline: () => void;\n  \n  // Stats\n  estimatedCloudTime: string;\n  estimatedLocalTime: string;\n}\n\nexport function useDualPoolPipeline(): UseDualPoolReturn {\n  const [isRunning, setIsRunning] = useState(false);\n  const [cloudProgress, setCloudProgress] = useState<PoolProgress | null>(null);\n  const [localProgress, setLocalProgress] = useState<PoolProgress | null>(null);\n  const [lastResult, setLastResult] = useState<DualPoolResult | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  \n  const abortRef = useRef(false);\n  const batchRef = useRef(0);\n  \n  const runFullPipeline = useCallback(async (options?: {\n    cloudTarget?: number;\n    localTarget?: number;\n    runCloud?: boolean;\n    runLocal?: boolean;\n  }): Promise<DualPoolResult | null> => {\n    if (isRunning) {\n      setError('Pipeline already running');\n      return null;\n    }\n    \n    setIsRunning(true);\n    setError(null);\n    abortRef.current = false;\n    batchRef.current++;\n    \n    try {\n      const result = await runDualPoolPipeline(\n        options,\n        (status, cloud, local) => {\n          if (!abortRef.current) {\n            setCloudProgress(cloud);\n            setLocalProgress(local);\n          }\n        }\n      );\n      \n      setLastResult(result);\n      return result;\n      \n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Pipeline failed';\n      setError(message);\n      return null;\n      \n    } finally {\n      setIsRunning(false);\n    }\n  }, [isRunning]);\n  \n  const runCloudOnly = useCallback(async (target: number = 100): Promise<PoolPrediction[]> => {\n    if (isRunning) {\n      setError('Pipeline already running');\n      return [];\n    }\n    \n    setIsRunning(true);\n    setError(null);\n    abortRef.current = false;\n    batchRef.current++;\n    \n    try {\n      const predictions = await runCloudPoolBatch(\n        target,\n        batchRef.current,\n        (status, progress) => {\n          if (!abortRef.current) {\n            setCloudProgress({\n              poolName: 'CLOUD-VOLUME',\n              completed: 0,\n              target,\n              gamesPerHour: 100,\n              lastGameTime: Date.now(),\n              status: 'running',\n            });\n          }\n        }\n      );\n      \n      // Save predictions\n      await savePoolPredictions(predictions, 'CLOUD-VOLUME');\n      \n      return predictions;\n      \n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Cloud pool failed';\n      setError(message);\n      return [];\n      \n    } finally {\n      setIsRunning(false);\n    }\n  }, [isRunning]);\n  \n  const runLocalOnly = useCallback(async (target: number = 5): Promise<PoolPrediction[]> => {\n    if (isRunning) {\n      setError('Pipeline already running');\n      return [];\n    }\n    \n    setIsRunning(true);\n    setError(null);\n    abortRef.current = false;\n    batchRef.current++;\n    \n    try {\n      const predictions = await runLocalPoolBatch(\n        target,\n        batchRef.current,\n        (status, progress) => {\n          if (!abortRef.current) {\n            setLocalProgress({\n              poolName: 'LOCAL-DEEP',\n              completed: 0,\n              target,\n              gamesPerHour: 5,\n              lastGameTime: Date.now(),\n              status: 'running',\n            });\n          }\n        }\n      );\n      \n      // Save predictions\n      await savePoolPredictions(predictions, 'LOCAL-DEEP');\n      \n      return predictions;\n      \n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Local pool failed';\n      setError(message);\n      return [];\n      \n    } finally {\n      setIsRunning(false);\n    }\n  }, [isRunning]);\n  \n  const stopPipeline = useCallback(() => {\n    abortRef.current = true;\n    setIsRunning(false);\n  }, []);\n  \n  // Calculate estimated times based on targets\n  const estimatedCloudTime = `~${Math.ceil((cloudProgress?.target || 100) / CLOUD_POOL_CONFIG.targetPerHour * 60)} min`;\n  const estimatedLocalTime = `~${Math.ceil((localProgress?.target || 5) / LOCAL_POOL_CONFIG.targetPerHour * 60)} min`;\n  \n  return {\n    isRunning,\n    cloudProgress,\n    localProgress,\n    lastResult,\n    error,\n    runFullPipeline,\n    runCloudOnly,\n    runLocalOnly,\n    stopPipeline,\n    estimatedCloudTime,\n    estimatedLocalTime,\n  };\n}\n\nexport default useDualPoolPipeline;\n";export{n as default};
