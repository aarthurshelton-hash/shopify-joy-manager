const n="/**\n * Fractal Time Compression\n * \n * Detects self-similar patterns at different timescales (minutes, hours, days, weeks).\n * Markets are fractal - patterns that appear on 5-minute charts often mirror\n * patterns on daily charts, just compressed/expanded in time.\n */\n\ninterface FractalPattern {\n  id: string;\n  signature: number[];\n  timescale: 'minute' | 'hour' | 'day' | 'week';\n  startIndex: number;\n  endIndex: number;\n  similarity: number;\n  predictedContinuation: number[];\n}\n\ninterface TimescalePattern {\n  timescale: 'minute' | 'hour' | 'day' | 'week';\n  patterns: FractalPattern[];\n  dominantPattern: FractalPattern | null;\n  coherence: number; // How consistent patterns are within this timescale\n}\n\ninterface FractalState {\n  timescalePatterns: TimescalePattern[];\n  crossTimescaleCoherence: number;\n  activeFractals: FractalPattern[];\n  predictionConfidence: number;\n  suggestedDirection: 'up' | 'down' | 'neutral';\n}\n\nclass FractalTimeCompressor {\n  private patternLibrary: Map<string, FractalPattern[]> = new Map();\n  private readonly minPatternLength = 5;\n  private readonly similarityThreshold = 0.7;\n  private readonly regularizationFactor = 0.9;\n  private outcomeHistory: Array<{ patternId: string; wasCorrect: boolean }> = [];\n  \n  /**\n   * Analyze data at multiple timescales to find fractal patterns\n   */\n  analyzeFractals(\n    minuteData: number[],\n    hourData: number[],\n    dayData: number[],\n    weekData: number[]\n  ): FractalState {\n    const timescalePatterns: TimescalePattern[] = [\n      this.analyzeTimescale(minuteData, 'minute'),\n      this.analyzeTimescale(hourData, 'hour'),\n      this.analyzeTimescale(dayData, 'day'),\n      this.analyzeTimescale(weekData, 'week'),\n    ];\n    \n    // Find cross-timescale similarities\n    const activeFractals = this.findCrossTimescalePatterns(timescalePatterns);\n    \n    // Calculate cross-timescale coherence\n    const crossTimescaleCoherence = this.calculateCrossTimescaleCoherence(timescalePatterns);\n    \n    // Generate prediction based on fractal alignment\n    const prediction = this.generatePrediction(activeFractals, crossTimescaleCoherence);\n    \n    return {\n      timescalePatterns,\n      crossTimescaleCoherence,\n      activeFractals,\n      predictionConfidence: prediction.confidence * this.regularizationFactor,\n      suggestedDirection: prediction.direction,\n    };\n  }\n  \n  /**\n   * Analyze patterns within a single timescale\n   */\n  private analyzeTimescale(data: number[], timescale: 'minute' | 'hour' | 'day' | 'week'): TimescalePattern {\n    if (data.length < this.minPatternLength * 2) {\n      return { timescale, patterns: [], dominantPattern: null, coherence: 0 };\n    }\n    \n    const patterns: FractalPattern[] = [];\n    const normalized = this.normalizeData(data);\n    \n    // Look for repeating patterns using sliding window\n    for (let windowSize = this.minPatternLength; windowSize <= Math.min(20, data.length / 2); windowSize++) {\n      const recentWindow = normalized.slice(-windowSize);\n      \n      // Search for similar patterns in history\n      for (let i = 0; i < normalized.length - windowSize * 2; i++) {\n        const historicalWindow = normalized.slice(i, i + windowSize);\n        const similarity = this.calculateSimilarity(recentWindow, historicalWindow);\n        \n        if (similarity > this.similarityThreshold) {\n          // Found a matching pattern - what came after?\n          const continuation = normalized.slice(i + windowSize, i + windowSize * 2);\n          \n          patterns.push({\n            id: `${timescale}_${i}_${windowSize}`,\n            signature: historicalWindow,\n            timescale,\n            startIndex: i,\n            endIndex: i + windowSize,\n            similarity,\n            predictedContinuation: continuation,\n          });\n        }\n      }\n    }\n    \n    // Find dominant pattern (highest similarity with most occurrences)\n    const patternGroups = this.groupSimilarPatterns(patterns);\n    let dominantPattern: FractalPattern | null = null;\n    let maxScore = 0;\n    \n    for (const group of patternGroups) {\n      const avgSimilarity = group.reduce((sum, p) => sum + p.similarity, 0) / group.length;\n      const score = avgSimilarity * Math.sqrt(group.length);\n      if (score > maxScore) {\n        maxScore = score;\n        dominantPattern = group[0];\n      }\n    }\n    \n    // Calculate pattern coherence within timescale\n    const coherence = patterns.length > 0\n      ? patterns.reduce((sum, p) => sum + p.similarity, 0) / patterns.length\n      : 0;\n    \n    return { timescale, patterns, dominantPattern, coherence };\n  }\n  \n  /**\n   * Normalize data to -1 to 1 range for comparison\n   */\n  private normalizeData(data: number[]): number[] {\n    if (data.length === 0) return [];\n    \n    const min = Math.min(...data);\n    const max = Math.max(...data);\n    const range = max - min;\n    \n    if (range === 0) return data.map(() => 0);\n    return data.map(v => ((v - min) / range) * 2 - 1);\n  }\n  \n  /**\n   * Calculate similarity between two patterns using DTW-inspired approach\n   */\n  private calculateSimilarity(pattern1: number[], pattern2: number[]): number {\n    if (pattern1.length === 0 || pattern2.length === 0) return 0;\n    \n    // Simple correlation coefficient\n    const n = Math.min(pattern1.length, pattern2.length);\n    let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;\n    \n    for (let i = 0; i < n; i++) {\n      sumXY += pattern1[i] * pattern2[i];\n      sumX += pattern1[i];\n      sumY += pattern2[i];\n      sumX2 += pattern1[i] * pattern1[i];\n      sumY2 += pattern2[i] * pattern2[i];\n    }\n    \n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n    \n    if (denominator === 0) return 0;\n    \n    // Map correlation (-1 to 1) to similarity (0 to 1)\n    return (numerator / denominator + 1) / 2;\n  }\n  \n  /**\n   * Group similar patterns together\n   */\n  private groupSimilarPatterns(patterns: FractalPattern[]): FractalPattern[][] {\n    const groups: FractalPattern[][] = [];\n    const used = new Set<number>();\n    \n    for (let i = 0; i < patterns.length; i++) {\n      if (used.has(i)) continue;\n      \n      const group = [patterns[i]];\n      used.add(i);\n      \n      for (let j = i + 1; j < patterns.length; j++) {\n        if (used.has(j)) continue;\n        \n        const sim = this.calculateSimilarity(patterns[i].signature, patterns[j].signature);\n        if (sim > 0.8) {\n          group.push(patterns[j]);\n          used.add(j);\n        }\n      }\n      \n      groups.push(group);\n    }\n    \n    return groups;\n  }\n  \n  /**\n   * Find patterns that appear across multiple timescales\n   */\n  private findCrossTimescalePatterns(timescalePatterns: TimescalePattern[]): FractalPattern[] {\n    const crossTimescalePatterns: FractalPattern[] = [];\n    \n    // Compare dominant patterns across timescales\n    const dominants = timescalePatterns\n      .filter(tp => tp.dominantPattern !== null)\n      .map(tp => tp.dominantPattern!);\n    \n    for (let i = 0; i < dominants.length; i++) {\n      for (let j = i + 1; j < dominants.length; j++) {\n        // Resample to same length for comparison\n        const resampled1 = this.resample(dominants[i].signature, 20);\n        const resampled2 = this.resample(dominants[j].signature, 20);\n        \n        const similarity = this.calculateSimilarity(resampled1, resampled2);\n        \n        if (similarity > this.similarityThreshold) {\n          // Found a fractal! Same pattern at different timescales\n          crossTimescalePatterns.push({\n            ...dominants[i],\n            similarity,\n            id: `fractal_${dominants[i].timescale}_${dominants[j].timescale}`,\n          });\n        }\n      }\n    }\n    \n    return crossTimescalePatterns;\n  }\n  \n  /**\n   * Resample pattern to target length\n   */\n  private resample(data: number[], targetLength: number): number[] {\n    if (data.length === targetLength) return data;\n    if (data.length === 0) return new Array(targetLength).fill(0);\n    \n    const result: number[] = [];\n    const ratio = (data.length - 1) / (targetLength - 1);\n    \n    for (let i = 0; i < targetLength; i++) {\n      const srcIndex = i * ratio;\n      const lower = Math.floor(srcIndex);\n      const upper = Math.min(lower + 1, data.length - 1);\n      const fraction = srcIndex - lower;\n      \n      result.push(data[lower] * (1 - fraction) + data[upper] * fraction);\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Calculate coherence across timescales\n   */\n  private calculateCrossTimescaleCoherence(timescalePatterns: TimescalePattern[]): number {\n    const coherences = timescalePatterns.map(tp => tp.coherence).filter(c => c > 0);\n    if (coherences.length === 0) return 0;\n    \n    // Average coherence across timescales\n    const avgCoherence = coherences.reduce((a, b) => a + b, 0) / coherences.length;\n    \n    // Bonus for having patterns at multiple timescales\n    const timescaleBonus = coherences.length / 4;\n    \n    return Math.min(1, avgCoherence * (1 + timescaleBonus * 0.2));\n  }\n  \n  /**\n   * Generate prediction based on fractal patterns\n   */\n  private generatePrediction(\n    activeFractals: FractalPattern[],\n    coherence: number\n  ): { direction: 'up' | 'down' | 'neutral'; confidence: number } {\n    if (activeFractals.length === 0 || coherence < 0.3) {\n      return { direction: 'neutral', confidence: 0.3 };\n    }\n    \n    // Average predicted continuation direction\n    let upVotes = 0;\n    let downVotes = 0;\n    \n    for (const fractal of activeFractals) {\n      if (fractal.predictedContinuation.length > 0) {\n        const trend = this.calculateTrend(fractal.predictedContinuation);\n        if (trend > 0.05) upVotes += fractal.similarity;\n        else if (trend < -0.05) downVotes += fractal.similarity;\n      }\n    }\n    \n    const total = upVotes + downVotes;\n    if (total < 0.1) {\n      return { direction: 'neutral', confidence: 0.3 };\n    }\n    \n    const confidence = Math.min(0.85, coherence * (Math.abs(upVotes - downVotes) / total));\n    \n    return {\n      direction: upVotes > downVotes ? 'up' : 'down',\n      confidence,\n    };\n  }\n  \n  /**\n   * Calculate trend from data points\n   */\n  private calculateTrend(data: number[]): number {\n    if (data.length < 2) return 0;\n    \n    const first = data.slice(0, Math.ceil(data.length / 2));\n    const second = data.slice(Math.ceil(data.length / 2));\n    \n    const firstAvg = first.reduce((a, b) => a + b, 0) / first.length;\n    const secondAvg = second.reduce((a, b) => a + b, 0) / second.length;\n    \n    return secondAvg - firstAvg;\n  }\n  \n  /**\n   * Record outcome for learning\n   */\n  recordOutcome(patternId: string, wasCorrect: boolean): void {\n    this.outcomeHistory.push({ patternId, wasCorrect });\n    if (this.outcomeHistory.length > 500) {\n      this.outcomeHistory.shift();\n    }\n  }\n  \n  /**\n   * Get overall accuracy\n   */\n  getAccuracy(): number {\n    if (this.outcomeHistory.length < 10) return 0.5;\n    const correct = this.outcomeHistory.filter(o => o.wasCorrect).length;\n    return correct / this.outcomeHistory.length;\n  }\n  \n  /**\n   * Get confidence modifier based on fractal coherence\n   */\n  getConfidenceModifier(coherence: number): number {\n    const baseModifier = 0.9 + coherence * 0.2;\n    const accuracyModifier = 0.8 + this.getAccuracy() * 0.4;\n    return baseModifier * accuracyModifier * this.regularizationFactor;\n  }\n}\n\nexport const fractalTimeCompressor = new FractalTimeCompressor();\nexport type { FractalPattern, TimescalePattern, FractalState };\n";export{n as default};
