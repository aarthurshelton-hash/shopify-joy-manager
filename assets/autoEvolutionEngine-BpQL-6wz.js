const n="/**\n * Auto-Evolution Engine v7.13-COORDINATOR-AWARE\n * \n * PHILOSOPHY: The system NEVER stops. Uses LOCAL Stockfish only (no API dependencies).\n * \n * v7.13 CRITICAL FIXES:\n * - Checks isManualBenchmarkActive() BEFORE starting any batch\n * - Yields to manual benchmarks immediately\n * - Subscribes to lock changes for instant pause/resume\n * \n * v7.0 CRITICAL FIXES:\n * - All async operations have hard timeouts to prevent infinite hangs\n * - Abort controller pattern for cancelable batches\n * - Self-healing with exponential backoff\n * - Defensive Promise.race on EVERY external call\n * \n * ARCHITECTURE:\n * - LOCAL Stockfish is the ONLY analysis source (guaranteed to work)\n * - No cloud API dependencies - pipeline works offline\n * - Self-healing error recovery\n * - Automatic restart on any failure\n * - Incremental persistence (never lose data)\n */\n\nconst AUTO_EVOLUTION_VERSION = \"8.03-RECALIBRATED\";\nconsole.log(`[v8.03] autoEvolutionEngine.ts LOADED - Version: ${AUTO_EVOLUTION_VERSION}`);\n\nimport { \n  runCloudPoolBatch, \n  runLocalPoolBatch, \n  savePoolPredictions,\n  type PoolPrediction,\n  type PoolProgress,\n  CLOUD_POOL_CONFIG,\n  LOCAL_POOL_CONFIG,\n} from './dualPoolPipeline';\nimport { supabase } from '@/integrations/supabase/client';\nimport { getStockfishEngine, terminateStockfish } from './stockfishEngine';\nimport { isManualBenchmarkActive, subscribeToBenchmarkLock } from './benchmarkCoordinator';\n\n// ================ ENGINE STATE ================\n\nexport interface EvolutionState {\n  isRunning: boolean;\n  isPaused: boolean;\n  \n  // Lifetime stats\n  totalPredictions: number;\n  totalCloudPredictions: number;\n  totalLocalPredictions: number;\n  \n  // Current session\n  sessionStartedAt: Date | null;\n  sessionPredictions: number;\n  \n  // Health\n  consecutiveErrors: number;\n  lastErrorAt: Date | null;\n  lastSuccessAt: Date | null;\n  recoveryCount: number;\n  \n  // Pool status\n  cloudPoolStatus: 'idle' | 'running' | 'error' | 'recovering';\n  localPoolStatus: 'idle' | 'running' | 'error' | 'recovering';\n  \n  // Current batch\n  currentBatchNumber: number;\n  batchStartedAt: Date | null;\n}\n\ninterface EvolutionConfig {\n  cloudBatchSize: number;       // Games per volume batch\n  localBatchSize: number;       // Games per deep batch\n  cloudBatchIntervalMs: number; // Time between volume batches\n  localBatchIntervalMs: number; // Time between deep batches\n  maxConsecutiveErrors: number; // Before full recovery\n  recoveryDelayMs: number;      // Wait after error\n  healthCheckIntervalMs: number; // Check engine health\n}\n\n// v7.95-ZERO-PAUSE: Optimized intervals for continuous throughput\nconst DEFAULT_CONFIG: EvolutionConfig = {\n  cloudBatchSize: 5,               // 5 games per volume batch\n  localBatchSize: 1,               // 1 game per deep batch\n  cloudBatchIntervalMs: 10 * 1000,       // v7.95: 10s between volume batches (was 15s)\n  localBatchIntervalMs: 45 * 1000,       // v7.95: 45s between deep batches (was 60s)\n  maxConsecutiveErrors: 3,         // Allow 3 errors before recovery\n  recoveryDelayMs: 500,            // v7.95: 500ms recovery delay (was 2s)\n  healthCheckIntervalMs: 120 * 1000,     // v7.95: 2 min health checks (less frequent)\n};\n\n// v7.0: Hard timeout for any batch operation\nconst BATCH_TIMEOUT_MS = 90000; // 90 seconds max per batch\n\n// Singleton state\nconst engineState: EvolutionState = {\n  isRunning: false,\n  isPaused: false,\n  totalPredictions: 0,\n  totalCloudPredictions: 0,\n  totalLocalPredictions: 0,\n  sessionStartedAt: null,\n  sessionPredictions: 0,\n  consecutiveErrors: 0,\n  lastErrorAt: null,\n  lastSuccessAt: null,\n  recoveryCount: 0,\n  cloudPoolStatus: 'idle',\n  localPoolStatus: 'idle',\n  currentBatchNumber: 0,\n  batchStartedAt: null,\n};\n\n// Timer handles\nlet cloudBatchTimer: NodeJS.Timeout | null = null;\nlet localBatchTimer: NodeJS.Timeout | null = null;\nlet healthCheckTimer: NodeJS.Timeout | null = null;\n\n// Event listeners\ntype EvolutionListener = (state: EvolutionState, event: string, data?: any) => void;\nconst listeners: Set<EvolutionListener> = new Set();\n\n// ================ EVENT SYSTEM ================\n\nexport function subscribeToEvolution(listener: EvolutionListener): () => void {\n  listeners.add(listener);\n  return () => listeners.delete(listener);\n}\n\nfunction emitEvent(event: string, data?: any) {\n  listeners.forEach(listener => {\n    try {\n      listener({ ...engineState }, event, data);\n    } catch (err) {\n      console.error('[v6.93] Listener error:', err);\n    }\n  });\n}\n\n// ================ PERSISTENCE ================\n\n// v8.01-SMOOTH: Mutex to prevent concurrent persistence attempts\nlet persistenceMutex = false;\n\nasync function persistEvolutionState() {\n  // v8.01: Skip if already persisting (prevents duplicate key race condition)\n  if (persistenceMutex) {\n    return;\n  }\n  \n  persistenceMutex = true;\n  \n  try {\n    const payload = {\n      state_type: 'auto_evolution_engine',\n      genes: {\n        version: AUTO_EVOLUTION_VERSION,\n        total_predictions: engineState.totalPredictions,\n        total_cloud: engineState.totalCloudPredictions,\n        total_local: engineState.totalLocalPredictions,\n        recovery_count: engineState.recoveryCount,\n        consecutive_errors: engineState.consecutiveErrors,\n      },\n      fitness_score: engineState.consecutiveErrors === 0 ? 1 : \n        Math.max(0, 1 - engineState.consecutiveErrors * 0.2),\n      generation: engineState.currentBatchNumber,\n      last_mutation_at: new Date().toISOString(),\n    };\n    \n    // v8.01-SMOOTH: Use upsert with onConflict to prevent duplicate key errors\n    const { error } = await supabase\n      .from('evolution_state')\n      .upsert(payload, { \n        onConflict: 'state_type',\n        ignoreDuplicates: false  // We want to update, not skip\n      });\n    \n    if (error) {\n      // Only log if it's not a constraint error (those are expected during race conditions)\n      if (!error.message.includes('duplicate key') && !error.message.includes('unique constraint')) {\n        console.warn('[v8.01] State persistence warning:', error.message);\n      }\n    }\n  } catch (err) {\n    console.error('[v8.01] State persistence failed:', err);\n  } finally {\n    persistenceMutex = false;\n  }\n}\n\nasync function loadPreviousStats(): Promise<void> {\n  try {\n    // v7.22: Load REAL total prediction count from database\n    const { count: totalCount } = await supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true });\n    \n    if (totalCount) {\n      engineState.totalPredictions = totalCount;\n    }\n    \n    // v7.22: Load REAL pool-specific counts from database\n    // Volume pool = D18 depth (VOLUME-LOCAL, cloud batches)\n    const { count: volumeCount } = await supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .gte('stockfish_depth', 15)\n      .lte('stockfish_depth', 22);\n    \n    if (volumeCount) {\n      engineState.totalCloudPredictions = volumeCount;\n    }\n    \n    // Deep pool = D30+ depth (LOCAL-DEEP, local batches)\n    const { count: deepCount } = await supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .gte('stockfish_depth', 25);\n    \n    if (deepCount) {\n      engineState.totalLocalPredictions = deepCount;\n    }\n    \n    // Load evolution state\n    const { data } = await supabase\n      .from('evolution_state')\n      .select('*')\n      .eq('state_type', 'auto_evolution_engine')\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .maybeSingle();\n    \n    if (data?.genes) {\n      const genes = data.genes as any;\n      engineState.currentBatchNumber = data.generation || 0;\n      engineState.recoveryCount = genes.recovery_count || 0;\n    }\n    \n    console.log(`[v7.22] Loaded REAL stats: ${engineState.totalPredictions} total, ${engineState.totalCloudPredictions} volume (D18), ${engineState.totalLocalPredictions} deep (D30+)`);\n  } catch (err) {\n    console.warn('[v7.22] Could not load previous stats:', err);\n  }\n}\n\n// ================ HEALTH & RECOVERY ================\n\nasync function performHealthCheck(): Promise<boolean> {\n  console.log('[v6.93] Performing health check...');\n  \n  try {\n    // Check Stockfish engine\n    const engine = getStockfishEngine();\n    if (!engine.available) {\n      console.warn('[v6.93] Stockfish not available, attempting recovery...');\n      await recoverStockfish();\n    }\n    \n    // Check database connectivity\n    const { error } = await supabase\n      .from('chess_prediction_attempts')\n      .select('id', { head: true, count: 'exact' })\n      .limit(1);\n    \n    if (error) {\n      console.error('[v6.93] Database health check failed:', error);\n      return false;\n    }\n    \n    console.log('[v6.93] Health check passed ‚úì');\n    return true;\n    \n  } catch (err) {\n    console.error('[v6.93] Health check failed:', err);\n    return false;\n  }\n}\n\nasync function recoverStockfish(): Promise<void> {\n  console.log('[v7.95] Recovering Stockfish engine...');\n  \n  try {\n    terminateStockfish();\n    await new Promise(r => setTimeout(r, 500)); // v7.95: 500ms (was 2000ms)\n    \n    const engine = getStockfishEngine();\n    await engine.waitReady();\n    \n    console.log('[v7.95] Stockfish recovered ‚úì');\n  } catch (err) {\n    console.error('[v7.95] Stockfish recovery failed:', err);\n  }\n}\n\nasync function performFullRecovery(): Promise<void> {\n  console.log('[v7.95] FULL RECOVERY initiated...');\n  engineState.recoveryCount++;\n  \n  emitEvent('recovery_started', { count: engineState.recoveryCount });\n  \n  // 1. Stop all timers\n  stopTimers();\n  \n  // 2. Wait for any in-flight operations\n  await new Promise(r => setTimeout(r, Math.min(DEFAULT_CONFIG.recoveryDelayMs, 1000)));\n  \n  // 3. Recover Stockfish\n  await recoverStockfish();\n  \n  // 4. Reset error count\n  engineState.consecutiveErrors = 0;\n  engineState.cloudPoolStatus = 'idle';\n  engineState.localPoolStatus = 'idle';\n  \n  // 5. Persist state\n  await persistEvolutionState();\n  \n  // 6. Restart if engine was running - v7.95: 1s delay instead of 5s\n  if (engineState.isRunning && !engineState.isPaused) {\n    console.log('[v7.95] Restarting after recovery...');\n    await new Promise(r => setTimeout(r, 1000));\n    startTimers();\n  }\n  \n  emitEvent('recovery_complete', { count: engineState.recoveryCount });\n  console.log('[v7.95] FULL RECOVERY complete ‚úì');\n}\n\n// ================ BATCH PROCESSORS ================\n\n/**\n * v7.0: Wrap any promise with a hard timeout\n */\nfunction withTimeout<T>(promise: Promise<T>, ms: number, name: string): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => \n      setTimeout(() => reject(new Error(`${name} timeout after ${ms}ms`)), ms)\n    )\n  ]);\n}\n\nasync function runCloudBatch(): Promise<void> {\n  if (engineState.isPaused || !engineState.isRunning) return;\n  \n  // v7.13: CRITICAL - Check for manual benchmark lock BEFORE starting\n  if (isManualBenchmarkActive()) {\n    console.log('[v7.13-VOLUME] ‚è∏Ô∏è Manual benchmark active, skipping batch');\n    // Reschedule for later instead of running now\n    if (engineState.isRunning && !engineState.isPaused) {\n      cloudBatchTimer = setTimeout(runCloudBatch, 30000); // Check again in 30s\n    }\n    return;\n  }\n  \n  console.log(`[v7.13-VOLUME] Starting batch ${engineState.currentBatchNumber}...`);\n  engineState.cloudPoolStatus = 'running';\n  engineState.batchStartedAt = new Date();\n  emitEvent('cloud_batch_started', { batch: engineState.currentBatchNumber });\n  \n  try {\n    // v7.0: HARD TIMEOUT on entire batch operation\n    const predictions = await withTimeout(\n      runCloudPoolBatch(\n        DEFAULT_CONFIG.cloudBatchSize,\n        engineState.currentBatchNumber,\n        (status, progress, prediction) => {\n          console.log(`[v7.0-VOLUME] ${status}`);\n          if (prediction) {\n            emitEvent('prediction_complete', { \n              pool: 'volume', \n              prediction,\n              sessionTotal: engineState.sessionPredictions \n            });\n          }\n        }\n      ),\n      BATCH_TIMEOUT_MS,\n      'CloudBatch'\n    );\n    \n    if (predictions.length > 0) {\n      // v7.0: Timeout on save too\n      const runId = await withTimeout(\n        savePoolPredictions(predictions, 'VOLUME-LOCAL'),\n        30000,\n        'SavePredictions'\n      );\n      \n      // Update stats\n      engineState.totalPredictions += predictions.length;\n      engineState.totalCloudPredictions += predictions.length;\n      engineState.sessionPredictions += predictions.length;\n      engineState.consecutiveErrors = 0;\n      engineState.lastSuccessAt = new Date();\n      \n      console.log(`[v7.0-VOLUME] ‚úÖ Batch complete: ${predictions.length} predictions saved (Run: ${runId})`);\n      emitEvent('cloud_batch_complete', { \n        count: predictions.length, \n        runId,\n        totalSession: engineState.sessionPredictions,\n        totalLifetime: engineState.totalPredictions \n      });\n    } else {\n      console.warn('[v7.0-VOLUME] ‚ö†Ô∏è Batch returned 0 predictions - will retry next batch');\n      // Don't count as error - may just be no fresh games\n    }\n    \n    engineState.cloudPoolStatus = 'idle';\n    await withTimeout(persistEvolutionState(), 10000, 'PersistState');\n    \n  } catch (err) {\n    console.error('[v7.0-VOLUME] ‚ùå Batch failed:', err);\n    \n    engineState.consecutiveErrors++;\n    engineState.lastErrorAt = new Date();\n    engineState.cloudPoolStatus = 'error';\n    \n    emitEvent('cloud_batch_error', { error: err, consecutiveErrors: engineState.consecutiveErrors });\n    \n    // v7.0: Force stop Stockfish on timeout to prevent hung state\n    if (String(err).includes('timeout')) {\n      console.warn('[v7.0-VOLUME] ‚è±Ô∏è Timeout detected, forcing Stockfish reset...');\n      try {\n        terminateStockfish();\n        await new Promise(r => setTimeout(r, 2000));\n      } catch {}\n    }\n    \n    // Trigger recovery if too many errors\n    if (engineState.consecutiveErrors >= DEFAULT_CONFIG.maxConsecutiveErrors) {\n      await performFullRecovery();\n    }\n  }\n  \n  engineState.currentBatchNumber++;\n  \n  // Schedule next batch (self-healing: ALWAYS reschedule)\n  if (engineState.isRunning && !engineState.isPaused) {\n    console.log(`[v7.0-VOLUME] Next batch in ${DEFAULT_CONFIG.cloudBatchIntervalMs / 60000} min`);\n    cloudBatchTimer = setTimeout(runCloudBatch, DEFAULT_CONFIG.cloudBatchIntervalMs);\n  }\n}\n\nasync function runLocalBatch(): Promise<void> {\n  if (engineState.isPaused || !engineState.isRunning) return;\n  \n  // v7.13: CRITICAL - Check for manual benchmark lock BEFORE starting\n  if (isManualBenchmarkActive()) {\n    console.log('[v7.13-DEEP] ‚è∏Ô∏è Manual benchmark active, skipping batch');\n    // Reschedule for later instead of running now\n    if (engineState.isRunning && !engineState.isPaused) {\n      localBatchTimer = setTimeout(runLocalBatch, 30000); // Check again in 30s\n    }\n    return;\n  }\n  \n  console.log(`[v7.13-DEEP] Starting deep batch ${engineState.currentBatchNumber}...`);\n  engineState.localPoolStatus = 'running';\n  emitEvent('local_batch_started', { batch: engineState.currentBatchNumber });\n  \n  try {\n    // v7.0: HARD TIMEOUT on deep batch (2 min for deep analysis)\n    const predictions = await withTimeout(\n      runLocalPoolBatch(\n        DEFAULT_CONFIG.localBatchSize,\n        engineState.currentBatchNumber + 1000,\n        (status, progress, prediction) => {\n          console.log(`[v7.0-DEEP] ${status}`);\n          if (prediction) {\n            emitEvent('prediction_complete', { \n              pool: 'deep', \n              prediction,\n              sessionTotal: engineState.sessionPredictions \n            });\n          }\n        }\n      ),\n      120000, // 2 min timeout for deep analysis\n      'LocalBatch'\n    );\n    \n    if (predictions.length > 0) {\n      const runId = await withTimeout(\n        savePoolPredictions(predictions, 'LOCAL-DEEP'),\n        30000,\n        'SavePredictions'\n      );\n      \n      engineState.totalPredictions += predictions.length;\n      engineState.totalLocalPredictions += predictions.length;\n      engineState.sessionPredictions += predictions.length;\n      engineState.consecutiveErrors = 0;\n      engineState.lastSuccessAt = new Date();\n      \n      console.log(`[v7.0-DEEP] ‚úÖ Deep batch complete: ${predictions.length} predictions saved (Run: ${runId})`);\n      emitEvent('local_batch_complete', { \n        count: predictions.length, \n        runId,\n        totalSession: engineState.sessionPredictions,\n        totalLifetime: engineState.totalPredictions \n      });\n    } else {\n      console.warn('[v7.0-DEEP] ‚ö†Ô∏è Deep batch returned 0 predictions');\n    }\n    \n    engineState.localPoolStatus = 'idle';\n    await withTimeout(persistEvolutionState(), 10000, 'PersistState');\n    \n  } catch (err) {\n    console.error('[v7.0-DEEP] ‚ùå Deep batch failed:', err);\n    \n    engineState.consecutiveErrors++;\n    engineState.lastErrorAt = new Date();\n    engineState.localPoolStatus = 'error';\n    \n    emitEvent('local_batch_error', { error: err });\n    \n    // v7.0: Force Stockfish reset on timeout\n    if (String(err).includes('timeout')) {\n      console.warn('[v7.0-DEEP] ‚è±Ô∏è Timeout detected, forcing Stockfish reset...');\n      try {\n        terminateStockfish();\n        await new Promise(r => setTimeout(r, 2000));\n      } catch {}\n    }\n    \n    if (engineState.consecutiveErrors >= DEFAULT_CONFIG.maxConsecutiveErrors) {\n      await performFullRecovery();\n    }\n  }\n  \n  // Schedule next batch (self-healing: ALWAYS reschedule)\n  if (engineState.isRunning && !engineState.isPaused) {\n    console.log(`[v7.0-DEEP] Next deep batch in ${DEFAULT_CONFIG.localBatchIntervalMs / 60000} min`);\n    localBatchTimer = setTimeout(runLocalBatch, DEFAULT_CONFIG.localBatchIntervalMs);\n  }\n}\n\nfunction runHealthCheck(): void {\n  withTimeout(performHealthCheck(), 30000, 'HealthCheck')\n    .then(healthy => {\n      if (!healthy && engineState.isRunning) {\n        console.warn('[v7.0] Health check failed, triggering recovery...');\n        performFullRecovery();\n      }\n    })\n    .catch(err => {\n      console.warn('[v7.0] Health check timeout:', err);\n      if (engineState.isRunning) {\n        performFullRecovery();\n      }\n    });\n  \n  // Always reschedule\n  if (engineState.isRunning) {\n    healthCheckTimer = setTimeout(runHealthCheck, DEFAULT_CONFIG.healthCheckIntervalMs);\n  }\n}\n\n// ================ TIMER MANAGEMENT ================\n\nfunction startTimers(): void {\n  console.log('[v7.0] Starting evolution timers...');\n  \n  // Start volume pool immediately, then every 3 min\n  cloudBatchTimer = setTimeout(runCloudBatch, 1000);\n  \n  // Start deep pool after 30s, then every 10 min\n  localBatchTimer = setTimeout(runLocalBatch, 30 * 1000);\n  \n  // Health checks every 2 min\n  healthCheckTimer = setTimeout(runHealthCheck, DEFAULT_CONFIG.healthCheckIntervalMs);\n}\n\nfunction stopTimers(): void {\n  if (cloudBatchTimer) {\n    clearTimeout(cloudBatchTimer);\n    cloudBatchTimer = null;\n  }\n  if (localBatchTimer) {\n    clearTimeout(localBatchTimer);\n    localBatchTimer = null;\n  }\n  if (healthCheckTimer) {\n    clearTimeout(healthCheckTimer);\n    healthCheckTimer = null;\n  }\n}\n\n// ================ PUBLIC API ================\n\nexport async function startAutoEvolution(): Promise<void> {\n  if (engineState.isRunning) {\n    console.log('[v7.0] Already running');\n    return;\n  }\n  \n  console.log(`[v7.0] ========== AUTO-EVOLUTION ENGINE STARTING ==========`);\n  console.log(`[v7.0] Version: ${AUTO_EVOLUTION_VERSION}`);\n  console.log(`[v7.0] Volume: ${DEFAULT_CONFIG.cloudBatchSize} games every ${DEFAULT_CONFIG.cloudBatchIntervalMs / 60000} min`);\n  console.log(`[v7.0] Deep: ${DEFAULT_CONFIG.localBatchSize} games every ${DEFAULT_CONFIG.localBatchIntervalMs / 60000} min`);\n  console.log(`[v7.0] Batch timeout: ${BATCH_TIMEOUT_MS / 1000}s`);\n  console.log(`[v7.0] ======================================================`);\n  \n  // Load previous state with timeout\n  try {\n    await withTimeout(loadPreviousStats(), 15000, 'LoadStats');\n  } catch (err) {\n    console.warn('[v7.0] Failed to load previous stats, starting fresh:', err);\n  }\n  \n  // Initialize state\n  engineState.isRunning = true;\n  engineState.isPaused = false;\n  engineState.sessionStartedAt = new Date();\n  engineState.sessionPredictions = 0;\n  engineState.consecutiveErrors = 0;\n  \n  // Pre-warm Stockfish with timeout\n  try {\n    const engine = getStockfishEngine();\n    await withTimeout(engine.waitReady(), 20000, 'StockfishWarmup');\n    console.log('[v7.0] ‚úÖ Stockfish pre-warmed');\n  } catch (err) {\n    console.warn('[v7.0] ‚ö†Ô∏è Stockfish pre-warm failed, will retry during first batch:', err);\n  }\n  \n  // Start timers\n  startTimers();\n  \n  // Persist and emit\n  try {\n    await withTimeout(persistEvolutionState(), 10000, 'PersistState');\n  } catch {}\n  \n  emitEvent('engine_started', { \n    version: AUTO_EVOLUTION_VERSION,\n    totalPredictions: engineState.totalPredictions \n  });\n  \n  console.log('[v7.0] üöÄ Auto-evolution engine RUNNING - UNBLOCKABLE MODE');\n}\n\nexport function pauseAutoEvolution(): void {\n  if (!engineState.isRunning || engineState.isPaused) return;\n  \n  console.log('[v7.0] Pausing evolution...');\n  engineState.isPaused = true;\n  stopTimers();\n  emitEvent('engine_paused');\n}\n\nexport function resumeAutoEvolution(): void {\n  if (!engineState.isRunning || !engineState.isPaused) return;\n  \n  console.log('[v7.0] Resuming evolution...');\n  engineState.isPaused = false;\n  startTimers();\n  emitEvent('engine_resumed');\n}\n\nexport function stopAutoEvolution(): void {\n  \n  console.log('[v7.0] Stopping evolution engine...');\n  \n  engineState.isRunning = false;\n  engineState.isPaused = false;\n  stopTimers();\n  \n  persistEvolutionState();\n  emitEvent('engine_stopped', { sessionPredictions: engineState.sessionPredictions });\n  \n  console.log(`[v7.0] Evolution stopped. Session: ${engineState.sessionPredictions} predictions`);\n}\n\nexport function getEvolutionState(): EvolutionState {\n  return { ...engineState };\n}\n\nexport function forceRunBatch(pool: 'cloud' | 'local'): void {\n  if (!engineState.isRunning) {\n    console.warn('[v7.0] Engine not running');\n    return;\n  }\n  \n  if (pool === 'cloud') {\n    runCloudBatch();\n  } else {\n    runLocalBatch();\n  }\n}\n\nexport { AUTO_EVOLUTION_VERSION };\n";export{n as default};
