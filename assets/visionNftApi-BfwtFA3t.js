const n="import { supabase } from '@/integrations/supabase/client';\n\nexport interface VisionNFT {\n  id: string;\n  visualization_id: string;\n  token_id: string;\n  mint_number?: number;\n  \n  // Value tracking\n  mint_price_cents: number;\n  current_floor_price_cents: number;\n  all_time_high_cents?: number;\n  all_time_low_cents?: number;\n  appreciation_rate?: number;\n  \n  // Value sources\n  print_revenue_contribution_cents: number;\n  gamecard_pool_share_cents: number;\n  palette_pool_share_cents: number;\n  opening_pool_share_cents: number;\n  engagement_value_cents: number;\n  trading_premium_cents: number;\n  \n  // Attribution\n  game_id?: string;\n  palette_id?: string;\n  opening_eco?: string;\n  \n  // Rarity\n  rarity_score: number;\n  total_prints_ordered: number;\n  total_views: number;\n  total_unique_viewers: number;\n  total_downloads: number;\n  total_trades: number;\n  \n  // Ownership\n  current_owner_id?: string;\n  minted_by?: string;\n  minted_at: string;\n  \n  // Trading\n  last_sale_price_cents?: number;\n  last_sale_at?: string;\n}\n\nexport interface VisionValueHistory {\n  id: string;\n  vision_nft_id: string;\n  floor_price_cents: number;\n  total_contribution_cents: number;\n  \n  // Component breakdown\n  print_revenue_cents: number;\n  gamecard_share_cents: number;\n  palette_share_cents: number;\n  opening_share_cents: number;\n  engagement_cents: number;\n  trading_premium_cents: number;\n  \n  // Context\n  game_hype_score: number;\n  palette_scarcity: number;\n  \n  snapshot_date: string;\n  created_at: string;\n}\n\nexport interface VisionTrade {\n  id: string;\n  vision_nft_id: string;\n  seller_id?: string;\n  buyer_id?: string;\n  trade_price_cents: number;\n  trade_type: 'marketplace_sale' | 'private_trade' | 'external_sale' | 'initial_claim';\n  seller_gain_cents: number;\n  platform_fee_cents: number;\n  game_id?: string;\n  palette_id?: string;\n  traded_at: string;\n}\n\n// Get all vision NFTs for a user\nexport async function getUserVisionNFTs(userId: string): Promise<{\n  data: VisionNFT[];\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_nfts')\n      .select('*')\n      .eq('current_owner_id', userId)\n      .order('current_floor_price_cents', { ascending: false });\n\n    if (error) throw error;\n    return { data: (data || []) as VisionNFT[], error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Get a single vision NFT by ID\nexport async function getVisionNFT(visionNftId: string): Promise<{\n  data: VisionNFT | null;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_nfts')\n      .select('*')\n      .eq('id', visionNftId)\n      .single();\n\n    if (error) throw error;\n    return { data: data as VisionNFT, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n\n// Get vision NFT by visualization ID\nexport async function getVisionNFTByVisualization(visualizationId: string): Promise<{\n  data: VisionNFT | null;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_nfts')\n      .select('*')\n      .eq('visualization_id', visualizationId)\n      .single();\n\n    if (error) throw error;\n    return { data: data as VisionNFT, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n\n// Get value history for a vision (for charts)\nexport async function getVisionValueHistory(\n  visionNftId: string,\n  days: number = 30\n): Promise<{\n  data: VisionValueHistory[];\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_value_history')\n      .select('*')\n      .eq('vision_nft_id', visionNftId)\n      .gte('snapshot_date', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString().split('T')[0])\n      .order('snapshot_date', { ascending: true });\n\n    if (error) throw error;\n    return { data: (data || []) as VisionValueHistory[], error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Get trading history for a vision\nexport async function getVisionTrades(visionNftId: string): Promise<{\n  data: VisionTrade[];\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_trades')\n      .select('*')\n      .eq('vision_nft_id', visionNftId)\n      .order('traded_at', { ascending: false });\n\n    if (error) throw error;\n    return { data: (data || []) as VisionTrade[], error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Get top performing visions\nexport async function getTopPerformingVisions(\n  limit: number = 10,\n  timeframe: 'day' | 'week' | 'month' = 'week'\n): Promise<{\n  data: VisionNFT[];\n  error: Error | null;\n}> {\n  try {\n    const days = timeframe === 'day' ? 1 : timeframe === 'week' ? 7 : 30;\n    \n    // Get visions that appreciated most in the timeframe\n    const { data, error } = await supabase\n      .from('vision_nfts')\n      .select(`\n        *,\n        history:vision_value_history!inner(floor_price_cents, snapshot_date)\n      `)\n      .gte('vision_value_history.snapshot_date', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString().split('T')[0])\n      .order('appreciation_rate', { ascending: false })\n      .limit(limit);\n\n    if (error) throw error;\n    return { data: (data || []) as VisionNFT[], error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Get visions by game (for \"hot games\" feature)\nexport async function getVisionsByGame(gameId: string): Promise<{\n  data: VisionNFT[];\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_nfts')\n      .select('*')\n      .eq('game_id', gameId)\n      .order('current_floor_price_cents', { ascending: false });\n\n    if (error) throw error;\n    return { data: (data || []) as VisionNFT[], error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Get visions by palette (for scarcity calculations)\nexport async function getVisionsByPalette(paletteId: string): Promise<{\n  data: VisionNFT[];\n  count: number;\n  error: Error | null;\n}> {\n  try {\n    const { data, error, count } = await supabase\n      .from('vision_nfts')\n      .select('*', { count: 'exact' })\n      .eq('palette_id', paletteId)\n      .order('current_floor_price_cents', { ascending: false });\n\n    if (error) throw error;\n    return { data: (data || []) as VisionNFT[], count: count || 0, error: null };\n  } catch (error) {\n    return { data: [], count: 0, error: error as Error };\n  }\n}\n\n// Calculate total portfolio value for a user\nexport async function calculatePortfolioValue(userId: string): Promise<{\n  totalValueCents: number;\n  totalMintCostCents: number;\n  totalGainCents: number;\n  gainPercentage: number;\n  visionCount: number;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('vision_nfts')\n      .select('current_floor_price_cents, mint_price_cents')\n      .eq('current_owner_id', userId);\n\n    if (error) throw error;\n\n    const visions = data || [];\n    const totalValueCents = visions.reduce((sum, v) => sum + (v.current_floor_price_cents || 0), 0);\n    const totalMintCostCents = visions.reduce((sum, v) => sum + (v.mint_price_cents || 0), 0);\n    const totalGainCents = totalValueCents - totalMintCostCents;\n    const gainPercentage = totalMintCostCents > 0 ? (totalGainCents / totalMintCostCents) * 100 : 0;\n\n    return {\n      totalValueCents,\n      totalMintCostCents,\n      totalGainCents,\n      gainPercentage,\n      visionCount: visions.length,\n      error: null,\n    };\n  } catch (error) {\n    return {\n      totalValueCents: 0,\n      totalMintCostCents: 0,\n      totalGainCents: 0,\n      gainPercentage: 0,\n      visionCount: 0,\n      error: error as Error,\n    };\n  }\n}\n\n// Format cents to dollar display\nexport function formatValue(cents: number): string {\n  if (cents === 0) return '$0.00';\n  if (cents < 100) return `$0.${cents.toString().padStart(2, '0')}`;\n  return `$${(cents / 100).toFixed(2)}`;\n}\n\n// Format appreciation percentage\nexport function formatAppreciation(value: number): string {\n  const sign = value >= 0 ? '+' : '';\n  return `${sign}${value.toFixed(1)}%`;\n}\n";export{n as default};
