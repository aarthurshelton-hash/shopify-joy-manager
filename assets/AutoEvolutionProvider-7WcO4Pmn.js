const n="/**\n * AutoEvolutionProvider - v7.0-UNBLOCKABLE\n * \n * CRITICAL FIX: Previous versions had operations that could hang indefinitely.\n * \n * v7.0 CHANGES:\n * - All operations have hard timeouts\n * - Faster heartbeat to catch stalls sooner\n * - Immediate recovery on visibility change\n * - Engine reset on consecutive failures\n */\n\nimport { useEffect, useRef } from 'react';\nimport {\n  startAutoEvolution,\n  getEvolutionState,\n  subscribeToEvolution,\n} from '@/lib/chess/autoEvolutionEngine';\nimport { supabase } from '@/integrations/supabase/client';\n\nconst AUTO_EVOLUTION_VERSION = \"7.0-UNBLOCKABLE\";\n\ninterface AutoEvolutionProviderProps {\n  children: React.ReactNode;\n  autoStart?: boolean;\n}\n\nexport function AutoEvolutionProvider({ \n  children, \n  autoStart = true,\n}: AutoEvolutionProviderProps) {\n  const initRef = useRef(false);\n  const heartbeatRef = useRef<NodeJS.Timeout | null>(null);\n  \n  useEffect(() => {\n    if (!autoStart) return;\n    \n    // Prevent double-init in strict mode, but allow restart after page reload\n    if (initRef.current) return;\n    initRef.current = true;\n    \n    console.log(`[v7.0-UNBLOCKABLE] AutoEvolutionProvider mounted`);\n    \n    // Subscribe to events for logging\n    const unsubscribe = subscribeToEvolution((state, event, data) => {\n      if (event === 'cloud_batch_complete' || event === 'local_batch_complete') {\n        console.log(`[v7.0-UNBLOCKABLE] âœ… Batch complete: +${data?.count} predictions (session: ${state.sessionPredictions})`);\n        logEvolutionEvent(event, data);\n      } else if (event === 'recovery_complete') {\n        console.log(`[v7.0-UNBLOCKABLE] ðŸ”„ Recovery #${data?.count} complete`);\n      } else if (event === 'cloud_batch_error' || event === 'local_batch_error') {\n        console.error(`[v7.0-UNBLOCKABLE] âŒ Batch error:`, data?.error);\n        logEvolutionEvent('batch_error', { error: String(data?.error) });\n      }\n    });\n    \n    // IMMEDIATE START - no delay\n    const startEngine = async () => {\n      const state = getEvolutionState();\n      if (state.isRunning) {\n        console.log('[v7.0-UNBLOCKABLE] Engine already running');\n        return;\n      }\n      \n      console.log(`[v7.0-UNBLOCKABLE] ========================================`);\n      console.log(`[v7.0-UNBLOCKABLE] ðŸš€ AUTO-STARTING EVOLUTION PIPELINE`);\n      console.log(`[v7.0-UNBLOCKABLE] Version: ${AUTO_EVOLUTION_VERSION}`);\n      console.log(`[v7.0-UNBLOCKABLE] Time: ${new Date().toISOString()}`);\n      console.log(`[v7.0-UNBLOCKABLE] ========================================`);\n      \n      try {\n        // v7.0: Timeout on start operation\n        const startPromise = startAutoEvolution();\n        const timeoutPromise = new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Start timeout')), 30000)\n        );\n        \n        await Promise.race([startPromise, timeoutPromise]);\n        \n        const newState = getEvolutionState();\n        console.log(`[v7.0-UNBLOCKABLE] âœ… Engine running: ${newState.isRunning}`);\n        \n        await logEvolutionEvent('auto_start', { \n          version: AUTO_EVOLUTION_VERSION,\n          totalPredictions: newState.totalPredictions \n        });\n        \n      } catch (err) {\n        console.error('[v7.0-UNBLOCKABLE] âŒ Failed to auto-start:', err);\n        // Retry after 15s (faster retry)\n        setTimeout(startEngine, 15000);\n      }\n    };\n    \n    // Start immediately\n    startEngine();\n    \n    // HEARTBEAT: Check every 2 min if engine stopped and restart it\n    heartbeatRef.current = setInterval(async () => {\n      const state = getEvolutionState();\n      if (!state.isRunning) {\n        console.warn('[v7.0-UNBLOCKABLE] âš ï¸ Heartbeat detected engine stopped, restarting...');\n        await startEngine();\n      } else {\n        console.log(`[v7.0-UNBLOCKABLE] ðŸ’“ Heartbeat OK - Session: ${state.sessionPredictions} predictions`);\n      }\n    }, 2 * 60 * 1000);\n    \n    // VISIBILITY HANDLER: Resume when tab becomes visible\n    const handleVisibilityChange = async () => {\n      if (document.visibilityState === 'visible') {\n        console.log('[v7.0-UNBLOCKABLE] Tab became visible, checking engine...');\n        const state = getEvolutionState();\n        if (!state.isRunning) {\n          console.warn('[v7.0-UNBLOCKABLE] Engine not running, restarting...');\n          await startEngine();\n        }\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      unsubscribe();\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      if (heartbeatRef.current) {\n        clearInterval(heartbeatRef.current);\n      }\n      // Note: We do NOT stop the engine on unmount - it should keep running\n    };\n  }, [autoStart]);\n  \n  return <>{children}</>;\n}\n\n/**\n * Log evolution events to database for verification and tracking\n */\nasync function logEvolutionEvent(event: string, data?: Record<string, unknown>) {\n  try {\n    // v7.0: Timeout on log operation to prevent hanging\n    const insertPromise = supabase\n      .from('evolution_state')\n      .insert({\n        state_type: `v7.0_${event}`,\n        genes: {\n          version: AUTO_EVOLUTION_VERSION,\n          event,\n          timestamp: new Date().toISOString(),\n          ...data\n        },\n        fitness_score: 100,\n        generation: 0,\n      });\n    \n    const timeoutPromise = new Promise((_, reject) => \n      setTimeout(() => reject(new Error('Log timeout')), 5000)\n    );\n    \n    await Promise.race([insertPromise, timeoutPromise]);\n  } catch (err) {\n    // Silent fail - this is just for verification logging\n    console.warn('[v7.0-UNBLOCKABLE] Event log failed:', err);\n  }\n}\n\nexport default AutoEvolutionProvider;\n";export{n as default};
