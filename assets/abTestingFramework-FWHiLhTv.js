const e="/**\n * A/B Testing Framework for Enhanced Signature System\n * \n * Compares 4-quadrant (baseline) vs 8-quadrant (enhanced) accuracy\n * Runs parallel predictions and tracks performance metrics\n */\n\nimport { simulateGame } from '../gameSimulator';\nimport { extractEnhancedColorFlowSignature, EnhancedQuadrantProfile, compareEnhancedProfiles } from './enhancedSignatureExtractor';\nimport { extractColorFlowSignature } from './signatureExtractor';\nimport { QuadrantProfile, TemporalFlow, ColorFlowSignature } from './types';\n\n/**\n * A/B Test Result for a single game\n */\nexport interface ABTestResult {\n  gameId: string;\n  white: string;\n  black: string;\n  result: string;\n  \n  // Baseline (4-quadrant) prediction\n  baseline: {\n    archetype: string;\n    confidence: number;\n    quadrantProfile: QuadrantProfile;\n    fingerprint: string;\n    predictedResult: '1-0' | '0-1' | '1/2-1/2';\n  };\n  \n  // Enhanced (8-quadrant) prediction\n  enhanced: {\n    archetype: string;\n    confidence: number;\n    quadrantProfile: EnhancedQuadrantProfile;\n    fingerprint: string;\n    predictedResult: '1-0' | '0-1' | '1/2-1/2';\n    colorRichness: number;\n    complexity: number;\n  };\n  \n  // Comparison\n  correctPrediction: {\n    baseline: boolean;\n    enhanced: boolean;\n  };\n  profileSimilarity: number; // 0-1, how similar are the profiles\n  confidenceDelta: number;    // Enhanced - Baseline confidence\n  archetypeMatch: boolean;    // Do both predict same archetype family\n}\n\n/**\n * Aggregate A/B Test Statistics\n */\nexport interface ABTestStatistics {\n  totalGames: number;\n  baselineAccuracy: number;\n  enhancedAccuracy: number;\n  accuracyImprovement: number; // percentage points\n  \n  // Confidence metrics\n  avgBaselineConfidence: number;\n  avgEnhancedConfidence: number;\n  confidenceImprovement: number;\n  \n  // Archetype analysis\n  archetypeMatchRate: number;\n  mostImprovedArchetypes: Array<{ archetype: string; improvement: number }>;\n  leastImprovedArchetypes: Array<{ archetype: string; improvement: number }>;\n  \n  // Enhanced-specific metrics\n  avgColorRichness: number;\n  avgComplexity: number;\n  profileSimilarityAvg: number;\n}\n\n/**\n * Predict game result based on archetype (simplified heuristic)\n * Used for A/B testing - in production would use actual ML model\n */\nfunction predictResultFromArchetype(\n  archetype: string,\n  quadrantProfile: QuadrantProfile | EnhancedQuadrantProfile,\n  isEnhanced: boolean\n): { result: '1-0' | '0-1' | '1/2-1/2'; confidence: number } {\n  let whiteAdvantage = 0;\n  let confidence = 0.5;\n  \n  if (isEnhanced) {\n    const enhanced = quadrantProfile as EnhancedQuadrantProfile;\n    \n    // Calculate advantage from 8-quadrant profile\n    whiteAdvantage += enhanced.q1_kingside_white * 0.3;\n    whiteAdvantage += enhanced.q2_queenside_white * 0.3;\n    whiteAdvantage -= enhanced.q3_kingside_black * 0.3;\n    whiteAdvantage -= enhanced.q4_queenside_black * 0.3;\n    whiteAdvantage += enhanced.q5_center_white * 0.4;\n    whiteAdvantage -= enhanced.q6_center_black * 0.4;\n    whiteAdvantage += enhanced.q7_extended_kingside * 0.2;\n    whiteAdvantage += enhanced.q8_extended_queenside * 0.2;\n    \n    // Piece-type advantages\n    if (enhanced.bishop_dominance > 0.35) {\n      whiteAdvantage += 0.5;\n      confidence += 0.1;\n    }\n    if (enhanced.knight_dominance > 0.40) {\n      whiteAdvantage += 0.3;\n      confidence += 0.05;\n    }\n    if (enhanced.pawn_advancement > 0.5) {\n      whiteAdvantage += 0.4;\n      confidence += 0.08;\n    }\n    \n    // Archetype-specific adjustments\n    if (archetype.includes('kingside') && archetype.includes('white')) {\n      whiteAdvantage += 0.6;\n      confidence += 0.15;\n    } else if (archetype.includes('kingside') && archetype.includes('black')) {\n      whiteAdvantage -= 0.6;\n      confidence += 0.15;\n    } else if (archetype.includes('queenside') && archetype.includes('white')) {\n      whiteAdvantage += 0.4;\n      confidence += 0.1;\n    } else if (archetype.includes('queenside') && archetype.includes('black')) {\n      whiteAdvantage -= 0.4;\n      confidence += 0.1;\n    }\n  } else {\n    // Baseline 4-quadrant calculation\n    whiteAdvantage += (quadrantProfile as QuadrantProfile).kingsideWhite * 0.5;\n    whiteAdvantage += (quadrantProfile as QuadrantProfile).queensideWhite * 0.4;\n    whiteAdvantage -= (quadrantProfile as QuadrantProfile).kingsideBlack * 0.5;\n    whiteAdvantage -= (quadrantProfile as QuadrantProfile).queensideBlack * 0.4;\n    \n    if (archetype.includes('kingside_attack')) {\n      whiteAdvantage += 0.5;\n      confidence += 0.1;\n    } else if (archetype.includes('queenside_pressure')) {\n      whiteAdvantage += 0.3;\n      confidence += 0.08;\n    } else if (archetype.includes('prophylactic')) {\n      whiteAdvantage += 0.2;\n      confidence += 0.05;\n    }\n  }\n  \n  // Determine result\n  let result: '1-0' | '0-1' | '1/2-1/2';\n  if (whiteAdvantage > 0.8) {\n    result = '1-0';\n    confidence += 0.15;\n  } else if (whiteAdvantage < -0.8) {\n    result = '0-1';\n    confidence += 0.15;\n  } else {\n    result = '1/2-1/2';\n  }\n  \n  // Cap confidence at 0.95\n  confidence = Math.min(confidence, 0.95);\n  \n  return { result, confidence };\n}\n\n/**\n * Run A/B test on a single game\n */\nexport function runSingleABTest(\n  gameId: string,\n  pgn: string,\n  actualResult: string\n): ABTestResult {\n  const simulation = simulateGame(pgn);\n  \n  // Baseline extraction (4-quadrant)\n  const baselineSignature = extractColorFlowSignature(simulation.board, simulation.gameData, simulation.totalMoves);\n  const baselinePrediction = predictResultFromArchetype(\n    baselineSignature.archetype,\n    baselineSignature.quadrantProfile,\n    false\n  );\n  \n  // Enhanced extraction (8-quadrant)\n  const enhancedSignature = extractEnhancedColorFlowSignature(simulation);\n  const enhancedPrediction = predictResultFromArchetype(\n    enhancedSignature.archetype,\n    enhancedSignature.quadrantProfile,\n    true\n  );\n  \n  // Compare profiles (convert baseline to enhanced format for comparison)\n  const baselineAsEnhanced: EnhancedQuadrantProfile = {\n    q1_kingside_white: baselineSignature.quadrantProfile.kingsideWhite || 0,\n    q2_queenside_white: baselineSignature.quadrantProfile.queensideWhite || 0,\n    q3_kingside_black: baselineSignature.quadrantProfile.kingsideBlack || 0,\n    q4_queenside_black: baselineSignature.quadrantProfile.queensideBlack || 0,\n    q5_center_white: baselineSignature.quadrantProfile.center > 0 ? baselineSignature.quadrantProfile.center : 0,\n    q6_center_black: baselineSignature.quadrantProfile.center < 0 ? baselineSignature.quadrantProfile.center : 0,\n    q7_extended_kingside: 0,\n    q8_extended_queenside: 0,\n    bishop_dominance: 0,\n    knight_dominance: 0,\n    rook_dominance: 0,\n    queen_dominance: 0,\n    pawn_advancement: 0,\n    temporalFlow: {\n      early: baselineSignature.temporalFlow ? (baselineSignature.temporalFlow.opening + baselineSignature.temporalFlow.middlegame) / 2 : 0,\n      mid: baselineSignature.temporalFlow ? baselineSignature.temporalFlow.middlegame : 0,\n      late: baselineSignature.temporalFlow ? baselineSignature.temporalFlow.endgame : 0,\n    },\n  };\n  \n  const profileSimilarity = compareEnhancedProfiles(\n    baselineAsEnhanced,\n    enhancedSignature.quadrantProfile\n  );\n  \n  // Determine correctness\n  const normalizeResult = (r: string): string => {\n    if (r === '1-0' || r === '1-0 ') return '1-0';\n    if (r === '0-1' || r === '0-1 ') return '0-1';\n    if (r.includes('1/2')) return '1/2-1/2';\n    if (r === '*') return 'unknown';\n    return r;\n  };\n  \n  const normalizedActual = normalizeResult(actualResult);\n  const baselineCorrect = normalizeResult(baselinePrediction.result) === normalizedActual;\n  const enhancedCorrect = normalizeResult(enhancedPrediction.result) === normalizedActual;\n  \n  // Check archetype family match\n  const baselineFamily = baselineSignature.archetype.split('_')[0];\n  const enhancedFamily = enhancedSignature.archetype.split('_')[0];\n  const archetypeMatch = baselineFamily === enhancedFamily;\n  \n  return {\n    gameId,\n    white: simulation.gameData.white,\n    black: simulation.gameData.black,\n    result: actualResult,\n    baseline: {\n      archetype: baselineSignature.archetype,\n      confidence: baselinePrediction.confidence,\n      quadrantProfile: baselineSignature.quadrantProfile,\n      fingerprint: baselineSignature.fingerprint,\n      predictedResult: baselinePrediction.result,\n    },\n    enhanced: {\n      archetype: enhancedSignature.archetype,\n      confidence: enhancedPrediction.confidence,\n      quadrantProfile: enhancedSignature.quadrantProfile,\n      fingerprint: enhancedSignature.fingerprint,\n      predictedResult: enhancedPrediction.result,\n      colorRichness: enhancedSignature.colorRichness,\n      complexity: enhancedSignature.complexity,\n    },\n    correctPrediction: {\n      baseline: baselineCorrect,\n      enhanced: enhancedCorrect,\n    },\n    profileSimilarity,\n    confidenceDelta: enhancedPrediction.confidence - baselinePrediction.confidence,\n    archetypeMatch,\n  };\n}\n\n/**\n * Run batch A/B test on multiple games\n */\nexport function runBatchABTest(\n  games: Array<{ gameId: string; pgn: string; result: string }>\n): { results: ABTestResult[]; statistics: ABTestStatistics } {\n  const results: ABTestResult[] = [];\n  \n  for (const game of games) {\n    try {\n      const testResult = runSingleABTest(game.gameId, game.pgn, game.result);\n      results.push(testResult);\n    } catch (e) {\n      console.error(`Failed to process game ${game.gameId}:`, e);\n    }\n  }\n  \n  const statistics = calculateABTestStatistics(results);\n  \n  return { results, statistics };\n}\n\n/**\n * Calculate aggregate statistics from A/B test results\n */\nexport function calculateABTestStatistics(results: ABTestResult[]): ABTestStatistics {\n  if (results.length === 0) {\n    return {\n      totalGames: 0,\n      baselineAccuracy: 0,\n      enhancedAccuracy: 0,\n      accuracyImprovement: 0,\n      avgBaselineConfidence: 0,\n      avgEnhancedConfidence: 0,\n      confidenceImprovement: 0,\n      archetypeMatchRate: 0,\n      mostImprovedArchetypes: [],\n      leastImprovedArchetypes: [],\n      avgColorRichness: 0,\n      avgComplexity: 0,\n      profileSimilarityAvg: 0,\n    };\n  }\n  \n  // Basic counts\n  const totalGames = results.length;\n  const baselineCorrect = results.filter(r => r.correctPrediction.baseline).length;\n  const enhancedCorrect = results.filter(r => r.correctPrediction.enhanced).length;\n  const archetypeMatches = results.filter(r => r.archetypeMatch).length;\n  \n  // Calculate averages\n  const avgBaselineConfidence = results.reduce((sum, r) => sum + r.baseline.confidence, 0) / totalGames;\n  const avgEnhancedConfidence = results.reduce((sum, r) => sum + r.enhanced.confidence, 0) / totalGames;\n  const avgColorRichness = results.reduce((sum, r) => sum + r.enhanced.colorRichness, 0) / totalGames;\n  const avgComplexity = results.reduce((sum, r) => sum + r.enhanced.complexity, 0) / totalGames;\n  const profileSimilarityAvg = results.reduce((sum, r) => sum + r.profileSimilarity, 0) / totalGames;\n  \n  // Archetype-specific analysis\n  const archetypeStats: Record<string, { baseline: number; enhanced: number; count: number }> = {};\n  \n  for (const result of results) {\n    const arch = result.enhanced.archetype;\n    if (!archetypeStats[arch]) {\n      archetypeStats[arch] = { baseline: 0, enhanced: 0, count: 0 };\n    }\n    archetypeStats[arch].count++;\n    if (result.correctPrediction.baseline) archetypeStats[arch].baseline++;\n    if (result.correctPrediction.enhanced) archetypeStats[arch].enhanced++;\n  }\n  \n  // Calculate improvements per archetype\n  const archetypeImprovements = Object.entries(archetypeStats)\n    .filter(([, stats]) => stats.count >= 3) // Need at least 3 samples\n    .map(([archetype, stats]) => ({\n      archetype,\n      improvement: (stats.enhanced / stats.count) - (stats.baseline / stats.count),\n    }))\n    .sort((a, b) => b.improvement - a.improvement);\n  \n  return {\n    totalGames,\n    baselineAccuracy: (baselineCorrect / totalGames) * 100,\n    enhancedAccuracy: (enhancedCorrect / totalGames) * 100,\n    accuracyImprovement: ((enhancedCorrect - baselineCorrect) / totalGames) * 100,\n    avgBaselineConfidence,\n    avgEnhancedConfidence,\n    confidenceImprovement: avgEnhancedConfidence - avgBaselineConfidence,\n    archetypeMatchRate: (archetypeMatches / totalGames) * 100,\n    mostImprovedArchetypes: archetypeImprovements.slice(0, 5),\n    leastImprovedArchetypes: archetypeImprovements.slice(-5).reverse(),\n    avgColorRichness,\n    avgComplexity,\n    profileSimilarityAvg,\n  };\n}\n\n/**\n * Generate A/B test report\n */\nexport function generateABTestReport(statistics: ABTestStatistics): string {\n  const improvement = statistics.accuracyImprovement >= 0 \n    ? `+${statistics.accuracyImprovement.toFixed(1)}%` \n    : `${statistics.accuracyImprovement.toFixed(1)}%`;\n  \n  return `\n╔══════════════════════════════════════════════════════════════╗\n║         ENHANCED SIGNATURE A/B TEST RESULTS                   ║\n╠══════════════════════════════════════════════════════════════╣\n║ Games Tested:       ${statistics.totalGames.toString().padEnd(35)} ║\n║                                                               ║\n║ BASELINE (4-Quadrant)    vs    ENHANCED (8-Quadrant)          ║\n║ ───────────────────────────────────────────────────────────── ║\n║ Accuracy:     ${statistics.baselineAccuracy.toFixed(1)}%    →    ${statistics.enhancedAccuracy.toFixed(1)}%    (${improvement})            ║\n║ Confidence:   ${(statistics.avgBaselineConfidence * 100).toFixed(1)}%   →   ${(statistics.avgEnhancedConfidence * 100).toFixed(1)}%   (${(statistics.confidenceImprovement * 100).toFixed(1)}%)            ║\n║                                                               ║\n║ ENHANCED METRICS:                                             ║\n║ ───────────────────────────────────────────────────────────── ║\n║ Color Richness:     ${(statistics.avgColorRichness * 100).toFixed(1)}% (12 piece types utilized)            ║\n║ Complexity:         ${statistics.avgComplexity.toFixed(2)} (visits per square)                 ║\n║ Profile Similarity: ${(statistics.profileSimilarityAvg * 100).toFixed(1)}% (vs baseline)                     ║\n║ Archetype Match:    ${statistics.archetypeMatchRate.toFixed(1)}% (same family)                    ║\n║                                                               ║\n║ TOP IMPROVEMENTS:                                               ║\n${statistics.mostImprovedArchetypes.slice(0, 3).map(a => \n  `║   • ${a.archetype.padEnd(25)} +${(a.improvement * 100).toFixed(1)}%                  ║`\n).join('\\n')}\n║                                                               ║\n╚══════════════════════════════════════════════════════════════╝\n`;\n}\n\n/**\n * Export results for further analysis\n */\nexport function exportABTestResults(\n  results: ABTestResult[],\n  filename: string\n): void {\n  const jsonData = JSON.stringify(results, null, 2);\n  \n  // In Node.js environment, would write to file\n  // For browser, return data for download\n  if (typeof window !== 'undefined') {\n    const blob = new Blob([jsonData], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n}\n\nexport default {\n  runSingleABTest,\n  runBatchABTest,\n  calculateABTestStatistics,\n  generateABTestReport,\n  exportABTestResults,\n};\n";export{e as default};
