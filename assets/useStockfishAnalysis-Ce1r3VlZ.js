const n="/**\n * React Hook for Stockfish Analysis\n * \n * Provides easy-to-use Stockfish integration for React components.\n * Handles engine lifecycle, analysis state, and cleanup.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  StockfishEngine, \n  getStockfishEngine, \n  PositionAnalysis, \n  GameAnalysis, \n  MoveAnalysis \n} from '@/lib/chess/stockfishEngine';\n\nexport interface UseStockfishAnalysisReturn {\n  // Engine state\n  isReady: boolean;\n  isAnalyzing: boolean;\n  error: string | null;\n  \n  // Analysis functions\n  analyzePosition: (fen: string, depth?: number) => Promise<PositionAnalysis | null>;\n  analyzeGame: (pgn: string, depth?: number) => Promise<GameAnalysis | null>;\n  evaluateMove: (fen: string, move: string, depth?: number) => Promise<{\n    cpLoss: number;\n    accuracy: number;\n    wasBest: boolean;\n    bestMove: string;\n  } | null>;\n  quickEval: (fen: string) => Promise<number | null>;\n  stopAnalysis: () => void;\n  \n  // Analysis results\n  currentAnalysis: PositionAnalysis | null;\n  gameAnalysis: GameAnalysis | null;\n  progress: { current: number; total: number } | null;\n  \n  // Engine info\n  engineVersion: string;\n  loadingProgress: number;\n}\n\nexport function useStockfishAnalysis(): UseStockfishAnalysisReturn {\n  const [isReady, setIsReady] = useState(false);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [currentAnalysis, setCurrentAnalysis] = useState<PositionAnalysis | null>(null);\n  const [gameAnalysis, setGameAnalysis] = useState<GameAnalysis | null>(null);\n  const [progress, setProgress] = useState<{ current: number; total: number } | null>(null);\n  const [engineVersion, setEngineVersion] = useState('Stockfish 17.1 WASM');\n  const [loadingProgress, setLoadingProgress] = useState(0);\n  \n  const engineRef = useRef<StockfishEngine | null>(null);\n  const mountedRef = useRef(true);\n  const initAttemptRef = useRef(0);\n\n  // Initialize engine on mount with retry logic\n  useEffect(() => {\n    mountedRef.current = true;\n    \n    const initEngine = async () => {\n      try {\n        console.log('[StockfishHook] Starting engine initialization...');\n        setLoadingProgress(10);\n        \n        const engine = getStockfishEngine();\n        engineRef.current = engine;\n        setLoadingProgress(30);\n        \n        // Poll for readiness with progress updates\n        const ready = await engine.waitReady((progress) => {\n          if (mountedRef.current) {\n            setLoadingProgress(30 + Math.floor(progress * 70));\n          }\n        });\n        \n        if (mountedRef.current) {\n          setIsReady(ready);\n          setLoadingProgress(100);\n          \n          if (ready) {\n            console.log('[StockfishHook] Engine ready!');\n            setEngineVersion('Stockfish 17.1 WASM');\n          } else {\n            // Retry once after a short delay\n            initAttemptRef.current++;\n            if (initAttemptRef.current < 2) {\n              console.log('[StockfishHook] Retrying initialization...');\n              setTimeout(initEngine, 1000);\n            } else {\n              setError('Stockfish failed to initialize after retries');\n            }\n          }\n        }\n      } catch (e) {\n        console.error('[StockfishHook] Init error:', e);\n        if (mountedRef.current) {\n          setError(e instanceof Error ? e.message : 'Unknown error');\n        }\n      }\n    };\n    \n    initEngine();\n    \n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n\n  // Analyze a single position\n  const analyzePosition = useCallback(async (fen: string, depth = 20): Promise<PositionAnalysis | null> => {\n    if (!engineRef.current || !isReady) {\n      setError('Engine not ready');\n      return null;\n    }\n    \n    setIsAnalyzing(true);\n    setError(null);\n    \n    try {\n      const analysis = await engineRef.current.analyzePosition(fen, { depth });\n      if (mountedRef.current) {\n        setCurrentAnalysis(analysis);\n        setIsAnalyzing(false);\n      }\n      return analysis;\n    } catch (e) {\n      if (mountedRef.current) {\n        setError(e instanceof Error ? e.message : 'Analysis failed');\n        setIsAnalyzing(false);\n      }\n      return null;\n    }\n  }, [isReady]);\n\n  // Analyze a full game\n  const analyzeGame = useCallback(async (pgn: string, depth = 15): Promise<GameAnalysis | null> => {\n    if (!engineRef.current || !isReady) {\n      setError('Engine not ready');\n      return null;\n    }\n    \n    setIsAnalyzing(true);\n    setError(null);\n    setProgress({ current: 0, total: 0 });\n    \n    try {\n      const analysis = await engineRef.current.analyzeGame(pgn, {\n        depth,\n        onProgress: (current, total) => {\n          if (mountedRef.current) {\n            setProgress({ current, total });\n          }\n        },\n      });\n      \n      if (mountedRef.current) {\n        setGameAnalysis(analysis);\n        setIsAnalyzing(false);\n        setProgress(null);\n      }\n      return analysis;\n    } catch (e) {\n      if (mountedRef.current) {\n        setError(e instanceof Error ? e.message : 'Analysis failed');\n        setIsAnalyzing(false);\n        setProgress(null);\n      }\n      return null;\n    }\n  }, [isReady]);\n\n  // Evaluate a specific move\n  const evaluateMove = useCallback(async (\n    fen: string, \n    move: string, \n    depth = 15\n  ): Promise<{ cpLoss: number; accuracy: number; wasBest: boolean; bestMove: string } | null> => {\n    if (!engineRef.current || !isReady) {\n      return null;\n    }\n    \n    try {\n      return await engineRef.current.evaluateMove(fen, move, depth);\n    } catch (e) {\n      setError(e instanceof Error ? e.message : 'Evaluation failed');\n      return null;\n    }\n  }, [isReady]);\n\n  // Quick evaluation (low depth, fast)\n  const quickEval = useCallback(async (fen: string): Promise<number | null> => {\n    if (!engineRef.current || !isReady) {\n      return null;\n    }\n    \n    try {\n      return await engineRef.current.quickEval(fen);\n    } catch (e) {\n      return null;\n    }\n  }, [isReady]);\n\n  // Stop current analysis\n  const stopAnalysis = useCallback(() => {\n    if (engineRef.current) {\n      engineRef.current.stop();\n    }\n    setIsAnalyzing(false);\n  }, []);\n\n  return {\n    isReady,\n    isAnalyzing,\n    error,\n    analyzePosition,\n    analyzeGame,\n    evaluateMove,\n    quickEval,\n    stopAnalysis,\n    currentAnalysis,\n    gameAnalysis,\n    progress,\n    engineVersion,\n    loadingProgress,\n  };\n}\n\n// ===================== UTILITY FUNCTIONS =====================\n\n/**\n * Convert centipawn score to human-readable evaluation\n */\nexport function formatEvaluation(cp: number, isMate: boolean = false, mateIn?: number): string {\n  if (isMate && mateIn !== undefined) {\n    return mateIn > 0 ? `M${mateIn}` : `-M${Math.abs(mateIn)}`;\n  }\n  \n  const score = cp / 100;\n  if (score > 0) {\n    return `+${score.toFixed(2)}`;\n  }\n  return score.toFixed(2);\n}\n\n/**\n * Get evaluation bar percentage (for UI)\n */\nexport function getEvalBarPercent(cp: number): number {\n  // Clamp to reasonable range and convert to percentage\n  // +1000cp = 90%, -1000cp = 10%, 0 = 50%\n  const clamped = Math.max(-1000, Math.min(1000, cp));\n  return 50 + (clamped / 1000) * 40;\n}\n\n/**\n * Classify move quality based on centipawn loss\n */\nexport function classifyMoveQuality(cpLoss: number): {\n  quality: 'brilliant' | 'great' | 'best' | 'good' | 'inaccuracy' | 'mistake' | 'blunder';\n  color: string;\n  symbol: string;\n} {\n  if (cpLoss < 0) {\n    return { quality: 'brilliant', color: '#26C9A2', symbol: '!!' };\n  }\n  if (cpLoss <= 5) {\n    return { quality: 'best', color: '#96BC4B', symbol: '✓' };\n  }\n  if (cpLoss <= 15) {\n    return { quality: 'great', color: '#81B64C', symbol: '!' };\n  }\n  if (cpLoss <= 30) {\n    return { quality: 'good', color: '#A3A3A3', symbol: '○' };\n  }\n  if (cpLoss <= 75) {\n    return { quality: 'inaccuracy', color: '#F7C631', symbol: '?!' };\n  }\n  if (cpLoss <= 200) {\n    return { quality: 'mistake', color: '#E58F2A', symbol: '?' };\n  }\n  return { quality: 'blunder', color: '#CA3431', symbol: '??' };\n}\n";export{n as default};
