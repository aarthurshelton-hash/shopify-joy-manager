const n="/**\n * Universal Prediction Hook\n * \n * React hook that provides unified access to the complete\n * En Pensent prediction system with real-time synchronization\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { unifiedSynchronizer, type SynchronizationState } from '@/lib/pensent-core/domains/universal/unifiedSynchronizer';\nimport { crossDomainEngine } from '@/lib/pensent-core/domains/universal/crossDomainEngine';\nimport { selfEvolvingSystem } from '@/lib/pensent-core/domains/finance/selfEvolvingSystem';\nimport type { UnifiedPrediction, DomainType, CrossDomainCorrelation } from '@/lib/pensent-core/domains/universal/types';\nimport type { MarketConditions } from '@/lib/pensent-core/domains/finance/evolution/types';\n\nexport interface UniversalPredictionState {\n  isInitialized: boolean;\n  isCalibrating: boolean;\n  calibrationProgress: number;\n  \n  // Current prediction\n  currentPrediction: UnifiedPrediction | null;\n  \n  // System health\n  syncState: SynchronizationState | null;\n  \n  // Domain insights\n  domainRankings: Array<{ domain: DomainType; accuracy: number; contribution: number }>;\n  topCorrelations: CrossDomainCorrelation[];\n  \n  // Evolution metrics\n  generation: number;\n  fitness: number;\n  velocity: number;\n}\n\nexport function useUniversalPrediction() {\n  const [state, setState] = useState<UniversalPredictionState>({\n    isInitialized: false,\n    isCalibrating: true,\n    calibrationProgress: 0,\n    currentPrediction: null,\n    syncState: null,\n    domainRankings: [],\n    topCorrelations: [],\n    generation: 1,\n    fitness: 0.5,\n    velocity: 0,\n  });\n  \n  const predictionIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  \n  // Initialize the universal system\n  useEffect(() => {\n    let mounted = true;\n    \n    const init = async () => {\n      try {\n        await unifiedSynchronizer.initialize();\n        \n        if (!mounted) return;\n        \n        setState(prev => ({\n          ...prev,\n          isInitialized: true,\n          isCalibrating: false,\n          calibrationProgress: 1,\n        }));\n      } catch (err) {\n        console.error('[useUniversalPrediction] Initialization failed:', err);\n      }\n    };\n    \n    init();\n    \n    return () => {\n      mounted = false;\n    };\n  }, []);\n  \n  // Subscribe to synchronization updates\n  useEffect(() => {\n    const unsubscribe = unifiedSynchronizer.subscribe((syncState) => {\n      setState(prev => ({\n        ...prev,\n        syncState,\n      }));\n    });\n    \n    return unsubscribe;\n  }, []);\n  \n  // Update rankings and correlations periodically\n  useEffect(() => {\n    const updateInterval = setInterval(() => {\n      const domainRankings = crossDomainEngine.getDomainRankings();\n      const topCorrelations = crossDomainEngine.getTopCorrelations(5);\n      const evolutionSummary = selfEvolvingSystem.getEvolutionSummary();\n      \n      setState(prev => ({\n        ...prev,\n        domainRankings,\n        topCorrelations,\n        generation: evolutionSummary.generation,\n        fitness: evolutionSummary.fitness,\n        velocity: evolutionSummary.velocity,\n      }));\n    }, 2000);\n    \n    return () => clearInterval(updateInterval);\n  }, []);\n  \n  /**\n   * Generate a prediction for market data\n   */\n  const predict = useCallback((\n    symbol: string,\n    momentum: number,\n    volatility: number,\n    volume: number,\n    direction: number\n  ): UnifiedPrediction | null => {\n    if (!state.isInitialized) return null;\n    \n    const prediction = unifiedSynchronizer.processMarketPrediction(\n      symbol,\n      momentum,\n      volatility,\n      volume,\n      direction\n    );\n    \n    setState(prev => ({\n      ...prev,\n      currentPrediction: prediction,\n    }));\n    \n    return prediction;\n  }, [state.isInitialized]);\n  \n  /**\n   * Record the outcome of a prediction\n   */\n  const recordOutcome = useCallback((\n    prediction: UnifiedPrediction,\n    actualDirection: 'up' | 'down' | 'neutral',\n    actualMagnitude: number,\n    conditions: MarketConditions\n  ): void => {\n    unifiedSynchronizer.recordOutcome(\n      prediction,\n      actualDirection,\n      actualMagnitude,\n      conditions\n    );\n  }, []);\n  \n  /**\n   * Start continuous prediction for a symbol\n   */\n  const startContinuousPrediction = useCallback((\n    symbol: string,\n    getMarketData: () => { momentum: number; volatility: number; volume: number; direction: number },\n    intervalMs = 1000\n  ): void => {\n    // Clear any existing interval\n    if (predictionIntervalRef.current) {\n      clearInterval(predictionIntervalRef.current);\n    }\n    \n    predictionIntervalRef.current = setInterval(() => {\n      const data = getMarketData();\n      predict(symbol, data.momentum, data.volatility, data.volume, data.direction);\n    }, intervalMs);\n  }, [predict]);\n  \n  /**\n   * Stop continuous prediction\n   */\n  const stopContinuousPrediction = useCallback((): void => {\n    if (predictionIntervalRef.current) {\n      clearInterval(predictionIntervalRef.current);\n      predictionIntervalRef.current = null;\n    }\n  }, []);\n  \n  /**\n   * Get full system summary\n   */\n  const getSystemSummary = useCallback(() => {\n    return unifiedSynchronizer.getSystemSummary();\n  }, []);\n  \n  /**\n   * Record a healing success (for auto-heal integration)\n   */\n  const recordHealingSuccess = useCallback(() => {\n    unifiedSynchronizer.recordHealingSuccess();\n  }, []);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopContinuousPrediction();\n    };\n  }, [stopContinuousPrediction]);\n  \n  return {\n    ...state,\n    predict,\n    recordOutcome,\n    startContinuousPrediction,\n    stopContinuousPrediction,\n    getSystemSummary,\n    recordHealingSuccess,\n  };\n}\n";export{n as default};
