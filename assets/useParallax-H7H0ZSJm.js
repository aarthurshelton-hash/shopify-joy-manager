const n="import { useState, useEffect, useCallback, useRef, RefObject } from 'react';\n\ninterface ParallaxOptions {\n  speed?: number; // 0.1 = slow, 0.5 = medium, 1 = same as scroll\n  direction?: 'up' | 'down';\n}\n\nexport function useParallax(\n  ref: RefObject<HTMLElement>,\n  options: ParallaxOptions = {}\n) {\n  const { speed = 0.3, direction = 'up' } = options;\n  const [offset, setOffset] = useState(0);\n  const rafRef = useRef<number | null>(null);\n  const lastOffsetRef = useRef(0);\n\n  const handleScroll = useCallback(() => {\n    // Cancel any pending frame\n    if (rafRef.current) {\n      cancelAnimationFrame(rafRef.current);\n    }\n    \n    rafRef.current = requestAnimationFrame(() => {\n      if (!ref.current) return;\n      \n      const rect = ref.current.getBoundingClientRect();\n      const windowHeight = window.innerHeight;\n      \n      // Calculate how far the element is from the center of the viewport\n      const elementCenter = rect.top + rect.height / 2;\n      const viewportCenter = windowHeight / 2;\n      const distanceFromCenter = elementCenter - viewportCenter;\n      \n      // Apply parallax based on distance from center\n      const parallaxOffset = Math.round(distanceFromCenter * speed * (direction === 'up' ? 1 : -1));\n      \n      // Only update state if offset changed significantly (reduces re-renders)\n      if (Math.abs(parallaxOffset - lastOffsetRef.current) > 0.5) {\n        lastOffsetRef.current = parallaxOffset;\n        setOffset(parallaxOffset);\n      }\n    });\n  }, [ref, speed, direction]);\n\n  useEffect(() => {\n    window.addEventListener('scroll', handleScroll, { passive: true });\n    handleScroll(); // Initial calculation\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n    };\n  }, [handleScroll]);\n\n  return offset;\n}\n\n// Simpler hook that just tracks scroll position with throttling\nexport function useScrollY() {\n  const [scrollY, setScrollY] = useState(0);\n  const rafRef = useRef<number | null>(null);\n  const lastScrollRef = useRef(0);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      \n      rafRef.current = requestAnimationFrame(() => {\n        const currentScroll = window.scrollY;\n        // Only update if scroll changed by at least 1px\n        if (Math.abs(currentScroll - lastScrollRef.current) >= 1) {\n          lastScrollRef.current = currentScroll;\n          setScrollY(currentScroll);\n        }\n      });\n    };\n\n    window.addEventListener('scroll', handleScroll, { passive: true });\n    handleScroll();\n\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n    };\n  }, []);\n\n  return scrollY;\n}\n";export{n as default};
