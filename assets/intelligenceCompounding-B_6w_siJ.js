const e="/**\n * Intelligence Compounding System v7.70\n * \n * UNIFIED LEARNING BOOST:\n * 1. Live Confidence Calibration - dynamically adjust based on rolling accuracy\n * 2. Disagreement Amplifier - boost archetypes when we beat Stockfish\n * 3. Temporal Decay Weighting - recent predictions count more than older ones\n * \n * This ensures En Pensent gets SMARTER with every prediction.\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport { StrategicArchetype } from '../colorFlowAnalysis';\n\n// ============= LIVE TRACKING STATE =============\n\ninterface ArchetypeStats {\n  totalPredictions: number;\n  correctPredictions: number;\n  recentPredictions: Array<{ correct: boolean; timestamp: number; weight: number }>;\n  disagreementWins: number;  // Times we beat Stockfish\n  disagreementLosses: number; // Times Stockfish beat us\n  boostMultiplier: number;  // Current confidence boost (1.0 = neutral)\n}\n\ninterface CompoundingState {\n  archetypes: Map<StrategicArchetype, ArchetypeStats>;\n  lastDatabaseSync: number;\n  globalAccuracy: number;\n  globalDisagreementWinRate: number;\n  initialized: boolean;\n}\n\nconst DECAY_HALF_LIFE_HOURS = 24; // Recent predictions decay over 24 hours\nconst ROLLING_WINDOW_SIZE = 100; // Track last 100 predictions per archetype\nconst DISAGREEMENT_BOOST_FACTOR = 0.15; // 15% boost per disagreement win\nconst MAX_BOOST = 1.5; // Cap boost at 50% increase\nconst MIN_BOOST = 0.7; // Minimum 30% reduction for poor performers\n\nconst state: CompoundingState = {\n  archetypes: new Map(),\n  lastDatabaseSync: 0,\n  globalAccuracy: 0.333, // Start at random baseline\n  globalDisagreementWinRate: 0,\n  initialized: false,\n};\n\n// ============= TEMPORAL DECAY WEIGHTING =============\n\n/**\n * Calculate weight for a prediction based on age (exponential decay)\n * Recent predictions matter more than older ones\n */\nfunction calculateTemporalWeight(timestampMs: number): number {\n  const ageHours = (Date.now() - timestampMs) / (1000 * 60 * 60);\n  // Exponential decay: weight = 0.5^(age/halfLife)\n  return Math.pow(0.5, ageHours / DECAY_HALF_LIFE_HOURS);\n}\n\n/**\n * Calculate weighted accuracy from recent predictions\n */\nfunction calculateWeightedAccuracy(predictions: Array<{ correct: boolean; timestamp: number; weight: number }>): number {\n  if (predictions.length === 0) return 0.333; // Random baseline\n  \n  let weightedCorrect = 0;\n  let totalWeight = 0;\n  \n  for (const pred of predictions) {\n    const weight = calculateTemporalWeight(pred.timestamp);\n    weightedCorrect += pred.correct ? weight : 0;\n    totalWeight += weight;\n  }\n  \n  return totalWeight > 0 ? weightedCorrect / totalWeight : 0.333;\n}\n\n// ============= DISAGREEMENT AMPLIFIER =============\n\n/**\n * Record a disagreement outcome (when En Pensent and Stockfish disagree)\n * If we were right, boost the archetype's confidence\n */\nexport function recordDisagreement(\n  archetype: StrategicArchetype,\n  enPensentCorrect: boolean,\n  stockfishCorrect: boolean\n): void {\n  const stats = getOrCreateArchetypeStats(archetype);\n  \n  // Only count when they actually disagreed\n  if (enPensentCorrect === stockfishCorrect) return;\n  \n  if (enPensentCorrect && !stockfishCorrect) {\n    // WE WON! Boost this archetype\n    stats.disagreementWins++;\n    stats.boostMultiplier = Math.min(\n      MAX_BOOST,\n      stats.boostMultiplier + DISAGREEMENT_BOOST_FACTOR\n    );\n    console.log(`[Intelligence] ✨ ${archetype} beat Stockfish! Boost: ${(stats.boostMultiplier * 100).toFixed(0)}%`);\n  } else {\n    // Stockfish won - slight penalty\n    stats.disagreementLosses++;\n    stats.boostMultiplier = Math.max(\n      MIN_BOOST,\n      stats.boostMultiplier - (DISAGREEMENT_BOOST_FACTOR / 2)\n    );\n  }\n  \n  state.archetypes.set(archetype, stats);\n}\n\n/**\n * Get the current boost multiplier for an archetype\n */\nexport function getArchetypeBoost(archetype: StrategicArchetype): number {\n  const stats = state.archetypes.get(archetype);\n  return stats?.boostMultiplier ?? 1.0;\n}\n\n// ============= LIVE CONFIDENCE CALIBRATION =============\n\n/**\n * Record a prediction outcome for live calibration\n */\nexport function recordPredictionOutcome(\n  archetype: StrategicArchetype,\n  wasCorrect: boolean,\n  enPensentCorrect?: boolean,\n  stockfishCorrect?: boolean\n): void {\n  const stats = getOrCreateArchetypeStats(archetype);\n  \n  // Add to rolling window\n  stats.recentPredictions.push({\n    correct: wasCorrect,\n    timestamp: Date.now(),\n    weight: 1.0, // Will be recalculated dynamically\n  });\n  \n  // Maintain window size\n  if (stats.recentPredictions.length > ROLLING_WINDOW_SIZE) {\n    stats.recentPredictions.shift();\n  }\n  \n  // Update totals\n  stats.totalPredictions++;\n  if (wasCorrect) stats.correctPredictions++;\n  \n  state.archetypes.set(archetype, stats);\n  \n  // Record disagreement if both outcomes provided\n  if (enPensentCorrect !== undefined && stockfishCorrect !== undefined) {\n    recordDisagreement(archetype, enPensentCorrect, stockfishCorrect);\n  }\n}\n\n/**\n * Get live-calibrated confidence for an archetype\n * Returns a multiplier to apply to base confidence\n */\nexport function getLiveConfidenceMultiplier(archetype: StrategicArchetype): number {\n  const stats = state.archetypes.get(archetype);\n  \n  if (!stats || stats.recentPredictions.length < 5) {\n    // Not enough data - return neutral\n    return 1.0;\n  }\n  \n  // Calculate weighted accuracy (recent predictions count more)\n  const weightedAccuracy = calculateWeightedAccuracy(stats.recentPredictions);\n  \n  // Calculate adjustment: if we're beating baseline (33.3%), boost confidence\n  const baseline = 0.333;\n  const delta = weightedAccuracy - baseline;\n  \n  // Scale: +16.7% accuracy (50% total) = +25% confidence multiplier\n  // Cap at ±50% adjustment\n  const adjustment = Math.max(-0.5, Math.min(0.5, delta * 1.5));\n  \n  return 1.0 + adjustment;\n}\n\n/**\n * Get comprehensive calibrated confidence for a prediction\n * Combines: live calibration × disagreement boost × temporal decay\n */\nexport function getCalibratedConfidence(\n  archetype: StrategicArchetype,\n  baseConfidence: number\n): { confidence: number; factors: string[] } {\n  const factors: string[] = [];\n  let finalConfidence = baseConfidence;\n  \n  // 1. Live calibration multiplier\n  const liveMultiplier = getLiveConfidenceMultiplier(archetype);\n  finalConfidence *= liveMultiplier;\n  if (liveMultiplier !== 1.0) {\n    factors.push(`Live calibration: ${liveMultiplier > 1 ? '+' : ''}${((liveMultiplier - 1) * 100).toFixed(0)}%`);\n  }\n  \n  // 2. Disagreement boost\n  const boost = getArchetypeBoost(archetype);\n  finalConfidence *= boost;\n  if (boost !== 1.0) {\n    factors.push(`Disagreement boost: ${boost > 1 ? '+' : ''}${((boost - 1) * 100).toFixed(0)}%`);\n  }\n  \n  // 3. Sample size confidence\n  const stats = state.archetypes.get(archetype);\n  if (stats && stats.totalPredictions > 50) {\n    factors.push(`${stats.totalPredictions} historical samples`);\n  }\n  \n  // Cap at reasonable bounds\n  finalConfidence = Math.max(10, Math.min(95, finalConfidence));\n  \n  return { confidence: finalConfidence, factors };\n}\n\n// ============= DATABASE SYNC =============\n\n/**\n * Initialize from database on first load\n */\nexport async function initializeFromDatabase(): Promise<void> {\n  if (state.initialized) return;\n  \n  console.log('[Intelligence] Initializing compounding system from database...');\n  \n  try {\n    // Load archetype performance data\n    const { data, error } = await supabase\n      .from('chess_prediction_attempts')\n      .select('hybrid_archetype, hybrid_correct, stockfish_correct, created_at')\n      .order('created_at', { ascending: false })\n      .limit(5000);\n    \n    if (error) {\n      console.error('[Intelligence] Database load error:', error);\n      state.initialized = true;\n      return;\n    }\n    \n    if (!data || data.length === 0) {\n      console.log('[Intelligence] No historical data found');\n      state.initialized = true;\n      return;\n    }\n    \n    // Process historical data\n    let totalCorrect = 0;\n    let totalDisagreementWins = 0;\n    let totalDisagreements = 0;\n    \n    for (const record of data) {\n      const archetype = normalizeArchetype(record.hybrid_archetype);\n      if (!archetype) continue;\n      \n      const stats = getOrCreateArchetypeStats(archetype);\n      const timestamp = new Date(record.created_at).getTime();\n      \n      // Add to predictions\n      stats.recentPredictions.push({\n        correct: record.hybrid_correct ?? false,\n        timestamp,\n        weight: calculateTemporalWeight(timestamp),\n      });\n      \n      // Keep only most recent within window\n      if (stats.recentPredictions.length > ROLLING_WINDOW_SIZE) {\n        stats.recentPredictions.shift();\n      }\n      \n      stats.totalPredictions++;\n      if (record.hybrid_correct) {\n        stats.correctPredictions++;\n        totalCorrect++;\n      }\n      \n      // Track disagreements\n      if (record.hybrid_correct !== record.stockfish_correct) {\n        totalDisagreements++;\n        if (record.hybrid_correct && !record.stockfish_correct) {\n          stats.disagreementWins++;\n          totalDisagreementWins++;\n        } else {\n          stats.disagreementLosses++;\n        }\n      }\n      \n      // Calculate boost multiplier from disagreement ratio\n      if (stats.disagreementWins + stats.disagreementLosses > 0) {\n        const ratio = stats.disagreementWins / (stats.disagreementWins + stats.disagreementLosses);\n        stats.boostMultiplier = MIN_BOOST + (MAX_BOOST - MIN_BOOST) * ratio;\n      }\n      \n      state.archetypes.set(archetype, stats);\n    }\n    \n    state.globalAccuracy = data.length > 0 ? totalCorrect / data.length : 0.333;\n    state.globalDisagreementWinRate = totalDisagreements > 0 \n      ? totalDisagreementWins / totalDisagreements \n      : 0;\n    state.lastDatabaseSync = Date.now();\n    state.initialized = true;\n    \n    console.log(`[Intelligence] Initialized with ${data.length} predictions:`);\n    console.log(`  - Global accuracy: ${(state.globalAccuracy * 100).toFixed(1)}%`);\n    console.log(`  - Disagreement win rate: ${(state.globalDisagreementWinRate * 100).toFixed(1)}%`);\n    console.log(`  - Archetypes tracked: ${state.archetypes.size}`);\n    \n  } catch (err) {\n    console.error('[Intelligence] Initialization error:', err);\n    state.initialized = true;\n  }\n}\n\n// ============= INTELLIGENCE METRICS =============\n\n/**\n * Get current intelligence metrics for display\n */\nexport function getIntelligenceMetrics(): {\n  globalAccuracy: number;\n  globalDisagreementWinRate: number;\n  archetypeCount: number;\n  topPerformers: Array<{ archetype: string; accuracy: number; boost: number }>;\n  isLearning: boolean;\n} {\n  const topPerformers: Array<{ archetype: string; accuracy: number; boost: number }> = [];\n  \n  for (const [archetype, stats] of state.archetypes) {\n    if (stats.totalPredictions >= 10) {\n      topPerformers.push({\n        archetype,\n        accuracy: stats.correctPredictions / stats.totalPredictions,\n        boost: stats.boostMultiplier,\n      });\n    }\n  }\n  \n  // Sort by accuracy\n  topPerformers.sort((a, b) => b.accuracy - a.accuracy);\n  \n  return {\n    globalAccuracy: state.globalAccuracy,\n    globalDisagreementWinRate: state.globalDisagreementWinRate,\n    archetypeCount: state.archetypes.size,\n    topPerformers: topPerformers.slice(0, 5),\n    isLearning: state.initialized && state.archetypes.size > 0,\n  };\n}\n\n// ============= HELPER FUNCTIONS =============\n\nfunction getOrCreateArchetypeStats(archetype: StrategicArchetype): ArchetypeStats {\n  let stats = state.archetypes.get(archetype);\n  \n  if (!stats) {\n    stats = {\n      totalPredictions: 0,\n      correctPredictions: 0,\n      recentPredictions: [],\n      disagreementWins: 0,\n      disagreementLosses: 0,\n      boostMultiplier: 1.0,\n    };\n    state.archetypes.set(archetype, stats);\n  }\n  \n  return stats;\n}\n\nfunction normalizeArchetype(raw: string | null): StrategicArchetype | null {\n  if (!raw) return null;\n  \n  const validArchetypes: StrategicArchetype[] = [\n    'kingside_attack', 'queenside_expansion', 'central_domination',\n    'prophylactic_defense', 'pawn_storm', 'piece_harmony',\n    'opposite_castling', 'closed_maneuvering', 'open_tactical',\n    'endgame_technique', 'sacrificial_attack', 'positional_squeeze',\n    'unknown',\n  ];\n  \n  const lower = raw.toLowerCase().replace(/\\s+/g, '_');\n  \n  if (validArchetypes.includes(lower as StrategicArchetype)) {\n    return lower as StrategicArchetype;\n  }\n  \n  // Fuzzy match\n  for (const valid of validArchetypes) {\n    if (lower.includes(valid) || valid.includes(lower)) {\n      return valid;\n    }\n  }\n  \n  return 'unknown';\n}\n\n// ============= EXPORTS =============\n\nexport { state as compoundingState };\n";export{e as default};
