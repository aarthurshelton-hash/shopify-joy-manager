const n="/**\n * Maximum Depth Stockfish Analysis\n * \n * CRITICAL METHODOLOGY NOTE:\n * ===========================\n * This module provides the SAME Stockfish engine to BOTH sides of the benchmark:\n * \n * 1. PURE STOCKFISH: Raw tactical centipawn evaluation only\n * 2. EN PENSENT HYBRID: Stockfish evaluation + Temporal Pattern Recognition\n * \n * We are NOT testing \"better Stockfish vs worse Stockfish\".\n * We are testing whether ADDING En Pensent's pattern wavelength recognition\n * to the SAME Stockfish evaluation produces better predictions.\n * \n * The hypothesis: Pure calculation misses strategic patterns that\n * En Pensent's temporal signature analysis can detect.\n * \n * Engine: Stockfish 10 ASM.js (~ELO 3000)\n * This provides the tactical baseline for both benchmark sides.\n */\n\nimport { getStockfishEngine, type PositionAnalysis } from './stockfishEngine';\n\nexport interface MaxDepthConfig {\n  depth: number;           // Target depth (default 40 for championship level)\n  maxTime?: number;        // Max time in ms (fallback limit)\n  nodes?: number;          // Node limit (optional)\n}\n\nexport interface MaxDepthResult {\n  evaluation: number;      // Centipawns\n  depth: number;           // Actual depth reached\n  nodes: number;           // Nodes searched\n  timeMs: number;          // Time taken\n  bestMove: string;\n  pv: string[];            // Principal variation\n  isMaxCapacity: boolean;  // True if we hit target depth\n  mateIn?: number;\n}\n\n// Default maximum capacity settings\nexport const MAX_CAPACITY_CONFIG: MaxDepthConfig = {\n  depth: 40,               // Championship-level analysis\n  maxTime: 30000,          // 30 second max\n  nodes: 100000000,        // 100M nodes limit\n};\n\n// Quick but still strong settings\nexport const HIGH_DEPTH_CONFIG: MaxDepthConfig = {\n  depth: 30,               // Strong but faster\n  maxTime: 10000,          // 10 second max\n  nodes: 10000000,         // 10M nodes limit\n};\n\n// Benchmark comparison settings (matching cloud depth)\nexport const BENCHMARK_CONFIG: MaxDepthConfig = {\n  depth: 25,               // Matches typical cloud depth\n  maxTime: 5000,           // 5 second max\n  nodes: 5000000,          // 5M nodes\n};\n\n/**\n * Analyze position with maximum depth Stockfish\n * This is TRUE Stockfish analysis, not cached cloud evaluations\n */\nexport async function analyzeWithMaxDepth(\n  fen: string,\n  config: MaxDepthConfig = BENCHMARK_CONFIG\n): Promise<MaxDepthResult> {\n  const startTime = Date.now();\n  \n  const engine = getStockfishEngine();\n  await engine.waitReady();\n  \n  // Use depth-based analysis for true maximum capacity\n  const analysis = await engine.analyzePosition(fen, {\n    depth: config.depth,\n    nodes: config.nodes,\n  });\n  \n  const timeMs = Date.now() - startTime;\n  \n  return {\n    evaluation: analysis.evaluation.score,\n    depth: analysis.evaluation.depth,\n    nodes: analysis.evaluation.nodes,\n    timeMs,\n    bestMove: analysis.bestMove,\n    pv: analysis.evaluation.pv,\n    isMaxCapacity: analysis.evaluation.depth >= config.depth,\n    mateIn: analysis.evaluation.mateIn,\n  };\n}\n\n/**\n * Compare Cloud eval vs Local Max-Depth eval for transparency\n */\nexport interface EvalComparison {\n  cloudEval: number | null;\n  cloudDepth: number | null;\n  localEval: number;\n  localDepth: number;\n  localNodes: number;\n  timeMs: number;\n  difference: number;        // Centipawn difference\n  agreement: boolean;        // Both predict same winner\n  isLocalMaxCapacity: boolean;\n}\n\n/**\n * Get both Cloud and Local evaluations for comparison\n */\nexport async function compareEvaluations(\n  fen: string,\n  cloudResult: { evaluation: number; depth: number } | null,\n  config: MaxDepthConfig = BENCHMARK_CONFIG\n): Promise<EvalComparison> {\n  const local = await analyzeWithMaxDepth(fen, config);\n  \n  const cloudEval = cloudResult?.evaluation ?? null;\n  const cloudDepth = cloudResult?.depth ?? null;\n  \n  const difference = cloudEval !== null \n    ? Math.abs(local.evaluation - cloudEval)\n    : 0;\n  \n  const cloudPrediction = cloudEval !== null \n    ? (cloudEval > 100 ? 'white' : cloudEval < -100 ? 'black' : 'draw')\n    : null;\n  const localPrediction = local.evaluation > 100 ? 'white' : local.evaluation < -100 ? 'black' : 'draw';\n  \n  return {\n    cloudEval,\n    cloudDepth,\n    localEval: local.evaluation,\n    localDepth: local.depth,\n    localNodes: local.nodes,\n    timeMs: local.timeMs,\n    difference,\n    agreement: cloudPrediction === localPrediction,\n    isLocalMaxCapacity: local.isMaxCapacity,\n  };\n}\n\n/**\n * Calculate implied ELO from depth and accuracy\n * Based on: Higher depth + better predictions = higher effective ELO\n */\nexport function calculateImpliedElo(\n  depth: number,\n  accuracy: number,\n  nodes: number\n): number {\n  // Base ELO from depth (each depth level ~= 50 ELO up to diminishing returns)\n  const depthElo = Math.min(depth * 50, 2000);\n  \n  // Accuracy bonus (100% accuracy = +800 ELO)\n  const accuracyElo = (accuracy / 100) * 800;\n  \n  // Nodes bonus (logarithmic scale, 100M nodes = +400 ELO)\n  const nodesElo = Math.min(Math.log10(nodes + 1) * 50, 400);\n  \n  // Base NNUE ELO (~3200)\n  const baseElo = 1800;\n  \n  return Math.round(baseElo + depthElo + accuracyElo + nodesElo);\n}\n\n/**\n * Format depth info for display\n */\nexport function formatDepthInfo(result: MaxDepthResult): string {\n  const millions = (result.nodes / 1000000).toFixed(1);\n  const capacity = result.isMaxCapacity ? 'MAX' : 'PARTIAL';\n  return `Depth ${result.depth} / ${millions}M nodes / ${result.timeMs}ms [${capacity}]`;\n}\n";export{n as default};
