const e="/**\n * Palette Availability Checker\n * \n * Checks which color palettes are available or taken for a given game (PGN).\n * Shows users if a game+palette combo is already owned and by whom.\n * Uses enhanced palette detection to identify palettes even when pieces didn't move.\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport { colorPalettes, PaletteId } from '@/lib/chess/pieceColors';\nimport { extractPaletteId } from '@/lib/marketplace/paletteArtMap';\n\nexport interface PaletteAvailabilityInfo {\n  paletteId: PaletteId;\n  paletteName: string;\n  isTaken: boolean;\n  ownerDisplayName?: string;\n  ownerUserId?: string;\n  visualizationId?: string;\n  isListedForSale: boolean;\n  listingPriceCents?: number;\n  isOwnedByCurrentUser: boolean;\n}\n\nexport interface GamePaletteAvailability {\n  availablePalettes: PaletteAvailabilityInfo[];\n  takenPalettes: PaletteAvailabilityInfo[];\n  totalAvailable: number;\n  totalTaken: number;\n}\n\n/**\n * Normalize PGN for comparison\n */\nfunction normalizePgn(pgn: string): string {\n  return pgn\n    .replace(/\\{[^}]*\\}/g, '') // Remove comments\n    .replace(/\\([^)]*\\)/g, '') // Remove variations\n    .replace(/\\s+/g, ' ')      // Normalize whitespace\n    .replace(/\\d+\\.\\s*/g, '')  // Remove move numbers\n    .trim()\n    .toLowerCase();\n}\n\n/**\n * Check palette availability for a specific game\n */\nexport async function getGamePaletteAvailability(\n  pgn: string,\n  currentUserId?: string\n): Promise<GamePaletteAvailability> {\n  const normalizedPgn = normalizePgn(pgn);\n  \n  // Fetch all visualizations that match this game's moves\n  const { data: matchingViz, error } = await supabase\n    .from('saved_visualizations')\n    .select(`\n      id,\n      user_id,\n      pgn,\n      game_data\n    `);\n  \n  if (error) {\n    console.error('Error fetching palette availability:', error);\n    return createEmptyAvailability();\n  }\n  \n  // Find visualizations with matching PGN\n  const takenPaletteMap = new Map<string, {\n    ownerId: string;\n    visualizationId: string;\n  }>();\n  \n  for (const viz of matchingViz || []) {\n    const vizPgn = normalizePgn(viz.pgn || '');\n    if (vizPgn === normalizedPgn) {\n      // Use enhanced palette detection that checks board colors when metadata is missing\n      const gameData = viz.game_data as Record<string, unknown>;\n      const paletteId = extractPaletteId(gameData) || 'modern';\n      \n      takenPaletteMap.set(paletteId, {\n        ownerId: viz.user_id || '',\n        visualizationId: viz.id,\n      });\n    }\n  }\n  \n  // Get owner names for taken palettes\n  const ownerIds = Array.from(new Set(Array.from(takenPaletteMap.values()).map(v => v.ownerId)));\n  const { data: profiles } = await supabase\n    .from('profiles')\n    .select('user_id, display_name')\n    .in('user_id', ownerIds);\n  \n  const profileMap = new Map(profiles?.map(p => [p.user_id, p.display_name]) || []);\n  \n  // Get listing info for taken palettes\n  const vizIds = Array.from(takenPaletteMap.values()).map(v => v.visualizationId);\n  const { data: listings } = await supabase\n    .from('visualization_listings')\n    .select('visualization_id, price_cents, status')\n    .in('visualization_id', vizIds)\n    .eq('status', 'active');\n  \n  const listingMap = new Map(listings?.map(l => [l.visualization_id, l.price_cents]) || []);\n  \n  // Build availability info for all palettes\n  const availablePalettes: PaletteAvailabilityInfo[] = [];\n  const takenPalettes: PaletteAvailabilityInfo[] = [];\n  \n  for (const palette of colorPalettes) {\n    if (palette.id === 'custom') continue; // Skip custom palette\n    \n    const taken = takenPaletteMap.get(palette.id);\n    const info: PaletteAvailabilityInfo = {\n      paletteId: palette.id,\n      paletteName: palette.name,\n      isTaken: !!taken,\n      ownerDisplayName: taken ? (profileMap.get(taken.ownerId) || 'A Collector') : undefined,\n      ownerUserId: taken?.ownerId,\n      visualizationId: taken?.visualizationId,\n      isListedForSale: taken ? listingMap.has(taken.visualizationId) : false,\n      listingPriceCents: taken ? listingMap.get(taken.visualizationId) : undefined,\n      isOwnedByCurrentUser: taken?.ownerId === currentUserId,\n    };\n    \n    if (taken) {\n      takenPalettes.push(info);\n    } else {\n      availablePalettes.push(info);\n    }\n  }\n  \n  return {\n    availablePalettes,\n    takenPalettes,\n    totalAvailable: availablePalettes.length,\n    totalTaken: takenPalettes.length,\n  };\n}\n\nfunction createEmptyAvailability(): GamePaletteAvailability {\n  const allPalettes = colorPalettes\n    .filter(p => p.id !== 'custom')\n    .map(p => ({\n      paletteId: p.id,\n      paletteName: p.name,\n      isTaken: false,\n      isListedForSale: false,\n      isOwnedByCurrentUser: false,\n    }));\n  \n  return {\n    availablePalettes: allPalettes,\n    takenPalettes: [],\n    totalAvailable: allPalettes.length,\n    totalTaken: 0,\n  };\n}\n\n/**\n * Check if a specific palette is available for a game\n */\nexport async function isPaletteAvailableForGame(\n  pgn: string,\n  paletteId: PaletteId,\n  currentUserId?: string\n): Promise<{ available: boolean; owner?: string; visualizationId?: string; isListed?: boolean }> {\n  const availability = await getGamePaletteAvailability(pgn, currentUserId);\n  \n  const takenInfo = availability.takenPalettes.find(p => p.paletteId === paletteId);\n  \n  if (!takenInfo) {\n    return { available: true };\n  }\n  \n  return {\n    available: false,\n    owner: takenInfo.ownerDisplayName,\n    visualizationId: takenInfo.visualizationId,\n    isListed: takenInfo.isListedForSale,\n  };\n}\n";export{e as default};
