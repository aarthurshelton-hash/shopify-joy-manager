const e="/**\n * En Pensent Core SDK - Signature Extractor Tests\n * \n * Tests for fingerprint generation, temporal flow calculation, \n * and critical moment detection.\n */\n\nimport { describe, it, expect } from 'vitest';\nimport {\n  generateFingerprint,\n  calculateQuadrantProfile,\n  calculateTemporalFlow,\n  detectCriticalMoments,\n  calculateIntensity,\n  determineDominantForce,\n  determineFlowDirection,\n  hashString\n} from './signatureExtractor';\nimport { QuadrantProfile, TemporalFlow } from './types';\n\ndescribe('signatureExtractor', () => {\n  // ============================================================================\n  // generateFingerprint\n  // ============================================================================\n  describe('generateFingerprint', () => {\n    it('should generate a fingerprint with EP- prefix', () => {\n      const quadrantProfile: QuadrantProfile = { q1: 0.3, q2: 0.2, q3: 0.25, q4: 0.25 };\n      const temporalFlow: TemporalFlow = { opening: 0.5, middle: 0.6, ending: 0.4, trend: 'stable', momentum: 0 };\n      \n      const fingerprint = generateFingerprint(quadrantProfile, temporalFlow, 'test_archetype', 0.7);\n      \n      expect(fingerprint).toMatch(/^EP-[A-F0-9]{8}$/);\n    });\n\n    it('should generate deterministic fingerprints for same inputs', () => {\n      const quadrantProfile: QuadrantProfile = { q1: 0.4, q2: 0.3, q3: 0.2, q4: 0.1 };\n      const temporalFlow: TemporalFlow = { opening: 0.3, middle: 0.5, ending: 0.7, trend: 'accelerating', momentum: 0.5 };\n      \n      const fp1 = generateFingerprint(quadrantProfile, temporalFlow, 'archetype', 0.8);\n      const fp2 = generateFingerprint(quadrantProfile, temporalFlow, 'archetype', 0.8);\n      \n      expect(fp1).toBe(fp2);\n    });\n\n    it('should generate different fingerprints for different inputs', () => {\n      const quadrantProfile: QuadrantProfile = { q1: 0.25, q2: 0.25, q3: 0.25, q4: 0.25 };\n      const temporalFlow: TemporalFlow = { opening: 0.5, middle: 0.5, ending: 0.5, trend: 'stable', momentum: 0 };\n      \n      const fp1 = generateFingerprint(quadrantProfile, temporalFlow, 'alpha_type', 0.5);\n      const fp2 = generateFingerprint(quadrantProfile, temporalFlow, 'beta_type', 0.5);\n      \n      expect(fp1).not.toBe(fp2);\n    });\n\n    it('should handle edge case with zero values', () => {\n      const quadrantProfile: QuadrantProfile = { q1: 0, q2: 0, q3: 0, q4: 0 };\n      const temporalFlow: TemporalFlow = { opening: 0, middle: 0, ending: 0, trend: 'stable', momentum: 0 };\n      \n      const fingerprint = generateFingerprint(quadrantProfile, temporalFlow, '', 0);\n      \n      expect(fingerprint).toMatch(/^EP-[A-F0-9]{8}$/);\n    });\n\n    it('should handle edge case with max values', () => {\n      const quadrantProfile: QuadrantProfile = { q1: 1, q2: 1, q3: 1, q4: 1 };\n      const temporalFlow: TemporalFlow = { opening: 1, middle: 1, ending: 1, trend: 'volatile', momentum: 1 };\n      \n      const fingerprint = generateFingerprint(quadrantProfile, temporalFlow, 'max_archetype', 1);\n      \n      expect(fingerprint).toMatch(/^EP-[A-F0-9]{8}$/);\n    });\n  });\n\n  // ============================================================================\n  // calculateQuadrantProfile\n  // ============================================================================\n  describe('calculateQuadrantProfile', () => {\n    it('should calculate profile from activity distribution', () => {\n      const activities = [\n        { region: 'q1' as const, weight: 10 },\n        { region: 'q2' as const, weight: 20 },\n        { region: 'q3' as const, weight: 30 },\n        { region: 'q4' as const, weight: 40 },\n      ];\n      \n      const profile = calculateQuadrantProfile(activities);\n      \n      expect(profile.q1).toBeCloseTo(0.1);\n      expect(profile.q2).toBeCloseTo(0.2);\n      expect(profile.q3).toBeCloseTo(0.3);\n      expect(profile.q4).toBeCloseTo(0.4);\n    });\n\n    it('should return equal distribution for empty activities', () => {\n      const profile = calculateQuadrantProfile([]);\n      \n      expect(profile.q1).toBe(0.25);\n      expect(profile.q2).toBe(0.25);\n      expect(profile.q3).toBe(0.25);\n      expect(profile.q4).toBe(0.25);\n    });\n\n    it('should handle center region', () => {\n      const activities = [\n        { region: 'center' as const, weight: 50 },\n        { region: 'q1' as const, weight: 50 },\n      ];\n      \n      const profile = calculateQuadrantProfile(activities);\n      \n      expect(profile.center).toBeCloseTo(0.5);\n      expect(profile.q1).toBeCloseTo(0.5);\n    });\n\n    it('should normalize to sum of 1', () => {\n      const activities = [\n        { region: 'q1' as const, weight: 100 },\n        { region: 'q2' as const, weight: 200 },\n        { region: 'q3' as const, weight: 300 },\n        { region: 'q4' as const, weight: 400 },\n      ];\n      \n      const profile = calculateQuadrantProfile(activities);\n      const sum = profile.q1 + profile.q2 + profile.q3 + profile.q4 + (profile.center || 0);\n      \n      expect(sum).toBeCloseTo(1);\n    });\n\n    it('should handle single quadrant dominance', () => {\n      const activities = [\n        { region: 'q1' as const, weight: 100 },\n      ];\n      \n      const profile = calculateQuadrantProfile(activities);\n      \n      expect(profile.q1).toBe(1);\n      expect(profile.q2).toBe(0);\n      expect(profile.q3).toBe(0);\n      expect(profile.q4).toBe(0);\n    });\n  });\n\n  // ============================================================================\n  // calculateTemporalFlow\n  // ============================================================================\n  describe('calculateTemporalFlow', () => {\n    it('should calculate flow for empty array', () => {\n      const flow = calculateTemporalFlow([]);\n      \n      expect(flow.opening).toBe(0);\n      expect(flow.middle).toBe(0);\n      expect(flow.ending).toBe(0);\n      expect(flow.trend).toBe('stable');\n      expect(flow.momentum).toBe(0);\n    });\n\n    it('should detect accelerating trend', () => {\n      const activityLevels = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];\n      \n      const flow = calculateTemporalFlow(activityLevels);\n      \n      expect(flow.trend).toBe('accelerating');\n      expect(flow.ending).toBeGreaterThan(flow.opening);\n    });\n\n    it('should detect declining trend', () => {\n      const activityLevels = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1];\n      \n      const flow = calculateTemporalFlow(activityLevels);\n      \n      expect(flow.trend).toBe('declining');\n      expect(flow.ending).toBeLessThan(flow.opening);\n    });\n\n    it('should detect stable trend', () => {\n      const activityLevels = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5];\n      \n      const flow = calculateTemporalFlow(activityLevels);\n      \n      expect(flow.trend).toBe('stable');\n    });\n\n    it('should detect volatile trend', () => {\n      const activityLevels = [0.1, 0.9, 0.2, 0.8, 0.3, 0.7, 0.4, 0.6];\n      \n      const flow = calculateTemporalFlow(activityLevels);\n      \n      expect(flow.trend).toBe('volatile');\n    });\n\n    it('should calculate momentum correctly', () => {\n      const increasingActivity = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 1.0];\n      \n      const flow = calculateTemporalFlow(increasingActivity);\n      \n      expect(flow.momentum).toBeGreaterThan(0);\n    });\n\n    it('should handle custom phase boundaries', () => {\n      const activityLevels = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];\n      \n      const flow = calculateTemporalFlow(activityLevels, { opening: 0.5, middle: 0.3 });\n      \n      expect(flow.opening).toBeGreaterThan(0);\n      expect(flow.middle).toBeGreaterThan(0);\n      expect(flow.ending).toBeGreaterThan(0);\n    });\n\n    it('should bound momentum between -1 and 1', () => {\n      const extremeActivity = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1];\n      \n      const flow = calculateTemporalFlow(extremeActivity);\n      \n      expect(flow.momentum).toBeLessThanOrEqual(1);\n      expect(flow.momentum).toBeGreaterThanOrEqual(-1);\n    });\n  });\n\n  // ============================================================================\n  // detectCriticalMoments\n  // ============================================================================\n  describe('detectCriticalMoments', () => {\n    it('should return empty for short sequences', () => {\n      const moments = detectCriticalMoments([0.5, 0.6]);\n      \n      expect(moments).toHaveLength(0);\n    });\n\n    it('should detect significant increases', () => {\n      const values = [0.3, 0.3, 0.3, 0.9, 0.9, 0.9];\n      \n      const moments = detectCriticalMoments(values, { threshold: 0.3, minSeverity: 0.5 });\n      \n      expect(moments.length).toBeGreaterThan(0);\n      expect(moments[0].type).toBe('surge');\n    });\n\n    it('should detect significant decreases', () => {\n      const values = [0.9, 0.9, 0.9, 0.2, 0.2, 0.2];\n      \n      const moments = detectCriticalMoments(values, { threshold: 0.3, minSeverity: 0.5 });\n      \n      expect(moments.length).toBeGreaterThan(0);\n      expect(moments[0].type).toBe('drop');\n    });\n\n    it('should respect threshold parameter', () => {\n      const values = [0.5, 0.55, 0.6, 0.65, 0.7];\n      \n      const momentsLowThreshold = detectCriticalMoments(values, { threshold: 0.04 });\n      const momentsHighThreshold = detectCriticalMoments(values, { threshold: 0.5 });\n      \n      expect(momentsHighThreshold.length).toBe(0);\n    });\n\n    it('should respect minSeverity parameter', () => {\n      const values = [0.3, 0.5, 0.4, 0.6, 0.5];\n      \n      const momentsLowSeverity = detectCriticalMoments(values, { threshold: 0.1, minSeverity: 0.1 });\n      const momentsHighSeverity = detectCriticalMoments(values, { threshold: 0.1, minSeverity: 0.9 });\n      \n      expect(momentsHighSeverity.length).toBeLessThanOrEqual(momentsLowSeverity.length);\n    });\n\n    it('should limit results with maxMoments', () => {\n      const values = [0.1, 0.9, 0.1, 0.9, 0.1, 0.9, 0.1, 0.9, 0.1, 0.9];\n      \n      const moments = detectCriticalMoments(values, { threshold: 0.3, minSeverity: 0.5, maxMoments: 3 });\n      \n      expect(moments.length).toBeLessThanOrEqual(3);\n    });\n\n    it('should return moments in chronological order', () => {\n      const values = [0.2, 0.8, 0.3, 0.9, 0.4];\n      \n      const moments = detectCriticalMoments(values, { threshold: 0.3, minSeverity: 0.3 });\n      \n      for (let i = 1; i < moments.length; i++) {\n        expect(moments[i].index).toBeGreaterThan(moments[i - 1].index);\n      }\n    });\n\n    it('should include description in moments', () => {\n      const values = [0.2, 0.2, 0.8, 0.8];\n      \n      const moments = detectCriticalMoments(values, { threshold: 0.3, minSeverity: 0.5 });\n      \n      if (moments.length > 0) {\n        expect(moments[0].description).toBeDefined();\n        expect(moments[0].description.length).toBeGreaterThan(0);\n      }\n    });\n  });\n\n  // ============================================================================\n  // calculateIntensity\n  // ============================================================================\n  describe('calculateIntensity', () => {\n    it('should return 0 for empty metrics', () => {\n      const intensity = calculateIntensity([]);\n      \n      expect(intensity).toBe(0);\n    });\n\n    it('should calculate weighted average', () => {\n      const metrics = [\n        { value: 0.8, weight: 1 },\n        { value: 0.4, weight: 1 },\n      ];\n      \n      const intensity = calculateIntensity(metrics);\n      \n      expect(intensity).toBeCloseTo(0.6);\n    });\n\n    it('should respect weights', () => {\n      const metrics = [\n        { value: 1.0, weight: 3 },\n        { value: 0.0, weight: 1 },\n      ];\n      \n      const intensity = calculateIntensity(metrics);\n      \n      expect(intensity).toBeCloseTo(0.75);\n    });\n\n    it('should clamp result between 0 and 1', () => {\n      const metricsHigh = [{ value: 2.0, weight: 1 }];\n      const metricsLow = [{ value: -1.0, weight: 1 }];\n      \n      expect(calculateIntensity(metricsHigh)).toBe(1);\n      expect(calculateIntensity(metricsLow)).toBe(0);\n    });\n\n    it('should handle zero weights', () => {\n      const metrics = [\n        { value: 0.5, weight: 0 },\n        { value: 0.7, weight: 0 },\n      ];\n      \n      const intensity = calculateIntensity(metrics);\n      \n      expect(intensity).toBe(0);\n    });\n  });\n\n  // ============================================================================\n  // determineDominantForce\n  // ============================================================================\n  describe('determineDominantForce', () => {\n    it('should return primary when primary is significantly higher', () => {\n      const result = determineDominantForce(0.8, 0.3);\n      \n      expect(result).toBe('primary');\n    });\n\n    it('should return secondary when secondary is significantly higher', () => {\n      const result = determineDominantForce(0.3, 0.8);\n      \n      expect(result).toBe('secondary');\n    });\n\n    it('should return balanced when values are close', () => {\n      const result = determineDominantForce(0.5, 0.52);\n      \n      expect(result).toBe('balanced');\n    });\n\n    it('should respect custom balance threshold', () => {\n      // With low threshold (0.01), a difference of 0.02 exceeds it, so not balanced\n      const resultLowThreshold = determineDominantForce(0.52, 0.5, 0.01);\n      // With high threshold (0.1), a difference of 0.02 is within it, so balanced\n      const resultHighThreshold = determineDominantForce(0.52, 0.5, 0.1);\n      \n      expect(resultLowThreshold).toBe('primary');\n      expect(resultHighThreshold).toBe('balanced');\n    });\n\n    it('should handle equal values', () => {\n      const result = determineDominantForce(0.5, 0.5);\n      \n      expect(result).toBe('balanced');\n    });\n\n    it('should handle zero values', () => {\n      const result = determineDominantForce(0, 0);\n      \n      expect(result).toBe('balanced');\n    });\n  });\n\n  // ============================================================================\n  // determineFlowDirection\n  // ============================================================================\n  describe('determineFlowDirection', () => {\n    it('should detect forward direction', () => {\n      const profile: QuadrantProfile = { q1: 0.4, q2: 0.4, q3: 0.1, q4: 0.1 };\n      \n      const direction = determineFlowDirection(profile);\n      \n      expect(direction).toBe('forward');\n    });\n\n    it('should detect backward direction', () => {\n      const profile: QuadrantProfile = { q1: 0.1, q2: 0.1, q3: 0.4, q4: 0.4 };\n      \n      const direction = determineFlowDirection(profile);\n      \n      expect(direction).toBe('backward');\n    });\n\n    it('should detect lateral direction', () => {\n      const profile: QuadrantProfile = { q1: 0.4, q2: 0.1, q3: 0.4, q4: 0.1 };\n      \n      const direction = determineFlowDirection(profile);\n      \n      expect(direction).toBe('lateral');\n    });\n\n    it('should detect chaotic when evenly distributed', () => {\n      const profile: QuadrantProfile = { q1: 0.25, q2: 0.25, q3: 0.25, q4: 0.25 };\n      \n      const direction = determineFlowDirection(profile);\n      \n      expect(direction).toBe('chaotic');\n    });\n\n    it('should handle edge case with all zeros', () => {\n      const profile: QuadrantProfile = { q1: 0, q2: 0, q3: 0, q4: 0 };\n      \n      const direction = determineFlowDirection(profile);\n      \n      expect(['chaotic', 'forward', 'backward', 'lateral']).toContain(direction);\n    });\n  });\n\n  // ============================================================================\n  // hashString\n  // ============================================================================\n  describe('hashString', () => {\n    it('should generate consistent hash for same string', () => {\n      const hash1 = hashString('test-string');\n      const hash2 = hashString('test-string');\n      \n      expect(hash1).toBe(hash2);\n    });\n\n    it('should generate different hashes for different strings', () => {\n      const hash1 = hashString('string-a');\n      const hash2 = hashString('string-b');\n      \n      expect(hash1).not.toBe(hash2);\n    });\n\n    it('should return 8 character hex string', () => {\n      const hash = hashString('any-string');\n      \n      expect(hash).toMatch(/^[0-9a-f]{8}$/);\n    });\n\n    it('should handle empty string', () => {\n      const hash = hashString('');\n      \n      expect(hash).toMatch(/^[0-9a-f]{8}$/);\n    });\n\n    it('should handle long strings', () => {\n      const longString = 'a'.repeat(10000);\n      const hash = hashString(longString);\n      \n      expect(hash).toMatch(/^[0-9a-f]{8}$/);\n    });\n\n    it('should handle special characters', () => {\n      const hash = hashString('!@#$%^&*()_+-=[]{}|;:,.<>?');\n      \n      expect(hash).toMatch(/^[0-9a-f]{8}$/);\n    });\n\n    it('should handle unicode', () => {\n      const hash = hashString('æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆðŸŽ¯');\n      \n      expect(hash).toMatch(/^[0-9a-f]{8}$/);\n    });\n  });\n});\n";export{e as default};
