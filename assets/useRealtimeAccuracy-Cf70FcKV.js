const e="/**\n * Realtime Accuracy Hook v7.24 - LIVE STATS\n * Ensures all accuracy metrics auto-update across the entire En Pensent platform\n * v7.24: All stats fetched from DB and recalculated on every realtime event\n * Includes live ELO calculation from cumulative stats\n * Used by useAutoEvolution for real \"total\" counts\n */\n\nimport { useEffect, useCallback, useRef, useState } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useTradingSessionStore } from '@/stores/tradingSessionStore';\nimport { selfEvolvingSystem } from '@/lib/pensent-core/domains/finance/selfEvolvingSystem';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { \n  calculateEloFromBenchmark, \n  createInitialEloState,\n  type LiveEloState \n} from '@/lib/chess/liveEloTracker';\n\nexport interface RealtimeAccuracyState {\n  isConnected: boolean;\n  lastUpdate: Date | null;\n  updateCount: number;\n  channels: string[];\n}\n\nexport interface ChessCumulativeStats {\n  totalGames: number;\n  hybridWins: number;\n  stockfishWins: number;\n  bothCorrect: number;\n  bothWrong: number;\n  hybridAccuracy: number;\n  stockfishAccuracy: number;\n  avgConfidence: number;\n  // v7.24: Additional stats for full parity with getCumulativeStats\n  totalRuns: number;\n  hybridNetWins: number;\n  // v7.24: Pool-specific counts for AutoEvolutionPanel\n  volumePoolCount: number;  // D15-22 predictions\n  deepPoolCount: number;    // D25+ predictions\n}\n\nexport interface AccuracyUpdate {\n  type: 'prediction' | 'evolution' | 'security' | 'correlation' | 'chess';\n  data: unknown;\n  timestamp: Date;\n}\n\ntype AccuracyListener = (update: AccuracyUpdate) => void;\nconst accuracyListeners: Set<AccuracyListener> = new Set();\n\nexport function subscribeToAccuracyUpdates(listener: AccuracyListener): () => void {\n  accuracyListeners.add(listener);\n  return () => accuracyListeners.delete(listener);\n}\n\nfunction broadcastAccuracyUpdate(update: AccuracyUpdate) {\n  accuracyListeners.forEach(listener => listener(update));\n}\n\n// Cached chess stats with timestamp for efficient querying\nlet cachedChessStats: ChessCumulativeStats | null = null;\nlet lastChessStatsFetch = 0;\nconst CHESS_STATS_CACHE_MS = 5000; // v7.32: Increased to 5s to reduce DB spam\nlet lastLoggedTotal = 0; // v7.32: Only log when data changes\n\n/**\n * Fetch cumulative chess stats directly from database\n * Uses count queries to bypass 1000 row limit\n */\n/**\n * Fetch cumulative chess stats directly from database\n * v7.25-AUDIT-FIX: Corrected all stat calculations to match DB truth\n * \n * DB TRUTH (verified):\n * - total_predictions: 3201\n * - hybrid_accuracy: 48.39% (hybrid_correct / total)\n * - stockfish_accuracy: 43.30% (stockfish_correct / total)\n * - hybrid_wins: 1549 (hybrid_correct=true, counting ALL hybrid correct)\n * - stockfish_wins: 1386 (stockfish_correct=true, counting ALL sf correct)\n * - both_correct: 1088\n * - both_wrong: 1354\n * - volume_pool (D15-22): 916\n * - deep_pool (D25+): 2052\n */\nexport async function fetchChessCumulativeStats(): Promise<ChessCumulativeStats> {\n  // Return cached if fresh\n  if (cachedChessStats && Date.now() - lastChessStatsFetch < CHESS_STATS_CACHE_MS) {\n    return cachedChessStats;\n  }\n\n  const [\n    { count: totalGames },\n    { count: hybridCorrectCount },   // ALL games where hybrid was correct\n    { count: stockfishCorrectCount }, // ALL games where stockfish was correct\n    { count: bothCorrectCount },      // Both correct\n    { count: bothWrongCount },        // Both wrong\n    { count: hybridOnlyWins },        // Hybrid correct, SF wrong (exclusive wins)\n    { count: sfOnlyWins },            // SF correct, Hybrid wrong (exclusive wins)\n    { count: totalRuns },\n    { count: volumeCount },\n    { count: deepCount },\n  ] = await Promise.all([\n    // Total valid predictions\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true }),\n    // Hybrid correct (includes both_correct)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true),\n    // Stockfish correct (includes both_correct)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('stockfish_correct', true),\n    // Both correct\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true)\n      .eq('stockfish_correct', true),\n    // Both wrong\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', false)\n      .eq('stockfish_correct', false),\n    // Hybrid exclusive wins (hybrid correct, SF wrong)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true)\n      .eq('stockfish_correct', false),\n    // SF exclusive wins (SF correct, hybrid wrong)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', false)\n      .eq('stockfish_correct', true),\n    // Total benchmark runs\n    supabase\n      .from('chess_benchmark_results')\n      .select('*', { count: 'exact', head: true }),\n    // Volume pool = D15-22\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .gte('stockfish_depth', 15)\n      .lte('stockfish_depth', 22),\n    // Deep pool = D25+\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .gte('stockfish_depth', 25),\n  ]);\n\n  const total = totalGames || 0;\n  const hybridTotal = hybridCorrectCount || 0;\n  const sfTotal = stockfishCorrectCount || 0;\n  const bothC = bothCorrectCount || 0;\n  const bothW = bothWrongCount || 0;\n  const hybridExclusive = hybridOnlyWins || 0;\n  const sfExclusive = sfOnlyWins || 0;\n\n  const stats: ChessCumulativeStats = {\n    totalGames: total,\n    // For head-to-head comparison, use EXCLUSIVE wins (where only one was right)\n    hybridWins: hybridExclusive,\n    stockfishWins: sfExclusive,\n    bothCorrect: bothC,\n    bothWrong: bothW,\n    // Accuracy = correct / total (includes both_correct in numerator)\n    hybridAccuracy: total > 0 ? (hybridTotal / total) * 100 : 0,\n    stockfishAccuracy: total > 0 ? (sfTotal / total) * 100 : 0,\n    avgConfidence: 0.7,\n    // v7.25: Additional stats\n    totalRuns: totalRuns || 0,\n    hybridNetWins: hybridExclusive - sfExclusive,\n    // v7.25: Pool counts\n    volumePoolCount: volumeCount || 0,\n    deepPoolCount: deepCount || 0,\n  };\n\n  cachedChessStats = stats;\n  lastChessStatsFetch = Date.now();\n  \n  // v7.32: Only log when data actually changes\n  if (total !== lastLoggedTotal) {\n    console.log('[v7.32] Stats updated:', { total, hybridAcc: stats.hybridAccuracy.toFixed(2), sfAcc: stats.stockfishAccuracy.toFixed(2) });\n    lastLoggedTotal = total;\n  }\n  \n  return stats;\n}\n\n/**\n * Force invalidate chess stats cache\n */\nexport function invalidateChessStatsCache() {\n  cachedChessStats = null;\n  lastChessStatsFetch = 0;\n}\n\nexport function useRealtimeAccuracy(enabled = true) {\n  const queryClient = useQueryClient();\n  const { syncEvolutionState, globalAccuracy } = useTradingSessionStore();\n  const channelsRef = useRef<ReturnType<typeof supabase.channel>[]>([]);\n  \n  const [state, setState] = useState<RealtimeAccuracyState>({\n    isConnected: false,\n    lastUpdate: null,\n    updateCount: 0,\n    channels: []\n  });\n  \n  const [chessStats, setChessStats] = useState<ChessCumulativeStats | null>(null);\n  \n  // v7.23: Live ELO state calculated from realtime chess stats\n  const [liveEloState, setLiveEloState] = useState<LiveEloState>(createInitialEloState());\n  \n  // v7.23: Update ELO whenever chess stats change\n  const updateEloFromStats = useCallback((stats: ChessCumulativeStats) => {\n    if (stats.totalGames > 0) {\n      const newElo = calculateEloFromBenchmark(\n        stats.hybridAccuracy,\n        stats.stockfishAccuracy,\n        stats.hybridWins,\n        stats.stockfishWins,\n        stats.bothCorrect,\n        stats.totalGames,\n        35 // Default depth estimate\n      );\n      setLiveEloState(newElo);\n    }\n  }, []);\n\n  // Sync all accuracy data from database\n  const syncAccuracyData = useCallback(async () => {\n    try {\n      // Sync evolution state from local system\n      syncEvolutionState();\n      \n      // Fetch chess cumulative stats\n      const freshChessStats = await fetchChessCumulativeStats();\n      setChessStats(freshChessStats);\n      updateEloFromStats(freshChessStats); // v7.23: Update ELO from fresh stats\n      \n      broadcastAccuracyUpdate({\n        type: 'chess',\n        data: freshChessStats,\n        timestamp: new Date()\n      });\n      \n      // Fetch latest security metrics\n      const { data: securityMetrics } = await supabase\n        .from('security_accuracy_metrics')\n        .select('*')\n        .order('composite_accuracy', { ascending: false });\n      \n      if (securityMetrics) {\n        broadcastAccuracyUpdate({\n          type: 'security',\n          data: securityMetrics,\n          timestamp: new Date()\n        });\n      }\n\n      // Fetch latest evolution state\n      const { data: evolutionData } = await supabase\n        .from('evolution_state')\n        .select('*')\n        .eq('state_type', 'global')\n        .single();\n\n      if (evolutionData) {\n        broadcastAccuracyUpdate({\n          type: 'evolution',\n          data: evolutionData,\n          timestamp: new Date()\n        });\n      }\n\n      // Fetch latest correlations\n      const { data: correlations } = await supabase\n        .from('market_correlations')\n        .select('*')\n        .order('calculated_at', { ascending: false })\n        .limit(50);\n\n      if (correlations) {\n        broadcastAccuracyUpdate({\n          type: 'correlation',\n          data: correlations,\n          timestamp: new Date()\n        });\n      }\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({ queryKey: ['security-metrics'] });\n      queryClient.invalidateQueries({ queryKey: ['evolution-state'] });\n      queryClient.invalidateQueries({ queryKey: ['market-correlations'] });\n      queryClient.invalidateQueries({ queryKey: ['prediction-outcomes'] });\n      queryClient.invalidateQueries({ queryKey: ['chess-cumulative-stats'] });\n      queryClient.invalidateQueries({ queryKey: ['benchmark-stats'] });\n\n      setState(prev => ({\n        ...prev,\n        lastUpdate: new Date(),\n        updateCount: prev.updateCount + 1\n      }));\n    } catch (error) {\n      console.error('[RealtimeAccuracy] Sync error:', error);\n    }\n  }, [syncEvolutionState, queryClient]);\n\n  // Set up realtime subscriptions\n  useEffect(() => {\n    if (!enabled) return;\n\n    const channels: ReturnType<typeof supabase.channel>[] = [];\n\n    // Chess prediction attempts channel - CRITICAL for FIDE ELO updates\n    const chessChannel = supabase\n      .channel('realtime-chess-predictions')\n      .on(\n        'postgres_changes',\n        { event: 'INSERT', schema: 'public', table: 'chess_prediction_attempts' },\n        async (payload) => {\n          console.log('[RealtimeAccuracy] Chess prediction update:', payload.eventType);\n          \n          // Invalidate cache and refetch\n          invalidateChessStatsCache();\n          const freshStats = await fetchChessCumulativeStats();\n          setChessStats(freshStats);\n          updateEloFromStats(freshStats); // v7.23: Update ELO immediately\n          \n          broadcastAccuracyUpdate({\n            type: 'chess',\n            data: freshStats,\n            timestamp: new Date()\n          });\n\n          setState(prev => ({\n            ...prev,\n            lastUpdate: new Date(),\n            updateCount: prev.updateCount + 1\n          }));\n\n          queryClient.invalidateQueries({ queryKey: ['chess-cumulative-stats'] });\n          queryClient.invalidateQueries({ queryKey: ['benchmark-stats'] });\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('[RealtimeAccuracy] Chess predictions channel connected');\n        }\n      });\n    channels.push(chessChannel);\n\n    // Chess benchmark results channel - for completed benchmark syncing\n    const benchmarkChannel = supabase\n      .channel('realtime-chess-benchmarks')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'chess_benchmark_results' },\n        async (payload) => {\n          console.log('[RealtimeAccuracy] Benchmark result update:', payload.eventType, payload.new);\n          \n          // Invalidate cache and refetch all chess-related queries\n          invalidateChessStatsCache();\n          const freshStats = await fetchChessCumulativeStats();\n          setChessStats(freshStats);\n          updateEloFromStats(freshStats); // v7.23: Update ELO immediately\n          \n          broadcastAccuracyUpdate({\n            type: 'chess',\n            data: { ...freshStats, benchmarkEvent: payload.eventType, benchmarkData: payload.new },\n            timestamp: new Date()\n          });\n\n          setState(prev => ({\n            ...prev,\n            lastUpdate: new Date(),\n            updateCount: prev.updateCount + 1\n          }));\n\n          queryClient.invalidateQueries({ queryKey: ['chess-cumulative-stats'] });\n          queryClient.invalidateQueries({ queryKey: ['benchmark-stats'] });\n          queryClient.invalidateQueries({ queryKey: ['benchmark-history'] });\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('[RealtimeAccuracy] Benchmark results channel connected');\n        }\n      });\n    channels.push(benchmarkChannel);\n\n    // Prediction outcomes channel\n    const predictionChannel = supabase\n      .channel('realtime-predictions')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'prediction_outcomes' },\n        (payload) => {\n          console.log('[RealtimeAccuracy] Prediction update:', payload.eventType);\n          syncEvolutionState();\n          selfEvolvingSystem.getState();\n          \n          broadcastAccuracyUpdate({\n            type: 'prediction',\n            data: payload.new,\n            timestamp: new Date()\n          });\n\n          setState(prev => ({\n            ...prev,\n            lastUpdate: new Date(),\n            updateCount: prev.updateCount + 1\n          }));\n\n          queryClient.invalidateQueries({ queryKey: ['prediction-outcomes'] });\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('[RealtimeAccuracy] Prediction channel connected');\n        }\n      });\n    channels.push(predictionChannel);\n\n    // Evolution state channel\n    const evolutionChannel = supabase\n      .channel('realtime-evolution')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'evolution_state' },\n        (payload) => {\n          console.log('[RealtimeAccuracy] Evolution update:', payload.eventType);\n          syncEvolutionState();\n          \n          broadcastAccuracyUpdate({\n            type: 'evolution',\n            data: payload.new,\n            timestamp: new Date()\n          });\n\n          setState(prev => ({\n            ...prev,\n            lastUpdate: new Date(),\n            updateCount: prev.updateCount + 1\n          }));\n\n          queryClient.invalidateQueries({ queryKey: ['evolution-state'] });\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('[RealtimeAccuracy] Evolution channel connected');\n        }\n      });\n    channels.push(evolutionChannel);\n\n    // Security metrics channel\n    const securityChannel = supabase\n      .channel('realtime-security-metrics')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'security_accuracy_metrics' },\n        (payload) => {\n          console.log('[RealtimeAccuracy] Security metrics update:', payload.eventType);\n          \n          broadcastAccuracyUpdate({\n            type: 'security',\n            data: payload.new,\n            timestamp: new Date()\n          });\n\n          setState(prev => ({\n            ...prev,\n            lastUpdate: new Date(),\n            updateCount: prev.updateCount + 1\n          }));\n\n          queryClient.invalidateQueries({ queryKey: ['security-metrics'] });\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('[RealtimeAccuracy] Security metrics channel connected');\n        }\n      });\n    channels.push(securityChannel);\n\n    // Market correlations channel\n    const correlationChannel = supabase\n      .channel('realtime-correlations')\n      .on(\n        'postgres_changes',\n        { event: '*', schema: 'public', table: 'market_correlations' },\n        (payload) => {\n          console.log('[RealtimeAccuracy] Correlation update:', payload.eventType);\n          \n          broadcastAccuracyUpdate({\n            type: 'correlation',\n            data: payload.new,\n            timestamp: new Date()\n          });\n\n          setState(prev => ({\n            ...prev,\n            lastUpdate: new Date(),\n            updateCount: prev.updateCount + 1\n          }));\n\n          queryClient.invalidateQueries({ queryKey: ['market-correlations'] });\n        }\n      )\n      .subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('[RealtimeAccuracy] Correlation channel connected');\n        }\n      });\n    channels.push(correlationChannel);\n\n    channelsRef.current = channels;\n\n    setState(prev => ({\n      ...prev,\n      isConnected: true,\n      channels: ['chess', 'benchmarks', 'predictions', 'evolution', 'security', 'correlations']\n    }));\n\n    // Initial sync\n    syncAccuracyData();\n\n    // Periodic sync every 5 seconds for local state\n    const syncInterval = setInterval(() => {\n      syncEvolutionState();\n    }, 5000);\n\n    return () => {\n      clearInterval(syncInterval);\n      channels.forEach(channel => {\n        supabase.removeChannel(channel);\n      });\n      setState(prev => ({ ...prev, isConnected: false, channels: [] }));\n    };\n  }, [enabled, syncEvolutionState, queryClient, syncAccuracyData]);\n\n  return {\n    ...state,\n    globalAccuracy,\n    chessStats,\n    liveEloState, // v7.23: Expose live ELO calculated from realtime stats\n    syncAccuracyData,\n    subscribeToUpdates: subscribeToAccuracyUpdates\n  };\n}\n";export{e as default};
