const n="/**\n * Unified Evolution System\n * The Code is the BLOOD - The Market is the NERVOUS SYSTEM\n * When code evolves, the entire En Pensent universe adapts\n */\n\nimport { useCallback, useEffect, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface EvolutionEvent {\n  type: 'code_analysis' | 'code_fix' | 'pattern_discovered' | 'archetype_shift' | 'market_sync';\n  source: 'code' | 'market' | 'chess';\n  data: Record<string, unknown>;\n  timestamp: Date;\n}\n\nexport interface UnifiedState {\n  codeHealth: number; // 0-100\n  marketSync: number; // 0-100\n  patternAlignment: number; // 0-100\n  lastEvolution: Date | null;\n  evolutionCount: number;\n}\n\n// Simple event emitter for cross-domain communication\ntype EvolutionListener = (event: EvolutionEvent) => void;\nconst evolutionListeners: Set<EvolutionListener> = new Set();\n\nexport function subscribeToEvolution(listener: EvolutionListener): () => void {\n  evolutionListeners.add(listener);\n  return () => evolutionListeners.delete(listener);\n}\n\nfunction broadcastEvolution(event: EvolutionEvent) {\n  evolutionListeners.forEach(listener => listener(event));\n}\n\nexport function useUnifiedEvolution() {\n  const { toast } = useToast();\n  const stateRef = useRef<UnifiedState>({\n    codeHealth: 100,\n    marketSync: 100,\n    patternAlignment: 100,\n    lastEvolution: null,\n    evolutionCount: 0\n  });\n  \n  // Emit evolution event across the entire universe\n  const emitEvolution = useCallback(async (event: EvolutionEvent) => {\n    console.log('[UnifiedEvolution] Emitting:', event.type, 'from', event.source);\n    \n    // Broadcast to local listeners\n    broadcastEvolution(event);\n    \n    // Persist to database for cross-session learning\n    try {\n      const evolutionData = {\n        state_type: 'unified_evolution',\n        genes: {\n          code_health: stateRef.current.codeHealth,\n          market_sync: stateRef.current.marketSync,\n          pattern_alignment: stateRef.current.patternAlignment,\n          last_event: event\n        },\n        generation: stateRef.current.evolutionCount + 1,\n        fitness_score: (stateRef.current.codeHealth + stateRef.current.marketSync + stateRef.current.patternAlignment) / 3,\n        last_mutation_at: new Date().toISOString()\n      };\n      \n      const { error } = await supabase\n        .from('evolution_state')\n        .insert(evolutionData as any);\n      \n      if (error) {\n        console.warn('[UnifiedEvolution] Insert warning:', error.message);\n      }\n      \n      stateRef.current.evolutionCount++;\n      stateRef.current.lastEvolution = new Date();\n    } catch (err) {\n      console.error('[UnifiedEvolution] Failed to persist:', err);\n    }\n  }, []);\n  \n  // Code was analyzed - propagate learnings\n  const onCodeAnalyzed = useCallback(async (analysisResult: {\n    archetype: string;\n    health: number;\n    recommendations: string[];\n  }) => {\n    stateRef.current.codeHealth = analysisResult.health;\n    \n    await emitEvolution({\n      type: 'code_analysis',\n      source: 'code',\n      data: analysisResult,\n      timestamp: new Date()\n    });\n    \n    // Broadcast market recalibration\n    broadcastEvolution({\n      type: 'market_sync',\n      source: 'code',\n      data: {\n        trigger: 'code_analysis',\n        codeArchetype: analysisResult.archetype,\n        healthFactor: analysisResult.health / 100\n      },\n      timestamp: new Date()\n    });\n    \n    toast({\n      title: 'ðŸ§¬ Universe Synchronized',\n      description: `Code patterns propagated. Market calibration updated.`\n    });\n  }, [emitEvolution, toast]);\n  \n  // Code was fixed - auto-evolve the system\n  const onCodeFixed = useCallback(async (fix: {\n    file: string;\n    issue: string;\n    resolution: string;\n  }) => {\n    // Increase code health\n    stateRef.current.codeHealth = Math.min(100, stateRef.current.codeHealth + 5);\n    \n    await emitEvolution({\n      type: 'code_fix',\n      source: 'code',\n      data: fix,\n      timestamp: new Date()\n    });\n    \n    // Broadcast pattern learned\n    broadcastEvolution({\n      type: 'pattern_discovered',\n      source: 'code',\n      data: {\n        domain: 'code',\n        pattern: fix.issue,\n        resolution: fix.resolution,\n        impact: 'positive'\n      },\n      timestamp: new Date()\n    });\n  }, [emitEvolution]);\n  \n  // New pattern discovered\n  const onPatternDiscovered = useCallback(async (pattern: {\n    domain: string;\n    signature: string;\n    confidence: number;\n  }) => {\n    stateRef.current.patternAlignment = Math.min(100, stateRef.current.patternAlignment + 2);\n    \n    await emitEvolution({\n      type: 'pattern_discovered',\n      source: pattern.domain as 'code' | 'market' | 'chess',\n      data: pattern,\n      timestamp: new Date()\n    });\n  }, [emitEvolution]);\n  \n  // Market synced successfully\n  const onMarketSynced = useCallback(async (syncData: {\n    accuracy: number;\n    correlations: number;\n    ticksProcessed: number;\n  }) => {\n    stateRef.current.marketSync = syncData.accuracy;\n    \n    await emitEvolution({\n      type: 'market_sync',\n      source: 'market',\n      data: syncData,\n      timestamp: new Date()\n    });\n  }, [emitEvolution]);\n  \n  // Get current unified state\n  const getUnifiedState = useCallback(() => {\n    return { ...stateRef.current };\n  }, []);\n  \n  return {\n    emitEvolution,\n    onCodeAnalyzed,\n    onCodeFixed,\n    onPatternDiscovered,\n    onMarketSynced,\n    getUnifiedState,\n    subscribeToEvolution\n  };\n}\n";export{n as default};
