const e="import { useCallback } from 'react';\nimport { toast } from 'sonner';\nimport { generateCleanPrintImage } from '@/lib/chess/printImageGenerator';\nimport type { ExportState } from '@/components/chess/UnifiedVisionExperience';\nimport { SimulationResult, SquareData, GameData } from '@/lib/chess/gameSimulator';\nimport { generateGameHash } from '@/lib/visualizations/gameCanonical';\nimport type { PieceType } from '@/lib/chess/pieceColors';\n\ninterface VisualizationData {\n  board: SquareData[][];\n  gameData: GameData;\n  totalMoves: number;\n  pgn: string;\n  title?: string;\n  visualizationId?: string;\n  paletteId?: string;\n  shareId?: string;\n}\n\ninterface UseVisualizationHandlersOptions {\n  visualizationData: VisualizationData;\n  isPremium: boolean;\n  isCheckingSubscription: boolean;\n  onUpgradePrompt: () => void;\n  onSaveToGallery?: () => Promise<string | null>;\n  setOrderData?: (data: unknown) => void;\n  navigate?: (path: string) => void;\n}\n\ninterface UseVisualizationHandlersReturn {\n  handleExport: (type: 'hd' | 'gif' | 'print' | 'preview', exportState?: ExportState) => Promise<void>;\n  handleShare: () => Promise<void>;\n  handleSaveToGallery: () => Promise<string | null>;\n}\n\nexport function useVisualizationHandlers({\n  visualizationData,\n  isPremium,\n  isCheckingSubscription,\n  onUpgradePrompt,\n  onSaveToGallery,\n  setOrderData,\n  navigate,\n}: UseVisualizationHandlersOptions): UseVisualizationHandlersReturn {\n  const { board, gameData, totalMoves, pgn, title, visualizationId, paletteId, shareId } = visualizationData;\n\n  const handleExport = useCallback(async (type: 'hd' | 'gif' | 'print' | 'preview', exportState?: ExportState) => {\n    if (!board || !gameData) return;\n\n    // Build filtered board based on export state\n    const filteredBoard = exportState && exportState.currentMove < totalMoves && exportState.currentMove > 0\n      ? board.map(row => \n          row.map(square => ({\n            ...square,\n            visits: square.visits.filter(visit => visit.moveNumber <= exportState.currentMove)\n          }))\n        )\n      : board;\n\n    // Build highlight state for rendering\n    const highlightState = exportState?.lockedPieces && exportState.lockedPieces.length > 0 ? {\n      lockedPieces: exportState.lockedPieces.map(p => ({\n        pieceType: p.pieceType as PieceType,\n        pieceColor: (p.pieceColor === 'white' ? 'w' : p.pieceColor === 'black' ? 'b' : p.pieceColor) as 'w' | 'b',\n      })),\n      compareMode: exportState.compareMode,\n    } : undefined;\n\n    const exportSimulation: SimulationResult = {\n      board: filteredBoard,\n      gameData,\n      totalMoves,\n    };\n\n    switch (type) {\n      case 'preview': {\n        try {\n          const shouldWatermark = !isPremium || isCheckingSubscription;\n          const base64Image = await generateCleanPrintImage(exportSimulation, {\n            darkMode: exportState?.darkMode || false,\n            withWatermark: shouldWatermark,\n            highlightState,\n            pgn,\n            capturedState: exportState ? {\n              currentMove: exportState.currentMove,\n              selectedPhase: 'all',\n              lockedPieces: exportState.lockedPieces || [],\n              compareMode: exportState.compareMode,\n              displayMode: 'art',\n              darkMode: exportState.darkMode,\n              showTerritory: false,\n              showHeatmaps: false,\n              showPieces: exportState.showPieces,\n              pieceOpacity: exportState.pieceOpacity,\n              capturedAt: new Date(),\n            } : undefined,\n          });\n\n          const response = await fetch(base64Image);\n          const blob = await response.blob();\n          const url = URL.createObjectURL(blob);\n          const link = document.createElement('a');\n          link.href = url;\n          link.download = `${title || 'chess-visualization'}-preview.png`;\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n          URL.revokeObjectURL(url);\n\n          toast.success('Preview downloaded!');\n        } catch (error) {\n          console.error('Preview export failed:', error);\n          toast.error('Failed to generate preview');\n        }\n        break;\n      }\n\n      case 'hd': {\n        if (!isPremium) {\n          onUpgradePrompt();\n          return;\n        }\n\n        try {\n          const base64Image = await generateCleanPrintImage(exportSimulation, {\n            darkMode: exportState?.darkMode || false,\n            withWatermark: false,\n            highlightState,\n            pgn,\n            capturedState: exportState ? {\n              currentMove: exportState.currentMove,\n              selectedPhase: 'all',\n              lockedPieces: exportState.lockedPieces || [],\n              compareMode: exportState.compareMode,\n              displayMode: 'art',\n              darkMode: exportState.darkMode,\n              showTerritory: false,\n              showHeatmaps: false,\n              showPieces: exportState.showPieces,\n              pieceOpacity: exportState.pieceOpacity,\n              capturedAt: new Date(),\n            } : undefined,\n          });\n\n          const response = await fetch(base64Image);\n          const blob = await response.blob();\n          const url = URL.createObjectURL(blob);\n          const link = document.createElement('a');\n          link.href = url;\n          link.download = `${title || 'chess-visualization'}-HD.png`;\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n          URL.revokeObjectURL(url);\n\n          toast.success('HD image downloaded!');\n        } catch (error) {\n          console.error('HD export failed:', error);\n          toast.error('Failed to generate HD image');\n        }\n        break;\n      }\n\n      case 'gif': {\n        if (!isPremium) {\n          onUpgradePrompt();\n          return;\n        }\n\n        // GIF generation requires DOM element capture - handled by pages directly\n        toast.info('GIF generation coming soon in unified handler');\n        break;\n      }\n\n      case 'print': {\n        if (setOrderData && navigate) {\n          const currentGameHash = pgn ? generateGameHash(pgn) : undefined;\n          \n          setOrderData({\n            title: title || 'Chess Visualization',\n            pgn,\n            gameData: {\n              white: gameData.white,\n              black: gameData.black,\n              event: gameData.event,\n              date: gameData.date,\n              result: gameData.result,\n            },\n            simulation: exportSimulation,\n            shareId: shareId || undefined,\n            returnPath: '/',\n            gameHash: currentGameHash,\n            paletteId: paletteId || 'classic',\n            capturedState: exportState ? {\n              currentMove: exportState.currentMove,\n              selectedPhase: 'all',\n              lockedPieces: exportState.lockedPieces,\n              compareMode: exportState.compareMode,\n              displayMode: 'standard',\n              darkMode: exportState.darkMode,\n              showTerritory: false,\n              showHeatmaps: false,\n              showPieces: exportState.showPieces,\n              pieceOpacity: exportState.pieceOpacity,\n              capturedAt: new Date(),\n            } : undefined,\n          });\n          navigate('/order-print');\n        } else {\n          toast.error('Print ordering not available in this context');\n        }\n        break;\n      }\n    }\n  }, [board, gameData, totalMoves, pgn, title, isPremium, isCheckingSubscription, onUpgradePrompt, setOrderData, navigate, shareId, paletteId]);\n\n  const handleShare = useCallback(async () => {\n    if (!shareId && !visualizationId) {\n      toast.error('Cannot share - no visualization ID available');\n      return;\n    }\n\n    const shareUrl = `${window.location.origin}/v/${shareId || visualizationId}`;\n\n    if (navigator.share) {\n      try {\n        await navigator.share({\n          title: title || 'Chess Visualization',\n          text: 'Check out this chess visualization on En Pensent!',\n          url: shareUrl,\n        });\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          await navigator.clipboard.writeText(shareUrl);\n          toast.success('Link copied to clipboard');\n        }\n      }\n    } else {\n      await navigator.clipboard.writeText(shareUrl);\n      toast.success('Link copied to clipboard');\n    }\n  }, [shareId, visualizationId, title]);\n\n  const handleSaveToGallery = useCallback(async (): Promise<string | null> => {\n    if (onSaveToGallery) {\n      return await onSaveToGallery();\n    }\n    toast.error('Save to gallery not available in this context');\n    return null;\n  }, [onSaveToGallery]);\n\n  return {\n    handleExport,\n    handleShare,\n    handleSaveToGallery,\n  };\n}\n";export{e as default};
