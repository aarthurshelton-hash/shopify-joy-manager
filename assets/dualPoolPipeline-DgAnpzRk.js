const n="/** v7.98-SMOOTH-AUDIT\n * Dual-Pool Automated Benchmark Pipeline\n * VERSION: 7.98-SMOOTH-AUDIT (2026-01-28)\n * \n * v7.98 FIXES:\n * - Unique constraint on game_id for proper upsert\n * - Randomized time windows for more fresh games\n * - Synced version across all files\n * \n * ARCHITECTURE:\n * ============\n * Two parallel processing pools - LOCAL STOCKFISH IS PRIMARY (guaranteed to work)\n * \n * v7.94-FIRST-MOVE-FIX:\n * - Compensates for white's structural 7% activity advantage from moving first\n * - Without compensation: 98% white_wins predictions (broken)\n * - With compensation: ~50/50 prediction distribution (correct)\n * \n * v7.93-SMOOTH-FLOW: Adaptive rate limiting with burst detection\n * v7.0 CRITICAL FIXES:\n * - All game fetching has hard timeouts (15s per source)\n * - Individual game analysis has hard timeout (30s)\n * - No operation can block indefinitely\n * - Graceful degradation on partial failures\n * \n * 1. HIGH-VOLUME LOCAL POOL (100+ results/hour)\n *    - Uses LOCAL Stockfish 17 NNUE at optimized depth (D18)\n *    - Fast and RELIABLE - no external API dependencies\n *    - Best for: Volume, guaranteed throughput\n * \n * 2. DEEP LOCAL POOL (5 results/hour)  \n *    - Uses local Stockfish 17 NNUE at maximum depth (D30)\n *    - Slow but precise: ~12 minutes/game\n *    - Best for: Edge cases, pattern discovery\n * \n * CRITICAL: Cloud API is OPTIONAL enhancement, not required.\n * Pipeline MUST work without any external API.\n * \n * v7.90-EQUILIBRIUM: Uses THREE-WAY confidence voting for balanced predictions\n * - CEO insight: \"we can win both white AND black, build on the most likely\"\n * - Calculates independent white/black/draw confidence scores\n * - Picks the outcome with highest confidence (no more bias oscillation)\n */\n\nconst DUAL_POOL_VERSION = \"8.03-RECALIBRATED\";\nconsole.log(`[v8.03] dualPoolPipeline.ts LOADED - Version: ${DUAL_POOL_VERSION}`);\n\n// v7.0: Hard timeout wrapper for any async operation\nfunction withTimeout<T>(promise: Promise<T>, ms: number, name: string): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => \n      setTimeout(() => reject(new Error(`${name} timeout after ${ms}ms`)), ms)\n    )\n  ]);\n}\n\nimport { Chess } from 'chess.js';\nimport { getStockfishEngine, terminateStockfish } from './stockfishEngine';\nimport { evaluatePosition as evaluateCloudPosition, getRateLimitStatus } from './lichessCloudEval';\nimport { generateHybridPrediction } from './hybridPrediction';\nimport { fetchLichessGames, lichessGameToPgn, type LichessGame } from './gameImport/lichessApi';\nimport { fetchChessComGames, type ChessComGame } from './gameImport/chesscomApi';\nimport { hashPosition } from './benchmarkPersistence';\nimport { supabase } from '@/integrations/supabase/client';\nimport { isManualBenchmarkActive } from './benchmarkCoordinator';\nimport { initKnownIds, isKnown, markKnown, getKnownIds, toRawId } from './simpleDedup';\nimport { breathe, RATE_LIMIT_BREATHING_MS } from './breathingPacer';\n\n// ================ POOL CONFIGURATIONS ================\n\nexport interface PoolConfig {\n  name: string;\n  targetPerHour: number;\n  stockfishMode: 'local_fast' | 'local_deep'; // v6.94: Always local, just different depth\n  localDepth: number;\n  localNodes: number;\n  analysisTimeout: number; // ms\n  delayBetweenGames: number; // ms\n}\n\n// v8.04-AGGRESSIVE: Optimized for higher throughput while maintaining stability\nexport const CLOUD_POOL_CONFIG: PoolConfig = {\n  name: 'VOLUME-LOCAL',\n  targetPerHour: 180,       // v8.04: Increased from 120 (50% more)\n  stockfishMode: 'local_fast',\n  localDepth: 14,           // v8.04: D14 (was D16) - faster analysis, still quality\n  localNodes: 1500000,      // v8.04: 1.5M nodes (was 2M) - faster timeout\n  analysisTimeout: 8000,    // v8.04: 8s max (was 10s) - quicker dropout on failures\n  delayBetweenGames: 200,   // v8.04: 200ms (was 400ms) - 2x throughput\n};\n\n// v8.04-AGGRESSIVE: Optimized for higher deep analysis throughput\nexport const LOCAL_POOL_CONFIG: PoolConfig = {\n  name: 'LOCAL-DEEP',\n  targetPerHour: 25,        // v8.04: Increased from 15 (66% more)\n  stockfishMode: 'local_deep',\n  localDepth: 22,           // v8.04: D22 (was D24) - faster deep analysis\n  localNodes: 25000000,     // v8.04: 25M nodes (was 30M) - quicker completion\n  analysisTimeout: 25000,   // v8.04: 25s max (was 30s) - tighter timeouts\n  delayBetweenGames: 400,   // v8.04: 400ms (was 600ms) - 1.5x throughput\n};\n\n// ================ TYPES ================\n\nexport interface PoolPrediction {\n  gameId: string;\n  gameName: string;\n  moveNumber: number;\n  fen: string;\n  pgn: string;\n  \n  // Stockfish evaluation\n  stockfishEval: number;\n  stockfishDepth: number;\n  stockfishMode: 'cloud' | 'local';\n  stockfishNodes?: number;\n  \n  stockfishPrediction: 'white_wins' | 'black_wins' | 'draw';\n  stockfishConfidence: number;\n  \n  // Hybrid prediction\n  hybridPrediction: 'white_wins' | 'black_wins' | 'draw';\n  hybridConfidence: number;\n  hybridArchetype: string;\n  \n  // Actual result\n  actualResult: 'white_wins' | 'black_wins' | 'draw';\n  \n  // Scoring\n  stockfishCorrect: boolean;\n  hybridCorrect: boolean;\n  \n  // Metadata\n  dataSource: 'lichess' | 'chesscom';\n  poolName: string;\n  analysisTimeMs: number;\n  \n  // v7.17: Additional game metadata for DB alignment\n  whiteElo?: number;\n  blackElo?: number;\n  timeControl?: string;\n}\n\nexport interface PoolProgress {\n  poolName: string;\n  completed: number;\n  target: number;\n  gamesPerHour: number;\n  lastGameTime: number;\n  status: 'running' | 'paused' | 'completed' | 'error';\n  errorMessage?: string;\n}\n\nexport interface DualPoolResult {\n  cloudPool: PoolPrediction[];\n  localPool: PoolPrediction[];\n  totalProcessed: number;\n  cloudAccuracy: { stockfish: number; hybrid: number };\n  localAccuracy: { stockfish: number; hybrid: number };\n  startedAt: Date;\n  completedAt?: Date;\n}\n\n// ================ PLAYER POOLS ================\n\n// v8.04-AGGRESSIVE: Expanded verified player pools for higher game yield\nconst LICHESS_ELITE_PLAYERS = [\n  // Original 16\n  'DrNykterstein', 'nihalsarin2004', 'FairChess_on_YouTube',\n  'LyonBeast', 'Bombegansen', 'GMWSO', 'Vladimirovich9000',\n  'penguingim1', 'AnishGiri', 'DanielNaroditsky', 'opperwezen',\n  'Fins', 'Polish_fighter3000', 'howitzer14', 'lachesisQ',\n  'TemurKuybokarov', 'Msb2', 'Zhigalko_Sergei', 'chaborak',\n  'Alireza2003', 'FerdinandPorsche', 'realDonaldDuck',\n  // v8.04: Additional verified strong players\n  'GMKrikor', 'platinumcloud', 'BogdanDeac', 'mutdpro',\n  'yoseph2013', 'KontraJG', 'Javokhir_Sindarov', 'rasulovvugar',\n  'GMVallejo', 'kingsafety', 'muisback', 'DrNyktersteinFan',\n  'BaryshBufetov', 'Zhigalko_Igor', 'ShimanovAlex', 'Vladimirovich3000',\n];\n\n// v8.04-AGGRESSIVE: Expanded Chess.com player pool\nconst CHESSCOM_ELITE_PLAYERS = [\n  // Original 16\n  'MagnusCarlsen', 'Hikaru', 'FabianoCaruana', 'LevonAronian',\n  'GarryKasparov', 'DanielNaroditsky', 'GothamChess', 'AnishGiri',\n  'WesleySo', 'Firouzja2003', 'NihalSarin', 'Naroditsky',\n  'MVL_Chess', 'Alireza_Firouz', 'lachesisQ', 'DominguezPerez',\n  // v8.04: Additional verified players\n  'EricHansen', 'Rensch', 'BotezLive', 'Anna_Chess', \n  'GiriAnish', 'Grischuk', 'AronianLevon', 'SoWesley',\n  'CaruanaFabiano', 'Nepomniachtchi', 'DingLiren', 'CarlsenMagnus',\n];\n\n// ================ UTILITY FUNCTIONS ================\n\nfunction shuffleArray<T>(array: T[]): T[] {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n}\n\n/**\n * v7.87-TARGETED: Generate hybrid prediction with TARGETED calibration\n * \n * v7.85-v7.86 was over-aggressive, flipping too many predictions to white.\n * v7.87 only flips for prophylactic_defense archetype or when SF strongly favors white.\n */\n/**\n * v7.90-EQUILIBRIUM: Generate hybrid prediction using THREE-WAY confidence voting\n * \n * CEO insight: We can win both white AND black - use all signals together\n * Instead of oscillating biases, calculate confidence for ALL outcomes and pick highest\n */\nasync function generateLocalHybridPrediction(\n  pgn: string,\n  stockfishEval: number,\n  stockfishDepth: number\n): Promise<{\n  prediction: 'white_wins' | 'black_wins' | 'draw';\n  confidence: number;\n  archetype: string;\n}> {\n  try {\n    const { simulateGame } = await import('./gameSimulator');\n    const { extractColorFlowSignature, predictFromColorFlow, calculateEquilibriumScores } = await import('./colorFlowAnalysis');\n    \n    const simulation = simulateGame(pgn);\n    const colorSignature = extractColorFlowSignature(simulation.board, simulation.gameData, simulation.totalMoves);\n    \n    // v7.90 EQUILIBRIUM: Use new three-way prediction with SF context\n    const colorPrediction = predictFromColorFlow(\n      colorSignature, \n      simulation.totalMoves,\n      stockfishEval,  // Pass SF eval for equilibrium calculation\n      stockfishDepth\n    );\n    \n    const archetype = colorSignature.archetype || 'unknown';\n    \n    // Convert to expected format\n    const prediction: 'white_wins' | 'black_wins' | 'draw' = \n      colorPrediction.predictedWinner === 'white' ? 'white_wins' :\n      colorPrediction.predictedWinner === 'black' ? 'black_wins' : 'draw';\n    \n    // v7.90: Confidence is already balanced by equilibrium system\n    const confidence = colorPrediction.confidence;\n    \n    return {\n      prediction,\n      confidence,\n      archetype,\n    };\n  } catch (err) {\n    console.warn('[v8.02-CALIBRATED] Hybrid error, using balanced SF fallback:', err);\n    const sfPred = evalToPredictionBalanced(stockfishEval);\n    return {\n      prediction: sfPred.prediction,\n      confidence: sfPred.confidence,\n      archetype: sfPred.archetype, // v8.02: Infer archetype from eval pattern\n    };\n  }\n}\n\n/**\n * v8.02-CALIBRATED: Balanced SF-only fallback with archetype inference\n * Key fix: Symmetric thresholds and archetype assignment (no more 'FALLBACK')\n */\nfunction evalToPredictionBalanced(cp: number): { \n  prediction: 'white_wins' | 'black_wins' | 'draw'; \n  confidence: number;\n  archetype: string;\n} {\n  // v8.02: SYMMETRIC thresholds - same for white and black\n  if (cp > 100) {\n    return { prediction: 'white_wins', confidence: Math.min(85, 55 + Math.abs(cp) / 10), archetype: 'positional_squeeze' };\n  } else if (cp < -100) {\n    return { prediction: 'black_wins', confidence: Math.min(85, 55 + Math.abs(cp) / 10), archetype: 'positional_squeeze' };\n  } else if (cp > 40) {\n    return { prediction: 'white_wins', confidence: 45 + Math.abs(cp) / 5, archetype: 'central_domination' };\n  } else if (cp < -40) {\n    return { prediction: 'black_wins', confidence: 45 + Math.abs(cp) / 5, archetype: 'central_domination' };\n  } else if (cp > 15) {\n    // v8.02: Slight edge - could go either way, predict conservatively\n    return { prediction: 'white_wins', confidence: 38, archetype: 'piece_harmony' };\n  } else if (cp < -15) {\n    return { prediction: 'black_wins', confidence: 38, archetype: 'piece_harmony' };\n  } else {\n    // v8.02: Equal position = draw with moderate confidence\n    return { prediction: 'draw', confidence: 42, archetype: 'closed_maneuvering' };\n  }\n}\n\n// ================ GAME FETCHERS ================\n\n// v7.17: Aligned with DB schema fields\ninterface UnifiedGame {\n  id: string;\n  name: string;\n  pgn: string;\n  result: 'white_wins' | 'black_wins' | 'draw';\n  source: 'lichess' | 'chesscom';\n  rating: number;\n  // v7.17: Additional metadata for DB alignment\n  whiteElo?: number;\n  blackElo?: number;\n  timeControl?: string;\n}\n\nasync function fetchLichessGamesForPool(\n  count: number,\n  existingIds: Set<string>,\n  batchNumber: number,\n  onProgress?: (msg: string) => void\n): Promise<UnifiedGame[]> {\n  const games: UnifiedGame[] = [];\n  const shuffledPlayers = shuffleArray([...LICHESS_ELITE_PLAYERS]);\n  \n  // v8.03: MUCH more aggressive randomization to avoid window collisions\n  const now = Date.now();\n  \n  // v8.03: Fully randomized window - don't rely on batch number at all\n  // This ensures each fetch has a unique time window\n  const randomYear = 2019 + Math.floor(Math.random() * 6); // 2019-2024\n  const randomMonth = Math.floor(Math.random() * 12);\n  const randomDay = 1 + Math.floor(Math.random() * 28);\n  \n  const windowStart = new Date(randomYear, randomMonth, randomDay).getTime();\n  // v8.03: Shorter window (30 days) for more precision\n  const windowEnd = Math.min(now, windowStart + 30 * 24 * 60 * 60 * 1000);\n  \n  onProgress?.(`[Lichess] Batch ${batchNumber}: ${new Date(windowStart).toISOString().slice(0,10)}`);\n  \n  // v8.04: Try more players (10 instead of 7) with expanded pool\n  for (const player of shuffledPlayers.slice(0, 10)) {\n    if (games.length >= count) break;\n    \n    try {\n      const result = await fetchLichessGames(player, {\n        max: 30, // v8.03: Request more games (was 20)\n        since: windowStart,\n        until: windowEnd,\n        rated: true,\n        opening: true,\n        moves: true,\n        pgnInJson: true,\n      });\n      \n      for (const game of result.games) {\n        if (games.length >= count) break;\n        \n        // v8.03: Check both raw and prefixed forms\n        const rawId = game.id.replace(/^li_/, '');\n        if (existingIds.has(rawId) || existingIds.has(game.id)) continue;\n        \n        const moveCount = game.moves?.split(' ').length || 0;\n        if (moveCount < 20) continue;\n        \n        const pgn = lichessGameToPgn(game);\n        const whiteName = game.players.white.user?.name || 'Anon';\n        const blackName = game.players.black.user?.name || 'Anon';\n        const whiteRating = game.players.white.rating || 2000;\n        const blackRating = game.players.black.rating || 2000;\n        \n        games.push({\n          id: game.id,\n          name: `${whiteName} (${whiteRating}) vs ${blackName} (${blackRating})`,\n          pgn,\n          result: game.winner === 'white' ? 'white_wins' : \n                 game.winner === 'black' ? 'black_wins' : 'draw',\n          source: 'lichess',\n          rating: Math.max(whiteRating, blackRating),\n          whiteElo: whiteRating,\n          blackElo: blackRating,\n          timeControl: game.speed || undefined,\n        });\n      }\n      \n      // v8.03: Reduced delay (400ms) for faster throughput\n      await new Promise(r => setTimeout(r, 400));\n    } catch (err) {\n      console.warn(`[v8.03] Lichess fetch failed for ${player}:`, err);\n      await new Promise(r => setTimeout(r, 800));\n    }\n  }\n  \n  return shuffleArray(games);\n}\n\nasync function fetchChessComGamesForPool(\n  count: number,\n  existingIds: Set<string>,\n  batchNumber: number,\n  onProgress?: (msg: string) => void\n): Promise<UnifiedGame[]> {\n  const games: UnifiedGame[] = [];\n  const shuffledPlayers = shuffleArray([...CHESSCOM_ELITE_PLAYERS]);\n  \n  // v8.03: FULLY randomized archive offset (0-36 months)\n  const monthOffset = Math.floor(Math.random() * 36);\n  \n  onProgress?.(`[Chess.com] Batch ${batchNumber}: Archive offset ${monthOffset} months`);\n  \n  // v8.04: Try more players (8 instead of 5) with expanded pool\n  for (const player of shuffledPlayers.slice(0, 8)) {\n    if (games.length >= count) break;\n    \n    try {\n      const result = await fetchChessComGames(player, {\n        max: 30, // v8.03: Request more games (was 20)\n        months: 2, // v8.03: Narrower window for precision\n        monthOffset,\n      });\n      \n      for (const game of result.games) {\n        if (games.length >= count) break;\n        \n        // Extract game ID from URL\n        const urlMatch = game.url.match(/\\/game\\/live\\/(\\d+)/);\n        const gameId = urlMatch ? `cc_${urlMatch[1]}` : `cc_${game.end_time}`;\n        \n        // v8.03: Check both raw and prefixed forms\n        const rawId = gameId.replace(/^cc_/, '');\n        if (existingIds.has(rawId) || existingIds.has(gameId)) continue;\n        if (!game.pgn || game.pgn.length < 100) continue;\n        \n        const gameResult = game.white.result === 'win' ? 'white_wins' :\n                      game.black.result === 'win' ? 'black_wins' : 'draw';\n        \n        games.push({\n          id: gameId,\n          name: `${game.white.username} (${game.white.rating}) vs ${game.black.username} (${game.black.rating})`,\n          pgn: game.pgn,\n          result: gameResult,\n          source: 'chesscom',\n          rating: Math.max(game.white.rating, game.black.rating),\n          whiteElo: game.white.rating,\n          blackElo: game.black.rating,\n          timeControl: game.time_class || undefined,\n        });\n      }\n      \n      // v8.03: Reduced delay (500ms) for faster throughput\n      await new Promise(r => setTimeout(r, 500));\n    } catch (err) {\n      console.warn(`[v8.03] Chess.com fetch failed for ${player}:`, err);\n      await new Promise(r => setTimeout(r, 1000));\n    }\n  }\n  \n  return shuffleArray(games);\n}\n\n// ================ ANALYSIS FUNCTIONS ================\n\n/**\n * v6.94-BULLETPROOF: Always use LOCAL Stockfish for guaranteed results\n * Cloud API is OPTIONAL enhancement only - pipeline works without it\n */\nasync function analyzeWithLocalStockfish(\n  game: UnifiedGame,\n  movesToPlay: number,\n  config: PoolConfig\n): Promise<{ eval: number; depth: number; nodes?: number; mode: string } | null> {\n  // v7.30-YIELD: CRITICAL - Check lock BEFORE touching Stockfish engine\n  if (isManualBenchmarkActive()) {\n    console.log(`[v7.30-YIELD] Manual benchmark owns engine, skipping analysis for ${game.id}`);\n    return null;\n  }\n  \n  const chess = new Chess();\n  \n  try {\n    chess.loadPgn(game.pgn);\n  } catch {\n    console.warn(`[v6.94] PGN parse failed for ${game.id}`);\n    return null;\n  }\n  \n  const history = chess.history();\n  if (history.length < movesToPlay) {\n    return null;\n  }\n  \n  chess.reset();\n  for (let i = 0; i < movesToPlay; i++) {\n    chess.move(history[i]);\n  }\n  \n  const fen = chess.fen();\n  \n  try {\n    const engine = getStockfishEngine();\n    \n    // Health check with timeout\n    const readyTimeout = new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error('Engine ready timeout')), 15000)\n    );\n    \n    try {\n      await Promise.race([engine.waitReady(), readyTimeout]);\n    } catch (readyErr) {\n      console.warn(`[v7.93] Engine not ready, smooth recovery...`);\n      terminateStockfish();\n      await new Promise(r => setTimeout(r, 500)); // v7.93: 500ms recovery (balanced)\n      const newEngine = getStockfishEngine();\n      await newEngine.waitReady();\n    }\n    \n    // Analysis with timeout\n    const analysisTimeout = new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Analysis timeout after ${config.analysisTimeout}ms`)), config.analysisTimeout)\n    );\n    \n    const analysis = await Promise.race([\n      engine.analyzePosition(fen, { \n        depth: config.localDepth,\n        nodes: config.localNodes,\n      }),\n      analysisTimeout,\n    ]);\n    \n    return {\n      eval: analysis.evaluation.score,\n      depth: analysis.evaluation.depth,\n      nodes: analysis.evaluation.nodes,\n      mode: config.stockfishMode,\n    };\n  } catch (err) {\n    console.error(`[v7.93] Analysis failed for ${game.id}:`, err);\n    \n    // v7.93: Smooth recovery - 500ms then attempt engine reset\n    try {\n      terminateStockfish();\n      await new Promise(r => setTimeout(r, 500));\n      const newEngine = getStockfishEngine();\n      await Promise.race([\n        newEngine.waitReady(),\n        new Promise(r => setTimeout(r, 3000))\n      ]);\n    } catch (recoveryErr) {\n      console.warn('[v7.93] Recovery failed:', recoveryErr);\n      // v7.93: Extra delay after failed recovery\n      await new Promise(r => setTimeout(r, 1000));\n    }\n    \n    return null;\n  }\n}\n\n// Legacy wrapper for backward compatibility\nasync function analyzeWithCloudPool(\n  game: UnifiedGame,\n  movesToPlay: number,\n  config: PoolConfig\n): Promise<{ eval: number; depth: number; nodes?: number } | null> {\n  // v6.94: Route to local Stockfish - cloud is unreliable\n  const result = await analyzeWithLocalStockfish(game, movesToPlay, CLOUD_POOL_CONFIG);\n  return result ? { eval: result.eval, depth: result.depth, nodes: result.nodes } : null;\n}\n\nasync function analyzeWithLocalPool(\n  game: UnifiedGame,\n  movesToPlay: number,\n  config: PoolConfig\n): Promise<{ eval: number; depth: number; nodes?: number } | null> {\n  const result = await analyzeWithLocalStockfish(game, movesToPlay, config);\n  return result ? { eval: result.eval, depth: result.depth, nodes: result.nodes } : null;\n}\n\n// ================ MAIN PIPELINE FUNCTIONS ================\n\nexport async function runCloudPoolBatch(\n  targetCount: number,\n  batchNumber: number,\n  onProgress?: (status: string, progress: number, prediction?: PoolPrediction) => void\n): Promise<PoolPrediction[]> {\n  const predictions: PoolPrediction[] = [];\n  const config = CLOUD_POOL_CONFIG;\n  \n  // v7.13: Check for manual benchmark before starting\n  if (isManualBenchmarkActive()) {\n    console.log('[v7.13] Manual benchmark active, skipping pool batch');\n    return predictions;\n  }\n  \n  onProgress?.(`[${config.name}] Starting batch ${batchNumber}...`, 0);\n  \n  // v7.15-SIMPLE-DEDUP: Init known IDs ONCE (cached after first call)\n  try {\n    await withTimeout(initKnownIds(), 8000, 'InitKnownIds');\n  } catch (err) {\n    console.warn('[v7.15] Failed to init known IDs, continuing:', err);\n  }\n  const existingIds = getKnownIds();\n  \n  // v7.0: Fetch games with hard timeouts - continue even if one source fails\n  let lichessGames: UnifiedGame[] = [];\n  let chesscomGames: UnifiedGame[] = [];\n  \n  try {\n    lichessGames = await withTimeout(\n      fetchLichessGamesForPool(Math.ceil(targetCount * 0.7), existingIds, batchNumber, (msg) => onProgress?.(msg, 5)),\n      20000,\n      'FetchLichess'\n    );\n  } catch (err) {\n    console.warn('[v7.15] Lichess fetch timeout/error:', err);\n  }\n  \n  try {\n    chesscomGames = await withTimeout(\n      fetchChessComGamesForPool(Math.ceil(targetCount * 0.3), existingIds, batchNumber, (msg) => onProgress?.(msg, 10)),\n      20000,\n      'FetchChessCom'\n    );\n  } catch (err) {\n    console.warn('[v7.15] Chess.com fetch timeout/error:', err);\n  }\n  \n  // v7.15-SIMPLE-DEDUP: Filter games using simple check\n  const allGames = shuffleArray([...lichessGames, ...chesscomGames]).filter(game => !isKnown(game.id));\n  \n  if (allGames.length === 0) {\n    onProgress?.(`[${config.name}] No fresh games found`, 100);\n    return [];\n  }\n  \n  onProgress?.(`[${config.name}] Processing ${allGames.length} fresh games...`, 15);\n  \n  let processed = 0;\n  for (const game of allGames) {\n    if (predictions.length >= targetCount) break;\n    \n    // v7.30-YIELD: Check for manual benchmark at START of each game\n    if (isManualBenchmarkActive()) {\n      console.log(`[v7.30-YIELD] Manual benchmark detected mid-batch, yielding ${predictions.length} predictions`);\n      return predictions; // Return what we have so far\n    }\n    \n    const startTime = Date.now();\n    const movesToPlay = 15 + Math.floor(Math.random() * 20); // 15-35\n    \n    try {\n      const sfResult = await analyzeWithCloudPool(game, movesToPlay, config);\n      if (!sfResult) {\n        processed++;\n        continue;\n      }\n      \n      // Get position for hybrid analysis\n      const chess = new Chess();\n      chess.loadPgn(game.pgn);\n      const history = chess.history();\n      chess.reset();\n      for (let i = 0; i < movesToPlay; i++) {\n        chess.move(history[i]);\n      }\n      const fen = chess.fen();\n      const truncatedPgn = chess.pgn();\n      \n      // v6.96-LOCAL: Use local hybrid prediction (no cloud API)\n      const hybridResult = await generateLocalHybridPrediction(truncatedPgn, sfResult.eval, sfResult.depth);\n      \n      const sfPrediction = evalToPredictionBalanced(sfResult.eval);\n      \n      const prediction: PoolPrediction = {\n        gameId: game.id,\n        gameName: game.name,\n        moveNumber: movesToPlay,\n        fen,\n        pgn: truncatedPgn,\n        stockfishEval: sfResult.eval,\n        stockfishDepth: sfResult.depth,\n        stockfishMode: 'local', // v6.96: Always local now\n        stockfishNodes: sfResult.nodes,\n        stockfishPrediction: sfPrediction.prediction,\n        stockfishConfidence: sfPrediction.confidence,\n        hybridPrediction: hybridResult.prediction,\n        hybridConfidence: hybridResult.confidence,\n        hybridArchetype: hybridResult.archetype,\n        actualResult: game.result,\n        stockfishCorrect: sfPrediction.prediction === game.result,\n        hybridCorrect: hybridResult.prediction === game.result,\n        dataSource: game.source,\n        poolName: config.name,\n        analysisTimeMs: Date.now() - startTime,\n        // v7.17: Include ELO and time control for DB alignment\n        whiteElo: game.whiteElo,\n        blackElo: game.blackElo,\n        timeControl: game.timeControl,\n      };\n      \n      predictions.push(prediction);\n      processed++;\n      \n      const progress = 15 + (processed / allGames.length) * 85;\n      onProgress?.(`[${config.name}] ${predictions.length}/${targetCount} analyzed`, progress, prediction);\n      \n      // v7.41-BREATHE: Use breathing pacer to mark known AND enforce cooldown\n      await breathe(game.id, markKnown, config.delayBetweenGames);\n      \n    } catch (err) {\n      console.error(`[${config.name}] Error processing ${game.id}:`, err);\n      processed++;\n    }\n  }\n  \n  onProgress?.(`[${config.name}] Completed: ${predictions.length} predictions`, 100);\n  return predictions;\n}\n\nexport async function runLocalPoolBatch(\n  targetCount: number,\n  batchNumber: number,\n  onProgress?: (status: string, progress: number, prediction?: PoolPrediction) => void\n): Promise<PoolPrediction[]> {\n  const predictions: PoolPrediction[] = [];\n  const config = LOCAL_POOL_CONFIG;\n  \n  onProgress?.(`[${config.name}] Starting batch ${batchNumber}...`, 0);\n  \n  // v7.15-SIMPLE-DEDUP: Init known IDs ONCE (cached after first call)\n  try {\n    await withTimeout(initKnownIds(), 8000, 'InitKnownIds');\n  } catch (err) {\n    console.warn('[v7.15] Failed to init known IDs:', err);\n  }\n  const existingIds = getKnownIds();\n  \n  // Fetch games - prefer Lichess for local analysis\n  const rawGames = await fetchLichessGamesForPool(\n    targetCount * 3, // Fetch extra for filtering\n    existingIds, \n    batchNumber + 100, // Different window than cloud pool\n    (msg) => onProgress?.(msg, 5)\n  );\n  \n  // v7.15-SIMPLE-DEDUP: Filter using simple check\n  const games = rawGames.filter(game => !isKnown(game.id));\n  \n  if (games.length === 0) {\n    onProgress?.(`[${config.name}] No fresh games found`, 100);\n    return [];\n  }\n  \n  onProgress?.(`[${config.name}] Deep analyzing ${Math.min(games.length, targetCount)} games...`, 10);\n  \n  let processed = 0;\n  for (const game of games) {\n    if (predictions.length >= targetCount) break;\n    \n    // v7.30-YIELD: Check for manual benchmark at START of each game\n    if (isManualBenchmarkActive()) {\n      console.log(`[v7.30-YIELD] Manual benchmark detected mid-batch, yielding ${predictions.length} predictions`);\n      return predictions; // Return what we have so far\n    }\n    \n    const startTime = Date.now();\n    const movesToPlay = 15 + Math.floor(Math.random() * 20);\n    \n    const progressBase = 10 + (processed / targetCount) * 90;\n    onProgress?.(`[${config.name}] Deep analyzing: ${game.name}`, progressBase);\n    \n    try {\n      const sfResult = await analyzeWithLocalPool(game, movesToPlay, config);\n      if (!sfResult) {\n        processed++;\n        continue;\n      }\n      \n      // Get position for hybrid analysis\n      const chess = new Chess();\n      chess.loadPgn(game.pgn);\n      const history = chess.history();\n      chess.reset();\n      for (let i = 0; i < movesToPlay; i++) {\n        chess.move(history[i]);\n      }\n      const fen = chess.fen();\n      const truncatedPgn = chess.pgn();\n      \n      // v6.96-LOCAL: Use local hybrid prediction (no cloud API)\n      const hybridResult = await generateLocalHybridPrediction(truncatedPgn, sfResult.eval, sfResult.depth);\n      \n      const sfPrediction = evalToPredictionBalanced(sfResult.eval);\n      \n      const prediction: PoolPrediction = {\n        gameId: game.id,\n        gameName: game.name,\n        moveNumber: movesToPlay,\n        fen,\n        pgn: truncatedPgn,\n        stockfishEval: sfResult.eval,\n        stockfishDepth: sfResult.depth,\n        stockfishMode: 'local',\n        stockfishNodes: sfResult.nodes,\n        stockfishPrediction: sfPrediction.prediction,\n        stockfishConfidence: sfPrediction.confidence,\n        hybridPrediction: hybridResult.prediction,\n        hybridConfidence: hybridResult.confidence,\n        hybridArchetype: hybridResult.archetype,\n        actualResult: game.result,\n        stockfishCorrect: sfPrediction.prediction === game.result,\n        hybridCorrect: hybridResult.prediction === game.result,\n        dataSource: game.source,\n        poolName: config.name,\n        analysisTimeMs: Date.now() - startTime,\n        // v7.17: Include ELO and time control for DB alignment\n        whiteElo: game.whiteElo,\n        blackElo: game.blackElo,\n        timeControl: game.timeControl,\n      };\n      \n      predictions.push(prediction);\n      processed++;\n      \n      console.log(`[${config.name}] Deep analysis complete: ${game.name} (${Math.round((Date.now() - startTime) / 1000)}s)`);\n      onProgress?.(`[${config.name}] ${predictions.length}/${targetCount} deep analyzed`, progressBase + 5, prediction);\n      \n      // v7.41-BREATHE: Use breathing pacer to mark known AND enforce cooldown\n      await breathe(game.id, markKnown, config.delayBetweenGames);\n      \n    } catch (err) {\n      console.error(`[${config.name}] Error processing ${game.id}:`, err);\n      processed++;\n    }\n  }\n  \n  onProgress?.(`[${config.name}] Completed: ${predictions.length} deep predictions`, 100);\n  return predictions;\n}\n\n// ================ PERSISTENCE ================\n\nexport async function savePoolPredictions(\n  predictions: PoolPrediction[],\n  poolName: string\n): Promise<string | null> {\n  if (predictions.length === 0) return null;\n  \n  const runId = `pool-${poolName}-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;\n  \n  try {\n    // Calculate stats\n    const sfCorrect = predictions.filter(p => p.stockfishCorrect).length;\n    const hybridCorrect = predictions.filter(p => p.hybridCorrect).length;\n    \n    // Save benchmark result\n    const { data: benchmarkData, error: benchmarkError } = await supabase\n      .from('chess_benchmark_results')\n      .insert({\n        run_id: runId,\n        data_source: 'dual_pool_pipeline',\n        total_games: predictions.length,\n        completed_games: predictions.length,\n        prediction_move_number: 25, // Average\n        stockfish_accuracy: (sfCorrect / predictions.length) * 100,\n        hybrid_accuracy: (hybridCorrect / predictions.length) * 100,\n        stockfish_wins: predictions.filter(p => p.stockfishCorrect && !p.hybridCorrect).length,\n        hybrid_wins: predictions.filter(p => p.hybridCorrect && !p.stockfishCorrect).length,\n        both_correct: predictions.filter(p => p.stockfishCorrect && p.hybridCorrect).length,\n        both_wrong: predictions.filter(p => !p.stockfishCorrect && !p.hybridCorrect).length,\n        stockfish_version: poolName === 'LOCAL-DEEP' ? 'Stockfish 17 NNUE Local D30' : 'Lichess Cloud SF17',\n        stockfish_mode: poolName.toLowerCase(),\n        hybrid_version: `En Pensent v6.92 (${poolName})`,\n        data_quality_tier: 'dual_pool',\n        games_analyzed: predictions.map(p => p.gameName),\n      })\n      .select('id')\n      .single();\n    \n    if (benchmarkError) {\n      console.error(`[v6.92] Failed to save benchmark:`, benchmarkError);\n      return null;\n    }\n    \n    const benchmarkId = benchmarkData.id;\n    \n    // Save individual predictions\n    // v7.17-SCHEMA-ALIGNED: Ensure all fields match DB schema exactly\n    const attempts = predictions.map(p => ({\n      benchmark_id: benchmarkId,\n      // v7.17: Strip prefix from game_id for DB consistency (raw ID only)\n      game_id: toRawId(p.gameId),\n      game_name: p.gameName,\n      move_number: p.moveNumber,\n      fen: p.fen,\n      pgn: p.pgn,\n      stockfish_eval: p.stockfishEval,\n      stockfish_depth: p.stockfishDepth,\n      stockfish_prediction: p.stockfishPrediction,\n      stockfish_confidence: p.stockfishConfidence,\n      hybrid_prediction: p.hybridPrediction,\n      hybrid_confidence: p.hybridConfidence,\n      hybrid_archetype: p.hybridArchetype,\n      actual_result: p.actualResult,\n      stockfish_correct: p.stockfishCorrect,\n      hybrid_correct: p.hybridCorrect,\n      position_hash: hashPosition(p.fen),\n      data_source: p.dataSource,\n      data_quality_tier: 'dual_pool',\n      // v7.17: Add missing fields that manual benchmark includes\n      lichess_id_verified: true,\n      time_control: p.timeControl || null,\n      white_elo: p.whiteElo || null,\n      black_elo: p.blackElo || null,\n    }));\n    \n    // v7.90: Batch upsert with conflict handling to prevent duplicate key errors\n    const BATCH_SIZE = 25;\n    for (let i = 0; i < attempts.length; i += BATCH_SIZE) {\n      const batch = attempts.slice(i, i + BATCH_SIZE);\n      const { error } = await supabase\n        .from('chess_prediction_attempts')\n        .upsert(batch, { \n          onConflict: 'game_id',\n          ignoreDuplicates: true \n        });\n      \n      if (error) {\n        console.error(`[v7.90] Batch ${i / BATCH_SIZE + 1} failed:`, error);\n      }\n    }\n    \n    console.log(`[v6.92] Saved ${predictions.length} predictions to run ${runId}`);\n    return runId;\n    \n  } catch (err) {\n    console.error(`[v6.92] Save failed:`, err);\n    return null;\n  }\n}\n\n// ================ MAIN DUAL-POOL RUNNER ================\n\nexport async function runDualPoolPipeline(\n  options: {\n    cloudTarget?: number;\n    localTarget?: number;\n    runCloud?: boolean;\n    runLocal?: boolean;\n  } = {},\n  onProgress?: (status: string, cloudProgress: PoolProgress, localProgress: PoolProgress) => void\n): Promise<DualPoolResult> {\n  const {\n    cloudTarget = 100,\n    localTarget = 5,\n    runCloud = true,\n    runLocal = true,\n  } = options;\n  \n  const result: DualPoolResult = {\n    cloudPool: [],\n    localPool: [],\n    totalProcessed: 0,\n    cloudAccuracy: { stockfish: 0, hybrid: 0 },\n    localAccuracy: { stockfish: 0, hybrid: 0 },\n    startedAt: new Date(),\n  };\n  \n  const cloudProgress: PoolProgress = {\n    poolName: 'CLOUD-VOLUME',\n    completed: 0,\n    target: cloudTarget,\n    gamesPerHour: 0,\n    lastGameTime: Date.now(),\n    status: 'running',\n  };\n  \n  const localProgress: PoolProgress = {\n    poolName: 'LOCAL-DEEP',\n    completed: 0,\n    target: localTarget,\n    gamesPerHour: 0,\n    lastGameTime: Date.now(),\n    status: 'running',\n  };\n  \n  const batchNumber = Math.floor(Date.now() / 3600000); // Hour-based batch\n  \n  // Run pools sequentially for stability (can be parallelized if needed)\n  if (runCloud) {\n    cloudProgress.status = 'running';\n    onProgress?.('Running cloud pool...', cloudProgress, localProgress);\n    \n    const cloudPredictions = await runCloudPoolBatch(\n      cloudTarget,\n      batchNumber,\n      (status, progress, prediction) => {\n        if (prediction) {\n          cloudProgress.completed++;\n          cloudProgress.lastGameTime = Date.now();\n        }\n        onProgress?.(status, cloudProgress, localProgress);\n      }\n    );\n    \n    result.cloudPool = cloudPredictions;\n    cloudProgress.completed = cloudPredictions.length;\n    cloudProgress.status = 'completed';\n    \n    // Calculate accuracy\n    if (cloudPredictions.length > 0) {\n      result.cloudAccuracy.stockfish = (cloudPredictions.filter(p => p.stockfishCorrect).length / cloudPredictions.length) * 100;\n      result.cloudAccuracy.hybrid = (cloudPredictions.filter(p => p.hybridCorrect).length / cloudPredictions.length) * 100;\n    }\n    \n    // Save cloud predictions\n    await savePoolPredictions(cloudPredictions, 'CLOUD-VOLUME');\n  }\n  \n  if (runLocal) {\n    localProgress.status = 'running';\n    onProgress?.('Running local deep pool...', cloudProgress, localProgress);\n    \n    const localPredictions = await runLocalPoolBatch(\n      localTarget,\n      batchNumber,\n      (status, progress, prediction) => {\n        if (prediction) {\n          localProgress.completed++;\n          localProgress.lastGameTime = Date.now();\n        }\n        onProgress?.(status, cloudProgress, localProgress);\n      }\n    );\n    \n    result.localPool = localPredictions;\n    localProgress.completed = localPredictions.length;\n    localProgress.status = 'completed';\n    \n    // Calculate accuracy\n    if (localPredictions.length > 0) {\n      result.localAccuracy.stockfish = (localPredictions.filter(p => p.stockfishCorrect).length / localPredictions.length) * 100;\n      result.localAccuracy.hybrid = (localPredictions.filter(p => p.hybridCorrect).length / localPredictions.length) * 100;\n    }\n    \n    // Save local predictions\n    await savePoolPredictions(localPredictions, 'LOCAL-DEEP');\n  }\n  \n  result.totalProcessed = result.cloudPool.length + result.localPool.length;\n  result.completedAt = new Date();\n  \n  onProgress?.(`Pipeline complete: ${result.totalProcessed} total predictions`, cloudProgress, localProgress);\n  \n  return result;\n}\n\nexport default runDualPoolPipeline;\n";export{n as default};
