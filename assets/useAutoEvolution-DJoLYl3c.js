const t="/**\n * React Hook for Auto-Evolution Engine v7.24-LIVE-STATS\n * \n * Provides complete control over the self-healing evolution system:\n * - Start/Stop/Pause controls\n * - Real-time stats and progress from DATABASE\n * - Event subscriptions for UI updates\n * - Force batch triggers\n * \n * v7.24: Stats are now fetched from DB on mount (not just when engine starts)\n *        Uses useRealtimeAccuracyContext for live updates\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useToast } from '@/hooks/use-toast';\nimport {\n  startAutoEvolution,\n  stopAutoEvolution,\n  pauseAutoEvolution,\n  resumeAutoEvolution,\n  getEvolutionState,\n  subscribeToEvolution,\n  forceRunBatch,\n  type EvolutionState,\n  AUTO_EVOLUTION_VERSION,\n} from '@/lib/chess/autoEvolutionEngine';\nimport { useRealtimeAccuracyContext } from '@/providers/RealtimeAccuracyProvider';\n\nexport interface UseAutoEvolutionReturn {\n  // State\n  state: EvolutionState;\n  isRunning: boolean;\n  isPaused: boolean;\n  \n  // Stats\n  sessionPredictions: number;\n  totalPredictions: number;\n  cloudPredictions: number;\n  localPredictions: number;\n  \n  // Health\n  consecutiveErrors: number;\n  recoveryCount: number;\n  poolStatus: {\n    cloud: string;\n    local: string;\n  };\n  \n  // Time info\n  sessionDuration: string;\n  lastSuccess: string;\n  lastError: string;\n  \n  // Actions\n  start: () => Promise<void>;\n  stop: () => void;\n  pause: () => void;\n  resume: () => void;\n  forceCloud: () => void;\n  forceLocal: () => void;\n  \n  // Events\n  lastEvent: { type: string; data?: any } | null;\n  \n  // Version\n  version: string;\n}\n\nexport function useAutoEvolution(): UseAutoEvolutionReturn {\n  const { toast } = useToast();\n  const [state, setState] = useState<EvolutionState>(getEvolutionState);\n  const [lastEvent, setLastEvent] = useState<{ type: string; data?: any } | null>(null);\n  const [sessionDuration, setSessionDuration] = useState('0s');\n  \n  // v7.24: Use realtime context for LIVE database stats\n  const { chessStats } = useRealtimeAccuracyContext();\n  \n  const sessionTimerRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Subscribe to evolution events\n  useEffect(() => {\n    const unsubscribe = subscribeToEvolution((newState, event, data) => {\n      setState(newState);\n      setLastEvent({ type: event, data });\n      \n      // Toast notifications for key events\n      if (event === 'cloud_batch_complete' || event === 'local_batch_complete') {\n        toast({\n          title: `ðŸ§¬ ${event.includes('cloud') ? 'Cloud' : 'Deep'} Batch Complete`,\n          description: `+${data?.count} predictions (${newState.sessionPredictions} session / ${chessStats?.totalGames || newState.totalPredictions} total)`,\n        });\n      } else if (event === 'recovery_complete') {\n        toast({\n          title: 'ðŸ”„ Auto-Recovery Complete',\n          description: `System recovered (${data?.count} total recoveries)`,\n        });\n      } else if (event === 'engine_started') {\n        toast({\n          title: 'ðŸš€ Auto-Evolution ACTIVE',\n          description: `v${AUTO_EVOLUTION_VERSION} - Never stops absorbing data`,\n        });\n      }\n    });\n    \n    return unsubscribe;\n  }, [toast, chessStats]);\n  \n  // Session duration timer\n  useEffect(() => {\n    if (state.isRunning && state.sessionStartedAt) {\n      sessionTimerRef.current = setInterval(() => {\n        const elapsed = Date.now() - state.sessionStartedAt!.getTime();\n        const hours = Math.floor(elapsed / 3600000);\n        const mins = Math.floor((elapsed % 3600000) / 60000);\n        const secs = Math.floor((elapsed % 60000) / 1000);\n        \n        if (hours > 0) {\n          setSessionDuration(`${hours}h ${mins}m`);\n        } else if (mins > 0) {\n          setSessionDuration(`${mins}m ${secs}s`);\n        } else {\n          setSessionDuration(`${secs}s`);\n        }\n      }, 1000);\n    } else {\n      if (sessionTimerRef.current) {\n        clearInterval(sessionTimerRef.current);\n      }\n      setSessionDuration('0s');\n    }\n    \n    return () => {\n      if (sessionTimerRef.current) {\n        clearInterval(sessionTimerRef.current);\n      }\n    };\n  }, [state.isRunning, state.sessionStartedAt]);\n  \n  // Actions\n  const start = useCallback(async () => {\n    await startAutoEvolution();\n  }, []);\n  \n  const stop = useCallback(() => {\n    stopAutoEvolution();\n    toast({\n      title: 'â¹ï¸ Evolution Stopped',\n      description: `Session: ${state.sessionPredictions} predictions`,\n    });\n  }, [state.sessionPredictions, toast]);\n  \n  const pause = useCallback(() => {\n    pauseAutoEvolution();\n    toast({\n      title: 'â¸ï¸ Evolution Paused',\n      description: 'Will resume from current position',\n    });\n  }, [toast]);\n  \n  const resume = useCallback(() => {\n    resumeAutoEvolution();\n    toast({\n      title: 'â–¶ï¸ Evolution Resumed',\n      description: 'Continuing data absorption',\n    });\n  }, [toast]);\n  \n  const forceCloud = useCallback(() => {\n    forceRunBatch('cloud');\n    toast({\n      title: 'âš¡ Forcing Cloud Batch',\n      description: 'Running immediate cloud analysis',\n    });\n  }, [toast]);\n  \n  const forceLocal = useCallback(() => {\n    forceRunBatch('local');\n    toast({\n      title: 'âš¡ Forcing Deep Batch',\n      description: 'Running immediate deep analysis',\n    });\n  }, [toast]);\n  \n  // Format time helpers\n  const formatTimeAgo = (date: Date | null): string => {\n    if (!date) return 'never';\n    const elapsed = Date.now() - date.getTime();\n    if (elapsed < 60000) return `${Math.floor(elapsed / 1000)}s ago`;\n    if (elapsed < 3600000) return `${Math.floor(elapsed / 60000)}m ago`;\n    return `${Math.floor(elapsed / 3600000)}h ago`;\n  };\n  \n  // v7.24: Use REAL database stats from realtime context, not engine singleton\n  // This ensures stats are accurate even before engine starts\n  const totalFromDb = chessStats?.totalGames || 0;\n  const volumeFromDb = chessStats?.volumePoolCount || 0;\n  const deepFromDb = chessStats?.deepPoolCount || 0;\n  \n  return {\n    state,\n    isRunning: state.isRunning,\n    isPaused: state.isPaused,\n    \n    sessionPredictions: state.sessionPredictions,\n    // v7.24: Prefer DB stats over engine state\n    totalPredictions: totalFromDb > 0 ? totalFromDb : state.totalPredictions,\n    cloudPredictions: volumeFromDb > 0 ? volumeFromDb : state.totalCloudPredictions,\n    localPredictions: deepFromDb > 0 ? deepFromDb : state.totalLocalPredictions,\n    \n    consecutiveErrors: state.consecutiveErrors,\n    recoveryCount: state.recoveryCount,\n    poolStatus: {\n      cloud: state.cloudPoolStatus,\n      local: state.localPoolStatus,\n    },\n    \n    sessionDuration,\n    lastSuccess: formatTimeAgo(state.lastSuccessAt),\n    lastError: formatTimeAgo(state.lastErrorAt),\n    \n    start,\n    stop,\n    pause,\n    resume,\n    forceCloud,\n    forceLocal,\n    \n    lastEvent,\n    version: AUTO_EVOLUTION_VERSION,\n  };\n}\n\nexport default useAutoEvolution;\n";export{t as default};
