const n="/**\n * Options Flow Integration Module\n * \n * Integrates with options flow data providers to detect:\n * - Unusual options activity (sweeps, blocks, whale trades)\n * - Sentiment indicators (bullish/bearish flow)\n * - Implied volatility changes\n * - Gamma exposure levels\n */\n\nimport { ASSET_CLASSES } from '../trading/multiAssetConfig';\n\ninterface OptionsFlowAlert {\n  id: string;\n  timestamp: string;\n  symbol: string;\n  underlyingPrice: number;\n  expiration: string;\n  strike: number;\n  type: 'call' | 'put';\n  side: 'buy' | 'sell';\n  size: number;\n  premium: number;\n  iv: number;\n  delta: number;\n  alertType: 'sweep' | 'block' | 'whale' | 'unusual_volume' | 'repeat';\n  sentiment: 'bullish' | 'bearish' | 'neutral';\n  confidence: number;\n  tags: string[];\n}\n\ninterface FlowSummary {\n  symbol: string;\n  timestamp: string;\n  callVolume: number;\n  putVolume: number;\n  callPremium: number;\n  putPremium: number;\n  callOpenInterest: number;\n  putOpenInterest: number;\n  ivRank: number;\n  ivPercentile: number;\n  putCallRatio: number;\n  bullishFlow: boolean;\n  netPremium: number;\n  unusualActivity: boolean;\n}\n\ninterface GammaExposure {\n  symbol: string;\n  timestamp: string;\n  totalGamma: number;\n  callGamma: number;\n  putGamma: number;\n  gammaNotional: number;\n  maxPain: number;\n  pinRisk: boolean;\n}\n\nexport class OptionsFlowIntegration {\n  private flowHistory: Map<string, OptionsFlowAlert[]> = new Map();\n  private summaries: Map<string, FlowSummary> = new Map();\n  private gammaData: Map<string, GammaExposure> = new Map();\n  private subscribers: ((alert: OptionsFlowAlert) => void)[] = [];\n  \n  private readonly API_ENDPOINTS = {\n    unusualWolves: 'https://api.unusualwhales.com',\n    marketChameleon: 'https://api.marketchameleon.com',\n    cheddarFlow: 'https://api.cheddarflow.com',\n  };\n  \n  constructor(private apiKey: string, private supabase: any) {}\n  \n  async initialize() {\n    console.log('[OptionsFlow] Initializing options flow module...');\n    \n    // Start polling for flow data\n    this.startFlowPolling();\n    \n    // Start gamma exposure tracking\n    this.startGammaTracking();\n    \n    console.log('[OptionsFlow] Initialized');\n  }\n  \n  private startFlowPolling() {\n    // Poll every 30 seconds during market hours\n    setInterval(async () => {\n      if (this.isMarketOpen()) {\n        await this.fetchOptionsFlow();\n      }\n    }, 30000);\n  }\n  \n  private startGammaTracking() {\n    // Update gamma exposure every 5 minutes\n    setInterval(async () => {\n      if (this.isMarketOpen()) {\n        await this.updateGammaExposure();\n      }\n    }, 300000);\n  }\n  \n  private async fetchOptionsFlow() {\n    try {\n      // Fetch from multiple sources\n      const alerts: OptionsFlowAlert[] = [];\n      \n      // Source 1: Unusual Whales (if API key available)\n      const uwAlerts = await this.fetchUnusualWhales();\n      alerts.push(...uwAlerts);\n      \n      // Source 2: Market Chameleon\n      const mcAlerts = await this.fetchMarketChameleon();\n      alerts.push(...mcAlerts);\n      \n      // Process and filter alerts\n      for (const alert of alerts) {\n        if (this.isSignificant(alert)) {\n          this.processAlert(alert);\n        }\n      }\n      \n      // Update summaries\n      this.updateSummaries();\n      \n    } catch (err) {\n      console.error('[OptionsFlow] Fetch error:', err);\n    }\n  }\n  \n  private async fetchUnusualWhales(): Promise<OptionsFlowAlert[]> {\n    // Placeholder - integrate with actual Unusual Whales API\n    // Requires API key and subscription\n    return [];\n  }\n  \n  private async fetchMarketChameleon(): Promise<OptionsFlowAlert[]> {\n    // Placeholder - integrate with Market Chameleon API\n    return [];\n  }\n  \n  private async updateGammaExposure() {\n    for (const symbol of ASSET_CLASSES.OPTIONS.underlying) {\n      try {\n        const gamma = await this.calculateGammaExposure(symbol);\n        this.gammaData.set(symbol, gamma);\n        \n        // Save to database\n        await this.supabase.from('gamma_exposure').insert({\n          symbol,\n          ...gamma,\n          timestamp: new Date().toISOString(),\n        });\n      } catch (err) {\n        console.warn(`[OptionsFlow] Gamma calc failed for ${symbol}:`, err);\n      }\n    }\n  }\n  \n  private async calculateGammaExposure(symbol: string): Promise<GammaExposure> {\n    // Fetch options chain\n    const { data: chain } = await this.supabase\n      .from('options_chain')\n      .select('*')\n      .eq('symbol', symbol)\n      .order('strike', { ascending: true });\n    \n    if (!chain || chain.length === 0) {\n      return {\n        symbol,\n        timestamp: new Date().toISOString(),\n        totalGamma: 0,\n        callGamma: 0,\n        putGamma: 0,\n        gammaNotional: 0,\n        maxPain: 0,\n        pinRisk: false,\n      };\n    }\n    \n    let totalGamma = 0;\n    let callGamma = 0;\n    let putGamma = 0;\n    let gammaNotional = 0;\n    \n    // Calculate gamma exposure\n    for (const option of chain) {\n      const gamma = option.gamma || 0;\n      const oi = option.open_interest || 0;\n      const gammaExposure = gamma * oi * option.underlying_price;\n      \n      totalGamma += gammaExposure;\n      \n      if (option.type === 'call') {\n        callGamma += gammaExposure;\n      } else {\n        putGamma += gammaExposure;\n      }\n      \n      gammaNotional += Math.abs(gammaExposure);\n    }\n    \n    // Find max pain (strike with minimum total value)\n    const strikes = [...new Set(chain.map((o: any) => o.strike))];\n    let maxPain = strikes[0];\n    let minPain = Infinity;\n    \n    for (const strike of strikes) {\n      const pain = chain\n        .filter((o: any) => o.strike === strike)\n        .reduce((sum: number, o: any) => {\n          const intrinsic = o.type === 'call' \n            ? Math.max(0, o.underlying_price - o.strike)\n            : Math.max(0, o.strike - o.underlying_price);\n          return sum + intrinsic * o.open_interest;\n        }, 0);\n      \n      if (pain < minPain) {\n        minPain = pain;\n        maxPain = strike;\n      }\n    }\n    \n    // Check for pin risk (price near max pain with high gamma)\n    const currentPrice = chain[0]?.underlying_price || 0;\n    const pinRisk = Math.abs(currentPrice - maxPain) / currentPrice < 0.01 && \n                   Math.abs(totalGamma) > 1000000;\n    \n    return {\n      symbol,\n      timestamp: new Date().toISOString(),\n      totalGamma,\n      callGamma,\n      putGamma,\n      gammaNotional,\n      maxPain,\n      pinRisk,\n    };\n  }\n  \n  private processAlert(alert: OptionsFlowAlert) {\n    // Add to history\n    if (!this.flowHistory.has(alert.symbol)) {\n      this.flowHistory.set(alert.symbol, []);\n    }\n    \n    const history = this.flowHistory.get(alert.symbol)!;\n    history.push(alert);\n    \n    // Keep last 1000 alerts per symbol\n    if (history.length > 1000) {\n      history.shift();\n    }\n    \n    // Save to database\n    this.saveAlert(alert);\n    \n    // Notify subscribers\n    this.subscribers.forEach(cb => {\n      try {\n        cb(alert);\n      } catch (err) {\n        console.error('[OptionsFlow] Subscriber error:', err);\n      }\n    });\n  }\n  \n  private updateSummaries() {\n    for (const [symbol, alerts] of this.flowHistory) {\n      const recent = alerts.filter(a => \n        new Date(a.timestamp).getTime() > Date.now() - 3600000 // Last hour\n      );\n      \n      const calls = recent.filter(a => a.type === 'call');\n      const puts = recent.filter(a => a.type === 'put');\n      \n      const callVolume = calls.reduce((sum, a) => sum + a.size, 0);\n      const putVolume = puts.reduce((sum, a) => sum + a.size, 0);\n      const callPremium = calls.reduce((sum, a) => sum + a.premium, 0);\n      const putPremium = puts.reduce((sum, a) => sum + a.premium, 0);\n      \n      const summary: FlowSummary = {\n        symbol,\n        timestamp: new Date().toISOString(),\n        callVolume,\n        putVolume,\n        callPremium,\n        putPremium,\n        callOpenInterest: 0, // Would need OI data\n        putOpenInterest: 0,\n        ivRank: 0, // Would need IV history\n        ivPercentile: 0,\n        putCallRatio: callVolume > 0 ? putVolume / callVolume : 0,\n        bullishFlow: callPremium > putPremium * 1.2,\n        netPremium: callPremium - putPremium,\n        unusualActivity: recent.some(a => a.alertType === 'unusual_volume' || a.alertType === 'whale'),\n      };\n      \n      this.summaries.set(symbol, summary);\n    }\n  }\n  \n  private isSignificant(alert: OptionsFlowAlert): boolean {\n    // Filter criteria\n    const minPremium = 50000; // $50k minimum\n    const minSize = 100; // 100 contracts minimum\n    \n    return alert.premium >= minPremium || alert.size >= minSize;\n  }\n  \n  private isMarketOpen(): boolean {\n    const now = new Date();\n    const hour = now.getHours();\n    const day = now.getDay();\n    \n    // Simple check - 9:30 AM to 4:00 PM ET, weekdays only\n    // Adjust for your timezone\n    return day >= 1 && day <= 5 && hour >= 9 && hour < 16;\n  }\n  \n  private async saveAlert(alert: OptionsFlowAlert) {\n    try {\n      await this.supabase.from('options_flow_alerts').insert(alert);\n    } catch (err) {\n      console.warn('[OptionsFlow] Failed to save alert:', err);\n    }\n  }\n  \n  // Public API\n  subscribe(callback: (alert: OptionsFlowAlert) => void) {\n    this.subscribers.push(callback);\n  }\n  \n  unsubscribe(callback: (alert: OptionsFlowAlert) => void) {\n    const idx = this.subscribers.indexOf(callback);\n    if (idx > -1) this.subscribers.splice(idx, 1);\n  }\n  \n  getRecentAlerts(symbol: string, minutes: number = 30): OptionsFlowAlert[] {\n    const history = this.flowHistory.get(symbol) || [];\n    const cutoff = Date.now() - minutes * 60000;\n    return history.filter(a => new Date(a.timestamp).getTime() > cutoff);\n  }\n  \n  getFlowSummary(symbol: string): FlowSummary | undefined {\n    return this.summaries.get(symbol);\n  }\n  \n  getGammaExposure(symbol: string): GammaExposure | undefined {\n    return this.gammaData.get(symbol);\n  }\n  \n  getBullishSymbols(): string[] {\n    const bullish: string[] = [];\n    for (const [symbol, summary] of this.summaries) {\n      if (summary.bullishFlow && summary.netPremium > 100000) {\n        bullish.push(symbol);\n      }\n    }\n    return bullish;\n  }\n  \n  getBearishSymbols(): string[] {\n    const bearish: string[] = [];\n    for (const [symbol, summary] of this.summaries) {\n      if (!summary.bullishFlow && summary.netPremium < -100000) {\n        bearish.push(symbol);\n      }\n    }\n    return bearish;\n  }\n  \n  getUnusualActivity(): { symbol: string; alerts: OptionsFlowAlert[] }[] {\n    const result: { symbol: string; alerts: OptionsFlowAlert[] }[] = [];\n    \n    for (const [symbol, summary] of this.summaries) {\n      if (summary.unusualActivity) {\n        const alerts = this.getRecentAlerts(symbol, 15);\n        if (alerts.length > 0) {\n          result.push({ symbol, alerts });\n        }\n      }\n    }\n    \n    return result.sort((a, b) => b.alerts.length - a.alerts.length);\n  }\n  \n  getHighGammaSymbols(): string[] {\n    const highGamma: string[] = [];\n    for (const [symbol, gamma] of this.gammaData) {\n      if (Math.abs(gamma.totalGamma) > 500000) {\n        highGamma.push(symbol);\n      }\n    }\n    return highGamma;\n  }\n  \n  getPinRiskSymbols(): string[] {\n    const pinRisk: string[] = [];\n    for (const [symbol, gamma] of this.gammaData) {\n      if (gamma.pinRisk) {\n        pinRisk.push(symbol);\n      }\n    }\n    return pinRisk;\n  }\n}\n";export{n as default};
