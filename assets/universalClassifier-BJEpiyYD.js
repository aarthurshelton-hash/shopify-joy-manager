const e="/**\n * En Pensent Core SDK - Universal Archetype Classification\n */\n\nimport { TemporalSignature, ArchetypeRegistry } from '../types';\n\n/**\n * Universal archetype classification based purely on signature metrics\n * This can be used when no domain-specific archetype registry is available\n */\nexport function classifyUniversalArchetype(signature: TemporalSignature): string {\n  const { intensity, temporalFlow, quadrantProfile, criticalMoments } = signature;\n  \n  // High intensity + accelerating = aggressive pattern\n  if (intensity > 0.7 && temporalFlow.trend === 'accelerating') {\n    return 'aggressive_expansion';\n  }\n  \n  // Low intensity + stable = maintenance pattern\n  if (intensity < 0.3 && temporalFlow.trend === 'stable') {\n    return 'maintenance_mode';\n  }\n  \n  // High volatility + many critical moments = chaotic pattern\n  if (temporalFlow.trend === 'volatile' && criticalMoments.length > 3) {\n    return 'chaotic_evolution';\n  }\n  \n  // Declining trend + negative momentum = decline pattern\n  if (temporalFlow.trend === 'declining' && temporalFlow.momentum < -0.3) {\n    return 'controlled_decline';\n  }\n  \n  // Check quadrant concentration\n  const { q1, q2, q3, q4 } = quadrantProfile;\n  const maxQuadrant = Math.max(q1, q2, q3, q4);\n  const minQuadrant = Math.min(q1, q2, q3, q4);\n  \n  if (maxQuadrant - minQuadrant > 0.5) {\n    return 'concentrated_activity';\n  }\n  \n  // Balanced distribution\n  if (Math.abs(q1 - q2) < 0.1 && Math.abs(q3 - q4) < 0.1) {\n    return 'balanced_approach';\n  }\n  \n  return 'standard_evolution';\n}\n\n/**\n * Calculate archetype similarity between two archetypes\n */\nexport function calculateArchetypeSimilarity(\n  archetypeA: string,\n  archetypeB: string,\n  registry: ArchetypeRegistry\n): number {\n  if (archetypeA === archetypeB) return 1;\n  \n  const defA = registry.archetypes[archetypeA];\n  const defB = registry.archetypes[archetypeB];\n  \n  if (!defA || !defB) return 0;\n  \n  // Check if they're related archetypes\n  if (defA.relatedArchetypes?.includes(archetypeB) || \n      defB.relatedArchetypes?.includes(archetypeA)) {\n    return 0.7;\n  }\n  \n  // Compare keywords overlap\n  const keywordsA = new Set(defA.keywords ?? []);\n  const keywordsB = new Set(defB.keywords ?? []);\n  \n  let overlap = 0;\n  for (const k of keywordsA) {\n    if (keywordsB.has(k)) overlap++;\n  }\n  \n  const totalKeywords = keywordsA.size + keywordsB.size - overlap;\n  const keywordSimilarity = totalKeywords > 0 ? overlap / totalKeywords : 0;\n  \n  // Compare success rates\n  const successRateDiff = Math.abs(defA.successRate - defB.successRate);\n  const successSimilarity = 1 - successRateDiff;\n  \n  return (keywordSimilarity * 0.6) + (successSimilarity * 0.4);\n}\n";export{e as default};
