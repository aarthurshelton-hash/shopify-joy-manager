const n="/**\n * Color Flow Prediction Engine v8.07-AGREEMENT-CALIBRATED\n * \n * Generates strategic predictions from color flow signatures\n * \n * v8.07 AGREEMENT-CALIBRATED:\n * - Boost confidence when SF and Hybrid agree (56% historical accuracy)\n * - Defer to SF on disagreements (SF 45.5% vs Hybrid 35.8%)\n * - Eliminate FALLBACK/unknown archetypes\n * - Apply historical archetype calibration\n */\n\nimport { ColorFlowSignature, ColorFlowPrediction, StrategicArchetype } from './types';\nimport { ARCHETYPE_DEFINITIONS } from './archetypeDefinitions';\nimport { calculateEquilibriumScores, EquilibriumScores } from './equilibriumPredictor';\nimport { \n  calibrateConfidence, \n  getSfPrediction, \n  forceArchetypeAssignment \n} from './archetypeCalibration';\n\n// Store last equilibrium scores for debugging/transparency\nlet lastEquilibriumScores: EquilibriumScores | null = null;\nlet lastCalibrationReason: string = '';\n\n/**\n * Get the last equilibrium calculation (for debugging/UI display)\n */\nexport function getLastEquilibriumScores(): EquilibriumScores | null {\n  return lastEquilibriumScores;\n}\n\n/**\n * Get the last calibration reason (for debugging/UI display)\n */\nexport function getLastCalibrationReason(): string {\n  return lastCalibrationReason;\n}\n\n/**\n * Generate strategic predictions based on color flow signature\n * \n * v8.07 AGREEMENT-CALIBRATED: Uses agreement weighting + historical calibration\n */\nexport function predictFromColorFlow(\n  signature: ColorFlowSignature,\n  currentMoveNumber: number,\n  stockfishEval: number = 0,\n  stockfishDepth: number = 18\n): ColorFlowPrediction {\n  // v8.07: Force-assign archetype if unknown\n  const effectiveArchetype = forceArchetypeAssignment(\n    signature.archetype,\n    signature.dominantSide,\n    signature.flowDirection,\n    signature.intensity\n  );\n  \n  const archetypeDef = ARCHETYPE_DEFINITIONS[effectiveArchetype];\n  \n  // v7.90 EQUILIBRIUM: Calculate all three outcome confidences\n  const equilibrium = calculateEquilibriumScores(\n    { ...signature, archetype: effectiveArchetype },\n    stockfishEval,\n    stockfishDepth,\n    currentMoveNumber\n  );\n  \n  // Store for debugging access\n  lastEquilibriumScores = equilibrium;\n  \n  // Get SF-only prediction for agreement check\n  const sfPrediction = getSfPrediction(stockfishEval);\n  \n  // v8.07: Apply agreement-based calibration\n  const calibration = calibrateConfidence(\n    effectiveArchetype,\n    equilibrium.prediction,\n    sfPrediction,\n    equilibrium.finalConfidence,\n    stockfishEval\n  );\n  \n  lastCalibrationReason = calibration.reason;\n  \n  // Determine final prediction\n  let predictedWinner: 'white' | 'black' | 'draw';\n  let finalConfidence: number;\n  \n  if (calibration.deferToStockfish) {\n    // SF takes precedence\n    if (sfPrediction === 'white_wins') {\n      predictedWinner = 'white';\n    } else if (sfPrediction === 'black_wins') {\n      predictedWinner = 'black';\n    } else {\n      predictedWinner = 'draw';\n    }\n    finalConfidence = calibration.adjustedConfidence;\n  } else {\n    // Use Hybrid prediction with calibrated confidence\n    if (equilibrium.prediction === 'white_wins') {\n      predictedWinner = 'white';\n    } else if (equilibrium.prediction === 'black_wins') {\n      predictedWinner = 'black';\n    } else {\n      predictedWinner = 'draw';\n    }\n    finalConfidence = calibration.adjustedConfidence;\n  }\n  \n  // If low clarity, reduce confidence further\n  if (!equilibrium.highClarity) {\n    finalConfidence = Math.max(30, finalConfidence - 8);\n  }\n  \n  // Clamp to reasonable range\n  finalConfidence = Math.max(30, Math.min(85, finalConfidence));\n  \n  // Strategic guidance based on archetype\n  const guidance = generateStrategicGuidance(signature);\n  \n  // Predict future critical squares\n  const futureCriticalSquares = predictCriticalSquares(signature);\n  \n  // Describe expected evolution\n  const expectedEvolution = describeExpectedEvolution(signature, currentMoveNumber);\n  \n  return {\n    predictedWinner,\n    confidence: finalConfidence,\n    lookaheadMoves: archetypeDef.lookaheadConfidence,\n    strategicGuidance: guidance,\n    futureCriticalSquares,\n    expectedEvolution,\n  };\n}\n\nfunction generateStrategicGuidance(signature: ColorFlowSignature): string[] {\n  const guidance: string[] = [];\n  const archetype = signature.archetype;\n  \n  switch (archetype) {\n    case 'kingside_attack':\n      guidance.push('Maintain pressure on the h-file and g-file');\n      guidance.push('Look for sacrificial breakthroughs near the king');\n      break;\n    case 'queenside_expansion':\n      guidance.push('Control the c-file for rook infiltration');\n      guidance.push('Advance queenside pawns to create passed pawn');\n      break;\n    case 'central_domination':\n      guidance.push('Use central control to restrict opponent mobility');\n      guidance.push('Prepare pawn breaks to open lines');\n      break;\n    case 'endgame_technique':\n      guidance.push('Activate the king immediately');\n      guidance.push('Create or protect passed pawns');\n      break;\n    default:\n      guidance.push('Maintain piece coordination');\n      guidance.push('Look for tactical opportunities');\n  }\n  \n  if (signature.flowDirection === 'kingside') {\n    guidance.push('Color flow indicates kingside as the decisive theater');\n  } else if (signature.flowDirection === 'queenside') {\n    guidance.push('Color flow indicates queenside expansion opportunity');\n  }\n  \n  return guidance;\n}\n\nfunction predictCriticalSquares(signature: ColorFlowSignature): string[] {\n  const squares: string[] = [];\n  \n  switch (signature.flowDirection) {\n    case 'kingside':\n      squares.push('g4', 'h5', 'f5', 'g7');\n      break;\n    case 'queenside':\n      squares.push('c4', 'b5', 'd5', 'c7');\n      break;\n    case 'central':\n      squares.push('d4', 'e4', 'd5', 'e5');\n      break;\n    case 'diagonal':\n      squares.push('a1', 'h8', 'a8', 'h1');\n      break;\n    default:\n      squares.push('d4', 'e5');\n  }\n  \n  return squares.slice(0, 4);\n}\n\nfunction describeExpectedEvolution(\n  signature: ColorFlowSignature, \n  currentMove: number\n): string {\n  const archetype = ARCHETYPE_DEFINITIONS[signature.archetype];\n  \n  if (currentMove < 15) {\n    return `Opening phase suggests ${archetype.name}. Expect color intensity to ${\n      signature.temporalFlow.volatility > 50 ? 'increase rapidly' : 'develop gradually'\n    } toward the ${signature.flowDirection}.`;\n  } else if (currentMove < 30) {\n    return `Middlegame ${archetype.name} pattern established. Color flow is ${\n      signature.dominantSide === 'contested' ? 'evenly contested' : `favoring ${signature.dominantSide}`\n    }. Watch for tactical breaks in the ${signature.flowDirection}.`;\n  } else {\n    return `Late game ${archetype.name}. Pattern suggests ${\n      signature.dominantSide === 'contested' ? 'drawing tendencies' : \n      `favorable conversion for ${signature.dominantSide}`\n    }.`;\n  }\n}\n";export{n as default};
