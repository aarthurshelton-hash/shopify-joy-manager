const n="/**\n * Light/Photonic Domain Adapter\n * Converts photonic signals to En Pensent temporal signatures\n * \n * Light carries information at the fundamental level of reality.\n * This adapter extracts temporal patterns from:\n * - Electromagnetic spectrum variations\n * - Photon intensity fluctuations\n * - Wavelength harmonics\n * - Phase relationships\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\ninterface PhotonicData {\n  wavelength: number; // nanometers\n  intensity: number; // 0-1\n  phase: number; // radians\n  polarization: number; // degrees\n  timestamp: number;\n}\n\nclass LightDomainAdapter implements DomainAdapter<PhotonicData> {\n  domain = 'light' as const;\n  name = 'Photonic Pattern Analyzer';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 1000;\n  \n  // Visible light spectrum boundaries\n  private readonly SPECTRUM = {\n    violet: { min: 380, max: 450 },\n    blue: { min: 450, max: 495 },\n    green: { min: 495, max: 570 },\n    yellow: { min: 570, max: 590 },\n    orange: { min: 590, max: 620 },\n    red: { min: 620, max: 750 },\n  };\n\n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[LightAdapter] Initialized - Photonic pattern recognition active');\n  }\n\n  processRawData(data: PhotonicData): UniversalSignal {\n    const { wavelength, intensity, phase, polarization, timestamp } = data;\n    \n    // Normalize wavelength to frequency (THz)\n    const frequency = (3e8 / (wavelength * 1e-9)) / 1e12;\n    \n    // Extract harmonic components from the light signal\n    const harmonics = this.extractHarmonics(wavelength, intensity, phase);\n    \n    const signal: UniversalSignal = {\n      domain: 'light',\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData: [wavelength, intensity, phase, polarization],\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.lastUpdate = timestamp;\n    return signal;\n  }\n\n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n\n    const recentSignals = signals.slice(-100);\n    \n    // Calculate quadrant profile based on spectral distribution\n    const quadrantProfile = this.calculateQuadrantFromSpectrum(recentSignals);\n    \n    // Temporal flow from signal intensity patterns\n    const temporalFlow = this.calculateTemporalFlow(recentSignals);\n    \n    // Calculate advanced metrics\n    const avgIntensity = recentSignals.reduce((sum, s) => sum + s.intensity, 0) / recentSignals.length;\n    const intensityVariance = this.calculateVariance(recentSignals.map(s => s.intensity));\n    const phaseCoherence = this.calculatePhaseCoherence(recentSignals);\n    const dominantFreq = this.findDominantFrequency(recentSignals);\n    const harmonicRes = this.calculateHarmonicResonance(recentSignals);\n    \n    return {\n      domain: 'light',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgIntensity,\n      momentum: this.calculateMomentum(recentSignals),\n      volatility: Math.sqrt(intensityVariance),\n      dominantFrequency: dominantFreq,\n      harmonicResonance: harmonicRes,\n      phaseAlignment: phaseCoherence,\n      extractedAt: Date.now(),\n    };\n  }\n\n  private extractHarmonics(wavelength: number, intensity: number, phase: number): number[] {\n    // Extract first 8 harmonic components\n    const fundamentalFreq = 3e8 / (wavelength * 1e-9);\n    return Array.from({ length: 8 }, (_, i) => {\n      const harmonicNum = i + 1;\n      const amplitude = intensity / Math.pow(harmonicNum, 1.5);\n      const phaseShift = (phase * harmonicNum) % (2 * Math.PI);\n      return amplitude * Math.cos(phaseShift);\n    });\n  }\n\n  private calculateQuadrantFromSpectrum(signals: UniversalSignal[]): DomainSignature['quadrantProfile'] {\n    // Map spectral characteristics to quadrants\n    // High frequency (blue/violet) = aggressive\n    // Low frequency (red/infrared) = defensive\n    // High intensity = tactical\n    // Phase coherence = strategic\n    \n    const avgFreq = signals.reduce((sum, s) => sum + s.frequency, 0) / signals.length;\n    const avgIntensity = signals.reduce((sum, s) => sum + s.intensity, 0) / signals.length;\n    const phaseCoherence = this.calculatePhaseCoherence(signals);\n    \n    // Normalize to 0-1 range\n    const freqNorm = Math.min(avgFreq / 800, 1); // THz\n    const intensityNorm = avgIntensity;\n    const coherenceNorm = phaseCoherence;\n    \n    const total = freqNorm + (1 - freqNorm) + intensityNorm + coherenceNorm;\n    \n    return {\n      aggressive: freqNorm / total,\n      defensive: (1 - freqNorm) / total,\n      tactical: intensityNorm / total,\n      strategic: coherenceNorm / total,\n    };\n  }\n\n  private calculateTemporalFlow(signals: UniversalSignal[]): DomainSignature['temporalFlow'] {\n    const len = signals.length;\n    const third = Math.floor(len / 3);\n    \n    const earlyIntensity = signals.slice(0, third).reduce((sum, s) => sum + s.intensity, 0) / third || 0;\n    const midIntensity = signals.slice(third, 2 * third).reduce((sum, s) => sum + s.intensity, 0) / third || 0;\n    const lateIntensity = signals.slice(2 * third).reduce((sum, s) => sum + s.intensity, 0) / third || 0;\n    \n    const total = earlyIntensity + midIntensity + lateIntensity || 1;\n    \n    return {\n      early: earlyIntensity / total,\n      mid: midIntensity / total,\n      late: lateIntensity / total,\n    };\n  }\n\n  private calculateVariance(values: number[]): number {\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n  }\n\n  private calculatePhaseCoherence(signals: UniversalSignal[]): number {\n    if (signals.length < 2) return 0;\n    \n    let coherenceSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      const phaseDiff = Math.abs(signals[i].phase - signals[i - 1].phase);\n      coherenceSum += Math.cos(phaseDiff);\n    }\n    \n    return (coherenceSum / (signals.length - 1) + 1) / 2; // Normalize to 0-1\n  }\n\n  private findDominantFrequency(signals: UniversalSignal[]): number {\n    // Simple peak detection in frequency domain\n    const freqBuckets = new Map<number, number>();\n    \n    signals.forEach(s => {\n      const bucket = Math.round(s.frequency / 10) * 10;\n      freqBuckets.set(bucket, (freqBuckets.get(bucket) || 0) + s.intensity);\n    });\n    \n    let maxBucket = 0;\n    let maxValue = 0;\n    freqBuckets.forEach((value, bucket) => {\n      if (value > maxValue) {\n        maxValue = value;\n        maxBucket = bucket;\n      }\n    });\n    \n    return maxBucket;\n  }\n\n  private calculateHarmonicResonance(signals: UniversalSignal[]): number {\n    // Measure how well harmonics align across signals\n    if (signals.length < 2) return 0;\n    \n    let resonanceSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      const h1 = signals[i].harmonics;\n      const h2 = signals[i - 1].harmonics;\n      \n      let dotProduct = 0;\n      let mag1 = 0;\n      let mag2 = 0;\n      \n      for (let j = 0; j < h1.length; j++) {\n        dotProduct += h1[j] * h2[j];\n        mag1 += h1[j] * h1[j];\n        mag2 += h2[j] * h2[j];\n      }\n      \n      const cosineSim = dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2) || 1);\n      resonanceSum += (cosineSim + 1) / 2;\n    }\n    \n    return resonanceSum / (signals.length - 1);\n  }\n\n  private calculateMomentum(signals: UniversalSignal[]): number {\n    if (signals.length < 10) return 0;\n    \n    const recent = signals.slice(-10);\n    const older = signals.slice(-20, -10);\n    \n    const recentAvg = recent.reduce((sum, s) => sum + s.intensity, 0) / recent.length;\n    const olderAvg = older.length > 0 \n      ? older.reduce((sum, s) => sum + s.intensity, 0) / older.length \n      : recentAvg;\n    \n    return (recentAvg - olderAvg) / (olderAvg || 1);\n  }\n\n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'light',\n      quadrantProfile: { aggressive: 0.25, defensive: 0.25, tactical: 0.25, strategic: 0.25 },\n      temporalFlow: { early: 0.33, mid: 0.34, late: 0.33 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0,\n      dominantFrequency: 550,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now(),\n    };\n  }\n\n  // Simulate photonic data for market correlation\n  generateMarketCorrelatedSignal(marketMomentum: number, marketVolatility: number): PhotonicData {\n    const baseWavelength = 550; // Green - neutral\n    \n    // Market momentum shifts the wavelength (blue = bullish, red = bearish)\n    const wavelengthShift = -marketMomentum * 100; // Negative momentum -> red shift\n    const wavelength = Math.max(380, Math.min(750, baseWavelength + wavelengthShift));\n    \n    // Volatility affects intensity\n    const intensity = 0.5 + (marketVolatility * 0.5);\n    \n    // Momentum affects phase\n    const phase = (marketMomentum + 1) * Math.PI;\n    \n    return {\n      wavelength,\n      intensity: Math.max(0, Math.min(1, intensity)),\n      phase: phase % (2 * Math.PI),\n      polarization: Math.random() * 360,\n      timestamp: Date.now(),\n    };\n  }\n}\n\nexport const lightAdapter = new LightDomainAdapter();\nexport type { PhotonicData };\n";export{n as default};
