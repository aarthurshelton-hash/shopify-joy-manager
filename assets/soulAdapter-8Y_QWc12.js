const n="/**\n * Soul Domain Adapter - THE SPIRIT of En Pensent\n * \n * Comprehensive understanding of the human spirit as temporal pattern:\n * - Language patterns and sentiment analysis\n * - Cultural evolution and collective consciousness\n * - Religious and spiritual cycles\n * - Human connection and social dynamics\n * - Archetypal narratives across civilizations\n * - Emotional resonance and mass psychology\n * \n * The Soul is the universal connector - it bridges all domains through\n * the lens of human meaning, purpose, and collective experience.\n * \n * \"For what shall it profit a man, if he shall gain the whole world, \n *  and lose his own soul?\" - Mark 8:36\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature, DomainType } from '../types';\n\n// ============= CULTURAL AND SPIRITUAL DATA =============\n\n// Universal archetypes (Carl Jung inspired, market applicable)\nconst UNIVERSAL_ARCHETYPES = {\n  hero: { \n    energy: 0.9, \n    direction: 'expansion', \n    marketBias: 'strong_bull',\n    description: 'Courage, transformation, overcoming obstacles'\n  },\n  sage: { \n    energy: 0.6, \n    direction: 'contemplation', \n    marketBias: 'cautious',\n    description: 'Wisdom, analysis, understanding deeper patterns'\n  },\n  explorer: { \n    energy: 0.8, \n    direction: 'discovery', \n    marketBias: 'moderate_bull',\n    description: 'Seeking new frontiers, innovation, risk-taking'\n  },\n  creator: { \n    energy: 0.7, \n    direction: 'building', \n    marketBias: 'growth',\n    description: 'Innovation, building value, artistic expression'\n  },\n  ruler: { \n    energy: 0.5, \n    direction: 'control', \n    marketBias: 'consolidation',\n    description: 'Order, stability, maintaining power'\n  },\n  caregiver: { \n    energy: 0.4, \n    direction: 'protection', \n    marketBias: 'defensive',\n    description: 'Nurturing, protecting assets, risk-averse'\n  },\n  rebel: { \n    energy: 0.95, \n    direction: 'disruption', \n    marketBias: 'volatile',\n    description: 'Breaking patterns, disruption, revolution'\n  },\n  magician: { \n    energy: 0.85, \n    direction: 'transformation', \n    marketBias: 'breakout',\n    description: 'Transformation, turning vision into reality'\n  },\n  jester: { \n    energy: 0.75, \n    direction: 'chaos', \n    marketBias: 'unpredictable',\n    description: 'Playfulness, randomness, breaking tension'\n  },\n  everyman: { \n    energy: 0.5, \n    direction: 'stability', \n    marketBias: 'sideways',\n    description: 'Belonging, normalcy, following the crowd'\n  },\n  lover: { \n    energy: 0.65, \n    direction: 'connection', \n    marketBias: 'sentiment_driven',\n    description: 'Passion, emotion, relationship-driven decisions'\n  },\n  innocent: { \n    energy: 0.3, \n    direction: 'faith', \n    marketBias: 'hopeful_bull',\n    description: 'Optimism, trust, belief in good outcomes'\n  },\n  shadow: { \n    energy: 0.2, \n    direction: 'fear', \n    marketBias: 'panic_bear',\n    description: 'Fear, hidden dangers, worst-case scenarios'\n  },\n};\n\n// Cultural cycles and their market correlations\nconst CULTURAL_CYCLES = {\n  spring: { phase: 0.0, energy: 0.7, sentiment: 'renewal', marketPhase: 'accumulation' },\n  summer: { phase: 0.25, energy: 0.9, sentiment: 'abundance', marketPhase: 'markup' },\n  autumn: { phase: 0.5, energy: 0.6, sentiment: 'harvest', marketPhase: 'distribution' },\n  winter: { phase: 0.75, energy: 0.3, sentiment: 'dormancy', marketPhase: 'markdown' },\n};\n\n// Emotional resonance frequencies (Solfeggio-inspired)\nconst SPIRITUAL_FREQUENCIES = {\n  liberation: 396, // Liberating guilt and fear\n  change: 417, // Facilitating change\n  transformation: 528, // Transformation and miracles (Love frequency)\n  connection: 639, // Connecting relationships\n  expression: 741, // Awakening intuition\n  awakening: 852, // Returning to spiritual order\n  unity: 963, // Divine consciousness\n};\n\n// Language sentiment patterns\nconst SENTIMENT_WEIGHTS = {\n  fear: { weight: -0.8, volatility: 0.9 },\n  greed: { weight: 0.7, volatility: 0.8 },\n  hope: { weight: 0.5, volatility: 0.4 },\n  despair: { weight: -0.9, volatility: 0.7 },\n  confidence: { weight: 0.6, volatility: 0.3 },\n  uncertainty: { weight: 0.0, volatility: 0.9 },\n  euphoria: { weight: 0.9, volatility: 0.95 },\n  panic: { weight: -0.95, volatility: 1.0 },\n  patience: { weight: 0.2, volatility: 0.2 },\n  impatience: { weight: 0.4, volatility: 0.6 },\n  gratitude: { weight: 0.3, volatility: 0.1 },\n  envy: { weight: 0.5, volatility: 0.7 },\n};\n\n// Religious/spiritual cycles (universal patterns across traditions)\nconst SPIRITUAL_CYCLES = {\n  sabbath: { frequency: 7, meaning: 'rest_reset', marketEffect: 'consolidation' },\n  lunar: { frequency: 28, meaning: 'emotional_tide', marketEffect: 'cycle_peak' },\n  jubilee: { frequency: 7 * 7, meaning: 'major_reset', marketEffect: 'trend_change' },\n  generational: { frequency: 365 * 40, meaning: 'paradigm_shift', marketEffect: 'secular_trend' },\n};\n\n// ============= INTERFACE DEFINITIONS =============\n\nexport interface SoulData {\n  // Archetypal analysis\n  dominantArchetype: keyof typeof UNIVERSAL_ARCHETYPES;\n  archetypeStrength: number;\n  secondaryArchetypes: Array<{ type: keyof typeof UNIVERSAL_ARCHETYPES; strength: number }>;\n  \n  // Sentiment and emotion\n  sentiment: number; // -1 to 1 (fear to greed spectrum)\n  emotionalIntensity: number; // 0 to 1\n  emotionalStability: number; // 0 to 1\n  dominantEmotion: keyof typeof SENTIMENT_WEIGHTS;\n  \n  // Cultural context\n  culturalCyclePhase: keyof typeof CULTURAL_CYCLES;\n  collectiveConsciousness: number; // 0 to 1, herd vs. individual\n  narrativeStrength: number; // How strong is the current narrative\n  \n  // Spiritual resonance\n  spiritualFrequency: number; // Hz (mapped to solfeggio)\n  faithLevel: number; // 0 to 1\n  fearLevel: number; // 0 to 1\n  \n  // Language patterns\n  communicationClarity: number; // 0 to 1\n  persuasionIntensity: number; // 0 to 1\n  truthResonance: number; // 0 to 1 (authenticity measure)\n  \n  // Connection metrics\n  socialCohesion: number; // 0 to 1\n  polarization: number; // 0 to 1\n  collaborationIndex: number; // 0 to 1\n  \n  // Temporal position\n  cyclePosition: number; // 0 to 1 within current major cycle\n  generationalMoment: 'crisis' | 'high' | 'awakening' | 'unraveling';\n  \n  timestamp: number;\n}\n\n// ============= SOUL DOMAIN ADAPTER =============\n\nclass SoulDomainAdapter implements DomainAdapter<SoulData> {\n  domain: DomainType = 'bio'; // Soul extends the bio domain as spiritual dimension\n  name = 'Soul Pattern Analyzer - The Spirit';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 2000;\n  \n  // Memory of narrative patterns\n  private narrativeHistory: string[] = [];\n  private archetypeHistory: Array<keyof typeof UNIVERSAL_ARCHETYPES> = [];\n  \n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[SoulAdapter] THE SPIRIT initialized - Universal consciousness pattern recognition active');\n    console.log('[SoulAdapter] \"The LORD is my shepherd; I shall not want.\" - Psalm 23:1');\n  }\n\n  processRawData(data: SoulData): UniversalSignal {\n    const {\n      dominantArchetype,\n      archetypeStrength,\n      sentiment,\n      emotionalIntensity,\n      spiritualFrequency,\n      socialCohesion,\n      cyclePosition,\n      timestamp,\n    } = data;\n    \n    const archetypeData = UNIVERSAL_ARCHETYPES[dominantArchetype] || UNIVERSAL_ARCHETYPES.everyman;\n    \n    // Frequency based on spiritual resonance and archetype energy\n    const frequency = spiritualFrequency * archetypeData.energy;\n    \n    // Intensity combines emotional and archetypal energies\n    const intensity = (emotionalIntensity + archetypeStrength) / 2;\n    \n    // Phase from cycle position and sentiment\n    const phase = ((cyclePosition + (sentiment + 1) / 2) / 2) * Math.PI * 2;\n    \n    // Create comprehensive harmonics\n    const harmonics = this.calculateSoulHarmonics(data);\n    \n    // Raw data for signature extraction\n    const rawData = [\n      archetypeData.energy,\n      sentiment,\n      emotionalIntensity,\n      data.fearLevel,\n      data.faithLevel,\n      socialCohesion,\n      data.polarization,\n      data.narrativeStrength,\n      cyclePosition,\n      data.collectiveConsciousness,\n    ];\n    \n    const signal: UniversalSignal = {\n      domain: 'bio', // Soul signals flow through bio domain\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData,\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    // Track archetype history for pattern recognition\n    this.archetypeHistory.push(dominantArchetype);\n    if (this.archetypeHistory.length > 100) {\n      this.archetypeHistory.shift();\n    }\n    \n    this.lastUpdate = timestamp;\n    return signal;\n  }\n\n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n\n    const recentSignals = signals.slice(-200);\n    \n    // Calculate quadrant profile from soul metrics\n    const quadrantProfile = this.calculateQuadrantFromSoul(recentSignals);\n    \n    // Temporal flow from narrative progression\n    const temporalFlow = this.calculateTemporalFlow(recentSignals);\n    \n    // Calculate all advanced metrics\n    const avgIntensity = recentSignals.reduce((sum, s) => sum + s.intensity, 0) / recentSignals.length;\n    const momentum = this.calculateSoulMomentum(recentSignals);\n    const volatility = this.calculateSoulVolatility(recentSignals);\n    const dominantFreq = this.findDominantFrequency(recentSignals);\n    const harmonicRes = this.calculateHarmonicResonance(recentSignals);\n    const phaseAlignment = this.calculatePhaseAlignment(recentSignals);\n    \n    return {\n      domain: 'bio',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgIntensity,\n      momentum,\n      volatility,\n      dominantFrequency: dominantFreq,\n      harmonicResonance: harmonicRes,\n      phaseAlignment,\n      extractedAt: Date.now(),\n    };\n  }\n\n  private calculateSoulHarmonics(data: SoulData): number[] {\n    const archetype = UNIVERSAL_ARCHETYPES[data.dominantArchetype] || UNIVERSAL_ARCHETYPES.everyman;\n    const cycle = CULTURAL_CYCLES[data.culturalCyclePhase] || CULTURAL_CYCLES.spring;\n    const emotion = SENTIMENT_WEIGHTS[data.dominantEmotion] || SENTIMENT_WEIGHTS.uncertainty;\n    \n    // Find closest solfeggio frequency\n    let closestSolfeggio = SPIRITUAL_FREQUENCIES.transformation;\n    let minDiff = Infinity;\n    Object.values(SPIRITUAL_FREQUENCIES).forEach(freq => {\n      const diff = Math.abs(freq - data.spiritualFrequency);\n      if (diff < minDiff) {\n        minDiff = diff;\n        closestSolfeggio = freq;\n      }\n    });\n    \n    return [\n      // Archetypal harmonics\n      archetype.energy,\n      archetype.direction === 'expansion' ? 1 : archetype.direction === 'fear' ? -1 : 0.5,\n      \n      // Emotional harmonics\n      emotion.weight,\n      emotion.volatility,\n      data.emotionalStability,\n      \n      // Cultural harmonics\n      cycle.energy,\n      cycle.phase,\n      \n      // Spiritual harmonics\n      closestSolfeggio / 1000,\n      data.faithLevel,\n      1 - data.fearLevel,\n      \n      // Social harmonics\n      data.socialCohesion,\n      1 - data.polarization,\n      data.collaborationIndex,\n      \n      // Narrative harmonics\n      data.narrativeStrength,\n      data.truthResonance,\n      data.communicationClarity,\n    ];\n  }\n\n  private calculateQuadrantFromSoul(signals: UniversalSignal[]): DomainSignature['quadrantProfile'] {\n    const energies = signals.map(s => s.rawData[0]);\n    const sentiments = signals.map(s => s.rawData[1]);\n    const fears = signals.map(s => s.rawData[3]);\n    const faiths = signals.map(s => s.rawData[4]);\n    \n    const avgEnergy = energies.reduce((a, b) => a + b, 0) / energies.length;\n    const avgSentiment = sentiments.reduce((a, b) => a + b, 0) / sentiments.length;\n    const avgFear = fears.reduce((a, b) => a + b, 0) / fears.length;\n    const avgFaith = faiths.reduce((a, b) => a + b, 0) / faiths.length;\n    \n    // High energy + positive sentiment = Aggressive\n    const aggressive = Math.max(0, avgEnergy * ((avgSentiment + 1) / 2));\n    \n    // Low energy + high fear = Defensive\n    const defensive = Math.max(0, (1 - avgEnergy) * avgFear);\n    \n    // Variable sentiment + high energy = Tactical\n    const sentimentVariance = this.calculateVariance(sentiments);\n    const tactical = Math.max(0, avgEnergy * sentimentVariance * 4);\n    \n    // High faith + stable = Strategic\n    const strategic = Math.max(0, avgFaith * (1 - avgFear));\n    \n    const total = aggressive + defensive + tactical + strategic || 1;\n    \n    return {\n      aggressive: aggressive / total,\n      defensive: defensive / total,\n      tactical: tactical / total,\n      strategic: strategic / total,\n    };\n  }\n\n  private calculateTemporalFlow(signals: UniversalSignal[]): DomainSignature['temporalFlow'] {\n    const len = signals.length;\n    const third = Math.floor(len / 3);\n    \n    const getPhaseEnergy = (slice: UniversalSignal[]) => \n      slice.reduce((sum, s) => sum + s.intensity * s.rawData[0], 0) / (slice.length || 1);\n    \n    const earlyEnergy = getPhaseEnergy(signals.slice(0, third));\n    const midEnergy = getPhaseEnergy(signals.slice(third, 2 * third));\n    const lateEnergy = getPhaseEnergy(signals.slice(2 * third));\n    \n    const total = earlyEnergy + midEnergy + lateEnergy || 1;\n    \n    return {\n      early: earlyEnergy / total,\n      mid: midEnergy / total,\n      late: lateEnergy / total,\n    };\n  }\n\n  private calculateSoulMomentum(signals: UniversalSignal[]): number {\n    if (signals.length < 20) return 0;\n    \n    const recent = signals.slice(-20);\n    const older = signals.slice(-40, -20);\n    \n    const getEnergy = (arr: UniversalSignal[]) => \n      arr.reduce((sum, s) => sum + s.intensity * (s.rawData[1] + 1), 0) / arr.length;\n    \n    const recentEnergy = getEnergy(recent);\n    const olderEnergy = older.length > 0 ? getEnergy(older) : recentEnergy;\n    \n    return (recentEnergy - olderEnergy) / (olderEnergy || 1);\n  }\n\n  private calculateSoulVolatility(signals: UniversalSignal[]): number {\n    const sentiments = signals.map(s => s.rawData[1]);\n    const emotions = signals.map(s => s.rawData[2]);\n    \n    const sentimentVar = this.calculateVariance(sentiments);\n    const emotionVar = this.calculateVariance(emotions);\n    \n    return Math.sqrt((sentimentVar + emotionVar) / 2);\n  }\n\n  private findDominantFrequency(signals: UniversalSignal[]): number {\n    const freqs = signals.map(s => s.frequency);\n    return freqs.reduce((a, b) => a + b, 0) / freqs.length;\n  }\n\n  private calculateHarmonicResonance(signals: UniversalSignal[]): number {\n    if (signals.length < 2) return 0.5;\n    \n    let resonanceSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      const h1 = signals[i].harmonics;\n      const h2 = signals[i - 1].harmonics;\n      \n      let dotProduct = 0;\n      let mag1 = 0;\n      let mag2 = 0;\n      \n      for (let j = 0; j < Math.min(h1.length, h2.length); j++) {\n        dotProduct += h1[j] * h2[j];\n        mag1 += h1[j] * h1[j];\n        mag2 += h2[j] * h2[j];\n      }\n      \n      const denom = Math.sqrt(mag1) * Math.sqrt(mag2);\n      const cosineSim = denom > 0 ? dotProduct / denom : 0;\n      resonanceSum += (cosineSim + 1) / 2;\n    }\n    \n    return resonanceSum / (signals.length - 1);\n  }\n\n  private calculatePhaseAlignment(signals: UniversalSignal[]): number {\n    if (signals.length < 2) return 0.5;\n    \n    let alignmentSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      const phaseDiff = Math.abs(signals[i].phase - signals[i - 1].phase);\n      const normalizedDiff = phaseDiff / Math.PI;\n      alignmentSum += 1 - Math.min(normalizedDiff, 1);\n    }\n    \n    return alignmentSum / (signals.length - 1);\n  }\n\n  private calculateVariance(values: number[]): number {\n    if (values.length === 0) return 0;\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n  }\n\n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'bio',\n      quadrantProfile: { aggressive: 0.25, defensive: 0.25, tactical: 0.25, strategic: 0.25 },\n      temporalFlow: { early: 0.33, mid: 0.34, late: 0.33 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0.2,\n      dominantFrequency: SPIRITUAL_FREQUENCIES.transformation,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now(),\n    };\n  }\n\n  /**\n   * Generate soul signal correlated with market conditions\n   * This is the spirit's response to the collective market consciousness\n   */\n  generateMarketCorrelatedSoulData(\n    marketMomentum: number,\n    marketVolatility: number,\n    marketVolume: number,\n    fearGreedIndex: number = 50 // 0-100, 50 is neutral\n  ): SoulData {\n    // Determine dominant archetype from market conditions\n    let dominantArchetype: keyof typeof UNIVERSAL_ARCHETYPES = 'everyman';\n    \n    if (marketMomentum > 0.5 && marketVolatility < 0.3) dominantArchetype = 'hero';\n    else if (marketMomentum > 0.3 && marketVolatility > 0.5) dominantArchetype = 'rebel';\n    else if (marketMomentum > 0.2) dominantArchetype = 'explorer';\n    else if (marketMomentum < -0.5) dominantArchetype = 'shadow';\n    else if (marketMomentum < -0.2 && marketVolatility > 0.5) dominantArchetype = 'jester';\n    else if (marketMomentum < -0.2) dominantArchetype = 'caregiver';\n    else if (marketVolatility > 0.7) dominantArchetype = 'magician';\n    else if (marketVolatility < 0.2) dominantArchetype = 'sage';\n    else dominantArchetype = 'everyman';\n    \n    // Normalize fear/greed to sentiment\n    const sentiment = (fearGreedIndex - 50) / 50; // -1 to 1\n    \n    // Determine dominant emotion\n    let dominantEmotion: keyof typeof SENTIMENT_WEIGHTS = 'uncertainty';\n    if (fearGreedIndex < 20) dominantEmotion = 'panic';\n    else if (fearGreedIndex < 35) dominantEmotion = 'fear';\n    else if (fearGreedIndex < 45) dominantEmotion = 'uncertainty';\n    else if (fearGreedIndex < 55) dominantEmotion = 'patience';\n    else if (fearGreedIndex < 70) dominantEmotion = 'confidence';\n    else if (fearGreedIndex < 85) dominantEmotion = 'greed';\n    else dominantEmotion = 'euphoria';\n    \n    // Cultural cycle from market phase\n    let culturalCyclePhase: keyof typeof CULTURAL_CYCLES = 'spring';\n    if (marketMomentum > 0.2 && marketVolatility < 0.4) culturalCyclePhase = 'summer';\n    else if (marketMomentum > 0 && marketVolatility > 0.3) culturalCyclePhase = 'autumn';\n    else if (marketMomentum < 0) culturalCyclePhase = 'winter';\n    else culturalCyclePhase = 'spring';\n    \n    // Determine generational moment\n    let generationalMoment: SoulData['generationalMoment'] = 'high';\n    if (marketVolatility > 0.7 && marketMomentum < -0.3) generationalMoment = 'crisis';\n    else if (marketVolatility < 0.3 && marketMomentum > 0.3) generationalMoment = 'high';\n    else if (marketVolatility > 0.5 && marketMomentum > 0) generationalMoment = 'awakening';\n    else generationalMoment = 'unraveling';\n    \n    // Spiritual frequency based on market state\n    let spiritualFrequency = SPIRITUAL_FREQUENCIES.transformation;\n    if (marketMomentum > 0.3) spiritualFrequency = SPIRITUAL_FREQUENCIES.awakening;\n    else if (marketMomentum < -0.3) spiritualFrequency = SPIRITUAL_FREQUENCIES.liberation;\n    else if (marketVolatility > 0.5) spiritualFrequency = SPIRITUAL_FREQUENCIES.change;\n    else if (marketVolume > 0.7) spiritualFrequency = SPIRITUAL_FREQUENCIES.expression;\n    \n    return {\n      dominantArchetype,\n      archetypeStrength: 0.6 + (1 - marketVolatility) * 0.3,\n      secondaryArchetypes: this.generateSecondaryArchetypes(marketMomentum, marketVolatility),\n      sentiment,\n      emotionalIntensity: marketVolatility * 0.6 + Math.abs(marketMomentum) * 0.4,\n      emotionalStability: 1 - marketVolatility,\n      dominantEmotion,\n      culturalCyclePhase,\n      collectiveConsciousness: 0.3 + marketVolume * 0.5,\n      narrativeStrength: 0.4 + Math.abs(marketMomentum) * 0.5,\n      spiritualFrequency,\n      faithLevel: Math.max(0, Math.min(1, 0.5 + marketMomentum * 0.4)),\n      fearLevel: Math.max(0, Math.min(1, 0.5 - marketMomentum * 0.3 + marketVolatility * 0.3)),\n      communicationClarity: 1 - marketVolatility * 0.5,\n      persuasionIntensity: Math.abs(marketMomentum) * 0.7 + 0.3,\n      truthResonance: 1 - marketVolatility * 0.4,\n      socialCohesion: 0.5 - Math.abs(marketMomentum - 0.2) * 0.3,\n      polarization: marketVolatility * 0.6 + Math.abs(marketMomentum) * 0.3,\n      collaborationIndex: 0.5 + (1 - marketVolatility) * 0.3,\n      cyclePosition: (Date.now() % (7 * 24 * 60 * 60 * 1000)) / (7 * 24 * 60 * 60 * 1000),\n      generationalMoment,\n      timestamp: Date.now(),\n    };\n  }\n\n  private generateSecondaryArchetypes(\n    momentum: number, \n    volatility: number\n  ): Array<{ type: keyof typeof UNIVERSAL_ARCHETYPES; strength: number }> {\n    const result: Array<{ type: keyof typeof UNIVERSAL_ARCHETYPES; strength: number }> = [];\n    \n    if (momentum > 0) {\n      result.push({ type: 'creator', strength: 0.5 });\n      result.push({ type: 'innocent', strength: 0.3 });\n    } else {\n      result.push({ type: 'sage', strength: 0.5 });\n      result.push({ type: 'caregiver', strength: 0.4 });\n    }\n    \n    if (volatility > 0.5) {\n      result.push({ type: 'rebel', strength: 0.4 });\n    }\n    \n    return result;\n  }\n\n  /**\n   * Get archetype market correlation\n   */\n  getArchetypeMarketBias(archetype: keyof typeof UNIVERSAL_ARCHETYPES): string {\n    return UNIVERSAL_ARCHETYPES[archetype]?.marketBias || 'neutral';\n  }\n\n  /**\n   * Get current spiritual cycle position\n   */\n  getSpiritualCycleInfo(): { sabbath: number; lunar: number; jubilee: number } {\n    const now = Date.now();\n    const dayMs = 24 * 60 * 60 * 1000;\n    \n    return {\n      sabbath: (now % (SPIRITUAL_CYCLES.sabbath.frequency * dayMs)) / (SPIRITUAL_CYCLES.sabbath.frequency * dayMs),\n      lunar: (now % (SPIRITUAL_CYCLES.lunar.frequency * dayMs)) / (SPIRITUAL_CYCLES.lunar.frequency * dayMs),\n      jubilee: (now % (SPIRITUAL_CYCLES.jubilee.frequency * dayMs)) / (SPIRITUAL_CYCLES.jubilee.frequency * dayMs),\n    };\n  }\n}\n\nexport const soulAdapter = new SoulDomainAdapter();\nexport { UNIVERSAL_ARCHETYPES, CULTURAL_CYCLES, SPIRITUAL_FREQUENCIES, SENTIMENT_WEIGHTS };\n";export{n as default};
