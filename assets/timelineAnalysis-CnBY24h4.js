const n="/**\n * Timeline Analysis Utilities\n * \n * Unified analysis functions for extracting timeline moments from PGN,\n * including tactics, special moves, move quality, and phase detection.\n */\n\nimport { Chess, Move, PieceSymbol, Square } from 'chess.js';\nimport { classifyMoves, MoveQuality, ClassifiedMove } from './moveQuality';\nimport { \n  analyzeGame, \n  GameAnalysis, \n  TacticalMotif, \n  SpecialMove, \n  GamePhase \n} from './chessAnalysis';\nimport { TimelineMoment, MomentType } from '@/components/chess/EnhancedTimelineMarker';\n\nexport interface TimelineAnalysisResult {\n  moments: TimelineMoment[];\n  phases: GamePhase[];\n  tactics: TacticalMotif[];\n  specialMoves: SpecialMove[];\n  classifiedMoves: ClassifiedMove[];\n  summary: {\n    totalMoves: number;\n    captureCount: number;\n    checkCount: number;\n    checkmateCount: number;\n    castleCount: number;\n    brilliantCount: number;\n    greatCount: number;\n    blunderCount: number;\n    mistakeCount: number;\n    inaccuracyCount: number;\n    forkCount: number;\n    pinCount: number;\n    sacrificeCount: number;\n    promotionCount: number;\n    enPassantCount: number;\n    accuracy: number;\n  };\n}\n\n/**\n * Performs comprehensive timeline analysis on a PGN\n */\nexport function analyzeTimeline(pgn: string, moves: string[]): TimelineAnalysisResult {\n  const moments: TimelineMoment[] = [];\n  const summary = {\n    totalMoves: moves.length,\n    captureCount: 0,\n    checkCount: 0,\n    checkmateCount: 0,\n    castleCount: 0,\n    brilliantCount: 0,\n    greatCount: 0,\n    blunderCount: 0,\n    mistakeCount: 0,\n    inaccuracyCount: 0,\n    forkCount: 0,\n    pinCount: 0,\n    sacrificeCount: 0,\n    promotionCount: 0,\n    enPassantCount: 0,\n    accuracy: 0,\n  };\n\n  // Get classified moves for quality analysis\n  let classifiedMoves: ClassifiedMove[] = [];\n  try {\n    classifiedMoves = classifyMoves(pgn);\n  } catch {\n    // Silent fail\n  }\n\n  // Get full game analysis for tactics and special moves\n  let gameAnalysis: GameAnalysis | null = null;\n  try {\n    gameAnalysis = analyzeGame(pgn);\n  } catch {\n    // Silent fail\n  }\n\n  // Process each move for basic events and quality\n  moves.forEach((move, index) => {\n    const moveNumber = index + 1;\n    const player: 'white' | 'black' = index % 2 === 0 ? 'white' : 'black';\n    const classified = classifiedMoves[index];\n    const quality = classified?.quality;\n\n    // Move quality moments (prioritize these as they're most significant)\n    if (quality === 'brilliant') {\n      moments.push({ \n        moveNumber, \n        type: 'brilliant', \n        move, \n        player, \n        quality,\n        description: 'An exceptional move that dramatically improves the position, often involving a brilliant sacrifice.'\n      });\n      summary.brilliantCount++;\n    } else if (quality === 'great') {\n      moments.push({ \n        moveNumber, \n        type: 'great', \n        move, \n        player, \n        quality,\n        description: 'A strong move that significantly strengthens the position.'\n      });\n      summary.greatCount++;\n    } else if (quality === 'blunder') {\n      moments.push({ \n        moveNumber, \n        type: 'blunder', \n        move, \n        player, \n        quality,\n        description: 'A severe error that may lose the game.'\n      });\n      summary.blunderCount++;\n    } else if (quality === 'mistake') {\n      moments.push({ \n        moveNumber, \n        type: 'mistake', \n        move, \n        player, \n        quality,\n        description: 'A clear error losing material or significant advantage.'\n      });\n      summary.mistakeCount++;\n    } else if (quality === 'inaccuracy') {\n      moments.push({ \n        moveNumber, \n        type: 'inaccuracy', \n        move, \n        player, \n        quality,\n        description: 'A slightly imprecise move that gives up some advantage.'\n      });\n      summary.inaccuracyCount++;\n    }\n\n    // Checkmate (highest priority event)\n    if (move.includes('#')) {\n      moments.push({ \n        moveNumber, \n        type: 'checkmate', \n        move, \n        player,\n        description: `${player === 'white' ? 'White' : 'Black'} delivers checkmate! The game ends in victory.`\n      });\n      summary.checkmateCount++;\n    }\n    // Check\n    else if (move.includes('+')) {\n      moments.push({ \n        moveNumber, \n        type: 'check', \n        move, \n        player,\n        description: `${player === 'white' ? 'White' : 'Black'} puts the king in check.`\n      });\n      summary.checkCount++;\n    }\n\n    // Capture (only if not already a quality move to avoid duplicates)\n    if (move.includes('x') && !quality) {\n      const capturedPiece = guessCapturedPiece(move);\n      moments.push({ \n        moveNumber, \n        type: 'capture', \n        move, \n        player,\n        description: capturedPiece \n          ? `${player === 'white' ? 'White' : 'Black'} captures the ${capturedPiece}.`\n          : `A piece is captured, shifting the material balance.`\n      });\n      summary.captureCount++;\n    }\n\n    // Castling\n    if (move.includes('O-O') || move.includes('0-0')) {\n      const isKingside = move === 'O-O' || move === '0-0';\n      moments.push({ \n        moveNumber, \n        type: 'castling', \n        move, \n        player,\n        description: `${player === 'white' ? 'White' : 'Black'} castles ${isKingside ? 'kingside' : 'queenside'}, bringing the king to safety.`\n      });\n      summary.castleCount++;\n    }\n\n    // Promotion\n    if (move.includes('=')) {\n      const promotedTo = move.match(/=([QRBN])/)?.[1];\n      const isUnderpromotion = promotedTo && promotedTo !== 'Q';\n      moments.push({ \n        moveNumber, \n        type: isUnderpromotion ? 'underpromotion' : 'promotion', \n        move, \n        player,\n        description: isUnderpromotion\n          ? `Strategic underpromotion to ${getPieceName(promotedTo as PieceSymbol)}!`\n          : `Pawn promotes to ${getPieceName((promotedTo || 'Q') as PieceSymbol)}!`\n      });\n      summary.promotionCount++;\n    }\n  });\n\n  // Add tactical moments from game analysis\n  if (gameAnalysis) {\n    for (const tactic of gameAnalysis.tactics) {\n      const existingMoment = moments.find(m => m.moveNumber === tactic.moveNumber);\n      \n      if (tactic.type === 'fork' || tactic.type === 'pin' || tactic.type === 'skewer' || \n          tactic.type === 'discovery' || tactic.type === 'sacrifice') {\n        // Add as new moment or enrich existing\n        if (!existingMoment || existingMoment.type === 'capture') {\n          moments.push({\n            moveNumber: tactic.moveNumber,\n            type: tactic.type as MomentType,\n            move: tactic.notation,\n            player: tactic.moveNumber % 2 === 1 ? 'white' : 'black',\n            tactic,\n            description: tactic.description\n          });\n          \n          if (tactic.type === 'fork') summary.forkCount++;\n          if (tactic.type === 'pin') summary.pinCount++;\n          if (tactic.type === 'sacrifice') summary.sacrificeCount++;\n        } else if (existingMoment) {\n          existingMoment.tactic = tactic;\n        }\n      }\n    }\n\n    // Add special moves\n    for (const special of gameAnalysis.specialMoves) {\n      if (special.type === 'en_passant') {\n        const existingIdx = moments.findIndex(m => m.moveNumber === special.moveNumber && m.type === 'capture');\n        if (existingIdx >= 0) {\n          moments[existingIdx].type = 'en_passant';\n          moments[existingIdx].description = 'En passant capture! A special pawn capture.';\n        }\n        summary.enPassantCount++;\n      }\n    }\n  }\n\n  // Calculate accuracy\n  if (classifiedMoves.length > 0) {\n    const goodMoves = classifiedMoves.filter(m => \n      ['brilliant', 'great', 'best', 'good', 'book'].includes(m.quality)\n    ).length;\n    summary.accuracy = Math.round((goodMoves / classifiedMoves.length) * 100);\n  }\n\n  // Sort moments by move number and remove duplicates\n  const uniqueMoments = deduplicateMoments(moments.sort((a, b) => a.moveNumber - b.moveNumber));\n\n  return {\n    moments: uniqueMoments,\n    phases: gameAnalysis?.phases || getDefaultPhases(moves.length),\n    tactics: gameAnalysis?.tactics || [],\n    specialMoves: gameAnalysis?.specialMoves || [],\n    classifiedMoves,\n    summary\n  };\n}\n\n/**\n * Remove duplicate moments at the same move number, keeping the most significant\n */\nfunction deduplicateMoments(moments: TimelineMoment[]): TimelineMoment[] {\n  const seen = new Map<number, TimelineMoment[]>();\n  \n  for (const moment of moments) {\n    const existing = seen.get(moment.moveNumber) || [];\n    existing.push(moment);\n    seen.set(moment.moveNumber, existing);\n  }\n  \n  const result: TimelineMoment[] = [];\n  const priority: Record<MomentType, number> = {\n    checkmate: 100,\n    brilliant: 95,\n    sacrifice: 90,\n    fork: 85,\n    pin: 80,\n    skewer: 78,\n    discovery: 75,\n    blunder: 70,\n    great: 65,\n    mistake: 60,\n    promotion: 55,\n    underpromotion: 54,\n    en_passant: 50,\n    check: 45,\n    inaccuracy: 40,\n    castling: 35,\n    capture: 30,\n  };\n  \n  for (const [, group] of seen) {\n    // Take top 2 most significant moments per move\n    const sorted = group.sort((a, b) => (priority[b.type] || 0) - (priority[a.type] || 0));\n    result.push(...sorted.slice(0, 2));\n  }\n  \n  return result.sort((a, b) => a.moveNumber - b.moveNumber);\n}\n\n/**\n * Get default phase breakdown when analysis isn't available\n */\nfunction getDefaultPhases(totalMoves: number): GamePhase[] {\n  const openingEnd = Math.min(Math.floor(totalMoves * 0.2), 30);\n  const endgameStart = Math.max(Math.floor(totalMoves * 0.7), openingEnd + 1);\n  \n  return [\n    {\n      name: 'opening',\n      startMove: 1,\n      endMove: openingEnd,\n      description: 'Development and central control',\n      keyEvents: ['Piece development', 'King safety', 'Center control']\n    },\n    {\n      name: 'middlegame',\n      startMove: openingEnd + 1,\n      endMove: endgameStart - 1,\n      description: 'Tactical battles and strategic maneuvering',\n      keyEvents: ['Attack building', 'Piece coordination', 'Tactical opportunities']\n    },\n    {\n      name: 'endgame',\n      startMove: endgameStart,\n      endMove: totalMoves,\n      description: 'King activation and pawn promotion',\n      keyEvents: ['King activation', 'Pawn advancement', 'Technique']\n    }\n  ];\n}\n\n/**\n * Guess the captured piece from move notation\n */\nfunction guessCapturedPiece(move: string): string | null {\n  // Simple heuristic - in SAN, captures don't explicitly state what was captured\n  // We can only guess based on destination square patterns\n  if (move.includes('x')) {\n    // If lowercase after x, it's just the square\n    // We can't reliably determine what was captured without board state\n    return null;\n  }\n  return null;\n}\n\n/**\n * Get full piece name from symbol\n */\nfunction getPieceName(piece: PieceSymbol): string {\n  const names: Record<string, string> = {\n    'Q': 'Queen',\n    'R': 'Rook', \n    'B': 'Bishop',\n    'N': 'Knight',\n    'K': 'King',\n    'q': 'Queen',\n    'r': 'Rook',\n    'b': 'Bishop',\n    'n': 'Knight',\n    'k': 'King',\n    'p': 'Pawn',\n  };\n  return names[piece] || piece;\n}\n\n/**\n * Get moment counts grouped by category\n */\nexport function getMomentCounts(moments: TimelineMoment[]) {\n  const counts: Record<MomentType, number> = {\n    capture: 0, check: 0, checkmate: 0, castling: 0,\n    brilliant: 0, great: 0, blunder: 0, mistake: 0, inaccuracy: 0,\n    fork: 0, pin: 0, skewer: 0, discovery: 0, sacrifice: 0,\n    en_passant: 0, promotion: 0, underpromotion: 0,\n  };\n  \n  for (const moment of moments) {\n    counts[moment.type]++;\n  }\n  \n  return counts;\n}\n";export{n as default};
