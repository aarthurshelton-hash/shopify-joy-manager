const e="/**\n * Social Media Domain Adapter\n * \n * Analyzes Twitter/X, Reddit, and social sentiment patterns\n * Free tier APIs available\n */\n\nexport interface SocialData {\n  platform: 'twitter' | 'reddit' | 'hackernews';\n  posts: Array<{\n    timestamp: number;\n    sentiment: number; // -1 to 1\n    engagement: number; // likes + shares normalized\n    viralVelocity: number; // rate of spread\n    topic: string;\n    authorInfluence: number; // follower count normalized\n  }>;\n  trendingTopics: string[];\n  timeRange: { start: number; end: number };\n}\n\nexport type SocialArchetype = \n  | 'viral_cascade' \n  | 'echo_chamber' \n  | 'organic_growth'\n  | 'influencer_driven'\n  | 'controversy_burst'\n  | 'meme_explosion'\n  | 'news_reaction'\n  | 'bot_coordinated';\n\nexport function extractSocialSignature(data: SocialData) {\n  const sentimentTrend = calculateSentimentTrend(data.posts);\n  const viralMomentum = calculateViralMomentum(data.posts);\n  \n  return {\n    domain: 'social',\n    archetype: classifySocialArchetype(data, viralMomentum),\n    quadrantProfile: {\n      q1: sentimentTrend.positivity,\n      q2: viralMomentum.spreadRate,\n      q3: sentimentTrend.negativity,\n      q4: viralMomentum.sustainability\n    },\n    temporalFlow: calculateTemporalFlow(data.posts),\n    intensity: Math.min(1, viralMomentum.velocity),\n    trendingTopics: data.trendingTopics.slice(0, 5)\n  };\n}\n\nfunction calculateSentimentTrend(posts: SocialData['posts']) {\n  const recent = posts.slice(-20);\n  const positive = recent.filter(p => p.sentiment > 0.3).length / recent.length;\n  const negative = recent.filter(p => p.sentiment < -0.3).length / recent.length;\n  return { positivity: positive, negativity: negative };\n}\n\nfunction calculateViralMomentum(posts: SocialData['posts']) {\n  const velocities = posts.map((p, i) => i > 0 ? p.engagement - posts[i-1].engagement : 0);\n  const avgVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;\n  const spreadRate = posts.filter(p => p.viralVelocity > 0.7).length / posts.length;\n  return { velocity: Math.abs(avgVelocity), spreadRate, sustainability: spreadRate > 0.3 ? 0.8 : 0.4 };\n}\n\nfunction classifySocialArchetype(data: SocialData, momentum: ReturnType<typeof calculateViralMomentum>): SocialArchetype {\n  const botScore = data.posts.filter(p => p.authorInfluence < 0.1 && p.engagement > 0.8).length / data.posts.length;\n  if (botScore > 0.4) return 'bot_coordinated';\n  if (momentum.velocity > 0.8 && momentum.spreadRate > 0.6) return 'viral_cascade';\n  if (momentum.sustainability > 0.7) return 'echo_chamber';\n  if (data.trendingTopics.some(t => t.includes('meme'))) return 'meme_explosion';\n  return 'organic_growth';\n}\n\nfunction calculateTemporalFlow(posts: SocialData['posts']) {\n  const thirds = Math.floor(posts.length / 3);\n  return {\n    early: posts.slice(0, thirds).reduce((sum, p) => sum + p.engagement, 0) / thirds || 0.3,\n    mid: posts.slice(thirds, thirds * 2).reduce((sum, p) => sum + p.engagement, 0) / thirds || 0.4,\n    late: posts.slice(thirds * 2).reduce((sum, p) => sum + p.engagement, 0) / (posts.length - thirds * 2) || 0.3\n  };\n}\n";export{e as default};
