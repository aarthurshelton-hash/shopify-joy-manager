const n="/**\n * Cross-Market Correlation Engine\n * Refactored into modular components with Speedrun Glitch Detection,\n * Consciousness Resonance, and Cultural Arbitrage integration\n */\n\nexport * from './crossMarket/types';\n\nimport { \n  AssetClass, \n  MarketTick, \n  BigPictureState, \n  MarketSnapshot \n} from './crossMarket/types';\nimport { updateCorrelations } from './crossMarket/correlationCalculator';\nimport { detectSignals } from './crossMarket/signalDetector';\nimport { calculateMetrics, calculatePredictionBoost } from './crossMarket/metricsCalculator';\nimport { speedrunGlitchDetector, SpeedrunState, MarketGlitch } from './speedrunGlitchDetector';\nimport { consciousnessResonanceDetector, ResonanceState } from './consciousnessResonanceDetector';\nimport { culturalArbitrageEngine, CulturalArbitrageOpportunity } from './culturalArbitrageEngine';\n\n// Extended state including new detectors\nexport interface EnhancedBigPictureState extends BigPictureState {\n  speedrunState?: SpeedrunState;\n  resonanceState?: ResonanceState;\n  actionableGlitches?: MarketGlitch[];\n  tradingRecommendation?: {\n    speedrun: ReturnType<typeof speedrunGlitchDetector.getTradingRecommendation>;\n    resonance: ReturnType<typeof consciousnessResonanceDetector.getTradingRecommendation>;\n    combined: {\n      action: 'BUY' | 'SELL' | 'WAIT' | 'SCALP' | 'HEDGE';\n      confidence: number;\n      reasoning: string;\n    };\n  };\n}\n\nclass CrossMarketEngine {\n  private tickHistory: Map<AssetClass, MarketTick[]> = new Map();\n  private maxHistory = 500;\n  private state: EnhancedBigPictureState;\n\n  constructor() {\n    this.state = this.createInitialState();\n    \n    const assetClasses: AssetClass[] = ['equity', 'bond', 'future', 'commodity', 'forex', 'crypto'];\n    assetClasses.forEach(ac => this.tickHistory.set(ac, []));\n    \n    // Initialize speedrun detector\n    speedrunGlitchDetector.initialize();\n  }\n\n  private createInitialState(): EnhancedBigPictureState {\n    return {\n      correlations: [],\n      activeSignals: [],\n      marketSentiment: 0,\n      volatilityIndex: 20,\n      riskAppetite: 0,\n      trendAlignment: 0.5,\n      predictionBoost: 1.0\n    };\n  }\n\n  processTick(tick: MarketTick): EnhancedBigPictureState {\n    // Store tick\n    const history = this.tickHistory.get(tick.assetClass) || [];\n    history.push(tick);\n    if (history.length > this.maxHistory) {\n      history.shift();\n    }\n    this.tickHistory.set(tick.assetClass, history);\n\n    // Update correlations\n    this.state.correlations = updateCorrelations(this.tickHistory);\n\n    // Detect cross-market signals\n    this.state.activeSignals = detectSignals(this.tickHistory, this.state.activeSignals);\n\n    // Calculate big picture metrics\n    const metrics = calculateMetrics(this.tickHistory, this.state);\n    Object.assign(this.state, metrics);\n\n    // Calculate prediction boost\n    this.state.predictionBoost = calculatePredictionBoost(this.state);\n\n    // Process through Speedrun Glitch Detector\n    this.state.speedrunState = speedrunGlitchDetector.processTick(tick, this.state);\n    this.state.actionableGlitches = speedrunGlitchDetector.getActionableGlitches();\n\n    // Process through Consciousness Resonance Detector\n    this.state.resonanceState = consciousnessResonanceDetector.processTick(tick, this.state);\n\n    // Get combined trading recommendations\n    const speedrunRec = speedrunGlitchDetector.getTradingRecommendation();\n    const resonanceRec = consciousnessResonanceDetector.getTradingRecommendation();\n    \n    this.state.tradingRecommendation = {\n      speedrun: speedrunRec,\n      resonance: resonanceRec,\n      combined: this.combineTradingRecommendations(speedrunRec, resonanceRec)\n    };\n\n    return this.state;\n  }\n\n  private combineTradingRecommendations(\n    speedrun: ReturnType<typeof speedrunGlitchDetector.getTradingRecommendation>,\n    resonance: ReturnType<typeof consciousnessResonanceDetector.getTradingRecommendation>\n  ): { action: 'BUY' | 'SELL' | 'WAIT' | 'SCALP' | 'HEDGE'; confidence: number; reasoning: string } {\n    // If both agree on direction with high confidence\n    if (speedrun.action === resonance.action && speedrun.confidence > 0.6 && resonance.confidence > 0.6) {\n      return {\n        action: speedrun.action as 'BUY' | 'SELL' | 'WAIT' | 'SCALP' | 'HEDGE',\n        confidence: (speedrun.confidence + resonance.confidence) / 2 + 0.1,\n        reasoning: `ALIGNED: Speedrun (${speedrun.glitchType || 'none'}) + Resonance (${resonance.mood}) both signal ${speedrun.action}`\n      };\n    }\n\n    // If one has much higher confidence\n    if (speedrun.confidence > resonance.confidence + 0.2) {\n      return {\n        action: speedrun.action as 'BUY' | 'SELL' | 'WAIT' | 'SCALP' | 'HEDGE',\n        confidence: speedrun.confidence,\n        reasoning: `SPEEDRUN DOMINANT: ${speedrun.reasoning}`\n      };\n    }\n\n    if (resonance.confidence > speedrun.confidence + 0.2) {\n      return {\n        action: resonance.action as 'BUY' | 'SELL' | 'WAIT' | 'SCALP' | 'HEDGE',\n        confidence: resonance.confidence,\n        reasoning: `RESONANCE DOMINANT: ${resonance.reasoning}`\n      };\n    }\n\n    // Conflicting signals - hedge or wait\n    if (speedrun.action !== resonance.action && speedrun.action !== 'WAIT' && resonance.action !== 'WAIT') {\n      return {\n        action: 'HEDGE',\n        confidence: 0.5,\n        reasoning: `CONFLICTING: Speedrun says ${speedrun.action}, Resonance says ${resonance.action}. Hedge recommended.`\n      };\n    }\n\n    return {\n      action: 'WAIT',\n      confidence: 0.4,\n      reasoning: 'No strong consensus between Speedrun and Resonance detectors.'\n    };\n  }\n\n  getState(): EnhancedBigPictureState {\n    return { ...this.state };\n  }\n\n  getSnapshot(): MarketSnapshot {\n    const getLatest = (ac: AssetClass): MarketTick | null => {\n      const history = this.tickHistory.get(ac) || [];\n      return history.length > 0 ? history[history.length - 1] : null;\n    };\n\n    return {\n      equity: getLatest('equity'),\n      bond: getLatest('bond'),\n      future: getLatest('future'),\n      commodity: getLatest('commodity'),\n      forex: getLatest('forex'),\n      crypto: getLatest('crypto')\n    };\n  }\n}\n\nexport const crossMarketEngine = new CrossMarketEngine();\n";export{n as default};
