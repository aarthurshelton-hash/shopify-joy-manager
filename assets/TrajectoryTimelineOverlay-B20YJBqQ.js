const n="/**\n * Trajectory Timeline Overlay\n * \n * Overlays predicted strategic milestones and trajectory markers\n * on the game replay timeline slider.\n */\n\nimport React from 'react';\nimport { motion } from 'framer-motion';\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@/components/ui/tooltip';\nimport { \n  Target, \n  TrendingUp, \n  AlertTriangle, \n  Crown, \n  Swords,\n  Shield,\n  Zap,\n  Flag\n} from 'lucide-react';\nimport { HybridPrediction, TrajectoryMilestone } from '@/lib/chess/hybridPrediction';\nimport { PatternPrediction } from '@/lib/chess/patternLearning';\nimport { cn } from '@/lib/utils';\n\ninterface TrajectoryTimelineOverlayProps {\n  hybridPrediction?: HybridPrediction | null;\n  patternPrediction?: PatternPrediction | null;\n  totalMoves: number;\n  currentMove: number;\n  orientation?: 'horizontal' | 'vertical';\n  className?: string;\n}\n\ninterface TrajectoryMarker {\n  move: number;\n  type: 'milestone' | 'turning_point' | 'critical' | 'prediction';\n  label: string;\n  description?: string;\n  confidence: number;\n  color: string;\n  icon: React.ComponentType<{ className?: string }>;\n}\n\nconst TrajectoryTimelineOverlay: React.FC<TrajectoryTimelineOverlayProps> = ({\n  hybridPrediction,\n  patternPrediction,\n  totalMoves,\n  currentMove,\n  orientation = 'vertical',\n  className,\n}) => {\n  // Generate trajectory markers from predictions\n  const markers = React.useMemo(() => {\n    const result: TrajectoryMarker[] = [];\n\n    // Add hybrid prediction trajectory milestones\n    if (hybridPrediction?.trajectoryPrediction?.expectedMilestones) {\n      hybridPrediction.trajectoryPrediction.expectedMilestones.forEach((milestone, index) => {\n        // Show milestone markers\n        result.push({\n          move: milestone.approximateMoveNumber,\n          type: milestone.description.toLowerCase().includes('critical') ? 'critical' : 'milestone',\n          label: `Move ${milestone.approximateMoveNumber}`,\n          description: milestone.description,\n          confidence: hybridPrediction.confidence.overall,\n          color: 'text-amber-400',\n          icon: Target,\n        });\n      });\n    }\n\n    // Add predicted trajectory milestones from pattern prediction\n    if (patternPrediction && patternPrediction.lookaheadMoves > 0) {\n      const lookaheadStart = totalMoves;\n      const lookaheadEnd = totalMoves + patternPrediction.lookaheadMoves;\n      \n      // Add prediction start marker\n      if (lookaheadStart > 0) {\n        result.push({\n          move: lookaheadStart,\n          type: 'prediction',\n          label: 'Prediction Zone',\n          description: `Pattern-based forecast for next ${patternPrediction.lookaheadMoves} moves`,\n          confidence: patternPrediction.confidence,\n          color: 'text-purple-400',\n          icon: Zap,\n        });\n      }\n\n      // Add critical points in prediction zone\n      const predictionMilestones = [\n        Math.round(lookaheadStart + patternPrediction.lookaheadMoves * 0.33),\n        Math.round(lookaheadStart + patternPrediction.lookaheadMoves * 0.66),\n        lookaheadEnd,\n      ];\n\n      predictionMilestones.forEach((move, index) => {\n        const isEnd = index === predictionMilestones.length - 1;\n        result.push({\n          move,\n          type: isEnd ? 'turning_point' : 'milestone',\n          label: isEnd ? 'Trajectory End' : `Checkpoint ${index + 1}`,\n          description: isEnd \n            ? `Predicted outcome: ${patternPrediction.mostLikelyOutcome.replace('_', ' ')}`\n            : `Pattern trajectory checkpoint`,\n          confidence: patternPrediction.confidence * (1 - index * 0.1),\n          color: isEnd \n            ? patternPrediction.mostLikelyOutcome === 'white_wins' ? 'text-sky-400' \n              : patternPrediction.mostLikelyOutcome === 'black_wins' ? 'text-rose-400' \n              : 'text-amber-400'\n            : 'text-purple-400/70',\n          icon: isEnd ? Flag : Shield,\n        });\n      });\n    }\n\n    // Sort by move number\n    return result.sort((a, b) => a.move - b.move);\n  }, [hybridPrediction, patternPrediction, totalMoves]);\n\n  if (markers.length === 0) return null;\n\n  // Calculate position based on move number and total\n  const getPosition = (move: number) => {\n    const maxMove = Math.max(\n      totalMoves,\n      patternPrediction ? totalMoves + patternPrediction.lookaheadMoves : totalMoves\n    );\n    return (move / maxMove) * 100;\n  };\n\n  const isVertical = orientation === 'vertical';\n\n  return (\n    <TooltipProvider>\n      <div \n        className={cn(\n          \"absolute pointer-events-none\",\n          isVertical ? \"inset-y-0 right-0 w-8\" : \"inset-x-0 top-0 h-8\",\n          className\n        )}\n      >\n        {markers.map((marker, index) => {\n          const position = getPosition(marker.move);\n          const isPast = marker.move <= currentMove;\n          const isCurrent = marker.move === currentMove;\n          const isFuture = marker.move > totalMoves;\n          const IconComponent = marker.icon;\n\n          return (\n            <Tooltip key={`${marker.move}-${marker.type}-${index}`}>\n              <TooltipTrigger asChild>\n                <motion.div\n                  initial={{ opacity: 0, scale: 0.5 }}\n                  animate={{ \n                    opacity: isFuture ? 0.6 : 1, \n                    scale: isCurrent ? 1.2 : 1 \n                  }}\n                  className={cn(\n                    \"absolute pointer-events-auto cursor-pointer transition-all\",\n                    isVertical \n                      ? \"right-1 -translate-y-1/2\" \n                      : \"top-1 -translate-x-1/2\"\n                  )}\n                  style={isVertical \n                    ? { top: `${position}%` } \n                    : { left: `${position}%` }\n                  }\n                >\n                  <div \n                    className={cn(\n                      \"flex items-center justify-center rounded-full transition-all\",\n                      isCurrent ? \"ring-2 ring-primary ring-offset-1 ring-offset-background\" : \"\",\n                      isPast && !isFuture ? \"opacity-100\" : \"opacity-70\",\n                      isFuture ? \"border border-dashed border-current\" : \"\",\n                      marker.type === 'critical' ? \"bg-rose-500/20\" : \n                      marker.type === 'turning_point' ? \"bg-amber-500/20\" :\n                      marker.type === 'prediction' ? \"bg-purple-500/20\" :\n                      \"bg-card/80\",\n                      \"w-5 h-5\"\n                    )}\n                  >\n                    <IconComponent className={cn(\"w-3 h-3\", marker.color)} />\n                  </div>\n                </motion.div>\n              </TooltipTrigger>\n              <TooltipContent \n                side={isVertical ? \"left\" : \"bottom\"} \n                className=\"max-w-[200px]\"\n              >\n                <div className=\"space-y-1\">\n                  <div className=\"flex items-center gap-2\">\n                    <IconComponent className={cn(\"w-3 h-3\", marker.color)} />\n                    <span className=\"font-medium text-xs\">{marker.label}</span>\n                    {isFuture && (\n                      <span className=\"text-[10px] text-muted-foreground bg-purple-500/20 px-1 rounded\">\n                        Predicted\n                      </span>\n                    )}\n                  </div>\n                  {marker.description && (\n                    <p className=\"text-[10px] text-muted-foreground\">\n                      {marker.description}\n                    </p>\n                  )}\n                  <div className=\"flex items-center gap-2 text-[10px] text-muted-foreground\">\n                    <span>Confidence:</span>\n                    <div className=\"flex-1 h-1 bg-muted rounded-full overflow-hidden\">\n                      <div \n                        className=\"h-full bg-primary rounded-full\"\n                        style={{ width: `${marker.confidence}%` }}\n                      />\n                    </div>\n                    <span>{Math.round(marker.confidence)}%</span>\n                  </div>\n                </div>\n              </TooltipContent>\n            </Tooltip>\n          );\n        })}\n\n        {/* Future zone indicator */}\n        {patternPrediction && patternPrediction.lookaheadMoves > 0 && (\n          <div \n            className={cn(\n              \"absolute bg-gradient-to-b from-purple-500/10 to-purple-500/5 border-l border-dashed border-purple-500/30\",\n              isVertical \n                ? \"inset-x-0 bottom-0\" \n                : \"inset-y-0 right-0\"\n            )}\n            style={isVertical \n              ? { top: `${getPosition(totalMoves)}%` }\n              : { left: `${getPosition(totalMoves)}%` }\n            }\n          />\n        )}\n      </div>\n    </TooltipProvider>\n  );\n};\n\nexport default TrajectoryTimelineOverlay;\n";export{n as default};
