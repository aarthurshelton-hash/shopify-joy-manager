const n="/**\n * Speedrun Glitch Detector\n * \n * Wires the Temporal Consciousness Speedrun Adapter to live market signals.\n * Detects \"natural glitches\" - optimization pathways that exist within the rules\n * but beyond the typical trader's intent.\n * \n * Based on CEO insight: Just as speedrunners find legitimate shortcuts in games,\n * markets contain natural optimization routes that can be exploited for merited success.\n */\n\nimport { \n  temporalConsciousnessSpeedrunAdapter,\n  SPEEDRUN_PHILOSOPHY,\n  ESPORTS_TEMPORAL_PATTERNS,\n  STRUCTURAL_GLITCHES,\n  TIME_PERCEPTION_MODIFIERS\n} from '../universal/adapters/temporalConsciousnessSpeedrunAdapter';\nimport type { BigPictureState, MarketTick } from './crossMarket/types';\n\n// ============================================================================\n// GLITCH TYPES FOR MARKET EXPLOITATION\n// ============================================================================\n\nexport interface MarketGlitch {\n  type: keyof typeof SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES;\n  confidence: number;\n  description: string;\n  actionable: boolean;\n  timeWindow: number; // milliseconds\n  riskReward: number;\n  signals: string[];\n}\n\nexport interface SpeedrunState {\n  activeGlitches: MarketGlitch[];\n  consciousnessResonance: number;\n  temporalCompression: number; // How \"compressed\" market time feels\n  glitchDensity: number; // How many opportunities per unit time\n  optimalHorizon: string; // fly/squirrel/human/whale perspective\n  lastUpdated: Date;\n}\n\n// ============================================================================\n// DETECTOR CLASS\n// ============================================================================\n\nclass SpeedrunGlitchDetector {\n  private state: SpeedrunState;\n  private recentTicks: MarketTick[] = [];\n  private maxRecentTicks = 100;\n  private isInitialized = false;\n\n  constructor() {\n    this.state = this.createInitialState();\n  }\n\n  initialize(): void {\n    if (this.isInitialized) return;\n    temporalConsciousnessSpeedrunAdapter.initialize();\n    this.isInitialized = true;\n    console.log('[SpeedrunGlitchDetector] Wired to live market signals');\n    console.log('[SpeedrunGlitchDetector] Hunting for natural optimization pathways...');\n  }\n\n  private createInitialState(): SpeedrunState {\n    return {\n      activeGlitches: [],\n      consciousnessResonance: 0.5,\n      temporalCompression: 1.0,\n      glitchDensity: 0,\n      optimalHorizon: 'HUMAN',\n      lastUpdated: new Date()\n    };\n  }\n\n  /**\n   * Process a market tick and detect glitch opportunities\n   */\n  processTick(tick: MarketTick, bigPictureState: BigPictureState): SpeedrunState {\n    if (!this.isInitialized) this.initialize();\n\n    // Track recent ticks\n    this.recentTicks.push(tick);\n    if (this.recentTicks.length > this.maxRecentTicks) {\n      this.recentTicks.shift();\n    }\n\n    // Calculate market metrics for glitch detection\n    const volatility = this.calculateVolatility();\n    const momentum = this.calculateMomentum();\n    const volume = this.normalizeVolume(tick.volume || 0);\n\n    // Use the adapter to detect glitch opportunities\n    const temporalSignal = temporalConsciousnessSpeedrunAdapter.processTemporalData({\n      observerType: 'AI',\n      marketData: { volatility, momentum, volume }\n    });\n\n    // Convert adapter glitches to actionable market glitches\n    const marketGlitches = this.convertToMarketGlitches(\n      temporalSignal.glitchOpportunities,\n      bigPictureState,\n      { volatility, momentum, volume }\n    );\n\n    // Determine optimal observation horizon\n    const optimalHorizon = this.determineOptimalHorizon(volatility, momentum);\n\n    // Calculate temporal compression (how fast market time feels)\n    const temporalCompression = this.calculateTemporalCompression(volatility, bigPictureState);\n\n    // Calculate glitch density\n    const glitchDensity = marketGlitches.length / Math.max(this.recentTicks.length, 1);\n\n    this.state = {\n      activeGlitches: marketGlitches,\n      consciousnessResonance: temporalSignal.consciousnessResonance,\n      temporalCompression,\n      glitchDensity,\n      optimalHorizon,\n      lastUpdated: new Date()\n    };\n\n    return this.state;\n  }\n\n  private calculateVolatility(): number {\n    if (this.recentTicks.length < 2) return 0.5;\n    \n    const prices = this.recentTicks.map(t => t.price);\n    const returns = prices.slice(1).map((p, i) => (p - prices[i]) / prices[i]);\n    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Normalize to 0-1 range (assuming typical daily vol of 1-5%)\n    return Math.min(1, stdDev * 100);\n  }\n\n  private calculateMomentum(): number {\n    if (this.recentTicks.length < 10) return 0;\n    \n    const recentPrice = this.recentTicks[this.recentTicks.length - 1].price;\n    const olderPrice = this.recentTicks[Math.max(0, this.recentTicks.length - 10)].price;\n    \n    const change = (recentPrice - olderPrice) / olderPrice;\n    // Normalize to -1 to 1 range\n    return Math.max(-1, Math.min(1, change * 20));\n  }\n\n  private normalizeVolume(volume: number): number {\n    // Simple normalization - assumes volume is already somewhat normalized\n    return Math.min(1, volume / 1000000);\n  }\n\n  private convertToMarketGlitches(\n    glitchStrings: string[],\n    bigPicture: BigPictureState,\n    metrics: { volatility: number; momentum: number; volume: number }\n  ): MarketGlitch[] {\n    return glitchStrings.map(glitchStr => {\n      const [type, ...descParts] = glitchStr.split(':');\n      const description = descParts.join(':').trim();\n      \n      const glitchType = type as keyof typeof SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES;\n      const category = SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES[glitchType];\n      \n      // Calculate actionability based on market conditions\n      const actionable = this.isGlitchActionable(glitchType, metrics, bigPicture);\n      \n      // Calculate time window (shorter for higher volatility)\n      const baseWindow = 60000; // 1 minute\n      const timeWindow = baseWindow / (1 + metrics.volatility * 2);\n      \n      // Risk/reward based on glitch type\n      const riskReward = this.calculateRiskReward(glitchType, metrics);\n      \n      // Confidence based on signal strength and alignment\n      const confidence = this.calculateGlitchConfidence(glitchType, metrics, bigPicture);\n      \n      return {\n        type: glitchType,\n        confidence,\n        description: category?.market || description,\n        actionable,\n        timeWindow,\n        riskReward,\n        signals: bigPicture.activeSignals.map(s => s.type)\n      };\n    });\n  }\n\n  private isGlitchActionable(\n    type: keyof typeof SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES,\n    metrics: { volatility: number; momentum: number; volume: number },\n    bigPicture: BigPictureState\n  ): boolean {\n    switch (type) {\n      case 'SEQUENCE_BREAK':\n        // Actionable when momentum and fundamentals diverge\n        return Math.abs(metrics.momentum) > 0.5 && bigPicture.trendAlignment < 0.3;\n      \n      case 'CLIP_THROUGH':\n        // Actionable when volatility is high but direction unclear\n        return metrics.volatility > 0.6 && Math.abs(metrics.momentum) < 0.3;\n      \n      case 'CHECKPOINT_SKIP':\n        // Actionable when strong trend with volume confirmation\n        return Math.abs(metrics.momentum) > 0.7 && metrics.volume > 0.5;\n      \n      case 'FRAME_PERFECT':\n        // Actionable during compression (pre-breakout)\n        return metrics.volatility < 0.15 && bigPicture.trendAlignment > 0.7;\n      \n      case 'WRONG_WARP':\n        // Actionable during chaos - high risk, high reward\n        return metrics.volatility > 0.8 && Math.abs(bigPicture.marketSentiment) > 0.7;\n      \n      default:\n        return false;\n    }\n  }\n\n  private calculateRiskReward(\n    type: keyof typeof SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES,\n    metrics: { volatility: number; momentum: number; volume: number }\n  ): number {\n    const baseReward: Record<keyof typeof SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES, number> = {\n      SEQUENCE_BREAK: 2.5,\n      CLIP_THROUGH: 1.8,\n      CHECKPOINT_SKIP: 3.0,\n      FRAME_PERFECT: 4.0,\n      WRONG_WARP: 5.0\n    };\n    \n    const base = baseReward[type] || 2.0;\n    // Adjust based on volatility (higher vol = potentially higher reward but more risk)\n    return base * (1 + metrics.volatility * 0.5);\n  }\n\n  private calculateGlitchConfidence(\n    type: keyof typeof SPEEDRUN_PHILOSOPHY.GLITCH_CATEGORIES,\n    metrics: { volatility: number; momentum: number; volume: number },\n    bigPicture: BigPictureState\n  ): number {\n    let confidence = 0.5;\n    \n    // Volume adds confidence\n    confidence += metrics.volume * 0.2;\n    \n    // Strong trend alignment adds confidence\n    confidence += bigPicture.trendAlignment * 0.15;\n    \n    // Type-specific confidence adjustments\n    if (type === 'FRAME_PERFECT' && metrics.volatility < 0.1) {\n      confidence += 0.2; // Compression patterns are reliable\n    }\n    \n    if (type === 'CHECKPOINT_SKIP' && bigPicture.predictionBoost > 1.2) {\n      confidence += 0.15; // Cross-market confirmation\n    }\n    \n    return Math.min(0.95, Math.max(0.1, confidence));\n  }\n\n  private determineOptimalHorizon(volatility: number, momentum: number): string {\n    // Match market conditions to optimal consciousness type\n    if (volatility > 0.8) return 'FLY'; // Need microsecond reactions\n    if (volatility > 0.5) return 'SQUIRREL'; // Day trading\n    if (Math.abs(momentum) > 0.7) return 'HUMAN'; // Swing trading\n    if (volatility < 0.2 && Math.abs(momentum) < 0.2) return 'ELEPHANT'; // Patient capital\n    return 'HUMAN'; // Default\n  }\n\n  private calculateTemporalCompression(volatility: number, bigPicture: BigPictureState): number {\n    // Higher volatility = time feels faster (more events per unit time)\n    const volComponent = 1 + volatility * 2;\n    \n    // More signals = denser time\n    const signalComponent = 1 + bigPicture.activeSignals.length * 0.1;\n    \n    return volComponent * signalComponent;\n  }\n\n  getState(): SpeedrunState {\n    return { ...this.state };\n  }\n\n  getActionableGlitches(): MarketGlitch[] {\n    return this.state.activeGlitches.filter(g => g.actionable);\n  }\n\n  getHighestConfidenceGlitch(): MarketGlitch | null {\n    const actionable = this.getActionableGlitches();\n    if (actionable.length === 0) return null;\n    return actionable.reduce((best, g) => g.confidence > best.confidence ? g : best);\n  }\n\n  /**\n   * Get trading recommendation based on detected glitches\n   */\n  getTradingRecommendation(): {\n    action: 'BUY' | 'SELL' | 'WAIT' | 'SCALP';\n    confidence: number;\n    glitchType: string | null;\n    reasoning: string;\n    timeframe: string;\n  } {\n    const bestGlitch = this.getHighestConfidenceGlitch();\n    \n    if (!bestGlitch) {\n      return {\n        action: 'WAIT',\n        confidence: 0.3,\n        glitchType: null,\n        reasoning: 'No actionable glitch patterns detected',\n        timeframe: 'N/A'\n      };\n    }\n\n    // Determine action based on glitch type\n    let action: 'BUY' | 'SELL' | 'WAIT' | 'SCALP';\n    let reasoning: string;\n    \n    switch (bestGlitch.type) {\n      case 'CHECKPOINT_SKIP':\n        // Strong trend - follow it\n        action = bestGlitch.riskReward > 3 ? 'BUY' : 'SELL';\n        reasoning = `Strong momentum detected - checkpoint skip opportunity. R:R ${bestGlitch.riskReward.toFixed(1)}`;\n        break;\n      \n      case 'FRAME_PERFECT':\n        // Compression before breakout\n        action = 'WAIT';\n        reasoning = `Volatility compression - prepare for frame-perfect entry on breakout`;\n        break;\n      \n      case 'CLIP_THROUGH':\n        // Scalp the volatility\n        action = 'SCALP';\n        reasoning = `High volatility, no direction - scalp both sides`;\n        break;\n      \n      case 'WRONG_WARP':\n        // Chaos trade\n        action = 'BUY';\n        reasoning = `Chaos state detected - WRONG_WARP may lead to unexpected gains`;\n        break;\n      \n      default:\n        action = 'WAIT';\n        reasoning = `Glitch pattern ${bestGlitch.type} detected - analyzing...`;\n    }\n\n    return {\n      action,\n      confidence: bestGlitch.confidence,\n      glitchType: bestGlitch.type,\n      reasoning,\n      timeframe: `${Math.round(bestGlitch.timeWindow / 1000)}s window`\n    };\n  }\n}\n\n// Export singleton\nexport const speedrunGlitchDetector = new SpeedrunGlitchDetector();\n// Types already exported above via interfaces\n";export{n as default};
