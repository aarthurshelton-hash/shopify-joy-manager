const e="/**\n * Cybersecurity & Threat Pattern Recognition Adapter\n * \n * Archetypal attack patterns as temporal sequences.\n * Phishing, malware, intrusion, social engineering -\n * all follow predictable temporal signatures before execution.\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\n// ═══════════════════════════════════════════════════════════════════════════════\n// ARCHETYPAL ATTACK PATTERNS (Real MITRE ATT&CK Framework + Temporal Analysis)\n// ═══════════════════════════════════════════════════════════════════════════════\n\nconst ATTACK_ARCHETYPES = {\n  // Reconnaissance Phase\n  reconnaissance: {\n    name: 'Initial Access Preparation',\n    temporalPattern: 'slow_burn_information_gathering',\n    indicators: [\n      'port_scanning',\n      'social_media_profiling', \n      'whois_lookup_patterns',\n      'dns_enumeration_spikes',\n      'credential_stuffing_prep'\n    ],\n    duration: 'days_to_weeks',\n    marketAnalogy: 'Due diligence before acquisition, information asymmetry exploitation'\n  },\n  \n  // Phishing Archetypes\n  phishing: {\n    spear: {\n      name: 'Targeted Deception',\n      temporalPattern: 'personalized_contact_buildup',\n      stages: [\n        'research_target',           // OSINT gathering\n        'craft_persona',             // Identity construction  \n        'establish_rapport',         // Trust building over time\n        'urgency_injection',         // Time pressure creation\n        'credential_harvest'         // Payload delivery\n      ],\n      detectionWindow: 'stage_3_4_boundary',\n      marketAnalogy: 'Pump and dump: Build confidence, create urgency, exit'\n    },\n    \n    whaling: {\n      name: 'Executive Targeting',\n      temporalPattern: 'authority_exploitation',\n      keyIndicator: 'C_level_impersonation_timing',\n      marketAnalogy: 'Insider trading mimicry'\n    },\n    \n    vishing: {\n      name: 'Voice Channel Exploitation',\n      temporalPattern: 'real_time_pressure_application',\n      marketAnalogy: 'Cold call high-pressure sales'\n    }\n  },\n  \n  // Malware Deployment Patterns  \n  malware: {\n    droppers: {\n      name: 'Staged Delivery',\n      temporalPattern: 'multi_stage_payload_assembly',\n      stages: ['initial_contact', 'dropper_download', 'c2_establishment', 'payload_retrieval', 'execution'],\n      detectionOpportunity: 'stage_2_to_3_transition'\n    },\n    \n    ransomware: {\n      name: 'Encryption Extortion',\n      temporalPattern: 'lateral_movement_then_sudden_encryption',\n      phases: [\n        'initial_compromise',        // Hours\n        'persistence_establishment', // Days\n        'reconnaissance_internal',   // Days\n        'lateral_movement',          // Days to weeks\n        'backup_destruction',        // Hours\n        'mass_encryption'            // Minutes\n      ],\n      criticalMoment: 'backup_destruction_detection',\n      marketAnalogy: 'Short squeeze: Position building, then sudden move'\n    },\n    \n    apt: {\n      name: 'Advanced Persistent Threat',\n      temporalPattern: 'long_term_dwell_with_sporadic_activity',\n      dwellTime: 'months_to_years',\n      activityBursts: 'targeted_data_exfiltration_events',\n      marketAnalogy: 'Long-term insider accumulation, periodic profit taking'\n    }\n  },\n  \n  // Social Engineering\n  socialEngineering: {\n    pretexting: {\n      name: 'Fabricated Scenario',\n      temporalPattern: 'narrative_construction_over_time',\n      credibilityBuilding: ' Gradual authority establishment',\n      marketAnalogy: 'Fraudulent investment narrative building'\n    },\n    \n    baiting: {\n      name: 'Curiosity Exploitation',\n      temporalPattern: 'immediate_gratification_trigger',\n      marketAnalogy: 'FOMO trading, get rich quick schemes'\n    },\n    \n    quidProQuo: {\n      name: 'Service Exchange Deception',\n      temporalPattern: 'helpful_service_then_exploit',\n      marketAnalogy: 'Free trial to subscription lock-in'\n    }\n  }\n};\n\n// ═══════════════════════════════════════════════════════════════════════════════\n// KILL CHAIN TEMPORAL ANALYSIS (Real Cyber Kill Chain Framework)\n// ═══════════════════════════════════════════════════════════════════════════════\n\nconst KILL_CHAIN_PHASES = [\n  { phase: 'reconnaissance', duration: 'weeks', detectability: 0.3, criticality: 0.2 },\n  { phase: 'weaponization', duration: 'days', detectability: 0.1, criticality: 0.4 },\n  { phase: 'delivery', duration: 'hours', detectability: 0.6, criticality: 0.6 },\n  { phase: 'exploitation', duration: 'minutes', detectability: 0.4, criticality: 0.8 },\n  { phase: 'installation', duration: 'minutes', detectability: 0.5, criticality: 0.9 },\n  { phase: 'c2_communication', duration: 'ongoing', detectability: 0.7, criticality: 0.9 },\n  { phase: 'actions_on_objectives', duration: 'variable', detectability: 0.8, criticality: 1.0 }\n];\n\n// ═══════════════════════════════════════════════════════════════════════════════\n// BEHAVIORAL BIOMETRICS (Real Technology)\n// ═══════════════════════════════════════════════════════════════════════════════\n\nconst BEHAVIORAL_BIOMETRICS = {\n  keystrokeDynamics: {\n    description: 'Typing rhythm analysis',\n    temporalFeatures: ['dwell_time', 'flight_time', 'typing_speed_variance'],\n    anomalyIndicators: ['stress_typing', 'automation_signatures', 'distraction_patterns']\n  },\n  \n  mouseDynamics: {\n    description: 'Cursor movement patterns',\n    temporalFeatures: ['movement_velocity', 'curvature_patterns', 'click_timing'],\n    anomalyIndicators: ['robotic_precision', 'hesitation_patterns', 'unusual_paths']\n  },\n  \n  navigationPatterns: {\n    description: 'User journey analysis',\n    temporalFeatures: ['page_sequence', 'time_on_page', 'interaction_depth'],\n    anomalyIndicators: ['credential_focused_path', 'unusual_knowledge', 'bypass_attempts']\n  }\n};\n\n// ═══════════════════════════════════════════════════════════════════════════════\n// ANOMALY DETECTION TEMPORAL SIGNATURES\n// ═══════════════════════════════════════════════════════════════════════════════\n\nconst ANOMALY_SIGNATURES = {\n  timeBased: {\n    afterHoursAccess: { risk: 0.7, pattern: 'off_hours_admin_activity' },\n    weekendActivity: { risk: 0.6, pattern: 'weekend_system_changes' },\n    holidayAccess: { risk: 0.8, pattern: 'holiday_sensitive_data_access' },\n    impossibleTravel: { risk: 0.9, pattern: 'geographic_impossibility' }\n  },\n  \n  volumeBased: {\n    dataExfiltration: { \n      pattern: 'sustained_high_volume_outbound',\n      temporalShape: 'gradual_ramp_or_sudden_spike',\n      threshold: '3_sigma_above_baseline'\n    },\n    credentialSpraying: {\n      pattern: 'rapid_authentication_attempts',\n      temporalShape: 'burst_pattern',\n      threshold: '10_attempts_per_minute'\n    }\n  },\n  \n  sequenceBased: {\n    privilegeEscalation: {\n      pattern: 'normal_user_to_admin_in_session',\n      temporalWindow: 'single_session',\n      criticality: 0.95\n    },\n    lateralMovement: {\n      pattern: 'sequential_host_access',\n      temporalShape: 'systematic_progression',\n      criticality: 0.9\n    }\n  }\n};\n\ninterface SecurityEvent {\n  timestamp: number;\n  eventType: keyof typeof ATTACK_ARCHETYPES | string;\n  severity: number; // 0-10\n  sourceIP?: string;\n  userAgent?: string;\n  behavioralBiometrics?: {\n    keystrokeVariance: number;\n    mouseEntropy: number;\n    navigationAnomaly: number;\n  };\n  killChainPhase?: number; // 0-6 index\n  dataVolume?: number;\n  geographicLocation?: { lat: number; lon: number };\n}\n\nclass CybersecurityAdapter implements DomainAdapter<SecurityEvent> {\n  domain = 'security' as const;\n  name = 'Cybersecurity & Threat Pattern Recognition';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private threatScore: number = 0;\n  private readonly BUFFER_SIZE = 10000; // Security needs large buffers\n  \n  // Active threat tracking\n  private activeThreats: Map<string, {\n    firstSeen: number;\n    lastSeen: number;\n    eventCount: number;\n    killChainProgression: number;\n    severityAccumulated: number;\n  }> = new Map();\n  \n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[CybersecurityAdapter] Initialized - Threat detection active');\n  }\n  \n  processRawData(event: SecurityEvent): UniversalSignal {\n    const { timestamp, eventType, severity, killChainPhase, behavioralBiometrics } = event;\n    \n    // Calculate threat frequency (higher frequency = higher threat)\n    const frequency = this.calculateThreatFrequency(event);\n    \n    // Intensity based on severity and kill chain progression\n    const killChainWeight = killChainPhase !== undefined \n      ? KILL_CHAIN_PHASES[killChainPhase]?.criticality || 0.5\n      : 0.5;\n    \n    const intensity = (severity / 10) * killChainWeight;\n    \n    // Phase encodes behavioral anomaly if present\n    let phase = 0;\n    if (behavioralBiometrics) {\n      phase = (behavioralBiometrics.keystrokeVariance + \n               behavioralBiometrics.mouseEntropy + \n               behavioralBiometrics.navigationAnomaly) / 3 * Math.PI;\n    }\n    \n    // Harmonics encode different threat dimensions\n    const harmonics = [\n      severity / 10,\n      killChainWeight,\n      behavioralBiometrics?.keystrokeVariance || 0.5,\n      behavioralBiometrics?.mouseEntropy || 0.5,\n      this.isBusinessHours(timestamp) ? 0.3 : 0.8, // After hours = higher risk\n      this.isGeographicallyAnomalous(event) ? 0.9 : 0.1\n    ];\n    \n    const signal: UniversalSignal = {\n      domain: 'security',\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData: [severity, killChainWeight, frequency, this.threatScore]\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.updateThreatTracking(event);\n    this.lastUpdate = timestamp;\n    return signal;\n  }\n  \n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n    \n    const recent = signals.slice(-1000); // Security looks at more history\n    \n    // Calculate threat profile\n    const avgSeverity = recent.reduce((sum, s) => sum + s.rawData[0], 0) / recent.length;\n    const avgKillChain = recent.reduce((sum, s) => sum + s.rawData[1], 0) / recent.length;\n    const avgFrequency = recent.reduce((sum, s) => sum + s.rawData[2], 0) / recent.length;\n    const currentThreatScore = recent[recent.length - 1]?.rawData[3] || 0;\n    \n    // Quadrant profile maps to security posture\n    const quadrantProfile = {\n      aggressive: avgSeverity * avgKillChain, // High severity, advanced kill chain\n      defensive: (1 - avgSeverity) * (1 - avgKillChain), // Low threat detected\n      tactical: avgFrequency * (1 - avgKillChain), // High activity, early stage\n      strategic: currentThreatScore // Overall threat intelligence\n    };\n    \n    // Temporal flow = kill chain progression\n    const temporalFlow = {\n      early: 1 - avgKillChain, // Recon/weaponization\n      mid: avgKillChain < 0.7 ? 0.5 : 0.2, // Delivery/exploitation\n      late: avgKillChain > 0.7 ? avgKillChain : 0.1 // C2/actions on objectives\n    };\n    \n    return {\n      domain: 'security',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgSeverity * avgKillChain,\n      momentum: avgFrequency > 0.5 ? 1 : -1, // Accelerating or decelerating threats\n      volatility: avgFrequency,\n      dominantFrequency: avgFrequency,\n      harmonicResonance: 1 - avgKillChain, // Lower = more advanced threat\n      phaseAlignment: currentThreatScore,\n      extractedAt: Date.now()\n    };\n  }\n  \n  private calculateThreatFrequency(event: SecurityEvent): number {\n    const key = `${event.sourceIP}_${event.eventType}`;\n    const existing = this.activeThreats.get(key);\n    \n    if (!existing) return 0.1;\n    \n    const timeWindow = (event.timestamp - existing.firstSeen) / 1000; // seconds\n    const frequency = existing.eventCount / (timeWindow + 1);\n    \n    // Normalize to 0-1 range (assuming > 1 event/sec is max frequency)\n    return Math.min(frequency, 1);\n  }\n  \n  private updateThreatTracking(event: SecurityEvent): void {\n    const key = `${event.sourceIP}_${event.eventType}`;\n    const existing = this.activeThreats.get(key);\n    \n    if (existing) {\n      existing.lastSeen = event.timestamp;\n      existing.eventCount++;\n      existing.severityAccumulated += event.severity;\n      if (event.killChainPhase !== undefined) {\n        existing.killChainProgression = Math.max(\n          existing.killChainProgression, \n          event.killChainPhase\n        );\n      }\n    } else {\n      this.activeThreats.set(key, {\n        firstSeen: event.timestamp,\n        lastSeen: event.timestamp,\n        eventCount: 1,\n        killChainProgression: event.killChainPhase || 0,\n        severityAccumulated: event.severity\n      });\n    }\n    \n    // Calculate overall threat score\n    this.threatScore = this.calculateOverallThreatScore();\n  }\n  \n  private calculateOverallThreatScore(): number {\n    let score = 0;\n    this.activeThreats.forEach(threat => {\n      const recency = (Date.now() - threat.lastSeen) / (1000 * 60 * 60); // hours ago\n      if (recency < 24) { // Only count recent threats\n        score += (threat.severityAccumulated / threat.eventCount) * \n                 (threat.killChainProgression / 6) * \n                 Math.exp(-recency / 24);\n      }\n    });\n    return Math.min(score / 100, 1); // Normalize\n  }\n  \n  private isBusinessHours(timestamp: number): boolean {\n    const date = new Date(timestamp);\n    const hour = date.getHours();\n    const day = date.getDay();\n    \n    // Business hours: Monday-Friday, 9am-5pm\n    return day >= 1 && day <= 5 && hour >= 9 && hour < 17;\n  }\n  \n  private isGeographicallyAnomalous(event: SecurityEvent): boolean {\n    // Simplified - would need user baseline in real implementation\n    return false;\n  }\n  \n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'security',\n      quadrantProfile: { aggressive: 0.1, defensive: 0.7, tactical: 0.1, strategic: 0.1 },\n      temporalFlow: { early: 0.5, mid: 0.3, late: 0.2 },\n      intensity: 0.1,\n      momentum: 0,\n      volatility: 0.2,\n      dominantFrequency: 0.1,\n      harmonicResonance: 0.8,\n      phaseAlignment: 0.1,\n      extractedAt: Date.now()\n    };\n  }\n  \n  // Detect attack archetype from event pattern\n  detectArchetype(events: SecurityEvent[]): keyof typeof ATTACK_ARCHETYPES | 'unknown' {\n    if (events.length < 3) return 'unknown';\n    \n    const patterns = {\n      phishing: events.filter(e => \n        e.eventType.toLowerCase().includes('email') || \n        e.eventType.toLowerCase().includes('credential')\n      ).length,\n      malware: events.filter(e => \n        e.eventType.toLowerCase().includes('malware') ||\n        e.eventType.toLowerCase().includes('execution')\n      ).length,\n      apt: events.filter(e => \n        (e.killChainPhase || 0) > 4 && events.length > 10\n      ).length\n    };\n    \n    const maxPattern = Object.entries(patterns).sort((a, b) => b[1] - a[1])[0];\n    return maxPattern[1] > 2 ? maxPattern[0] as keyof typeof ATTACK_ARCHETYPES : 'unknown';\n  }\n  \n  // Generate security event from market conditions\n  generateMarketCorrelatedData(marketVolatility: number, sentiment: number): SecurityEvent {\n    // High volatility markets correlate with heightened cyber activity\n    const severity = marketVolatility * 10;\n    const killChainPhase = marketVolatility > 0.7 ? 5 : marketVolatility > 0.4 ? 3 : 1;\n    \n    return {\n      timestamp: Date.now(),\n      eventType: marketVolatility > 0.8 ? 'ransomware_detection' : 'anomalous_access',\n      severity,\n      killChainPhase,\n      behavioralBiometrics: {\n        keystrokeVariance: sentiment > 0 ? 0.3 : 0.7, // Negative sentiment = stress\n        mouseEntropy: marketVolatility,\n        navigationAnomaly: marketVolatility * 0.8\n      }\n    };\n  }\n}\n\nexport const cybersecurityAdapter = new CybersecurityAdapter();\nexport { ATTACK_ARCHETYPES, KILL_CHAIN_PHASES, BEHAVIORAL_BIOMETRICS, ANOMALY_SIGNATURES };\nexport type { SecurityEvent };\n";export{e as default};
