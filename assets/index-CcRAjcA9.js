const n="/**\n * Hybrid Prediction Engine\n * \n * En Pensentâ„¢ Patent-Pending Technology\n * \n * Fuses Stockfish 17's 30-move tactical depth with\n * Color Flow Analysis strategic trajectory prediction.\n * \n * Innovation:\n * - Stockfish: \"Best move is e4 because it wins material\"\n * - Color Flow: \"This game arc leads to kingside attack in ~15 moves\"\n * - Hybrid: \"Play e4 (tactics) as part of the kingside attack trajectory (strategy)\"\n * \n * This creates predictions neither engine could make alone.\n * \n * CRITICAL: Loads historical learned patterns from 802+ validated positions\n * to ensure predictions leverage ALL accumulated knowledge.\n */\n\nimport { Chess } from 'chess.js';\nimport { \n  extractColorFlowSignature, \n  predictFromColorFlow,\n  ARCHETYPE_DEFINITIONS\n} from '../colorFlowAnalysis';\nimport { simulateGame } from '../gameSimulator';\nimport { evaluatePosition, PositionEvaluation } from '../lichessCloudEval';\nimport { PositionAnalysis } from '../stockfishEngine';\nimport { loadLearnedPatterns } from '../patternLearning/persistentPatternLoader';\n\n// Re-export types\nexport * from './types';\n\n// Import modular functions\nimport { createTacticalInsight } from './tacticalInsight';\nimport { createStrategicInsight } from './strategicInsight';\nimport { fuseRecommendations } from './fusedRecommendation';\nimport { generateTrajectoryPrediction } from './trajectoryPrediction';\nimport { calculateHybridConfidence, calculateCombinedScore, updateAccuracyCache } from './confidenceCalculator';\nimport { fetchChessCumulativeStats } from '@/hooks/useRealtimeAccuracy';\nimport { HybridPrediction } from './types';\n\n// Track if patterns have been loaded this session\nlet patternsLoadedThisSession = false;\n\n/**\n * Convert Lichess Cloud evaluation to PositionAnalysis format\n */\nfunction cloudEvalToPositionAnalysis(\n  cloudEval: PositionEvaluation | null,\n  fen: string\n): PositionAnalysis {\n  const cp = cloudEval?.evaluation ?? 0;\n  const isMate = cloudEval?.isMate ?? false;\n  const mateIn = cloudEval?.mateIn;\n  \n  return {\n    fen,\n    bestMove: cloudEval?.bestMove ?? 'e2e4',\n    ponder: cloudEval?.pv?.[1] ?? undefined,\n    evaluation: {\n      score: cp,\n      scoreType: isMate ? 'mate' : 'cp',\n      mateIn: mateIn ?? undefined,\n      depth: cloudEval?.depth ?? 20,\n      nodes: 50000,\n      nps: 0,\n      time: 0,\n      pv: cloudEval?.pv ?? [],\n    },\n    winProbability: cloudEval?.winProbability ?? 50,\n    isCheckmate: false,\n    isStalemate: false,\n    isDraw: false,\n  };\n}\n\n/**\n * Generate a hybrid prediction combining Stockfish tactics with Color Flow strategy\n * \n * v6.97-LOCAL: Accepts optional pre-computed evaluation to avoid cloud API calls\n */\nexport async function generateHybridPrediction(\n  pgn: string,\n  options: {\n    depth?: number;\n    onProgress?: (stage: string, progress: number) => void;\n    precomputedEval?: number; // v6.97: Skip cloud API if provided\n    precomputedDepth?: number;\n    skipCloudEval?: boolean;  // v6.97: Force skip cloud API\n  } = {}\n): Promise<HybridPrediction> {\n  const depth = options.depth || 18;\n  \n  // v7.14-FAST-BENCHMARK: Skip pattern loading entirely if we have precomputed eval\n  // or if skipCloudEval is set (indicates local benchmark mode)\n  const isBenchmarkMode = options.precomputedEval !== undefined || options.skipCloudEval;\n  \n  // CRITICAL: Load learned patterns from database on first prediction\n  // But skip if in benchmark mode (patterns already pre-loaded or not needed)\n  if (!patternsLoadedThisSession && !isBenchmarkMode) {\n    options.onProgress?.('Loading historical patterns from database', 2);\n    try {\n      const { loaded, hybridWins, totalAccuracy } = await loadLearnedPatterns();\n      console.log(`[HybridEngine] Loaded ${loaded} historical patterns (${hybridWins} breakthrough cases, ${totalAccuracy.toFixed(1)}% accuracy)`);\n      patternsLoadedThisSession = true;\n    } catch (e) {\n      console.warn('[HybridEngine] Could not load historical patterns:', e);\n    }\n  }\n  \n  options.onProgress?.('Simulating game visualization', 5);\n  \n  // Step 1: Simulate the game to get board state\n  const simulation = simulateGame(pgn);\n  const { board, gameData, totalMoves } = simulation;\n  \n  options.onProgress?.('Extracting color flow signature', 15);\n  \n  // Step 2: Extract Color Flow Signature\n  const colorSignature = extractColorFlowSignature(board, gameData, totalMoves);\n  \n  options.onProgress?.('Analyzing current position', 30);\n  \n  // Step 3: Get current position for analysis\n  const chess = new Chess();\n  try {\n    chess.loadPgn(pgn);\n  } catch {\n    // Fallback to starting position\n  }\n  const currentFen = chess.fen();\n  \n  // Step 4: Get Stockfish evaluation\n  // v6.97-LOCAL: Use precomputed eval if provided, otherwise try cloud (with fallback)\n  let positionAnalysis: PositionAnalysis;\n  \n  if (options.precomputedEval !== undefined) {\n    // Use pre-computed local Stockfish eval (no API call needed)\n    positionAnalysis = {\n      fen: currentFen,\n      bestMove: 'e2e4',\n      evaluation: {\n        score: options.precomputedEval,\n        scoreType: 'cp',\n        depth: options.precomputedDepth || depth,\n        nodes: 0,\n        nps: 0,\n        time: 0,\n        pv: [],\n      },\n      winProbability: 50 + (options.precomputedEval / 20),\n      isCheckmate: false,\n      isStalemate: false,\n      isDraw: false,\n    };\n  } else if (options.skipCloudEval) {\n    // Skip cloud API entirely, use neutral eval\n    positionAnalysis = {\n      fen: currentFen,\n      bestMove: 'e2e4',\n      evaluation: { score: 0, scoreType: 'cp', depth: 10, nodes: 0, nps: 0, time: 0, pv: [] },\n      winProbability: 50,\n      isCheckmate: false,\n      isStalemate: false,\n      isDraw: false,\n    };\n  } else {\n    // Original behavior: call cloud API (may trigger rate limits)\n    const cloudEval = await evaluatePosition(currentFen);\n    positionAnalysis = cloudEvalToPositionAnalysis(cloudEval, currentFen);\n  }\n  \n  options.onProgress?.('Fusing tactical and strategic analysis', 60);\n  \n  // Step 5: Generate strategic prediction from color flow\n  const colorPrediction = predictFromColorFlow(colorSignature, totalMoves);\n  \n  // Step 6: Create tactical insight\n  const tacticalInsight = createTacticalInsight(positionAnalysis, chess);\n  \n  // Step 7: Create strategic insight\n  const strategicInsight = createStrategicInsight(colorSignature, colorPrediction);\n  \n  options.onProgress?.('Generating fused recommendation', 75);\n  \n  // Step 8: Fuse recommendations\n  const fusedRec = fuseRecommendations(\n    tacticalInsight,\n    strategicInsight,\n    colorSignature,\n    chess\n  );\n  \n  options.onProgress?.('Calculating trajectory prediction', 85);\n  \n  // Step 9: Generate trajectory prediction\n  const trajectory = generateTrajectoryPrediction(\n    colorSignature,\n    positionAnalysis,\n    totalMoves,\n    chess\n  );\n  \n  // Step 10: Update accuracy cache and calculate confidence\n  // v7.2: Skip DB call in benchmark mode - accuracy is pre-cached\n  if (!isBenchmarkMode) {\n    try {\n      const stats = await fetchChessCumulativeStats();\n      if (stats.totalGames > 0) {\n        const totalCorrect = Math.round((stats.hybridAccuracy / 100) * stats.totalGames);\n        updateAccuracyCache(stats.totalGames, totalCorrect);\n      }\n    } catch (err) {\n      console.warn('[HybridEngine] Could not fetch accuracy stats for confidence calibration');\n    }\n  }\n  \n  const confidence = calculateHybridConfidence(\n    positionAnalysis,\n    colorSignature,\n    tacticalInsight,\n    strategicInsight\n  );\n  \n  options.onProgress?.('Complete', 100);\n  \n  // Step 11: Calculate combined score\n  const combinedScore = calculateCombinedScore(positionAnalysis, colorSignature, confidence);\n  \n  return {\n    combinedScore,\n    tacticalAnalysis: tacticalInsight,\n    strategicAnalysis: strategicInsight,\n    fusedRecommendation: fusedRec,\n    trajectoryPrediction: trajectory,\n    confidence,\n  };\n}\n\n// Re-export for backward compatibility\nexport { extractColorFlowSignature, predictFromColorFlow, ARCHETYPE_DEFINITIONS };\nexport default generateHybridPrediction;\n";export{n as default};
