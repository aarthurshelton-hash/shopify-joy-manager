const n="/**\n * Multi-Broker Data Adapter\n * \n * Aggregates real-time market data from multiple sources:\n * - Alpaca (Stocks + Crypto, Trading)\n * - Polygon (Premium tick data)\n * - Binance (24/7 Crypto)\n * - Finnhub (Sentiment + News)\n * - Twelve Data (Technical Indicators)\n * - Tradier (Options)\n * \n * Cross-validates signals for maximum accuracy\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport type { DomainAdapter, DomainSignature, UniversalSignal, DomainType } from '../types';\n\nexport interface MarketTick {\n  symbol: string;\n  price: number;\n  bid?: number;\n  ask?: number;\n  volume?: number;\n  timestamp: number;\n  source: string;\n}\n\nexport interface AggregatedMarketData {\n  symbol: string;\n  ticks: MarketTick[];\n  consensus: {\n    price: number;\n    spread: number;\n    confidence: number;\n  };\n  sentiment?: {\n    score: number;\n    buzz: number;\n    source: string;\n  };\n  technicals?: {\n    rsi?: number;\n    macd?: number;\n    sma20?: number;\n    ema50?: number;\n  };\n  sources: string[];\n  timestamp: number;\n}\n\nclass MultiBrokerAdapter implements DomainAdapter<AggregatedMarketData> {\n  domain: DomainType = 'market';\n  name = 'Multi-Broker Aggregator';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private dataHistory: AggregatedMarketData[] = [];\n  private readonly MAX_HISTORY = 1000;\n  \n  async initialize(): Promise<void> {\n    console.log('[MultiBrokerAdapter] Initializing multi-source data feed...');\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n  }\n\n  /**\n   * Fetch aggregated data from all broker sources\n   */\n  async fetchAggregatedData(\n    symbol: string,\n    assetType: 'stock' | 'crypto' | 'forex' = 'stock'\n  ): Promise<AggregatedMarketData | null> {\n    try {\n      const { data, error } = await supabase.functions.invoke('multi-broker-data', {\n        body: { symbol, assetType, action: 'aggregate' },\n      });\n\n      if (error) {\n        console.error('[MultiBrokerAdapter] Edge function error:', error);\n        return null;\n      }\n\n      if (data?.success && data.data) {\n        const aggregated = data.data as AggregatedMarketData;\n        \n        // Store in history\n        this.dataHistory.push(aggregated);\n        if (this.dataHistory.length > this.MAX_HISTORY) {\n          this.dataHistory.shift();\n        }\n        \n        this.lastUpdate = Date.now();\n        return aggregated;\n      }\n\n      return null;\n    } catch (err) {\n      console.error('[MultiBrokerAdapter] Fetch error:', err);\n      return null;\n    }\n  }\n\n  /**\n   * Process raw aggregated data into universal signal\n   */\n  processRawData(data: AggregatedMarketData): UniversalSignal {\n    const prices = data.ticks.map(t => t.price);\n    const avgPrice = data.consensus.price;\n    const priceRange = prices.length > 0 ? Math.max(...prices) - Math.min(...prices) : 0;\n    \n    // Calculate momentum from recent history\n    const recentHistory = this.dataHistory.slice(-10);\n    const momentum = recentHistory.length > 1\n      ? (avgPrice - recentHistory[0].consensus.price) / recentHistory[0].consensus.price\n      : 0;\n    \n    // Frequency based on update rate\n    const frequency = 1000 / (Date.now() - this.lastUpdate + 1);\n    \n    // Phase based on sentiment if available\n    const phase = data.sentiment \n      ? (data.sentiment.score + 1) / 2 * Math.PI \n      : Math.PI / 2;\n    \n    // Harmonics from technical indicators\n    const harmonics: number[] = [];\n    if (data.technicals?.rsi) {\n      harmonics.push(data.technicals.rsi / 100);\n    }\n    \n    return {\n      domain: 'market',\n      timestamp: data.timestamp,\n      intensity: data.consensus.confidence,\n      frequency,\n      phase,\n      harmonics,\n      rawData: prices,\n    };\n  }\n\n  /**\n   * Extract domain signature from multiple signals\n   */\n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n\n    const latestSignal = signals[signals.length - 1];\n    const recentData = this.dataHistory.slice(-20);\n    \n    // Calculate momentum trend\n    const priceChanges = recentData.slice(1).map((d, i) => \n      (d.consensus.price - recentData[i].consensus.price) / recentData[i].consensus.price\n    );\n    const avgMomentum = priceChanges.length > 0\n      ? priceChanges.reduce((a, b) => a + b, 0) / priceChanges.length\n      : 0;\n    \n    // Calculate volatility\n    const volatility = priceChanges.length > 0\n      ? Math.sqrt(priceChanges.reduce((sum, c) => sum + c * c, 0) / priceChanges.length)\n      : 0;\n    \n    // Calculate confidence from source diversity\n    const avgSources = recentData.length > 0\n      ? recentData.reduce((sum, d) => sum + d.sources.length, 0) / recentData.length\n      : 1;\n    const sourceConfidence = Math.min(1, avgSources / 5);\n    \n    // Determine quadrant profile from market conditions\n    const isUptrend = avgMomentum > 0;\n    const isVolatile = volatility > 0.01;\n    \n    return {\n      domain: 'market',\n      quadrantProfile: {\n        aggressive: isUptrend && isVolatile ? 0.8 : 0.3,\n        defensive: !isUptrend && !isVolatile ? 0.7 : 0.2,\n        tactical: isVolatile ? 0.7 : 0.4,\n        strategic: !isVolatile ? 0.6 : 0.3,\n      },\n      temporalFlow: {\n        early: recentData.length < 5 ? 0.8 : 0.3,\n        mid: recentData.length >= 5 && recentData.length < 15 ? 0.7 : 0.4,\n        late: recentData.length >= 15 ? 0.7 : 0.3,\n      },\n      intensity: latestSignal.intensity,\n      momentum: avgMomentum * 10, // Scale to -1 to 1 range roughly\n      volatility,\n      dominantFrequency: latestSignal.frequency,\n      harmonicResonance: sourceConfidence,\n      phaseAlignment: latestSignal.phase / Math.PI,\n      extractedAt: Date.now(),\n    };\n  }\n\n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'market',\n      quadrantProfile: { aggressive: 0.25, defensive: 0.25, tactical: 0.25, strategic: 0.25 },\n      temporalFlow: { early: 0.33, mid: 0.34, late: 0.33 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0.01,\n      dominantFrequency: 1,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now(),\n    };\n  }\n\n  /**\n   * Get data history for analysis\n   */\n  getHistory(): AggregatedMarketData[] {\n    return [...this.dataHistory];\n  }\n\n  /**\n   * Get the most recent aggregated data\n   */\n  getLatest(): AggregatedMarketData | null {\n    return this.dataHistory[this.dataHistory.length - 1] || null;\n  }\n\n  /**\n   * Calculate cross-source validation score\n   */\n  calculateValidationScore(): number {\n    const latest = this.getLatest();\n    if (!latest) return 0;\n    \n    // Score based on:\n    // 1. Number of sources (more = better)\n    // 2. Price agreement (lower variance = better)\n    // 3. Recency (fresher = better)\n    \n    const sourceScore = Math.min(1, latest.sources.length / 5);\n    const agreementScore = latest.consensus.confidence;\n    const recencyScore = Math.max(0, 1 - (Date.now() - latest.timestamp) / 60000);\n    \n    return (sourceScore * 0.3 + agreementScore * 0.5 + recencyScore * 0.2);\n  }\n}\n\n// Singleton instance\nexport const multiBrokerAdapter = new MultiBrokerAdapter();\n";export{n as default};
