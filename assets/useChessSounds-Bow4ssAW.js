const n="import { useCallback, useRef, useEffect } from 'react';\n\ntype SoundType = 'move' | 'capture' | 'check' | 'checkmate' | 'castle' | 'gameStart' | 'gameEnd' | 'victory' | 'defeat' | 'draw' | 'illegal';\n\ninterface AudioContextRef {\n  context: AudioContext | null;\n  gainNode: GainNode | null;\n}\n\nexport const useChessSounds = (enabled: boolean = true, volume: number = 0.5) => {\n  const audioRef = useRef<AudioContextRef>({ context: null, gainNode: null });\n  \n  // Initialize audio context on first user interaction\n  const initAudio = useCallback(() => {\n    if (audioRef.current.context) return;\n    \n    try {\n      const context = new (window.AudioContext || (window as any).webkitAudioContext)();\n      const gainNode = context.createGain();\n      gainNode.connect(context.destination);\n      gainNode.gain.value = volume;\n      \n      audioRef.current = { context, gainNode };\n    } catch (e) {\n      console.warn('Web Audio API not supported');\n    }\n  }, [volume]);\n\n  // Update volume\n  useEffect(() => {\n    if (audioRef.current.gainNode) {\n      audioRef.current.gainNode.gain.value = volume;\n    }\n  }, [volume]);\n\n  // Create a tone with specific parameters\n  const playTone = useCallback((\n    frequency: number,\n    duration: number,\n    type: OscillatorType = 'sine',\n    attack: number = 0.01,\n    decay: number = 0.1,\n    endFrequency?: number\n  ) => {\n    if (!enabled) return;\n    initAudio();\n    \n    const { context, gainNode } = audioRef.current;\n    if (!context || !gainNode) return;\n\n    const oscillator = context.createOscillator();\n    const envelope = context.createGain();\n    \n    oscillator.type = type;\n    oscillator.frequency.setValueAtTime(frequency, context.currentTime);\n    \n    if (endFrequency) {\n      oscillator.frequency.exponentialRampToValueAtTime(endFrequency, context.currentTime + duration);\n    }\n    \n    envelope.gain.setValueAtTime(0, context.currentTime);\n    envelope.gain.linearRampToValueAtTime(1, context.currentTime + attack);\n    envelope.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration - decay);\n    envelope.gain.linearRampToValueAtTime(0, context.currentTime + duration);\n    \n    oscillator.connect(envelope);\n    envelope.connect(gainNode);\n    \n    oscillator.start(context.currentTime);\n    oscillator.stop(context.currentTime + duration);\n  }, [enabled, initAudio]);\n\n  // Play noise burst (for captures)\n  const playNoise = useCallback((duration: number, filterFreq: number = 1000) => {\n    if (!enabled) return;\n    initAudio();\n    \n    const { context, gainNode } = audioRef.current;\n    if (!context || !gainNode) return;\n\n    const bufferSize = context.sampleRate * duration;\n    const buffer = context.createBuffer(1, bufferSize, context.sampleRate);\n    const data = buffer.getChannelData(0);\n    \n    for (let i = 0; i < bufferSize; i++) {\n      data[i] = Math.random() * 2 - 1;\n    }\n    \n    const noise = context.createBufferSource();\n    noise.buffer = buffer;\n    \n    const filter = context.createBiquadFilter();\n    filter.type = 'lowpass';\n    filter.frequency.value = filterFreq;\n    \n    const envelope = context.createGain();\n    envelope.gain.setValueAtTime(0.3, context.currentTime);\n    envelope.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration);\n    \n    noise.connect(filter);\n    filter.connect(envelope);\n    envelope.connect(gainNode);\n    \n    noise.start(context.currentTime);\n    noise.stop(context.currentTime + duration);\n  }, [enabled, initAudio]);\n\n  // Sound effect definitions\n  const playSound = useCallback((type: SoundType) => {\n    if (!enabled) return;\n    \n    switch (type) {\n      case 'move':\n        // Soft wooden tap\n        playTone(800, 0.08, 'sine', 0.005, 0.05);\n        playTone(400, 0.06, 'triangle', 0.005, 0.04);\n        break;\n        \n      case 'capture':\n        // Impact sound with noise\n        playNoise(0.12, 2000);\n        playTone(300, 0.1, 'square', 0.005, 0.08);\n        playTone(150, 0.15, 'sine', 0.01, 0.1);\n        break;\n        \n      case 'castle':\n        // Double tap (two pieces moving)\n        playTone(600, 0.06, 'sine', 0.005, 0.04);\n        setTimeout(() => playTone(700, 0.06, 'sine', 0.005, 0.04), 80);\n        break;\n        \n      case 'check':\n        // Alert tone\n        playTone(880, 0.15, 'triangle', 0.01, 0.1);\n        setTimeout(() => playTone(1100, 0.12, 'triangle', 0.01, 0.08), 120);\n        break;\n        \n      case 'checkmate':\n        // Dramatic descending tones\n        playTone(880, 0.2, 'sine', 0.01, 0.15);\n        setTimeout(() => playTone(660, 0.2, 'sine', 0.01, 0.15), 150);\n        setTimeout(() => playTone(440, 0.3, 'sine', 0.01, 0.2), 300);\n        setTimeout(() => playTone(330, 0.4, 'sine', 0.01, 0.3), 500);\n        break;\n        \n      case 'gameStart':\n        // Ascending fanfare\n        playTone(523, 0.12, 'sine', 0.01, 0.08); // C5\n        setTimeout(() => playTone(659, 0.12, 'sine', 0.01, 0.08), 100); // E5\n        setTimeout(() => playTone(784, 0.2, 'sine', 0.01, 0.15), 200); // G5\n        break;\n        \n      case 'gameEnd':\n        // Neutral end sound\n        playTone(440, 0.15, 'triangle', 0.01, 0.1);\n        setTimeout(() => playTone(349, 0.25, 'triangle', 0.01, 0.2), 150);\n        break;\n        \n      case 'victory':\n        // Triumphant ascending melody\n        playTone(523, 0.1, 'sine', 0.01, 0.08); // C5\n        setTimeout(() => playTone(659, 0.1, 'sine', 0.01, 0.08), 100); // E5\n        setTimeout(() => playTone(784, 0.1, 'sine', 0.01, 0.08), 200); // G5\n        setTimeout(() => playTone(1047, 0.3, 'sine', 0.01, 0.25), 300); // C6\n        break;\n        \n      case 'defeat':\n        // Sad descending tones\n        playTone(392, 0.2, 'sine', 0.02, 0.15); // G4\n        setTimeout(() => playTone(349, 0.2, 'sine', 0.02, 0.15), 200); // F4\n        setTimeout(() => playTone(330, 0.3, 'sine', 0.02, 0.25), 400); // E4\n        setTimeout(() => playTone(262, 0.4, 'sine', 0.02, 0.35), 650); // C4\n        break;\n        \n      case 'draw':\n        // Neutral resolution\n        playTone(440, 0.15, 'sine', 0.01, 0.1); // A4\n        setTimeout(() => playTone(440, 0.15, 'sine', 0.01, 0.1), 180); // A4\n        setTimeout(() => playTone(523, 0.2, 'sine', 0.01, 0.15), 360); // C5\n        break;\n        \n      case 'illegal':\n        // Error buzz\n        playTone(200, 0.1, 'square', 0.005, 0.08);\n        playTone(150, 0.08, 'sawtooth', 0.005, 0.06);\n        break;\n    }\n  }, [enabled, playTone, playNoise]);\n\n  // Cleanup\n  useEffect(() => {\n    return () => {\n      if (audioRef.current.context) {\n        audioRef.current.context.close();\n      }\n    };\n  }, []);\n\n  return { playSound, initAudio };\n};\n\n// Singleton for global sound access\nlet globalSoundInstance: ReturnType<typeof useChessSounds> | null = null;\n\nexport const getChessSounds = () => globalSoundInstance;\n\nexport const ChessSoundsProvider = ({ children, enabled = true, volume = 0.5 }: { \n  children: React.ReactNode; \n  enabled?: boolean; \n  volume?: number;\n}) => {\n  const sounds = useChessSounds(enabled, volume);\n  globalSoundInstance = sounds;\n  return children;\n};\n";export{n as default};
