const n="/**\n * Dynamic Allocation Engine\n * \n * Self-adjusting portfolio allocation based on:\n * - Market regime detection\n * - Strategy performance tracking\n * - Risk metrics (volatility, drawdown, correlation)\n * - Kelly criterion for position sizing\n */\n\nimport { ASSET_CLASSES, RISK_CONFIG, STRATEGY_REGISTRY, EVOLUTION_CONFIG } from './multiAssetConfig';\nimport { UnifiedDataPipeline } from './unifiedDataPipeline';\n\ninterface Allocation {\n  assetClass: string;\n  symbol: string;\n  targetWeight: number;\n  currentWeight: number;\n  strategy: string;\n  expectedReturn: number;\n  volatility: number;\n  sharpe: number;\n}\n\ninterface StrategyPerformance {\n  strategy: string;\n  totalReturn: number;\n  volatility: number;\n  sharpeRatio: number;\n  maxDrawdown: number;\n  winRate: number;\n  profitFactor: number;\n  trades: number;\n  lastUpdated: string;\n}\n\nexport class DynamicAllocationEngine {\n  private allocations: Allocation[] = [];\n  private strategyPerformance: Map<string, StrategyPerformance> = new Map();\n  private currentRegime: string = 'neutral';\n  private lastRebalance: Date = new Date();\n  \n  constructor(\n    private pipeline: UnifiedDataPipeline,\n    private supabase: any,\n    private accountBalance: number\n  ) {}\n  \n  async initialize() {\n    console.log('[AllocationEngine] Initializing...');\n    \n    // Load historical performance\n    await this.loadStrategyPerformance();\n    \n    // Set initial allocations\n    this.setBaseAllocations();\n    \n    // Start rebalancing loop\n    this.startRebalancingLoop();\n    \n    console.log('[AllocationEngine] Initialized');\n  }\n  \n  private setBaseAllocations() {\n    // Start with base weights from config\n    this.allocations = [];\n    \n    // Equities\n    ASSET_CLASSES.EQUITIES.symbols.US.forEach(symbol => {\n      this.allocations.push({\n        assetClass: 'EQUITIES_US',\n        symbol,\n        targetWeight: ASSET_CLASSES.EQUITIES.allocation / \n          (ASSET_CLASSES.EQUITIES.symbols.US.length + ASSET_CLASSES.EQUITIES.symbols.INTL.length + ASSET_CLASSES.EQUITIES.symbols.SECTORS.length),\n        currentWeight: 0,\n        strategy: 'MOMENTUM',\n        expectedReturn: 0.10,\n        volatility: 0.20,\n        sharpe: 0.5,\n      });\n    });\n    \n    // Bonds\n    ASSET_CLASSES.BONDS.symbols.forEach(symbol => {\n      this.allocations.push({\n        assetClass: 'BONDS',\n        symbol,\n        targetWeight: ASSET_CLASSES.BONDS.allocation / ASSET_CLASSES.BONDS.symbols.length,\n        currentWeight: 0,\n        strategy: 'CARRY_TRADE',\n        expectedReturn: 0.04,\n        volatility: 0.08,\n        sharpe: 0.5,\n      });\n    });\n    \n    // Forex\n    ASSET_CLASSES.FOREX.pairs.forEach(symbol => {\n      this.allocations.push({\n        assetClass: 'FOREX',\n        symbol,\n        targetWeight: ASSET_CLASSES.FOREX.allocation / ASSET_CLASSES.FOREX.pairs.length,\n        currentWeight: 0,\n        strategy: 'CARRY_TRADE',\n        expectedReturn: 0.03,\n        volatility: 0.10,\n        sharpe: 0.3,\n      });\n    });\n    \n    // Commodities\n    ASSET_CLASSES.COMMODITIES.symbols.forEach(symbol => {\n      this.allocations.push({\n        assetClass: 'COMMODITIES',\n        symbol,\n        targetWeight: ASSET_CLASSES.COMMODITIES.allocation / ASSET_CLASSES.COMMODITIES.symbols.length,\n        currentWeight: 0,\n        strategy: 'MEAN_REVERSION',\n        expectedReturn: 0.06,\n        volatility: 0.25,\n        sharpe: 0.24,\n      });\n    });\n  }\n  \n  private startRebalancingLoop() {\n    setInterval(async () => {\n      await this.rebalance();\n    }, EVOLUTION_CONFIG.REBALANCE_FREQUENCY_HOURS * 60 * 60 * 1000);\n  }\n  \n  async rebalance() {\n    console.log('[AllocationEngine] Starting rebalancing...');\n    \n    const macro = this.pipeline.getMacroRegime();\n    if (!macro) {\n      console.warn('[AllocationEngine] No macro data, skipping rebalance');\n      return;\n    }\n    \n    this.currentRegime = macro.marketRegime;\n    \n    // Step 1: Adjust allocations based on regime\n    await this.adjustForRegime(macro);\n    \n    // Step 2: Adjust for strategy performance\n    await this.adjustForStrategyPerformance();\n    \n    // Step 3: Apply risk constraints\n    this.applyRiskConstraints();\n    \n    // Step 4: Normalize to 100%\n    this.normalizeWeights();\n    \n    // Step 5: Save to database\n    await this.saveAllocations();\n    \n    this.lastRebalance = new Date();\n    console.log('[AllocationEngine] Rebalancing complete');\n  }\n  \n  private async adjustForRegime(macro: any) {\n    // Risk-on: Increase equities, decrease bonds\n    // Risk-off: Increase bonds, decrease equities\n    // Crisis: Cash/short positions\n    \n    switch (macro.marketRegime) {\n      case 'risk_on':\n        this.shiftWeight('EQUITIES_US', 0.10);\n        this.shiftWeight('BONDS', -0.05);\n        this.shiftWeight('COMMODITIES', 0.05);\n        break;\n        \n      case 'risk_off':\n        this.shiftWeight('EQUITIES_US', -0.10);\n        this.shiftWeight('BONDS', 0.10);\n        this.shiftWeight('FOREX', 0.05);\n        break;\n        \n      case 'crisis':\n        // Move to defensive: TLT, GLD, USD\n        this.allocations.forEach(a => {\n          if (a.assetClass === 'EQUITIES_US') a.targetWeight *= 0.3;\n          if (a.symbol === 'TLT') a.targetWeight *= 2;\n          if (a.symbol === 'GC' || a.symbol === 'GLD') a.targetWeight *= 1.5;\n        });\n        break;\n    }\n    \n    // Yield curve adjustments\n    if (macro.yieldCurve.slope < 0) {\n      // Inverted curve - defensive positioning\n      this.shiftWeight('BONDS', 0.05);\n      this.shiftWeight('EQUITIES_US', -0.05);\n    }\n  }\n  \n  private async adjustForStrategyPerformance() {\n    // Calculate weight adjustments based on strategy Sharpe ratios\n    const totalWeight = this.allocations.reduce((sum, a) => sum + a.targetWeight, 0);\n    \n    for (const allocation of this.allocations) {\n      const perf = this.strategyPerformance.get(allocation.strategy);\n      \n      if (perf && perf.trades >= EVOLUTION_CONFIG.MIN_TRADES_FOR_EVALUATION) {\n        if (perf.sharpeRatio < 1.0) {\n          // Underperforming - reduce allocation\n          allocation.targetWeight *= (1 - EVOLUTION_CONFIG.ADAPTATION_RATE);\n          allocation.strategy = this.findBetterStrategy(allocation.assetClass);\n        } else if (perf.sharpeRatio > 1.5) {\n          // Outperforming - increase allocation\n          allocation.targetWeight *= (1 + EVOLUTION_CONFIG.ADAPTATION_RATE);\n        }\n      }\n    }\n  }\n  \n  private applyRiskConstraints() {\n    // Max sector exposure\n    const sectorWeights = new Map<string, number>();\n    \n    for (const allocation of this.allocations) {\n      const current = sectorWeights.get(allocation.assetClass) || 0;\n      sectorWeights.set(allocation.assetClass, current + allocation.targetWeight);\n    }\n    \n    // Cap sector exposure\n    for (const allocation of this.allocations) {\n      const sectorWeight = sectorWeights.get(allocation.assetClass) || 0;\n      if (sectorWeight > RISK_CONFIG.MAX_SECTOR_EXPOSURE) {\n        const scale = RISK_CONFIG.MAX_SECTOR_EXPOSURE / sectorWeight;\n        allocation.targetWeight *= scale;\n      }\n    }\n    \n    // Correlation constraint - reduce correlated positions\n    this.reduceCorrelatedExposure();\n  }\n  \n  private reduceCorrelatedExposure() {\n    // Find highly correlated pairs and reduce combined exposure\n    const threshold = 0.8;\n    \n    for (let i = 0; i < this.allocations.length; i++) {\n      for (let j = i + 1; j < this.allocations.length; j++) {\n        const corr = this.pipeline.getCorrelation(\n          this.allocations[i].symbol,\n          this.allocations[j].symbol\n        );\n        \n        if (Math.abs(corr) > threshold) {\n          const combined = this.allocations[i].targetWeight + this.allocations[j].targetWeight;\n          \n          if (combined > RISK_CONFIG.MAX_CORRELATED_EXPOSURE) {\n            const scale = RISK_CONFIG.MAX_CORRELATED_EXPOSURE / combined;\n            this.allocations[i].targetWeight *= scale;\n            this.allocations[j].targetWeight *= scale;\n          }\n        }\n      }\n    }\n  }\n  \n  private normalizeWeights() {\n    const total = this.allocations.reduce((sum, a) => sum + a.targetWeight, 0);\n    \n    if (total > 0) {\n      this.allocations.forEach(a => {\n        a.targetWeight = a.targetWeight / total;\n      });\n    }\n  }\n  \n  private shiftWeight(assetClass: string, delta: number) {\n    const allocations = this.allocations.filter(a => a.assetClass === assetClass);\n    if (allocations.length === 0) return;\n    \n    const perAllocation = delta / allocations.length;\n    allocations.forEach(a => a.targetWeight += perAllocation);\n  }\n  \n  private findBetterStrategy(assetClass: string): string {\n    // Find best performing strategy for this asset class\n    let bestStrategy = 'MOMENTUM';\n    let bestSharpe = -Infinity;\n    \n    for (const [name, perf] of this.strategyPerformance) {\n      if (perf.sharpeRatio > bestSharpe && perf.trades > 20) {\n        bestSharpe = perf.sharpeRatio;\n        bestStrategy = name;\n      }\n    }\n    \n    return bestSharpe > 1.0 ? bestStrategy : 'MOMENTUM';\n  }\n  \n  calculatePositionSize(symbol: string, signalConfidence: number, stopLossPercent: number): number {\n    const allocation = this.allocations.find(a => a.symbol === symbol);\n    if (!allocation) return 0;\n    \n    // Kelly criterion sizing\n    const winRate = this.strategyPerformance.get(allocation.strategy)?.winRate || 0.5;\n    const avgWin = 1.5; // Take profit %\n    const avgLoss = stopLossPercent;\n    \n    // Kelly fraction: (p*b - q) / b where p=win rate, b=avg win/avg loss, q=loss rate\n    const b = avgWin / avgLoss;\n    const q = 1 - winRate;\n    const kelly = (winRate * b - q) / b;\n    \n    // Apply Kelly fraction and confidence\n    const positionPercent = allocation.targetWeight * Math.max(0, kelly) * RISK_CONFIG.KELLY_FRACTION * signalConfidence;\n    \n    // Convert to dollar amount\n    return this.accountBalance * positionPercent;\n  }\n  \n  async updateStrategyPerformance(strategy: string, tradeResult: { pnl: number; winning: boolean }) {\n    let perf = this.strategyPerformance.get(strategy);\n    \n    if (!perf) {\n      perf = {\n        strategy,\n        totalReturn: 0,\n        volatility: 0,\n        sharpeRatio: 0,\n        maxDrawdown: 0,\n        winRate: 0.5,\n        profitFactor: 1,\n        trades: 0,\n        lastUpdated: new Date().toISOString(),\n      };\n    }\n    \n    perf.trades++;\n    perf.totalReturn += tradeResult.pnl;\n    perf.winRate = ((perf.winRate * (perf.trades - 1)) + (tradeResult.winning ? 1 : 0)) / perf.trades;\n    perf.lastUpdated = new Date().toISOString();\n    \n    // Recalculate Sharpe (simplified)\n    const returns = [tradeResult.pnl / this.accountBalance];\n    const avg = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - avg, 2), 0) / returns.length;\n    const vol = Math.sqrt(variance) * Math.sqrt(252); // Annualize\n    perf.volatility = vol;\n    perf.sharpeRatio = vol > 0 ? avg / vol : 0;\n    \n    this.strategyPerformance.set(strategy, perf);\n    \n    // Persist to database\n    await this.supabase.from('strategy_performance').upsert({\n      strategy,\n      ...perf,\n      updated_at: new Date().toISOString(),\n    });\n  }\n  \n  private async loadStrategyPerformance() {\n    try {\n      const { data } = await this.supabase\n        .from('strategy_performance')\n        .select('*')\n        .order('updated_at', { ascending: false });\n      \n      if (data) {\n        data.forEach((row: any) => {\n          this.strategyPerformance.set(row.strategy, row);\n        });\n      }\n    } catch (err) {\n      console.warn('[AllocationEngine] Failed to load strategy performance:', err);\n    }\n  }\n  \n  private async saveAllocations() {\n    try {\n      await this.supabase.from('portfolio_allocations').upsert(\n        this.allocations.map(a => ({\n          symbol: a.symbol,\n          asset_class: a.assetClass,\n          target_weight: a.targetWeight,\n          current_weight: a.currentWeight,\n          strategy: a.strategy,\n          expected_return: a.expectedReturn,\n          volatility: a.volatility,\n          sharpe: a.sharpe,\n          regime: this.currentRegime,\n          updated_at: new Date().toISOString(),\n        }))\n      );\n    } catch (err) {\n      console.error('[AllocationEngine] Failed to save allocations:', err);\n    }\n  }\n  \n  getAllocations(): Allocation[] {\n    return this.allocations;\n  }\n  \n  getCurrentRegime(): string {\n    return this.currentRegime;\n  }\n  \n  getLastRebalance(): Date {\n    return this.lastRebalance;\n  }\n}\n";export{n as default};
