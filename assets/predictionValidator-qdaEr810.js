const n="/**\n * Prediction Validation System\n * Statistical comparison against baselines to prove edge\n */\n\nexport interface PredictionRecord {\n  id: string;\n  symbol: string;\n  predictedDirection: 'up' | 'down' | 'neutral';\n  predictedConfidence: number;\n  actualDirection: 'up' | 'down' | 'neutral' | null;\n  wasCorrect: boolean | null;\n  priceAtPrediction: number;\n  outcomePrice: number | null;\n  createdAt: Date;\n  resolvedAt: Date | null;\n}\n\nexport interface BaselineComparison {\n  baselineName: string;\n  baselineAccuracy: number;\n  systemAccuracy: number;\n  edge: number;\n  pValue: number;\n  isStatisticallySignificant: boolean;\n  sampleSize: number;\n  confidenceInterval: { low: number; high: number };\n}\n\nexport interface ValidationResult {\n  totalPredictions: number;\n  resolvedPredictions: number;\n  systemAccuracy: number;\n  baselineComparisons: BaselineComparison[];\n  overallEdge: number;\n  isProvenEdge: boolean;\n  confidenceLevel: number;\n  summary: string;\n}\n\n/**\n * Generate random baseline predictions (50/50)\n */\nexport function generateRandomBaseline(predictions: PredictionRecord[]): boolean[] {\n  return predictions.map(() => Math.random() > 0.5);\n}\n\n/**\n * Generate trend-following baseline predictions\n * Predicts continuation of recent price movement\n */\nexport function generateTrendBaseline(predictions: PredictionRecord[]): ('up' | 'down')[] {\n  // Simple trend follower: predict that recent direction continues\n  return predictions.map((pred, i) => {\n    if (i === 0) return 'up'; // Default for first\n    // In a real scenario, we'd look at recent price data\n    // For now, simulate with slight upward bias (markets tend to go up)\n    return Math.random() > 0.45 ? 'up' : 'down';\n  });\n}\n\n/**\n * Calculate binomial test p-value\n * Tests if observed success rate is significantly different from baseline\n */\nexport function calculatePValue(\n  successes: number,\n  trials: number,\n  baselineRate: number\n): number {\n  if (trials === 0) return 1;\n  \n  // Use normal approximation for large samples\n  const observedRate = successes / trials;\n  const variance = (baselineRate * (1 - baselineRate)) / trials;\n  const stdDev = Math.sqrt(variance);\n  \n  if (stdDev === 0) return observedRate === baselineRate ? 1 : 0;\n  \n  const zScore = (observedRate - baselineRate) / stdDev;\n  \n  // One-tailed test (we want to prove we're better, not just different)\n  // Using standard normal CDF approximation\n  const pValue = 1 - normalCDF(zScore);\n  \n  return pValue;\n}\n\n/**\n * Standard normal CDF approximation\n */\nfunction normalCDF(x: number): number {\n  const a1 =  0.254829592;\n  const a2 = -0.284496736;\n  const a3 =  1.421413741;\n  const a4 = -1.453152027;\n  const a5 =  1.061405429;\n  const p  =  0.3275911;\n\n  const sign = x < 0 ? -1 : 1;\n  x = Math.abs(x) / Math.sqrt(2);\n\n  const t = 1.0 / (1.0 + p * x);\n  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n  return 0.5 * (1.0 + sign * y);\n}\n\n/**\n * Calculate Wilson score confidence interval\n */\nexport function calculateConfidenceInterval(\n  successes: number,\n  trials: number,\n  confidenceLevel: number = 0.95\n): { low: number; high: number } {\n  if (trials === 0) return { low: 0, high: 1 };\n  \n  const z = confidenceLevel === 0.95 ? 1.96 : confidenceLevel === 0.99 ? 2.576 : 1.645;\n  const phat = successes / trials;\n  \n  const denominator = 1 + z * z / trials;\n  const center = phat + z * z / (2 * trials);\n  const margin = z * Math.sqrt((phat * (1 - phat) + z * z / (4 * trials)) / trials);\n  \n  return {\n    low: Math.max(0, (center - margin) / denominator),\n    high: Math.min(1, (center + margin) / denominator)\n  };\n}\n\n/**\n * Compare system predictions against random baseline\n */\nexport function compareToRandomBaseline(\n  predictions: PredictionRecord[]\n): BaselineComparison {\n  const resolved = predictions.filter(p => p.wasCorrect !== null);\n  const correct = resolved.filter(p => p.wasCorrect).length;\n  const total = resolved.length;\n  \n  const systemAccuracy = total > 0 ? correct / total : 0;\n  const baselineAccuracy = 0.5; // Random = 50%\n  \n  const pValue = calculatePValue(correct, total, baselineAccuracy);\n  const ci = calculateConfidenceInterval(correct, total);\n  \n  return {\n    baselineName: 'Random (50/50)',\n    baselineAccuracy,\n    systemAccuracy,\n    edge: systemAccuracy - baselineAccuracy,\n    pValue,\n    isStatisticallySignificant: pValue < 0.05,\n    sampleSize: total,\n    confidenceInterval: ci\n  };\n}\n\n/**\n * Compare system predictions against trend-following baseline\n */\nexport function compareToTrendBaseline(\n  predictions: PredictionRecord[]\n): BaselineComparison {\n  const resolved = predictions.filter(p => p.wasCorrect !== null);\n  const correct = resolved.filter(p => p.wasCorrect).length;\n  const total = resolved.length;\n  \n  const systemAccuracy = total > 0 ? correct / total : 0;\n  // Trend following historically has ~52-55% accuracy in various markets\n  const baselineAccuracy = 0.53;\n  \n  const pValue = calculatePValue(correct, total, baselineAccuracy);\n  const ci = calculateConfidenceInterval(correct, total);\n  \n  return {\n    baselineName: 'Trend Following',\n    baselineAccuracy,\n    systemAccuracy,\n    edge: systemAccuracy - baselineAccuracy,\n    pValue,\n    isStatisticallySignificant: pValue < 0.05,\n    sampleSize: total,\n    confidenceInterval: ci\n  };\n}\n\n/**\n * Full validation of predictions against all baselines\n */\nexport function validatePredictions(predictions: PredictionRecord[]): ValidationResult {\n  const resolved = predictions.filter(p => p.wasCorrect !== null);\n  const correct = resolved.filter(p => p.wasCorrect).length;\n  const systemAccuracy = resolved.length > 0 ? correct / resolved.length : 0;\n  \n  const randomComparison = compareToRandomBaseline(predictions);\n  const trendComparison = compareToTrendBaseline(predictions);\n  \n  const baselineComparisons = [randomComparison, trendComparison];\n  \n  // Overall edge is the minimum edge across all baselines\n  const overallEdge = Math.min(randomComparison.edge, trendComparison.edge);\n  \n  // System has proven edge if significant against ALL baselines\n  const isProvenEdge = baselineComparisons.every(b => b.isStatisticallySignificant && b.edge > 0);\n  \n  // Confidence level based on sample size and p-values\n  const avgPValue = baselineComparisons.reduce((sum, b) => sum + b.pValue, 0) / baselineComparisons.length;\n  const confidenceLevel = (1 - avgPValue) * 100;\n  \n  // Generate summary\n  let summary: string;\n  if (resolved.length < 30) {\n    summary = `Insufficient data for statistical significance (${resolved.length}/30 minimum predictions needed)`;\n  } else if (isProvenEdge) {\n    summary = `PROVEN EDGE: System shows ${(overallEdge * 100).toFixed(1)}% advantage over all baselines with statistical significance (p < 0.05)`;\n  } else if (overallEdge > 0) {\n    summary = `Positive edge detected (${(overallEdge * 100).toFixed(1)}%) but not yet statistically significant. More predictions needed.`;\n  } else {\n    summary = `No edge detected. System performing at or below baseline levels.`;\n  }\n  \n  return {\n    totalPredictions: predictions.length,\n    resolvedPredictions: resolved.length,\n    systemAccuracy,\n    baselineComparisons,\n    overallEdge,\n    isProvenEdge,\n    confidenceLevel,\n    summary\n  };\n}\n\n/**\n * Format validation result for display\n */\nexport function formatValidationSummary(result: ValidationResult): string {\n  const lines: string[] = [\n    `üìä Prediction Validation Report`,\n    `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`,\n    ``,\n    `Total Predictions: ${result.totalPredictions}`,\n    `Resolved: ${result.resolvedPredictions}`,\n    `System Accuracy: ${(result.systemAccuracy * 100).toFixed(1)}%`,\n    ``,\n    `Baseline Comparisons:`,\n  ];\n  \n  for (const comparison of result.baselineComparisons) {\n    const sig = comparison.isStatisticallySignificant ? '‚úì' : '‚óã';\n    const edgeStr = comparison.edge >= 0 ? `+${(comparison.edge * 100).toFixed(1)}%` : `${(comparison.edge * 100).toFixed(1)}%`;\n    lines.push(`  ${sig} vs ${comparison.baselineName}: ${edgeStr} (p=${comparison.pValue.toFixed(4)})`);\n  }\n  \n  lines.push(``);\n  lines.push(`${result.isProvenEdge ? 'üéØ' : '‚è≥'} ${result.summary}`);\n  \n  return lines.join('\\n');\n}\n";export{n as default};
