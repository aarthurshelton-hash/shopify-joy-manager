const n="/**\n * Human vs Algorithm Detector\n * \n * Cross-references chess behavioral patterns with market trading patterns\n * to identify whether trades are likely human-originated or algorithmic.\n * \n * KEY INSIGHT: The same psychological signatures that cause chess blunders\n * also appear in human trading behavior. Algorithms don't have these tells.\n */\n\nimport { PlayerFingerprint } from '../chess/playerFingerprint';\nimport { BlunderAnalysis, classifyTradeOrigin } from '../chess/blunderClassifier';\n\nexport interface MarketParticipantProfile {\n  participantId: string;\n  classification: 'human' | 'algorithmic' | 'hybrid' | 'unknown';\n  confidence: number;\n  \n  // Behavioral indicators\n  behaviorProfile: {\n    executionConsistency: number;      // Algos are consistent\n    emotionalDeviation: number;        // Humans deviate under pressure\n    timingPrecision: number;           // Algos hit precise levels\n    newsReactionSpeed: number;         // Algos react instantly\n    patternBreaking: number;           // Humans break their own patterns\n    tiltIndicators: number;            // Revenge trading, overtrading\n  };\n  \n  // If matched to chess fingerprint\n  chessFingerprint?: PlayerFingerprint;\n  fingerprintMatch?: {\n    similarity: number;\n    matchingTraits: string[];\n  };\n  \n  // Strategic implications\n  strategicInsights: {\n    exploitablePatterns: string[];\n    predictability: number;\n    optimalCounterStrategy: string;\n  };\n}\n\nexport interface TradeObservation {\n  timestamp: number;\n  symbol: string;\n  direction: 'buy' | 'sell';\n  size: number;\n  executionTimeMs: number;\n  priceDeviation: number;          // From VWAP or mid\n  sequenceNumber: number;          // Trade sequence in session\n  timeSinceLastTrade: number;\n  previousPnL?: number;            // If known\n  marketContext: {\n    volatility: number;\n    trend: 'up' | 'down' | 'sideways';\n    newsRecency: number;           // Ms since last news\n  };\n}\n\n/**\n * Analyze a series of trades to classify the participant\n */\nexport function classifyMarketParticipant(\n  trades: TradeObservation[],\n  knownFingerprints?: PlayerFingerprint[]\n): MarketParticipantProfile {\n  if (trades.length < 5) {\n    return createUnknownProfile('Insufficient data');\n  }\n  \n  // Calculate behavior metrics\n  const behaviorProfile = analyzeTradingBehavior(trades);\n  \n  // Determine classification\n  const { classification, confidence } = determineClassification(behaviorProfile);\n  \n  // Look for chess fingerprint matches if human\n  let fingerprintMatch: MarketParticipantProfile['fingerprintMatch'];\n  let chessFingerprint: PlayerFingerprint | undefined;\n  \n  if (classification === 'human' && knownFingerprints && knownFingerprints.length > 0) {\n    const match = findMatchingFingerprint(behaviorProfile, knownFingerprints);\n    if (match) {\n      fingerprintMatch = match.match;\n      chessFingerprint = match.fingerprint;\n    }\n  }\n  \n  // Generate strategic insights\n  const strategicInsights = generateStrategicInsights(\n    classification,\n    behaviorProfile,\n    chessFingerprint\n  );\n  \n  return {\n    participantId: `MP-${Date.now().toString(36)}`,\n    classification,\n    confidence,\n    behaviorProfile,\n    chessFingerprint,\n    fingerprintMatch,\n    strategicInsights\n  };\n}\n\nfunction analyzeTradingBehavior(trades: TradeObservation[]): MarketParticipantProfile['behaviorProfile'] {\n  // Execution consistency (std dev of execution times)\n  const execTimes = trades.map(t => t.executionTimeMs);\n  const avgExecTime = execTimes.reduce((a, b) => a + b, 0) / execTimes.length;\n  const execStdDev = Math.sqrt(\n    execTimes.reduce((sum, t) => sum + Math.pow(t - avgExecTime, 2), 0) / execTimes.length\n  );\n  const executionConsistency = 1 / (1 + execStdDev / 100);\n  \n  // Size consistency\n  const sizes = trades.map(t => t.size);\n  const avgSize = sizes.reduce((a, b) => a + b, 0) / sizes.length;\n  const sizeStdDev = Math.sqrt(\n    sizes.reduce((sum, s) => sum + Math.pow(s - avgSize, 2), 0) / sizes.length\n  );\n  const sizeConsistency = 1 / (1 + sizeStdDev / avgSize);\n  \n  // Emotional deviation (erratic sizing/timing after losses)\n  let emotionalDeviation = 0;\n  trades.forEach((trade, i) => {\n    if (i > 0 && trade.previousPnL !== undefined && trade.previousPnL < 0) {\n      const prevTrade = trades[i - 1];\n      const sizeChange = Math.abs(trade.size - prevTrade.size) / avgSize;\n      const timeChange = Math.abs(trade.timeSinceLastTrade - \n        (trades.slice(0, i).reduce((sum, t) => sum + t.timeSinceLastTrade, 0) / i));\n      emotionalDeviation += sizeChange + timeChange / 10000;\n    }\n  });\n  emotionalDeviation = Math.min(1, emotionalDeviation / trades.length);\n  \n  // Timing precision (how close to round numbers/levels)\n  const timingPrecision = trades.reduce((sum, t) => {\n    const deviation = t.priceDeviation;\n    return sum + (Math.abs(deviation) < 0.001 ? 1 : 0);\n  }, 0) / trades.length;\n  \n  // News reaction speed\n  const newsReactions = trades.filter(t => t.marketContext.newsRecency < 1000);\n  const newsReactionSpeed = newsReactions.length > 0 ?\n    newsReactions.reduce((sum, t) => sum + t.executionTimeMs, 0) / newsReactions.length : 1000;\n  const normalizedNewsReaction = 1 / (1 + newsReactionSpeed / 100);\n  \n  // Pattern breaking (deviation from own established patterns)\n  let patternBreaking = 0;\n  const recentTrend = trades.slice(-10);\n  const earlyTrend = trades.slice(0, 10);\n  if (recentTrend.length >= 5 && earlyTrend.length >= 5) {\n    const recentAvgSize = recentTrend.reduce((sum, t) => sum + t.size, 0) / recentTrend.length;\n    const earlyAvgSize = earlyTrend.reduce((sum, t) => sum + t.size, 0) / earlyTrend.length;\n    patternBreaking = Math.abs(recentAvgSize - earlyAvgSize) / Math.max(recentAvgSize, earlyAvgSize);\n  }\n  \n  // Tilt indicators\n  let tiltIndicators = 0;\n  let consecutiveLosses = 0;\n  trades.forEach(trade => {\n    if (trade.previousPnL !== undefined && trade.previousPnL < 0) {\n      consecutiveLosses++;\n      if (consecutiveLosses >= 3) {\n        tiltIndicators += 0.1;\n      }\n    } else {\n      consecutiveLosses = 0;\n    }\n  });\n  tiltIndicators = Math.min(1, tiltIndicators + emotionalDeviation * 0.5);\n  \n  return {\n    executionConsistency,\n    emotionalDeviation,\n    timingPrecision,\n    newsReactionSpeed: normalizedNewsReaction,\n    patternBreaking,\n    tiltIndicators\n  };\n}\n\nfunction determineClassification(\n  behavior: MarketParticipantProfile['behaviorProfile']\n): { classification: MarketParticipantProfile['classification']; confidence: number } {\n  \n  // Score for algorithmic\n  const algoScore = \n    behavior.executionConsistency * 0.25 +\n    (1 - behavior.emotionalDeviation) * 0.25 +\n    behavior.timingPrecision * 0.2 +\n    behavior.newsReactionSpeed * 0.15 +\n    (1 - behavior.patternBreaking) * 0.1 +\n    (1 - behavior.tiltIndicators) * 0.05;\n  \n  // Score for human\n  const humanScore =\n    (1 - behavior.executionConsistency) * 0.15 +\n    behavior.emotionalDeviation * 0.25 +\n    (1 - behavior.timingPrecision) * 0.15 +\n    (1 - behavior.newsReactionSpeed) * 0.15 +\n    behavior.patternBreaking * 0.15 +\n    behavior.tiltIndicators * 0.15;\n  \n  if (algoScore > humanScore * 1.5) {\n    return { classification: 'algorithmic', confidence: Math.min(0.95, algoScore) };\n  } else if (humanScore > algoScore * 1.5) {\n    return { classification: 'human', confidence: Math.min(0.95, humanScore) };\n  } else if (algoScore > 0.6 && humanScore > 0.4) {\n    return { classification: 'hybrid', confidence: 0.7 };\n  }\n  \n  return { classification: 'unknown', confidence: 0.5 };\n}\n\nfunction findMatchingFingerprint(\n  behavior: MarketParticipantProfile['behaviorProfile'],\n  fingerprints: PlayerFingerprint[]\n): { fingerprint: PlayerFingerprint; match: { similarity: number; matchingTraits: string[] } } | null {\n  \n  let bestMatch: { fingerprint: PlayerFingerprint; match: { similarity: number; matchingTraits: string[] } } | null = null;\n  let bestSimilarity = 0;\n  \n  for (const fp of fingerprints) {\n    const matchingTraits: string[] = [];\n    let similarity = 0;\n    \n    // Map trading behavior to chess fingerprint traits\n    \n    // Tilt resistance vs emotional deviation\n    const tiltMatch = Math.abs(fp.pressureProfile.tiltResistance - (1 - behavior.tiltIndicators));\n    if (tiltMatch < 0.2) {\n      matchingTraits.push('tilt_pattern_match');\n      similarity += 0.3;\n    }\n    \n    // Risk tolerance vs pattern breaking\n    const riskMatch = Math.abs(fp.styleProfile.riskTolerance - behavior.patternBreaking);\n    if (riskMatch < 0.2) {\n      matchingTraits.push('risk_profile_match');\n      similarity += 0.25;\n    }\n    \n    // Speed preference vs execution timing\n    const speedMatch = Math.abs(fp.styleProfile.speedPreference - behavior.executionConsistency);\n    if (speedMatch < 0.3) {\n      matchingTraits.push('speed_style_match');\n      similarity += 0.2;\n    }\n    \n    // Comeback probability vs emotional recovery\n    const recoveryMatch = Math.abs(fp.temporalPatterns.comebackProbability - (1 - behavior.emotionalDeviation));\n    if (recoveryMatch < 0.2) {\n      matchingTraits.push('recovery_pattern_match');\n      similarity += 0.25;\n    }\n    \n    if (similarity > bestSimilarity && similarity > 0.5) {\n      bestSimilarity = similarity;\n      bestMatch = { fingerprint: fp, match: { similarity, matchingTraits } };\n    }\n  }\n  \n  return bestMatch;\n}\n\nfunction generateStrategicInsights(\n  classification: MarketParticipantProfile['classification'],\n  behavior: MarketParticipantProfile['behaviorProfile'],\n  chessFingerprint?: PlayerFingerprint\n): MarketParticipantProfile['strategicInsights'] {\n  \n  const exploitablePatterns: string[] = [];\n  let optimalCounterStrategy = '';\n  let predictability = 0.5;\n  \n  if (classification === 'algorithmic') {\n    // Algos are predictable but hard to beat on speed\n    predictability = 0.8;\n    exploitablePatterns.push('front_run_on_known_levels');\n    exploitablePatterns.push('exploit_rebalancing_schedules');\n    optimalCounterStrategy = 'Anticipate algorithmic patterns, avoid competing on speed';\n  } else if (classification === 'human') {\n    predictability = 0.4 + behavior.emotionalDeviation * 0.3;\n    \n    if (behavior.tiltIndicators > 0.5) {\n      exploitablePatterns.push('tilt_after_losses');\n      optimalCounterStrategy = 'Wait for emotional mistakes after drawdowns';\n    }\n    \n    if (behavior.patternBreaking > 0.3) {\n      exploitablePatterns.push('pattern_deviation_under_pressure');\n      optimalCounterStrategy = 'Apply pressure to force deviations from strategy';\n    }\n    \n    if (chessFingerprint) {\n      // Use chess insights\n      if (chessFingerprint.blunderSignature.dominantBlunderType === 'human') {\n        exploitablePatterns.push('emotional_blunder_tendency');\n      }\n      \n      if (chessFingerprint.pressureProfile.tiltResistance < 0.4) {\n        exploitablePatterns.push('low_tilt_resistance');\n        optimalCounterStrategy = 'Grind them out - they crack under sustained pressure';\n      }\n    }\n  } else if (classification === 'hybrid') {\n    predictability = 0.6;\n    exploitablePatterns.push('human_override_moments');\n    optimalCounterStrategy = 'Identify when human takes over from algorithm';\n  }\n  \n  if (!optimalCounterStrategy) {\n    optimalCounterStrategy = 'Insufficient data for strategy recommendation';\n  }\n  \n  return {\n    exploitablePatterns,\n    predictability,\n    optimalCounterStrategy\n  };\n}\n\nfunction createUnknownProfile(reason: string): MarketParticipantProfile {\n  return {\n    participantId: 'unknown',\n    classification: 'unknown',\n    confidence: 0,\n    behaviorProfile: {\n      executionConsistency: 0.5,\n      emotionalDeviation: 0.5,\n      timingPrecision: 0.5,\n      newsReactionSpeed: 0.5,\n      patternBreaking: 0.5,\n      tiltIndicators: 0.5\n    },\n    strategicInsights: {\n      exploitablePatterns: [],\n      predictability: 0.5,\n      optimalCounterStrategy: reason\n    }\n  };\n}\n\n/**\n * The ultimate insight: Use chess behavioral patterns to predict market behavior\n */\nexport function predictMarketBehaviorFromChess(\n  fingerprint: PlayerFingerprint,\n  currentMarketConditions: {\n    volatility: number;\n    trend: 'up' | 'down' | 'sideways';\n    sessionLength: number;\n    recentPnL: number;\n  }\n): {\n  likelyBehavior: string;\n  blunderProbability: number;\n  optimalTiming: string;\n} {\n  let blunderProbability = 0.1; // Base rate\n  \n  // Time in session (fatigue)\n  if (currentMarketConditions.sessionLength > 4 * 60 * 60 * 1000) {\n    blunderProbability += 0.1;\n  }\n  \n  // Recent losses (tilt)\n  if (currentMarketConditions.recentPnL < 0) {\n    blunderProbability += (1 - fingerprint.pressureProfile.tiltResistance) * 0.2;\n  }\n  \n  // Volatility (pressure)\n  if (currentMarketConditions.volatility > 0.5) {\n    blunderProbability += (1 - fingerprint.pressureProfile.timePressurePerformance) * 0.15;\n  }\n  \n  // Determine likely behavior\n  let likelyBehavior = '';\n  if (blunderProbability > 0.4) {\n    likelyBehavior = 'Likely to make emotional decisions, may overtrade or revenge trade';\n  } else if (blunderProbability > 0.25) {\n    likelyBehavior = 'Under some pressure, may deviate from strategy';\n  } else {\n    likelyBehavior = 'Operating within normal parameters';\n  }\n  \n  // Optimal timing to exploit\n  let optimalTiming = '';\n  if (fingerprint.blunderSignature.blunderPhaseDistribution.endgame > 0.4) {\n    optimalTiming = 'Late session - they tend to make more mistakes toward close';\n  } else if (fingerprint.blunderSignature.blunderPhaseDistribution.opening > 0.4) {\n    optimalTiming = 'Early session - impulsive entries';\n  } else {\n    optimalTiming = 'Mid-session under high volatility';\n  }\n  \n  return {\n    likelyBehavior,\n    blunderProbability: Math.min(0.8, blunderProbability),\n    optimalTiming\n  };\n}\n";export{n as default};
