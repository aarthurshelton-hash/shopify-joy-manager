const e="// Map palette IDs to their corresponding AI-generated art images\n// and provide vision classification utilities\nimport artdecoArt from '@/assets/palettes/artdeco.jpg';\nimport autumnArt from '@/assets/palettes/autumn.jpg';\nimport cosmicArt from '@/assets/palettes/cosmic.jpg';\nimport cyberpunkArt from '@/assets/palettes/cyberpunk.jpg';\nimport desertArt from '@/assets/palettes/desert.jpg';\nimport egyptianArt from '@/assets/palettes/egyptian.jpg';\nimport greyscaleArt from '@/assets/palettes/greyscale.jpg';\nimport hotcoldArt from '@/assets/palettes/hotcold.jpg';\nimport japaneseArt from '@/assets/palettes/japanese.jpg';\nimport medievalArt from '@/assets/palettes/medieval.jpg';\nimport modernArt from '@/assets/palettes/modern.jpg';\nimport nordicArt from '@/assets/palettes/nordic.jpg';\nimport oceanArt from '@/assets/palettes/ocean.jpg';\nimport romanArt from '@/assets/palettes/roman.jpg';\nimport tropicalArt from '@/assets/palettes/tropical.jpg';\nimport vintageArt from '@/assets/palettes/vintage.jpg';\nimport { colorPalettes, PaletteId, PieceType } from '@/lib/chess/pieceColors';\nimport { detectGameCard } from '@/lib/chess/gameCardDetection';\n\nexport const paletteArtMap: Record<string, string> = {\n  hotCold: hotcoldArt,\n  medieval: medievalArt,\n  egyptian: egyptianArt,\n  roman: romanArt,\n  modern: modernArt,\n  greyscale: greyscaleArt,\n  japanese: japaneseArt,\n  nordic: nordicArt,\n  artdeco: artdecoArt,\n  tropical: tropicalArt,\n  cyberpunk: cyberpunkArt,\n  autumn: autumnArt,\n  ocean: oceanArt,\n  desert: desertArt,\n  cosmic: cosmicArt,\n  vintage: vintageArt,\n};\n\n// Human-readable palette names\nexport const paletteDisplayNames: Record<string, string> = {\n  hotCold: 'Hot & Cold',\n  medieval: 'Medieval',\n  egyptian: 'Egyptian',\n  roman: 'Roman Empire',\n  modern: 'Modern',\n  greyscale: 'Greyscale',\n  japanese: 'Japanese',\n  nordic: 'Nordic',\n  artdeco: 'Art Deco',\n  tropical: 'Tropical',\n  cyberpunk: 'Cyberpunk',\n  autumn: 'Autumn',\n  ocean: 'Ocean',\n  desert: 'Desert',\n  cosmic: 'Cosmic',\n  vintage: 'Vintage',\n  custom: 'Custom',\n};\n\n// All official En Pensent palettes (non-custom palettes that ship with the platform)\nexport const officialPaletteIds = [\n  'hotCold', 'medieval', 'egyptian', 'roman', 'modern', 'greyscale',\n  'japanese', 'nordic', 'artdeco', 'tropical', 'cyberpunk',\n  'autumn', 'ocean', 'desert', 'cosmic', 'vintage'\n];\n\n// Premium palettes that get special visual treatment (legacy - now all official palettes are equal)\nexport const premiumPaletteIds = officialPaletteIds;\n\n// All themed palettes (same as official for consistency)\nexport const themedPaletteIds = officialPaletteIds;\n\nexport function getPaletteArt(paletteId: string | undefined): string | null {\n  if (!paletteId) return null;\n  return paletteArtMap[paletteId] || null;\n}\n\nexport function getPaletteDisplayName(paletteId: string | undefined): string | null {\n  if (!paletteId) return null;\n  return paletteDisplayNames[paletteId] || null;\n}\n\n// Check if palette is an official En Pensent palette\nexport function isOfficialPalette(paletteId: string | undefined): boolean {\n  if (!paletteId) return false;\n  return officialPaletteIds.includes(paletteId);\n}\n\n// Legacy function - now just checks if it's an official palette\nexport function isPremiumPalette(paletteId: string | undefined): boolean {\n  return isOfficialPalette(paletteId);\n}\n\n// Legacy function - now just checks if it's an official palette\nexport function isThemedPalette(paletteId: string | undefined): boolean {\n  return isOfficialPalette(paletteId);\n}\n\n/**\n * Vision Classification Types:\n * - PREMIUM: Uses BOTH official game AND official palette (highest encryption value)\n * - GENESIS: Uses EITHER official game OR official palette (one or the other)\n * - STANDARD: Neither official game nor official palette (natural market value only)\n */\nexport type VisionTier = 'premium' | 'genesis' | 'standard';\n\nexport interface VisionClassification {\n  tier: VisionTier;\n  hasOfficialGame: boolean;\n  hasOfficialPalette: boolean;\n  gameName?: string;\n  paletteName?: string;\n}\n\n/**\n * Classify a vision based on its official game and palette usage\n */\nexport function classifyVision(\n  paletteId: string | undefined,\n  pgn: string | undefined\n): VisionClassification {\n  const hasOfficialPalette = isOfficialPalette(paletteId);\n  const paletteName = hasOfficialPalette ? getPaletteDisplayName(paletteId) || undefined : undefined;\n  \n  // Check for official game match\n  let hasOfficialGame = false;\n  let gameName: string | undefined;\n  \n  if (pgn) {\n    const gameMatch = detectGameCard(pgn);\n    if (gameMatch.isMatch && gameMatch.matchedGame) {\n      hasOfficialGame = true;\n      gameName = gameMatch.matchedGame.title;\n    }\n  }\n  \n  // Determine tier\n  let tier: VisionTier;\n  if (hasOfficialGame && hasOfficialPalette) {\n    tier = 'premium';\n  } else if (hasOfficialGame || hasOfficialPalette) {\n    tier = 'genesis';\n  } else {\n    tier = 'standard';\n  }\n  \n  return {\n    tier,\n    hasOfficialGame,\n    hasOfficialPalette,\n    gameName,\n    paletteName,\n  };\n}\n\n/**\n * Quick check if a vision is Premium tier (both official game AND palette)\n */\nexport function isPremiumVision(paletteId: string | undefined, pgn: string | undefined): boolean {\n  return classifyVision(paletteId, pgn).tier === 'premium';\n}\n\n/**\n * Quick check if a vision is Genesis tier (one official property, not both)\n */\nexport function isGenesisVision(paletteId: string | undefined, pgn: string | undefined): boolean {\n  return classifyVision(paletteId, pgn).tier === 'genesis';\n}\n\n/**\n * Detect palette from actual board color data\n * This is the \"genius\" system: when pieces don't move, no color appears on their starting square.\n * We detect the palette by analyzing the colors that ARE present on the board.\n */\nfunction detectPaletteFromBoardColors(board: unknown): string | undefined {\n  if (!Array.isArray(board) || board.length !== 8) return undefined;\n  \n  // Collect all unique colors from the board\n  const colorsFound = new Set<string>();\n  \n  for (const row of board) {\n    if (!Array.isArray(row)) continue;\n    for (const square of row) {\n      if (!square || typeof square !== 'object') continue;\n      const visits = (square as { visits?: Array<{ hexColor?: string }> }).visits;\n      if (!Array.isArray(visits)) continue;\n      \n      for (const visit of visits) {\n        if (visit && typeof visit.hexColor === 'string') {\n          // Normalize to uppercase for comparison\n          colorsFound.add(visit.hexColor.toUpperCase());\n        }\n      }\n    }\n  }\n  \n  if (colorsFound.size === 0) return undefined;\n  \n  // Check each palette for color matches\n  // A palette is considered a match if ALL colors found on the board belong to that palette\n  let bestMatch: { paletteId: string; matchCount: number } | null = null;\n  \n  for (const palette of colorPalettes) {\n    if (palette.id === 'custom') continue;\n    \n    // Build set of all colors in this palette\n    const paletteColors = new Set<string>();\n    for (const pieceType of ['k', 'q', 'r', 'b', 'n', 'p'] as PieceType[]) {\n      paletteColors.add(palette.white[pieceType].toUpperCase());\n      paletteColors.add(palette.black[pieceType].toUpperCase());\n    }\n    \n    // Count how many board colors match this palette\n    let matchCount = 0;\n    let allMatch = true;\n    \n    for (const color of colorsFound) {\n      if (paletteColors.has(color)) {\n        matchCount++;\n      } else {\n        allMatch = false;\n      }\n    }\n    \n    // If all colors match OR we have a high match count, consider this palette\n    // We use 70% threshold because some pieces may not have moved (intentional noise reduction)\n    const matchPercentage = colorsFound.size > 0 ? (matchCount / colorsFound.size) * 100 : 0;\n    \n    if (allMatch && matchCount > 0) {\n      // Perfect match - all board colors belong to this palette\n      return palette.id;\n    }\n    \n    if (matchPercentage >= 70 && (!bestMatch || matchCount > bestMatch.matchCount)) {\n      bestMatch = { paletteId: palette.id, matchCount };\n    }\n  }\n  \n  return bestMatch?.paletteId;\n}\n\n// Extract palette ID from game_data - checks visualizationState.paletteId first, then detects from board colors\nexport function extractPaletteId(gameData: Record<string, unknown> | undefined): string | undefined {\n  if (!gameData) return undefined;\n  \n  // Primary location: visualizationState.paletteId (how saveVisualization stores it)\n  if (typeof gameData.visualizationState === 'object' && gameData.visualizationState !== null) {\n    const vizState = gameData.visualizationState as Record<string, unknown>;\n    if (typeof vizState.paletteId === 'string' && vizState.paletteId !== 'custom') {\n      return vizState.paletteId;\n    }\n    // Check for linked palette (custom colors matching a featured palette)\n    if (typeof vizState.linkedPaletteId === 'string') {\n      return vizState.linkedPaletteId;\n    }\n  }\n  \n  // Fallback: direct paletteId\n  if (typeof gameData.paletteId === 'string' && gameData.paletteId !== 'custom') {\n    return gameData.paletteId;\n  }\n  \n  // Fallback: palette object\n  if (typeof gameData.palette === 'object' && gameData.palette !== null) {\n    const palette = gameData.palette as Record<string, unknown>;\n    if (typeof palette.id === 'string' && palette.id !== 'custom') {\n      return palette.id;\n    }\n  }\n  \n  // Advanced detection: analyze actual board colors to detect palette\n  // This handles cases where paletteId wasn't stored properly or pieces didn't move\n  if (gameData.board) {\n    const detectedPalette = detectPaletteFromBoardColors(gameData.board);\n    if (detectedPalette) {\n      return detectedPalette;\n    }\n  }\n  \n  return undefined;\n}\n\n// Extract PGN from game_data\nexport function extractPgn(gameData: Record<string, unknown> | undefined): string | undefined {\n  if (!gameData) return undefined;\n  \n  if (typeof gameData.pgn === 'string') {\n    return gameData.pgn;\n  }\n  \n  return undefined;\n}\n\n/**\n * Classify a vision directly from its game_data\n */\nexport function classifyVisionFromGameData(\n  gameData: Record<string, unknown> | undefined,\n  pgn?: string\n): VisionClassification {\n  const paletteId = extractPaletteId(gameData);\n  const effectivePgn = pgn || extractPgn(gameData);\n  return classifyVision(paletteId, effectivePgn);\n}\n";export{e as default};
