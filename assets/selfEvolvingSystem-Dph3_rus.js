const e="/**\n * Self-Evolving Learning System\n * Continuously adapts and improves based on prediction outcomes\n * \n * Refactored: Modular architecture with separated concerns\n * Enhanced: Anomaly Harvester integration for productive bug detection\n * Enhanced: Mirage Quantifier for weak signal materialization\n * \n * PHILOSOPHICAL FRAMEWORK:\n * - Humans experience OPTICAL ILLUSIONS (neurological bugs - brain processing limits)\n * - Humans experience MIRAGES (desperation projections - oasis in desert)\n * - AI experiences NEITHER - only MISUNDERSTANDINGS (miscalibrated patterns)\n * - But AI can MATERIALIZE weak signals through reflexivity (belief â†’ reality)\n */\n\nimport {\n  EvolutionState,\n  EvolutionMetrics,\n  CorrelationMemory,\n  LearnedPattern,\n  PredictionOutcome\n} from './evolution/types';\nimport { DEFAULT_GENES, updateGenePerformance, mutateGenes, getGeneValue } from './evolution/geneManager';\nimport { learnFromOutcome, getBestPatterns } from './evolution/patternLearner';\nimport { DEFAULT_THRESHOLDS, adaptThresholds } from './evolution/thresholdAdapter';\nimport { anomalyHarvester, HarvestedAnomaly, AnomalyType } from './evolution/anomalyHarvester';\nimport { mirageQuantifier, MirageSignal } from './evolution/mirageQuantifier';\n\n// Re-export types for backwards compatibility\nexport * from './evolution/types';\nexport { anomalyHarvester, type HarvestedAnomaly, type AnomalyType } from './evolution/anomalyHarvester';\nexport { mirageQuantifier, type MirageSignal } from './evolution/mirageQuantifier';\n\nclass SelfEvolvingSystem {\n  private state: EvolutionState;\n  private fitnessHistory: number[] = [];\n  private readonly maxHistorySize = 1000;\n  private previousFitness: number = 0.5;\n\n  constructor() {\n    this.state = this.createInitialState();\n  }\n\n  private createInitialState(): EvolutionState {\n    return {\n      metrics: {\n        generationNumber: 1,\n        startedAt: Date.now(),\n        totalPredictions: 0,\n        successfulEvolutions: 0,\n        currentFitness: 0.5,\n        peakFitness: 0.5,\n        learningVelocity: 0,\n        adaptationRate: 0.1\n      },\n      genes: [...DEFAULT_GENES.map(g => ({ ...g }))],\n      correlationMemory: [],\n      patternLibrary: [],\n      adaptiveThresholds: { ...DEFAULT_THRESHOLDS },\n      recentMutations: []\n    };\n  }\n\n  processOutcome(prediction: PredictionOutcome): EvolutionState {\n    this.state.metrics.totalPredictions++;\n    \n    const wasCorrect = prediction.predicted === prediction.actual;\n    const fitness = this.calculateFitness(wasCorrect, prediction.confidence);\n    \n    // ANOMALY HARVESTING: Detect productive bugs before updating state\n    const anomaly = anomalyHarvester.harvestFromOutcome(\n      prediction,\n      wasCorrect,\n      fitness,\n      this.previousFitness\n    );\n    \n    // Store previous fitness for next comparison\n    this.previousFitness = this.state.metrics.currentFitness;\n    \n    this.updateFitnessHistory(fitness);\n    this.updateCurrentFitness(fitness);\n    this.calculateLearningVelocity();\n    \n    updateGenePerformance(this.state.genes, wasCorrect, prediction.marketConditions);\n    \n    this.state.patternLibrary = learnFromOutcome(\n      this.state.patternLibrary,\n      prediction,\n      wasCorrect,\n      getGeneValue(this.state.genes, 'patternDecayRate')\n    );\n    \n    this.maybeEvolve();\n    this.state.adaptiveThresholds = adaptThresholds(this.state.adaptiveThresholds, this.state.metrics);\n    \n    return this.getState();\n  }\n\n  private calculateFitness(wasCorrect: boolean, confidence: number): number {\n    return wasCorrect ? 0.5 + confidence * 0.5 : 0.5 - confidence * 0.3;\n  }\n\n  private updateFitnessHistory(fitness: number): void {\n    this.fitnessHistory.push(fitness);\n    if (this.fitnessHistory.length > this.maxHistorySize) {\n      this.fitnessHistory.shift();\n    }\n  }\n\n  private updateCurrentFitness(fitness: number): void {\n    const alpha = this.state.metrics.adaptationRate;\n    this.state.metrics.currentFitness = alpha * fitness + (1 - alpha) * this.state.metrics.currentFitness;\n    \n    if (this.state.metrics.currentFitness > this.state.metrics.peakFitness) {\n      this.state.metrics.peakFitness = this.state.metrics.currentFitness;\n    }\n  }\n\n  private calculateLearningVelocity(): void {\n    if (this.fitnessHistory.length < 20) {\n      this.state.metrics.learningVelocity = 0;\n      return;\n    }\n    \n    const recentAvg = this.fitnessHistory.slice(-10).reduce((a, b) => a + b, 0) / 10;\n    const olderAvg = this.fitnessHistory.slice(-20, -10).reduce((a, b) => a + b, 0) / 10;\n    \n    this.state.metrics.learningVelocity = (recentAvg - olderAvg) * 10;\n  }\n\n  private maybeEvolve(): void {\n    const shouldEvolve = \n      this.state.metrics.totalPredictions % 50 === 0 ||\n      (this.state.metrics.learningVelocity < -0.05 && this.state.metrics.totalPredictions > 20);\n    \n    if (!shouldEvolve) return;\n    \n    const fitnessBefore = this.state.metrics.currentFitness;\n    const mutations = mutateGenes(this.state.genes, this.state.metrics.currentFitness);\n    this.state.recentMutations.push(...mutations);\n    this.state.recentMutations = this.state.recentMutations.slice(-20);\n    \n    // ANOMALY HARVESTING: Check each mutation for productive bugs\n    mutations.forEach(mutation => {\n      // Estimate fitness change from mutation (simplified)\n      const fitnessAfter = this.state.metrics.currentFitness;\n      anomalyHarvester.harvestFromMutation(\n        mutation.gene,\n        mutation.newValue - mutation.previousValue,\n        fitnessBefore,\n        fitnessAfter\n      );\n    });\n    \n    this.state.metrics.generationNumber++;\n    this.state.metrics.successfulEvolutions++;\n  }\n\n  getGeneValue(name: string): number {\n    return getGeneValue(this.state.genes, name);\n  }\n\n  getBestPatterns(limit: number = 5): LearnedPattern[] {\n    return getBestPatterns(this.state.patternLibrary, limit);\n  }\n\n  updateCorrelationMemory(market1: string, market2: string, observed: number): void {\n    const existing = this.state.correlationMemory.find(\n      m => (m.market1 === market1 && m.market2 === market2) ||\n           (m.market1 === market2 && m.market2 === market1)\n    );\n    \n    if (existing) {\n      existing.observedCorrelations.push(observed);\n      if (existing.observedCorrelations.length > 100) {\n        existing.observedCorrelations.shift();\n      }\n      existing.actualCorrelation = observed;\n      existing.accuracy = 1 - Math.abs(existing.predictedCorrelation - observed);\n      existing.lastUpdated = Date.now();\n    } else {\n      this.state.correlationMemory.push({\n        market1,\n        market2,\n        observedCorrelations: [observed],\n        predictedCorrelation: observed,\n        actualCorrelation: observed,\n        accuracy: 1,\n        lastUpdated: Date.now()\n      });\n    }\n  }\n\n  getState(): EvolutionState {\n    return { ...this.state };\n  }\n\n  getEvolutionSummary(): {\n    generation: number;\n    fitness: number;\n    velocity: number;\n    topGenes: Array<{ name: string; value: number; impact: number }>;\n    patternCount: number;\n    bestPatternAccuracy: number;\n    anomalyHarvest: {\n      totalAnomalies: number;\n      topPatterns: string[];\n      recentInsights: string[];\n    };\n  } {\n    const bestPattern = this.getBestPatterns(1)[0];\n    const anomalySummary = anomalyHarvester.getEvolutionarySummary();\n    \n    return {\n      generation: this.state.metrics.generationNumber,\n      fitness: this.state.metrics.currentFitness,\n      velocity: this.state.metrics.learningVelocity,\n      topGenes: this.state.genes\n        .sort((a, b) => Math.abs(b.performanceImpact) - Math.abs(a.performanceImpact))\n        .slice(0, 3)\n        .map(g => ({ name: g.name, value: g.value, impact: g.performanceImpact })),\n      patternCount: this.state.patternLibrary.length,\n      bestPatternAccuracy: bestPattern?.successRate ?? 0,\n      anomalyHarvest: {\n        totalAnomalies: anomalySummary.totalAnomalies,\n        topPatterns: anomalySummary.topPatterns,\n        recentInsights: anomalySummary.recentInsights\n      }\n    };\n  }\n\n  /**\n   * Record cross-domain resonance as a productive anomaly\n   */\n  recordCrossDomainResonance(\n    domain1: string,\n    domain2: string,\n    correlationStrength: number,\n    insight: string\n  ): HarvestedAnomaly | null {\n    return anomalyHarvester.harvestCrossDomainResonance(\n      domain1,\n      domain2,\n      correlationStrength,\n      insight\n    );\n  }\n\n  /**\n   * Get anomalies ready for persistence to en_pensent_memory\n   */\n  getAnomaliesForMemory(minImportance: number = 7): HarvestedAnomaly[] {\n    return anomalyHarvester.getAnomaliesForMemory(minImportance);\n  }\n\n  /**\n   * Get exploitable patterns discovered through anomaly harvesting\n   */\n  getExploitablePatterns(limit: number = 5) {\n    return anomalyHarvester.getTopExploitablePatterns(limit);\n  }\n\n  // ============= MIRAGE QUANTIFICATION SYSTEM =============\n  \n  /**\n   * Detect a potential \"mirage\" - a weak signal that might materialize\n   * Unlike human optical illusions, these are patterns we genuinely see\n   * but can't yet confirm - and acting on them might make them real\n   */\n  detectMirage(\n    prediction: { direction: 'up' | 'down' | 'neutral'; confidence: number; magnitude: number },\n    marketContext: { momentum: number; volatility: number; volume: number },\n    crossDomainSignals: { domain: string; alignment: number }[]\n  ): MirageSignal | null {\n    return mirageQuantifier.detectMirage(prediction, marketContext, crossDomainSignals);\n  }\n\n  /**\n   * Act on a mirage - betting on a weak signal\n   * This enables tracking of reflexivity (did our belief help make it real?)\n   */\n  actOnMirage(mirageId: string): void {\n    mirageQuantifier.actOnMirage(mirageId);\n  }\n\n  /**\n   * Resolve a mirage - did it materialize into reality or evaporate?\n   */\n  resolveMirage(\n    mirageId: string,\n    actualOutcome: { direction: 'up' | 'down' | 'neutral'; magnitude: number }\n  ): void {\n    mirageQuantifier.resolveMirage(mirageId, actualOutcome);\n    \n    // If it materialized, record as a productive anomaly\n    const metrics = mirageQuantifier.getMaterializationMetrics();\n    if (metrics.materializationRate > 0.5) {\n      anomalyHarvester.harvestCrossDomainResonance(\n        'mirage',\n        'reality',\n        metrics.avgReflexivityContribution,\n        `Mirage materialized with ${(metrics.materializationRate * 100).toFixed(0)}% rate`\n      );\n    }\n  }\n\n  /**\n   * Get mirages worth acting on (high materialization potential)\n   */\n  getActionableMirages(): MirageSignal[] {\n    return mirageQuantifier.getActionableMirages();\n  }\n\n  /**\n   * Get mirage materialization metrics for learning\n   */\n  getMirageMetrics() {\n    return mirageQuantifier.getMaterializationMetrics();\n  }\n\n  /**\n   * Cleanup expired mirages\n   */\n  cleanupMirages(): void {\n    mirageQuantifier.cleanupExpired();\n  }\n}\n\nexport const selfEvolvingSystem = new SelfEvolvingSystem();\n";export{e as default};
