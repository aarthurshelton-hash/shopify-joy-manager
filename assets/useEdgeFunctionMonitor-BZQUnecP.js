const n="/**\n * Edge Function Monitoring Hook\n * \n * Provides real-time monitoring of Supabase Edge Functions with\n * automatic health checks, metrics tracking, and alerting.\n */\n\nimport { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport {\n  checkEdgeFunctionHealth,\n  checkMultipleFunctions,\n  getFunctionMetrics,\n  getSystemHealthStatus,\n  clearHealthCache,\n  STANDARD_EDGE_FUNCTIONS,\n  type HealthCheckResult,\n  type FunctionMetrics,\n  type EdgeFunctionName,\n} from '@/lib/monitoring/edgeFunctionHealth';\n\ninterface MonitoringState {\n  results: HealthCheckResult[];\n  isLoading: boolean;\n  lastUpdated: string | null;\n  systemStatus: 'healthy' | 'warning' | 'critical' | 'unknown';\n  error: string | null;\n}\n\ninterface MonitoringConfig {\n  autoRefresh: boolean;\n  refreshInterval: number; // milliseconds\n  functions: EdgeFunctionName[];\n  onError?: (error: Error) => void;\n  onStatusChange?: (status: MonitoringState['systemStatus']) => void;\n}\n\nconst DEFAULT_CONFIG: MonitoringConfig = {\n  autoRefresh: true,\n  refreshInterval: 30_000, // 30 seconds\n  functions: [...STANDARD_EDGE_FUNCTIONS],\n};\n\nexport function useEdgeFunctionMonitor(userConfig?: Partial<MonitoringConfig>) {\n  const config = useMemo(() => ({ ...DEFAULT_CONFIG, ...userConfig }), [userConfig]);\n  \n  const [state, setState] = useState<MonitoringState>({\n    results: [],\n    isLoading: false,\n    lastUpdated: null,\n    systemStatus: 'unknown',\n    error: null,\n  });\n\n  const [metrics, setMetrics] = useState<Map<string, FunctionMetrics>>(new Map());\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const previousStatus = useRef<MonitoringState['systemStatus']>('unknown');\n\n  /**\n   * Perform health check on all monitored functions\n   */\n  const checkHealth = useCallback(async () => {\n    setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      const results = await checkMultipleFunctions(config.functions as string[]);\n      const systemHealth = getSystemHealthStatus(results);\n\n      // Update metrics for each function\n      const newMetrics = new Map(metrics);\n      results.forEach(result => {\n        const functionMetrics = getFunctionMetrics(result.functionName);\n        if (functionMetrics) {\n          newMetrics.set(result.functionName, functionMetrics);\n        }\n      });\n      setMetrics(newMetrics);\n\n      // Check for status change callback\n      if (\n        config.onStatusChange &&\n        systemHealth.status !== previousStatus.current\n      ) {\n        config.onStatusChange(systemHealth.status);\n      }\n      previousStatus.current = systemHealth.status;\n\n      setState({\n        results,\n        isLoading: false,\n        lastUpdated: new Date().toISOString(),\n        systemStatus: systemHealth.status,\n        error: null,\n      });\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      \n      if (config.onError) {\n        config.onError(error);\n      }\n\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: error.message,\n      }));\n    }\n  }, [config, metrics]);\n\n  /**\n   * Check health of a single function\n   */\n  const checkSingleFunction = useCallback(async (functionName: string) => {\n    try {\n      const result = await checkEdgeFunctionHealth(functionName);\n      \n      // Update results array\n      setState(prev => {\n        const existingIndex = prev.results.findIndex(\n          r => r.functionName === functionName\n        );\n        const newResults = [...prev.results];\n        \n        if (existingIndex >= 0) {\n          newResults[existingIndex] = result;\n        } else {\n          newResults.push(result);\n        }\n\n        const systemHealth = getSystemHealthStatus(newResults);\n        \n        return {\n          ...prev,\n          results: newResults,\n          systemStatus: systemHealth.status,\n          lastUpdated: new Date().toISOString(),\n        };\n      });\n\n      // Update metrics\n      const functionMetrics = getFunctionMetrics(functionName);\n      if (functionMetrics) {\n        setMetrics(prev => {\n          const newMetrics = new Map(prev);\n          newMetrics.set(functionName, functionMetrics);\n          return newMetrics;\n        });\n      }\n\n      return result;\n    } catch (err) {\n      throw err instanceof Error ? err : new Error('Failed to check function health');\n    }\n  }, []);\n\n  /**\n   * Clear all cached data\n   */\n  const clearCache = useCallback(() => {\n    clearHealthCache();\n    setMetrics(new Map());\n    setState(prev => ({\n      ...prev,\n      results: [],\n      lastUpdated: null,\n      systemStatus: 'unknown',\n    }));\n  }, []);\n\n  /**\n   * Get metrics for a specific function\n   */\n  const getMetrics = useCallback(\n    (functionName: string): FunctionMetrics | undefined => {\n      return metrics.get(functionName);\n    },\n    [metrics]\n  );\n\n  /**\n   * Get all metrics as array\n   */\n  const getAllMetrics = useCallback((): FunctionMetrics[] => {\n    return Array.from(metrics.values());\n  }, [metrics]);\n\n  // Auto-refresh effect\n  useEffect(() => {\n    // Initial check\n    checkHealth();\n\n    // Setup interval if autoRefresh is enabled\n    if (config.autoRefresh && config.refreshInterval > 0) {\n      intervalRef.current = setInterval(checkHealth, config.refreshInterval);\n    }\n\n    // Cleanup\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [checkHealth, config.autoRefresh, config.refreshInterval]);\n\n  return {\n    // State\n    results: state.results,\n    isLoading: state.isLoading,\n    lastUpdated: state.lastUpdated,\n    systemStatus: state.systemStatus,\n    error: state.error,\n    \n    // Actions\n    checkHealth,\n    checkSingleFunction,\n    clearCache,\n    \n    // Metrics\n    getMetrics,\n    getAllMetrics,\n    \n    // Helpers\n    healthyCount: state.results.filter(r => r.status === 'healthy').length,\n    warningCount: state.results.filter(r => r.status === 'warning').length,\n    errorCount: state.results.filter(r => r.status === 'error' || r.status === 'unhealthy').length,\n    totalCount: state.results.length,\n  };\n}\n\n/**\n * Hook for tracking individual edge function calls\n */\nexport function useEdgeFunctionTracker() {\n  const [invocations, setInvocations] = useState<Map<string, number>>(new Map());\n  const [errors, setErrors] = useState<Map<string, number>>(new Map());\n\n  const trackInvocation = useCallback((functionName: string, success: boolean) => {\n    setInvocations(prev => {\n      const newMap = new Map(prev);\n      newMap.set(functionName, (newMap.get(functionName) || 0) + 1);\n      return newMap;\n    });\n\n    if (!success) {\n      setErrors(prev => {\n        const newMap = new Map(prev);\n        newMap.set(functionName, (newMap.get(functionName) || 0) + 1);\n        return newMap;\n      });\n    }\n  }, []);\n\n  const getInvocationCount = useCallback(\n    (functionName: string): number => {\n      return invocations.get(functionName) || 0;\n    },\n    [invocations]\n  );\n\n  const getErrorCount = useCallback(\n    (functionName: string): number => {\n      return errors.get(functionName) || 0;\n    },\n    [errors]\n  );\n\n  const getErrorRate = useCallback(\n    (functionName: string): number => {\n      const invocations_count = invocations.get(functionName) || 0;\n      const errors_count = errors.get(functionName) || 0;\n      return invocations_count > 0 ? errors_count / invocations_count : 0;\n    },\n    [invocations, errors]\n  );\n\n  const resetTracking = useCallback(() => {\n    setInvocations(new Map());\n    setErrors(new Map());\n  }, []);\n\n  return {\n    trackInvocation,\n    getInvocationCount,\n    getErrorCount,\n    getErrorRate,\n    resetTracking,\n    totalInvocations: Array.from(invocations.values()).reduce((a, b) => a + b, 0),\n    totalErrors: Array.from(errors.values()).reduce((a, b) => a + b, 0),\n  };\n}\n";export{n as default};
