const n="/**\n * Consciousness Resonance Detector\n * \n * Detects collective market synchronization patterns.\n * \n * CEO INSIGHT: When millions of market participants unconsciously synchronize\n * their decision-making rhythms, powerful trend waves emerge.\n * \n * Based on Kuramoto synchronization model adapted for financial markets.\n */\n\nimport type { BigPictureState, MarketTick, CrossMarketSignal } from './crossMarket/types';\n\n// ============================================================================\n// CONSCIOUSNESS RESONANCE TYPES\n// ============================================================================\n\nexport interface ResonanceState {\n  globalSynchronization: number;   // 0-1: How synchronized market participants are\n  dominantFrequency: number;       // Hz: Main oscillation frequency\n  phaseAlignment: number;          // 0-1: How aligned the phases are\n  resonanceType: ResonanceType;\n  collectiveMood: CollectiveMood;\n  entrainmentStrength: number;     // How strongly participants are being pulled into sync\n  breakoutProbability: number;     // Probability of breaking current resonance\n  signals: ResonanceSignal[];\n  lastUpdated: Date;\n}\n\nexport type ResonanceType = \n  | 'COHERENT_BULL'      // Synchronized bullish behavior\n  | 'COHERENT_BEAR'      // Synchronized bearish behavior\n  | 'CHAOTIC_SCATTER'    // No synchronization - random walk\n  | 'BIFURCATION'        // About to split into two camps\n  | 'PHASE_TRANSITION'   // Shifting from one state to another\n  | 'STABLE_OSCILLATION' // Regular back-and-forth\n  | 'CRYSTALLIZING';     // Rapidly approaching full sync\n\nexport type CollectiveMood =\n  | 'EUPHORIA'           // Extreme greed, near top\n  | 'OPTIMISM'           // Healthy bullishness\n  | 'UNCERTAINTY'        // Neither bull nor bear\n  | 'ANXIETY'            // Growing fear\n  | 'CAPITULATION'       // Extreme fear, near bottom\n  | 'DEPRESSION'         // Post-crash apathy\n  | 'DISBELIEF';         // Early rally skepticism\n\nexport interface ResonanceSignal {\n  type: string;\n  strength: number;\n  description: string;\n  timestamp: Date;\n}\n\n// ============================================================================\n// KURAMOTO SYNCHRONIZATION PARAMETERS\n// ============================================================================\n\n/**\n * Kuramoto model: dθᵢ/dt = ωᵢ + (K/N) Σⱼ sin(θⱼ - θᵢ)\n * \n * In market terms:\n * - θᵢ = individual trader's \"phase\" (bullish to bearish position)\n * - ωᵢ = natural trading frequency (scalper to investor)\n * - K = coupling strength (how much traders influence each other)\n * - N = number of market participants\n */\nconst KURAMOTO_PARAMS = {\n  criticalCoupling: 0.4,    // K_c - below this, no sync; above, spontaneous sync\n  phaseNoise: 0.1,          // Random fluctuations in individual behavior\n  couplingDecay: 0.01,      // How fast coupling weakens without reinforcement\n  syncThreshold: 0.7,       // r > 0.7 = coherent synchronization\n  bifurcationThreshold: 0.4 // Multiple attractors emerge\n};\n\n// ============================================================================\n// DETECTOR CLASS\n// ============================================================================\n\nclass ConsciousnessResonanceDetector {\n  private state: ResonanceState;\n  private oscillatorPhases: number[] = [];\n  private priceHistory: number[] = [];\n  private volumeHistory: number[] = [];\n  private sentimentHistory: number[] = [];\n  private maxHistory = 200;\n\n  constructor() {\n    this.state = this.createInitialState();\n    // Initialize 100 virtual \"oscillators\" representing market participants\n    this.oscillatorPhases = Array.from({ length: 100 }, () => Math.random() * 2 * Math.PI);\n  }\n\n  private createInitialState(): ResonanceState {\n    return {\n      globalSynchronization: 0.5,\n      dominantFrequency: 0.1,\n      phaseAlignment: 0.5,\n      resonanceType: 'CHAOTIC_SCATTER',\n      collectiveMood: 'UNCERTAINTY',\n      entrainmentStrength: 0,\n      breakoutProbability: 0.5,\n      signals: [],\n      lastUpdated: new Date()\n    };\n  }\n\n  /**\n   * Process market data and detect collective synchronization\n   */\n  processTick(tick: MarketTick, bigPictureState: BigPictureState): ResonanceState {\n    // Update histories\n    this.priceHistory.push(tick.price);\n    this.volumeHistory.push(tick.volume || 0);\n    this.sentimentHistory.push(bigPictureState.marketSentiment);\n\n    if (this.priceHistory.length > this.maxHistory) {\n      this.priceHistory.shift();\n      this.volumeHistory.shift();\n      this.sentimentHistory.shift();\n    }\n\n    // Update oscillator simulation with market influence\n    this.updateOscillators(tick, bigPictureState);\n\n    // Calculate order parameter (global synchronization)\n    const { r, psi } = this.calculateOrderParameter();\n\n    // Detect dominant frequency via simple autocorrelation\n    const dominantFrequency = this.detectDominantFrequency();\n\n    // Determine resonance type\n    const resonanceType = this.determineResonanceType(r, bigPictureState);\n\n    // Determine collective mood\n    const collectiveMood = this.determineCollectiveMood(bigPictureState, r);\n\n    // Calculate entrainment strength\n    const entrainmentStrength = this.calculateEntrainmentStrength(r, bigPictureState);\n\n    // Calculate breakout probability\n    const breakoutProbability = this.calculateBreakoutProbability(r, resonanceType);\n\n    // Generate signals\n    const signals = this.generateSignals(r, resonanceType, collectiveMood, bigPictureState);\n\n    this.state = {\n      globalSynchronization: r,\n      dominantFrequency,\n      phaseAlignment: (Math.cos(psi) + 1) / 2, // Normalize to 0-1\n      resonanceType,\n      collectiveMood,\n      entrainmentStrength,\n      breakoutProbability,\n      signals,\n      lastUpdated: new Date()\n    };\n\n    return this.state;\n  }\n\n  /**\n   * Update oscillator phases using Kuramoto model\n   */\n  private updateOscillators(tick: MarketTick, bigPicture: BigPictureState): void {\n    const N = this.oscillatorPhases.length;\n    const K = 0.3 + bigPicture.volatilityIndex / 100; // Coupling increases with volatility\n    \n    // Calculate mean field\n    let sumSin = 0;\n    let sumCos = 0;\n    for (const phase of this.oscillatorPhases) {\n      sumSin += Math.sin(phase);\n      sumCos += Math.cos(phase);\n    }\n    const meanPhase = Math.atan2(sumSin, sumCos);\n    \n    // Market sentiment acts as external force\n    const externalForce = bigPicture.marketSentiment * 0.1;\n    \n    // Update each oscillator\n    for (let i = 0; i < N; i++) {\n      // Natural frequency (different traders have different rhythms)\n      const omega = 0.01 + (i / N) * 0.1;\n      \n      // Kuramoto coupling term\n      const coupling = (K / N) * Math.sin(meanPhase - this.oscillatorPhases[i]);\n      \n      // Update phase\n      const noise = (Math.random() - 0.5) * KURAMOTO_PARAMS.phaseNoise;\n      this.oscillatorPhases[i] += omega + coupling + externalForce + noise;\n      \n      // Keep phase in [0, 2π]\n      this.oscillatorPhases[i] = this.oscillatorPhases[i] % (2 * Math.PI);\n      if (this.oscillatorPhases[i] < 0) this.oscillatorPhases[i] += 2 * Math.PI;\n    }\n  }\n\n  /**\n   * Calculate Kuramoto order parameter (r, ψ)\n   * r = magnitude of synchronization (0 = random, 1 = perfect sync)\n   * ψ = collective phase\n   */\n  private calculateOrderParameter(): { r: number; psi: number } {\n    const N = this.oscillatorPhases.length;\n    let sumSin = 0;\n    let sumCos = 0;\n    \n    for (const phase of this.oscillatorPhases) {\n      sumSin += Math.sin(phase);\n      sumCos += Math.cos(phase);\n    }\n    \n    const r = Math.sqrt(sumSin * sumSin + sumCos * sumCos) / N;\n    const psi = Math.atan2(sumSin, sumCos);\n    \n    return { r, psi };\n  }\n\n  private detectDominantFrequency(): number {\n    if (this.priceHistory.length < 20) return 0.1;\n    \n    // Simple autocorrelation to find periodicity\n    const prices = this.priceHistory.slice(-50);\n    const mean = prices.reduce((a, b) => a + b, 0) / prices.length;\n    \n    let maxCorr = 0;\n    let bestLag = 1;\n    \n    for (let lag = 1; lag < prices.length / 2; lag++) {\n      let corr = 0;\n      let count = 0;\n      for (let i = lag; i < prices.length; i++) {\n        corr += (prices[i] - mean) * (prices[i - lag] - mean);\n        count++;\n      }\n      corr /= count;\n      \n      if (corr > maxCorr) {\n        maxCorr = corr;\n        bestLag = lag;\n      }\n    }\n    \n    // Convert lag to frequency (assuming ~1 tick per second)\n    return 1 / bestLag;\n  }\n\n  private determineResonanceType(r: number, bigPicture: BigPictureState): ResonanceType {\n    const momentum = bigPicture.marketSentiment;\n    const volatility = bigPicture.volatilityIndex / 100;\n    \n    if (r > KURAMOTO_PARAMS.syncThreshold) {\n      if (momentum > 0.3) return 'COHERENT_BULL';\n      if (momentum < -0.3) return 'COHERENT_BEAR';\n      return 'STABLE_OSCILLATION';\n    }\n    \n    if (r > KURAMOTO_PARAMS.bifurcationThreshold && r < KURAMOTO_PARAMS.syncThreshold) {\n      if (volatility > 0.5) return 'BIFURCATION';\n      return 'CRYSTALLIZING';\n    }\n    \n    if (volatility > 0.7) {\n      return 'PHASE_TRANSITION';\n    }\n    \n    return 'CHAOTIC_SCATTER';\n  }\n\n  private determineCollectiveMood(bigPicture: BigPictureState, r: number): CollectiveMood {\n    const sentiment = bigPicture.marketSentiment;\n    const volatility = bigPicture.volatilityIndex / 100;\n    const risk = bigPicture.riskAppetite;\n    \n    // Extreme synchronized states\n    if (r > 0.8 && sentiment > 0.7 && risk > 0.7) return 'EUPHORIA';\n    if (r > 0.8 && sentiment < -0.7 && volatility > 0.6) return 'CAPITULATION';\n    \n    // Moderate states\n    if (sentiment > 0.4) return 'OPTIMISM';\n    if (sentiment < -0.4 && volatility > 0.4) return 'ANXIETY';\n    if (sentiment < -0.6 && volatility < 0.3) return 'DEPRESSION';\n    \n    // Transition states\n    if (r < 0.4 && sentiment > 0.2 && volatility < 0.3) return 'DISBELIEF';\n    \n    return 'UNCERTAINTY';\n  }\n\n  private calculateEntrainmentStrength(r: number, bigPicture: BigPictureState): number {\n    // Entrainment = how strongly the collective is pulling individuals into sync\n    const baseEntrainment = r * 0.5;\n    const volatilityBoost = bigPicture.volatilityIndex / 100 * 0.3;\n    const signalBoost = Math.min(bigPicture.activeSignals.length * 0.05, 0.2);\n    \n    return Math.min(1, baseEntrainment + volatilityBoost + signalBoost);\n  }\n\n  private calculateBreakoutProbability(r: number, type: ResonanceType): number {\n    // High sync + crystallizing = high breakout probability\n    if (type === 'CRYSTALLIZING') return 0.7 + r * 0.2;\n    if (type === 'BIFURCATION') return 0.6;\n    if (type === 'PHASE_TRANSITION') return 0.8;\n    if (type === 'COHERENT_BULL' || type === 'COHERENT_BEAR') {\n      // Extremes tend to reverse\n      return r > 0.9 ? 0.6 : 0.3;\n    }\n    return 0.4;\n  }\n\n  private generateSignals(\n    r: number,\n    resonanceType: ResonanceType,\n    mood: CollectiveMood,\n    bigPicture: BigPictureState\n  ): ResonanceSignal[] {\n    const signals: ResonanceSignal[] = [];\n    const now = new Date();\n\n    // Synchronization signal\n    if (r > 0.8) {\n      signals.push({\n        type: 'HIGH_SYNC',\n        strength: r,\n        description: `Extreme collective synchronization (${(r * 100).toFixed(0)}%) - reversal likely`,\n        timestamp: now\n      });\n    }\n\n    // Mood transitions\n    if (mood === 'EUPHORIA') {\n      signals.push({\n        type: 'EUPHORIA_WARNING',\n        strength: 0.9,\n        description: 'Maximum greed detected - classic top signal',\n        timestamp: now\n      });\n    }\n    \n    if (mood === 'CAPITULATION') {\n      signals.push({\n        type: 'CAPITULATION_ALERT',\n        strength: 0.9,\n        description: 'Maximum fear detected - classic bottom signal',\n        timestamp: now\n      });\n    }\n\n    // Resonance type signals\n    if (resonanceType === 'CRYSTALLIZING') {\n      signals.push({\n        type: 'CRYSTALLIZATION',\n        strength: 0.75,\n        description: 'Market participants rapidly synchronizing - breakout imminent',\n        timestamp: now\n      });\n    }\n\n    if (resonanceType === 'BIFURCATION') {\n      signals.push({\n        type: 'BIFURCATION',\n        strength: 0.6,\n        description: 'Market splitting into two camps - expect volatility',\n        timestamp: now\n      });\n    }\n\n    return signals;\n  }\n\n  getState(): ResonanceState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get trading recommendation based on consciousness resonance\n   */\n  getTradingRecommendation(): {\n    action: 'BUY' | 'SELL' | 'WAIT' | 'HEDGE';\n    confidence: number;\n    reasoning: string;\n    mood: CollectiveMood;\n    synchronization: number;\n  } {\n    const { globalSynchronization, resonanceType, collectiveMood, breakoutProbability } = this.state;\n\n    let action: 'BUY' | 'SELL' | 'WAIT' | 'HEDGE';\n    let reasoning: string;\n    let confidence = 0.5;\n\n    // Contrarian signals on extreme moods\n    if (collectiveMood === 'EUPHORIA') {\n      action = 'SELL';\n      confidence = 0.85;\n      reasoning = 'EUPHORIA detected - crowd at maximum greed. Fade the crowd.';\n    } else if (collectiveMood === 'CAPITULATION') {\n      action = 'BUY';\n      confidence = 0.85;\n      reasoning = 'CAPITULATION detected - crowd at maximum fear. Buy the blood.';\n    } else if (collectiveMood === 'DISBELIEF' && globalSynchronization < 0.4) {\n      action = 'BUY';\n      confidence = 0.7;\n      reasoning = 'DISBELIEF phase - early rally not believed. Join quietly.';\n    } else if (resonanceType === 'CRYSTALLIZING') {\n      action = 'WAIT';\n      confidence = 0.6;\n      reasoning = 'CRYSTALLIZING - wait for breakout direction before entry.';\n    } else if (resonanceType === 'BIFURCATION') {\n      action = 'HEDGE';\n      confidence = 0.65;\n      reasoning = 'BIFURCATION - market splitting. Hedge both directions.';\n    } else if (globalSynchronization > 0.85 && resonanceType === 'COHERENT_BULL') {\n      action = 'SELL';\n      confidence = 0.7;\n      reasoning = 'Extreme bullish sync (>85%) - mean reversion likely.';\n    } else if (globalSynchronization > 0.85 && resonanceType === 'COHERENT_BEAR') {\n      action = 'BUY';\n      confidence = 0.7;\n      reasoning = 'Extreme bearish sync (>85%) - mean reversion likely.';\n    } else {\n      action = 'WAIT';\n      confidence = 0.4;\n      reasoning = `Normal resonance state (${(globalSynchronization * 100).toFixed(0)}% sync). No strong signal.`;\n    }\n\n    return {\n      action,\n      confidence,\n      reasoning,\n      mood: collectiveMood,\n      synchronization: globalSynchronization\n    };\n  }\n}\n\n// Export singleton\nexport const consciousnessResonanceDetector = new ConsciousnessResonanceDetector();\n// Types already exported above via interfaces\n";export{n as default};
