const n="/**\n * Global Trading Session Store\n * Persistent session management with live P&L tracking and global accuracy\n */\n\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { selfEvolvingSystem, EvolutionState } from '@/lib/pensent-core/domains/finance/selfEvolvingSystem';\n\nexport interface TradingSession {\n  id: string;\n  startedAt: number;\n  endedAt?: number;\n  startingBalance: number;\n  currentBalance: number;\n  peakBalance: number;\n  troughBalance: number;\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  totalPnl: number;\n  bestTrade: number;\n  worstTrade: number;\n  predictions: number;\n  correctPredictions: number;\n  status: 'active' | 'paused' | 'completed';\n}\n\nexport interface GlobalAccuracy {\n  totalPredictions: number;\n  correctPredictions: number;\n  accuracy: number;\n  directionAccuracy: number;\n  magnitudeAccuracy: number;\n  timingAccuracy: number;\n  confidenceCalibration: number;\n  streak: number;\n  bestStreak: number;\n  worstStreak: number;\n  currentStreak: number;\n  lastUpdated: number;\n}\n\nexport interface TradeRecord {\n  id: string;\n  sessionId: string;\n  symbol: string;\n  direction: 'long' | 'short';\n  entryPrice: number;\n  exitPrice?: number;\n  entryTime: number;\n  exitTime?: number;\n  shares: number;\n  pnl?: number;\n  pnlPercent?: number;\n  status: 'open' | 'closed';\n  predictionId?: string;\n  correlatedMoves: { symbol: string; pnl: number }[];\n}\n\ninterface TradingSessionState {\n  // Current session\n  currentSession: TradingSession | null;\n  sessionHistory: TradingSession[];\n  \n  // Active trades\n  activeTrades: TradeRecord[];\n  tradeHistory: TradeRecord[];\n  \n  // Global accuracy (persists across sessions)\n  globalAccuracy: GlobalAccuracy;\n  \n  // Evolution state\n  evolutionState: EvolutionState;\n  \n  // Live metrics\n  liveMetrics: {\n    ticksProcessed: number;\n    predictionsMade: number;\n    lastPredictionTime: number;\n    currentSymbol: string;\n    isStreaming: boolean;\n  };\n  \n  // Actions\n  startSession: (startingBalance?: number) => void;\n  pauseSession: () => void;\n  resumeSession: () => void;\n  endSession: () => void;\n  \n  // Trading actions\n  openTrade: (trade: Omit<TradeRecord, 'id' | 'sessionId' | 'status' | 'correlatedMoves'>) => TradeRecord;\n  closeTrade: (tradeId: string, exitPrice: number) => TradeRecord | null;\n  updateTradePrice: (tradeId: string, currentPrice: number, correlatedPrices: Map<string, number>) => void;\n  \n  // Prediction tracking\n  recordPrediction: (prediction: {\n    predicted: 'up' | 'down' | 'neutral';\n    actual: 'up' | 'down' | 'neutral';\n    confidence: number;\n    directionCorrect: boolean;\n    magnitudeAccuracy: number;\n    timingAccuracy: number;\n    marketConditions: {\n      correlationStrength: number;\n      volatility: number;\n      momentum: number;\n      leadingSignals: number;\n    };\n  }) => void;\n  \n  // Metrics\n  updateLiveMetrics: (metrics: Partial<TradingSessionState['liveMetrics']>) => void;\n  \n  // Evolution sync\n  syncEvolutionState: () => void;\n  \n  // Stats\n  getSessionStats: () => {\n    totalGrowth: number;\n    growthPercent: number;\n    winRate: number;\n    avgTradePnl: number;\n    sessionDuration: number;\n  };\n  \n  getAllTimeStats: () => {\n    totalSessions: number;\n    totalTrades: number;\n    totalPnl: number;\n    overallWinRate: number;\n    bestSession: number;\n    avgSessionGrowth: number;\n  };\n  \n  // Reset\n  resetSession: () => void;\n  resetAllData: () => void;\n}\n\nconst DEFAULT_STARTING_BALANCE = 1000;\n\nconst createDefaultGlobalAccuracy = (): GlobalAccuracy => ({\n  totalPredictions: 0,\n  correctPredictions: 0,\n  accuracy: 0,\n  directionAccuracy: 0,\n  magnitudeAccuracy: 0,\n  timingAccuracy: 0,\n  confidenceCalibration: 0,\n  streak: 0,\n  bestStreak: 0,\n  worstStreak: 0,\n  currentStreak: 0,\n  lastUpdated: Date.now()\n});\n\nexport const useTradingSessionStore = create<TradingSessionState>()(\n  persist(\n    (set, get) => ({\n      currentSession: null,\n      sessionHistory: [],\n      activeTrades: [],\n      tradeHistory: [],\n      globalAccuracy: createDefaultGlobalAccuracy(),\n      evolutionState: selfEvolvingSystem.getState(),\n      liveMetrics: {\n        ticksProcessed: 0,\n        predictionsMade: 0,\n        lastPredictionTime: 0,\n        currentSymbol: 'SPY',\n        isStreaming: false\n      },\n      \n      startSession: (startingBalance = DEFAULT_STARTING_BALANCE) => {\n        const existingSession = get().currentSession;\n        \n        // v7.51-UNIFIED: If session exists and is active/paused, just resume it - NEVER reset\n        if (existingSession && existingSession.status !== 'completed') {\n          set(state => ({\n            currentSession: {\n              ...existingSession,\n              status: 'active'\n            },\n            liveMetrics: {\n              ...state.liveMetrics,\n              isStreaming: true\n            }\n          }));\n          return;\n        }\n        \n        // Create new session with provided balance (preserves progress when continuing)\n        const session: TradingSession = {\n          id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          startedAt: Date.now(),\n          startingBalance,\n          currentBalance: startingBalance,\n          peakBalance: startingBalance,\n          troughBalance: startingBalance,\n          totalTrades: 0,\n          winningTrades: 0,\n          losingTrades: 0,\n          totalPnl: 0,\n          bestTrade: 0,\n          worstTrade: 0,\n          predictions: 0,\n          correctPredictions: 0,\n          status: 'active'\n        };\n        \n        set({ \n          currentSession: session, \n          activeTrades: [],\n          liveMetrics: {\n            ...get().liveMetrics,\n            isStreaming: true\n          }\n        });\n      },\n      \n      pauseSession: () => {\n        set(state => ({\n          currentSession: state.currentSession ? {\n            ...state.currentSession,\n            status: 'paused'\n          } : null,\n          liveMetrics: {\n            ...state.liveMetrics,\n            isStreaming: false\n          }\n        }));\n      },\n      \n      resumeSession: () => {\n        set(state => ({\n          currentSession: state.currentSession ? {\n            ...state.currentSession,\n            status: 'active'\n          } : null,\n          liveMetrics: {\n            ...state.liveMetrics,\n            isStreaming: true\n          }\n        }));\n      },\n      \n      endSession: () => {\n        const { currentSession, activeTrades } = get();\n        if (!currentSession) return;\n        \n        // Close all open trades at current prices\n        const closedTrades = activeTrades.map(t => ({\n          ...t,\n          status: 'closed' as const,\n          exitTime: Date.now()\n        }));\n        \n        const completedSession: TradingSession = {\n          ...currentSession,\n          endedAt: Date.now(),\n          status: 'completed'\n        };\n        \n        set(state => ({\n          currentSession: null,\n          sessionHistory: [completedSession, ...state.sessionHistory].slice(0, 100),\n          activeTrades: [],\n          tradeHistory: [...closedTrades, ...state.tradeHistory].slice(0, 1000),\n          liveMetrics: {\n            ...state.liveMetrics,\n            isStreaming: false\n          }\n        }));\n      },\n      \n      openTrade: (trade) => {\n        const { currentSession } = get();\n        if (!currentSession) {\n          get().startSession();\n        }\n        \n        const newTrade: TradeRecord = {\n          ...trade,\n          id: `trade_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          sessionId: get().currentSession?.id || 'unknown',\n          status: 'open',\n          correlatedMoves: []\n        };\n        \n        set(state => ({\n          activeTrades: [...state.activeTrades, newTrade],\n          currentSession: state.currentSession ? {\n            ...state.currentSession,\n            totalTrades: state.currentSession.totalTrades + 1\n          } : null\n        }));\n        \n        return newTrade;\n      },\n      \n      closeTrade: (tradeId, exitPrice) => {\n        const { activeTrades, currentSession } = get();\n        const trade = activeTrades.find(t => t.id === tradeId);\n        if (!trade || !currentSession) return null;\n        \n        const pnl = trade.direction === 'long'\n          ? (exitPrice - trade.entryPrice) * trade.shares\n          : (trade.entryPrice - exitPrice) * trade.shares;\n        const pnlPercent = (pnl / (trade.entryPrice * trade.shares)) * 100;\n        \n        const closedTrade: TradeRecord = {\n          ...trade,\n          exitPrice,\n          exitTime: Date.now(),\n          pnl,\n          pnlPercent,\n          status: 'closed'\n        };\n        \n        const isWin = pnl > 0;\n        const newBalance = currentSession.currentBalance + pnl;\n        \n        set(state => ({\n          activeTrades: state.activeTrades.filter(t => t.id !== tradeId),\n          tradeHistory: [closedTrade, ...state.tradeHistory].slice(0, 1000),\n          currentSession: state.currentSession ? {\n            ...state.currentSession,\n            currentBalance: newBalance,\n            peakBalance: Math.max(state.currentSession.peakBalance, newBalance),\n            troughBalance: Math.min(state.currentSession.troughBalance, newBalance),\n            totalPnl: state.currentSession.totalPnl + pnl,\n            winningTrades: state.currentSession.winningTrades + (isWin ? 1 : 0),\n            losingTrades: state.currentSession.losingTrades + (isWin ? 0 : 1),\n            bestTrade: Math.max(state.currentSession.bestTrade, pnl),\n            worstTrade: Math.min(state.currentSession.worstTrade, pnl)\n          } : null\n        }));\n        \n        return closedTrade;\n      },\n      \n      updateTradePrice: (tradeId, currentPrice, correlatedPrices) => {\n        set(state => ({\n          activeTrades: state.activeTrades.map(trade => {\n            if (trade.id !== tradeId) return trade;\n            \n            const pnl = trade.direction === 'long'\n              ? (currentPrice - trade.entryPrice) * trade.shares\n              : (trade.entryPrice - currentPrice) * trade.shares;\n            \n            const correlatedMoves = Array.from(correlatedPrices.entries()).map(([symbol, price]) => ({\n              symbol,\n              pnl: ((price - trade.entryPrice) / trade.entryPrice) * (trade.entryPrice * trade.shares)\n            }));\n            \n            return {\n              ...trade,\n              pnl,\n              pnlPercent: (pnl / (trade.entryPrice * trade.shares)) * 100,\n              correlatedMoves\n            };\n          }),\n          currentSession: state.currentSession ? {\n            ...state.currentSession,\n            currentBalance: state.currentSession.startingBalance + \n              state.activeTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) +\n              state.currentSession.totalPnl\n          } : null\n        }));\n      },\n      \n      recordPrediction: (prediction) => {\n        // Update self-evolving system\n        selfEvolvingSystem.processOutcome({\n          predicted: prediction.predicted,\n          actual: prediction.actual,\n          confidence: prediction.confidence,\n          marketConditions: prediction.marketConditions\n        });\n        \n        // Update global accuracy\n        set(state => {\n          const isCorrect = prediction.directionCorrect;\n          const newStreak = isCorrect \n            ? (state.globalAccuracy.currentStreak >= 0 ? state.globalAccuracy.currentStreak + 1 : 1)\n            : (state.globalAccuracy.currentStreak <= 0 ? state.globalAccuracy.currentStreak - 1 : -1);\n          \n          const totalPredictions = state.globalAccuracy.totalPredictions + 1;\n          const correctPredictions = state.globalAccuracy.correctPredictions + (isCorrect ? 1 : 0);\n          \n          // Exponential moving averages for multi-level accuracy\n          const alpha = 0.1;\n          const directionAccuracy = state.globalAccuracy.directionAccuracy * (1 - alpha) + \n            (isCorrect ? 1 : 0) * alpha;\n          const magnitudeAccuracy = state.globalAccuracy.magnitudeAccuracy * (1 - alpha) + \n            prediction.magnitudeAccuracy * alpha;\n          const timingAccuracy = state.globalAccuracy.timingAccuracy * (1 - alpha) + \n            prediction.timingAccuracy * alpha;\n          const confidenceCalibration = state.globalAccuracy.confidenceCalibration * (1 - alpha) + \n            (1 - Math.abs(prediction.confidence - (isCorrect ? 1 : 0))) * alpha;\n          \n          return {\n            globalAccuracy: {\n              totalPredictions,\n              correctPredictions,\n              accuracy: (correctPredictions / totalPredictions) * 100,\n              directionAccuracy: directionAccuracy * 100,\n              magnitudeAccuracy: magnitudeAccuracy * 100,\n              timingAccuracy: timingAccuracy * 100,\n              confidenceCalibration: confidenceCalibration * 100,\n              streak: state.globalAccuracy.streak + (isCorrect ? 1 : -1),\n              bestStreak: Math.max(state.globalAccuracy.bestStreak, newStreak),\n              worstStreak: Math.min(state.globalAccuracy.worstStreak, newStreak),\n              currentStreak: newStreak,\n              lastUpdated: Date.now()\n            },\n            evolutionState: selfEvolvingSystem.getState(),\n            currentSession: state.currentSession ? {\n              ...state.currentSession,\n              predictions: state.currentSession.predictions + 1,\n              correctPredictions: state.currentSession.correctPredictions + (isCorrect ? 1 : 0)\n            } : null,\n            liveMetrics: {\n              ...state.liveMetrics,\n              predictionsMade: state.liveMetrics.predictionsMade + 1,\n              lastPredictionTime: Date.now()\n            }\n          };\n        });\n      },\n      \n      updateLiveMetrics: (metrics) => {\n        set(state => ({\n          liveMetrics: {\n            ...state.liveMetrics,\n            ...metrics\n          }\n        }));\n      },\n      \n      syncEvolutionState: () => {\n        set({ evolutionState: selfEvolvingSystem.getState() });\n      },\n      \n      getSessionStats: () => {\n        const { currentSession } = get();\n        if (!currentSession) {\n          return {\n            totalGrowth: 0,\n            growthPercent: 0,\n            winRate: 0,\n            avgTradePnl: 0,\n            sessionDuration: 0\n          };\n        }\n        \n        const growth = currentSession.currentBalance - currentSession.startingBalance;\n        const completedTrades = currentSession.winningTrades + currentSession.losingTrades;\n        \n        return {\n          totalGrowth: growth,\n          growthPercent: (growth / currentSession.startingBalance) * 100,\n          winRate: completedTrades > 0 ? (currentSession.winningTrades / completedTrades) * 100 : 0,\n          avgTradePnl: completedTrades > 0 ? currentSession.totalPnl / completedTrades : 0,\n          sessionDuration: Date.now() - currentSession.startedAt\n        };\n      },\n      \n      getAllTimeStats: () => {\n        const { sessionHistory, currentSession } = get();\n        const allSessions = currentSession \n          ? [currentSession, ...sessionHistory] \n          : sessionHistory;\n        \n        if (allSessions.length === 0) {\n          return {\n            totalSessions: 0,\n            totalTrades: 0,\n            totalPnl: 0,\n            overallWinRate: 0,\n            bestSession: 0,\n            avgSessionGrowth: 0\n          };\n        }\n        \n        const totalTrades = allSessions.reduce((sum, s) => sum + s.totalTrades, 0);\n        const totalWins = allSessions.reduce((sum, s) => sum + s.winningTrades, 0);\n        const totalPnl = allSessions.reduce((sum, s) => sum + s.totalPnl, 0);\n        const growths = allSessions.map(s => s.currentBalance - s.startingBalance);\n        \n        return {\n          totalSessions: allSessions.length,\n          totalTrades,\n          totalPnl,\n          overallWinRate: totalTrades > 0 ? (totalWins / totalTrades) * 100 : 0,\n          bestSession: Math.max(...growths),\n          avgSessionGrowth: growths.reduce((a, b) => a + b, 0) / growths.length\n        };\n      },\n      \n      resetSession: () => {\n        set({\n          currentSession: null,\n          activeTrades: [],\n          liveMetrics: {\n            ticksProcessed: 0,\n            predictionsMade: 0,\n            lastPredictionTime: 0,\n            currentSymbol: 'SPY',\n            isStreaming: false\n          }\n        });\n      },\n      \n      resetAllData: () => {\n        set({\n          currentSession: null,\n          sessionHistory: [],\n          activeTrades: [],\n          tradeHistory: [],\n          globalAccuracy: createDefaultGlobalAccuracy(),\n          evolutionState: selfEvolvingSystem.getState(),\n          liveMetrics: {\n            ticksProcessed: 0,\n            predictionsMade: 0,\n            lastPredictionTime: 0,\n            currentSymbol: 'SPY',\n            isStreaming: false\n          }\n        });\n      }\n    }),\n    {\n      name: 'trading-session-storage',\n      partialize: (state) => ({\n        sessionHistory: state.sessionHistory,\n        tradeHistory: state.tradeHistory,\n        globalAccuracy: state.globalAccuracy\n      })\n    }\n  )\n);\n";export{n as default};
