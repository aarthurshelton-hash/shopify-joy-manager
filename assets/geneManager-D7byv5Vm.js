const n="/**\n * Gene Manager - Handles gene mutations and performance tracking\n */\n\nimport { LearningGene, Mutation, MarketConditions } from './types';\n\nexport const DEFAULT_GENES: LearningGene[] = [\n  { name: 'correlationWeight', value: 0.3, minValue: 0.1, maxValue: 0.6, mutationRate: 0.02, lastMutation: 0, performanceImpact: 0 },\n  { name: 'momentumWeight', value: 0.25, minValue: 0.1, maxValue: 0.5, mutationRate: 0.02, lastMutation: 0, performanceImpact: 0 },\n  { name: 'volatilityWeight', value: 0.2, minValue: 0.05, maxValue: 0.4, mutationRate: 0.02, lastMutation: 0, performanceImpact: 0 },\n  { name: 'sentimentWeight', value: 0.15, minValue: 0.05, maxValue: 0.3, mutationRate: 0.02, lastMutation: 0, performanceImpact: 0 },\n  { name: 'leadingIndicatorLag', value: 3, minValue: 1, maxValue: 10, mutationRate: 0.05, lastMutation: 0, performanceImpact: 0 },\n  { name: 'confidenceThreshold', value: 0.6, minValue: 0.4, maxValue: 0.9, mutationRate: 0.01, lastMutation: 0, performanceImpact: 0 },\n  { name: 'adaptationSpeed', value: 0.1, minValue: 0.01, maxValue: 0.3, mutationRate: 0.01, lastMutation: 0, performanceImpact: 0 },\n  { name: 'patternDecayRate', value: 0.95, minValue: 0.8, maxValue: 0.99, mutationRate: 0.005, lastMutation: 0, performanceImpact: 0 },\n];\n\nexport function updateGenePerformance(\n  genes: LearningGene[],\n  wasCorrect: boolean,\n  conditions: MarketConditions\n): void {\n  const impact = wasCorrect ? 0.1 : -0.1;\n  \n  genes.forEach(gene => {\n    let geneImpact = 0;\n    \n    switch (gene.name) {\n      case 'correlationWeight':\n        geneImpact = impact * conditions.correlationStrength;\n        break;\n      case 'momentumWeight':\n        geneImpact = impact * Math.abs(conditions.momentum);\n        break;\n      case 'volatilityWeight':\n        geneImpact = impact * (1 - conditions.volatility);\n        break;\n      case 'leadingIndicatorLag':\n        geneImpact = impact * conditions.leadingSignals;\n        break;\n      default:\n        geneImpact = impact * 0.5;\n    }\n    \n    gene.performanceImpact = gene.performanceImpact * 0.95 + geneImpact * 0.05;\n  });\n}\n\nexport function mutateGenes(genes: LearningGene[], currentFitness: number): Mutation[] {\n  const mutations: Mutation[] = [];\n  \n  genes.forEach(gene => {\n    if (Math.random() < gene.mutationRate) {\n      const previousValue = gene.value;\n      \n      let mutation = (Math.random() - 0.5) * 0.1 * (gene.maxValue - gene.minValue);\n      \n      if (gene.performanceImpact < -0.05) {\n        mutation *= -2;\n      }\n      \n      gene.value = Math.max(gene.minValue, Math.min(gene.maxValue, gene.value + mutation));\n      gene.lastMutation = Date.now();\n      \n      mutations.push({\n        gene: gene.name,\n        previousValue,\n        newValue: gene.value,\n        timestamp: Date.now(),\n        reason: gene.performanceImpact < 0 ? 'Poor performance' : 'Random exploration',\n        resultingFitness: currentFitness\n      });\n    }\n  });\n  \n  return mutations;\n}\n\nexport function getGeneValue(genes: LearningGene[], name: string): number {\n  return genes.find(g => g.name === name)?.value ?? 0;\n}\n";export{n as default};
