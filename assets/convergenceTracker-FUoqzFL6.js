const n="/**\n * Cross-Domain Convergence Tracker\n * Logs and analyzes moments when multiple domains align\n * Statistical improbability of convergence = evidence of universal pattern\n */\n\nimport { DomainType, DomainSignature, UnifiedPrediction } from '../types';\n\n// Convergence Event Structure\nexport interface ConvergenceEvent {\n  id: string;\n  timestamp: number;\n  alignedDomains: DomainType[];\n  alignmentCount: number;\n  direction: 'bullish' | 'bearish' | 'neutral';\n  averageConfidence: number;\n  momentumConsensus: number;\n  statisticalImprobability: number; // How unlikely this alignment is by chance\n  prediction?: UnifiedPrediction;\n  outcome?: {\n    actualDirection: 'up' | 'down' | 'neutral';\n    magnitude: number;\n    resolvedAt: number;\n    wasCorrect: boolean;\n  };\n}\n\n// Alignment Thresholds\nexport const ALIGNMENT_THRESHOLDS = {\n  strong: 0.7,    // 70% agreement in momentum direction\n  moderate: 0.5,  // 50% agreement\n  weak: 0.3       // 30% agreement\n};\n\n// Statistical significance levels\nexport const SIGNIFICANCE_LEVELS = {\n  highly_significant: 0.99,  // <1% chance by random\n  significant: 0.95,         // <5% chance by random\n  marginally_significant: 0.90, // <10% chance by random\n  not_significant: 0.0       // Could be random\n};\n\n// Calculate probability of N domains aligning by chance\nfunction calculateChanceProbability(alignedCount: number, totalDomains: number): number {\n  // If each domain has ~50% chance of agreeing with a direction\n  // P(N align) = 0.5^N + 0.5^N = 2 * 0.5^N = 0.5^(N-1)\n  // This is simplified - real calculation considers strength of agreement\n  const chanceOfAlignment = Math.pow(0.5, alignedCount - 1);\n  return chanceOfAlignment;\n}\n\n// Calculate statistical improbability (1 - chance probability)\nexport function calculateStatisticalImprobability(\n  alignedCount: number, \n  totalDomains: number,\n  averageAlignmentStrength: number\n): number {\n  const baseProbability = calculateChanceProbability(alignedCount, totalDomains);\n  // Adjust for strength of alignment (stronger = more improbable)\n  const adjustedProbability = baseProbability * (2 - averageAlignmentStrength);\n  return 1 - Math.min(1, adjustedProbability);\n}\n\n// Convergence Tracker Class\nexport class ConvergenceTracker {\n  private events: ConvergenceEvent[] = [];\n  private totalDomains: number;\n  private minimumAlignmentForEvent: number;\n\n  constructor(totalDomains: number = 21, minimumAlignment: number = 10) {\n    this.totalDomains = totalDomains;\n    this.minimumAlignmentForEvent = minimumAlignment;\n  }\n\n  // Analyze domain signatures for convergence\n  analyzeConvergence(signatures: Map<DomainType, DomainSignature>): ConvergenceEvent | null {\n    const domains = Array.from(signatures.entries());\n    \n    if (domains.length < this.minimumAlignmentForEvent) {\n      return null; // Not enough domains to analyze\n    }\n\n    // Calculate momentum direction consensus\n    const bullishDomains: DomainType[] = [];\n    const bearishDomains: DomainType[] = [];\n    const neutralDomains: DomainType[] = [];\n\n    let totalMomentum = 0;\n    let totalConfidence = 0;\n\n    for (const [domain, signature] of domains) {\n      totalMomentum += signature.momentum;\n      totalConfidence += signature.intensity * signature.harmonicResonance;\n\n      if (signature.momentum > 0.2) {\n        bullishDomains.push(domain);\n      } else if (signature.momentum < -0.2) {\n        bearishDomains.push(domain);\n      } else {\n        neutralDomains.push(domain);\n      }\n    }\n\n    // Determine which direction has convergence\n    const maxAlignment = Math.max(bullishDomains.length, bearishDomains.length);\n    \n    // Check if we meet minimum threshold\n    if (maxAlignment < this.minimumAlignmentForEvent) {\n      return null;\n    }\n\n    const direction = bullishDomains.length > bearishDomains.length ? 'bullish' : \n                     bearishDomains.length > bullishDomains.length ? 'bearish' : 'neutral';\n    \n    const alignedDomains = direction === 'bullish' ? bullishDomains : \n                           direction === 'bearish' ? bearishDomains : neutralDomains;\n\n    const averageConfidence = totalConfidence / domains.length;\n    const momentumConsensus = Math.abs(totalMomentum) / domains.length;\n\n    // Calculate how improbable this alignment is\n    const statisticalImprobability = calculateStatisticalImprobability(\n      alignedDomains.length,\n      this.totalDomains,\n      momentumConsensus\n    );\n\n    const event: ConvergenceEvent = {\n      id: `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n      alignedDomains,\n      alignmentCount: alignedDomains.length,\n      direction,\n      averageConfidence,\n      momentumConsensus,\n      statisticalImprobability\n    };\n\n    // Only record significant convergence events\n    if (statisticalImprobability >= SIGNIFICANCE_LEVELS.marginally_significant) {\n      this.events.push(event);\n      this.pruneOldEvents();\n    }\n\n    return event;\n  }\n\n  // Record outcome for a convergence event\n  recordOutcome(\n    eventId: string, \n    actualDirection: 'up' | 'down' | 'neutral',\n    magnitude: number\n  ): void {\n    const event = this.events.find(e => e.id === eventId);\n    if (!event) return;\n\n    const predictedDirection = event.direction === 'bullish' ? 'up' : \n                               event.direction === 'bearish' ? 'down' : 'neutral';\n    \n    event.outcome = {\n      actualDirection,\n      magnitude,\n      resolvedAt: Date.now(),\n      wasCorrect: actualDirection === predictedDirection\n    };\n  }\n\n  // Get convergence accuracy statistics\n  getAccuracyStats(): {\n    totalEvents: number;\n    resolvedEvents: number;\n    correctPredictions: number;\n    accuracy: number;\n    avgImprobabilityForCorrect: number;\n    avgImprobabilityForIncorrect: number;\n  } {\n    const resolvedEvents = this.events.filter(e => e.outcome);\n    const correctEvents = resolvedEvents.filter(e => e.outcome?.wasCorrect);\n    const incorrectEvents = resolvedEvents.filter(e => !e.outcome?.wasCorrect);\n\n    const avgImprobabilityForCorrect = correctEvents.length > 0 ?\n      correctEvents.reduce((sum, e) => sum + e.statisticalImprobability, 0) / correctEvents.length : 0;\n    \n    const avgImprobabilityForIncorrect = incorrectEvents.length > 0 ?\n      incorrectEvents.reduce((sum, e) => sum + e.statisticalImprobability, 0) / incorrectEvents.length : 0;\n\n    return {\n      totalEvents: this.events.length,\n      resolvedEvents: resolvedEvents.length,\n      correctPredictions: correctEvents.length,\n      accuracy: resolvedEvents.length > 0 ? correctEvents.length / resolvedEvents.length : 0,\n      avgImprobabilityForCorrect,\n      avgImprobabilityForIncorrect\n    };\n  }\n\n  // Get recent convergence events\n  getRecentEvents(limit: number = 20): ConvergenceEvent[] {\n    return [...this.events]\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  // Get most significant events (highest improbability)\n  getMostSignificantEvents(limit: number = 10): ConvergenceEvent[] {\n    return [...this.events]\n      .sort((a, b) => b.statisticalImprobability - a.statisticalImprobability)\n      .slice(0, limit);\n  }\n\n  // Prune events older than 30 days\n  private pruneOldEvents(): void {\n    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\n    this.events = this.events.filter(e => e.timestamp > thirtyDaysAgo);\n  }\n\n  // Export events for persistence\n  exportEvents(): ConvergenceEvent[] {\n    return [...this.events];\n  }\n\n  // Import events from persistence\n  importEvents(events: ConvergenceEvent[]): void {\n    this.events = events;\n  }\n\n  // Calculate proof strength based on convergence data\n  calculateProofStrength(): {\n    evidenceScore: number;\n    sampleSize: number;\n    pValue: number;\n    conclusion: string;\n  } {\n    const stats = this.getAccuracyStats();\n    \n    // Simple binomial test approximation\n    // If convergence events are random, accuracy should be ~33% (bullish/bearish/neutral)\n    // If accuracy is significantly higher, convergence has predictive value\n    \n    const expectedAccuracy = 0.33;\n    const observedAccuracy = stats.accuracy;\n    const n = stats.resolvedEvents;\n    \n    // Standard error of proportion\n    const se = Math.sqrt(expectedAccuracy * (1 - expectedAccuracy) / Math.max(1, n));\n    \n    // Z-score\n    const z = (observedAccuracy - expectedAccuracy) / Math.max(0.01, se);\n    \n    // Approximate p-value (one-tailed)\n    const pValue = 1 - this.normalCDF(z);\n    \n    // Evidence score (0-1)\n    const evidenceScore = Math.min(1, Math.max(0, (observedAccuracy - expectedAccuracy) * 3));\n    \n    let conclusion: string;\n    if (n < 30) {\n      conclusion = 'Insufficient data for statistical conclusion';\n    } else if (pValue < 0.01) {\n      conclusion = 'Strong evidence: Convergence significantly predicts outcomes';\n    } else if (pValue < 0.05) {\n      conclusion = 'Moderate evidence: Convergence appears predictive';\n    } else if (pValue < 0.10) {\n      conclusion = 'Weak evidence: Possible predictive value, more data needed';\n    } else {\n      conclusion = 'No significant evidence: Convergence may be coincidental';\n    }\n\n    return {\n      evidenceScore,\n      sampleSize: n,\n      pValue,\n      conclusion\n    };\n  }\n\n  // Helper: Normal CDF approximation\n  private normalCDF(x: number): number {\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x) / Math.sqrt(2);\n\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n    return 0.5 * (1.0 + sign * y);\n  }\n}\n\n// Singleton instance\nexport const convergenceTracker = new ConvergenceTracker(21, 10);\n\n// Export for use\nexport default convergenceTracker;\n";export{n as default};
