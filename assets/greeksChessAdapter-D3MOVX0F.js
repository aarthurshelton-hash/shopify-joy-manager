const e="/**\n * Greeks-Chess Adapter - Options Greeks ↔ Chess Constraints Mapping\n * \n * Formalizes the profound parallel between Options Greeks and Chess game dynamics:\n * - Δ Delta ↔ Material Balance (directional edge)\n * - Γ Gamma ↔ Tactical Sharpness (acceleration)\n * - Θ Theta ↔ Time Control Pressure (decay)\n * - ν Vega ↔ Position Complexity (volatility)\n * - ρ Rho ↔ Long-term Positional Factors\n * \n * @version 1.0-GREEKS-CHESS\n * @inventor Alec Arthur Shelton\n */\n\nexport interface GreeksProfile {\n  delta: number;      // -1 to 1 (directional sensitivity)\n  gamma: number;      // 0 to 1 (acceleration/sharpness)\n  theta: number;      // 0 to 1 (time pressure intensity)\n  vega: number;       // 0 to 1 (volatility/complexity sensitivity)\n  rho: number;        // 0 to 1 (long-term factor weight)\n}\n\nexport interface ChessConstraints {\n  timeControl: 'bullet' | 'blitz' | 'rapid' | 'classical';\n  materialBalance: number;     // -39 to +39 (standard piece values)\n  tacticalSharpness: number;   // 0 to 1 (position complexity)\n  pieceActivity: number;       // 0 to 1 (how active pieces are)\n  pawnStructure: number;       // 0 to 1 (structural integrity)\n  kingSafety: number;          // 0 to 1 (king exposure)\n}\n\nexport interface GreeksChessMapping {\n  greeks: GreeksProfile;\n  chessEquivalent: ChessConstraints;\n  optionsImplication: {\n    preferredStrategy: 'long_calls' | 'long_puts' | 'spreads' | 'iron_condor' | 'straddle' | 'strangle';\n    optimalExpiration: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'leaps';\n    riskLevel: 'aggressive' | 'moderate' | 'conservative';\n  };\n  confidenceBoost: number;\n}\n\n// Time control → Theta/Expiration mapping\nconst TIME_CONTROL_GREEKS: Record<string, { theta: number; expiration: string }> = {\n  'bullet': { theta: 0.95, expiration: 'daily' },      // Extreme time pressure = 0DTE\n  'blitz': { theta: 0.75, expiration: 'weekly' },      // Fast decay\n  'rapid': { theta: 0.45, expiration: 'monthly' },     // Balanced\n  'classical': { theta: 0.15, expiration: 'quarterly' }, // Low theta, Rho matters\n};\n\n// Material balance → Delta mapping\nfunction materialToDelta(materialBalance: number): number {\n  // Material ranges from -39 (black dominating) to +39 (white dominating)\n  // Delta ranges from -1 to 1\n  const normalized = Math.max(-1, Math.min(1, materialBalance / 20));\n  return normalized;\n}\n\n// Tactical sharpness → Gamma mapping\nfunction sharpnessToGamma(tacticalSharpness: number, pieceCount: number): number {\n  // High piece count + tactical complexity = high gamma\n  // Simplified positions = low gamma\n  const pieceMultiplier = Math.min(1, pieceCount / 32);\n  return tacticalSharpness * pieceMultiplier;\n}\n\n// Position complexity → Vega mapping\nfunction complexityToVega(pieceActivity: number, tacticalSharpness: number): number {\n  // Complex positions with active pieces = high vega (benefits from volatility)\n  // Quiet positions = low vega\n  return (pieceActivity * 0.6 + tacticalSharpness * 0.4);\n}\n\n// Pawn structure/long-term factors → Rho mapping\nfunction structureToRho(pawnStructure: number, timeControl: string): number {\n  // Long-term positional factors matter more in classical\n  const timeMultiplier = timeControl === 'classical' ? 1.0 : \n                         timeControl === 'rapid' ? 0.7 :\n                         timeControl === 'blitz' ? 0.4 : 0.2;\n  return pawnStructure * timeMultiplier;\n}\n\nclass GreeksChessAdapter {\n  private analysisHistory: GreeksChessMapping[] = [];\n  \n  /**\n   * Convert chess position constraints to Options Greeks profile\n   */\n  chessToGreeks(constraints: ChessConstraints): GreeksProfile {\n    const timeGreeks = TIME_CONTROL_GREEKS[constraints.timeControl] || TIME_CONTROL_GREEKS['rapid'];\n    \n    return {\n      delta: materialToDelta(constraints.materialBalance),\n      gamma: sharpnessToGamma(constraints.tacticalSharpness, 32), // Assume full piece count initially\n      theta: timeGreeks.theta,\n      vega: complexityToVega(constraints.pieceActivity, constraints.tacticalSharpness),\n      rho: structureToRho(constraints.pawnStructure, constraints.timeControl),\n    };\n  }\n  \n  /**\n   * Convert Options Greeks to equivalent chess constraints\n   */\n  greeksToChess(greeks: GreeksProfile): ChessConstraints {\n    // Reverse mapping\n    let timeControl: ChessConstraints['timeControl'] = 'rapid';\n    if (greeks.theta > 0.85) timeControl = 'bullet';\n    else if (greeks.theta > 0.6) timeControl = 'blitz';\n    else if (greeks.theta > 0.3) timeControl = 'rapid';\n    else timeControl = 'classical';\n    \n    return {\n      timeControl,\n      materialBalance: Math.round(greeks.delta * 20),\n      tacticalSharpness: greeks.gamma,\n      pieceActivity: greeks.vega * 0.8 + greeks.gamma * 0.2,\n      pawnStructure: greeks.rho,\n      kingSafety: 1 - greeks.gamma * 0.5, // High gamma = risky king positions\n    };\n  }\n  \n  /**\n   * Generate full mapping with trading implications\n   */\n  generateMapping(constraints: ChessConstraints): GreeksChessMapping {\n    const greeks = this.chessToGreeks(constraints);\n    \n    // Determine optimal strategy based on Greeks profile\n    let preferredStrategy: GreeksChessMapping['optionsImplication']['preferredStrategy'];\n    let riskLevel: GreeksChessMapping['optionsImplication']['riskLevel'];\n    \n    // High delta (directional edge) → directional trades\n    if (Math.abs(greeks.delta) > 0.6) {\n      preferredStrategy = greeks.delta > 0 ? 'long_calls' : 'long_puts';\n      riskLevel = 'aggressive';\n    }\n    // High gamma (tactical sharpness) → benefit from big moves\n    else if (greeks.gamma > 0.7) {\n      preferredStrategy = 'straddle';\n      riskLevel = 'aggressive';\n    }\n    // High vega (complexity) → volatility plays\n    else if (greeks.vega > 0.7) {\n      preferredStrategy = 'strangle';\n      riskLevel = 'moderate';\n    }\n    // Low volatility, neutral → collect premium\n    else if (greeks.gamma < 0.3 && Math.abs(greeks.delta) < 0.3) {\n      preferredStrategy = 'iron_condor';\n      riskLevel = 'conservative';\n    }\n    // Default to spreads for balanced risk\n    else {\n      preferredStrategy = 'spreads';\n      riskLevel = 'moderate';\n    }\n    \n    // Determine expiration from theta\n    const timeGreeks = TIME_CONTROL_GREEKS[constraints.timeControl];\n    const optimalExpiration = timeGreeks?.expiration as GreeksChessMapping['optionsImplication']['optimalExpiration'] || 'weekly';\n    \n    // Calculate confidence boost based on alignment\n    const alignmentScore = this.calculateAlignmentScore(greeks, constraints);\n    \n    const mapping: GreeksChessMapping = {\n      greeks,\n      chessEquivalent: constraints,\n      optionsImplication: {\n        preferredStrategy,\n        optimalExpiration,\n        riskLevel,\n      },\n      confidenceBoost: alignmentScore,\n    };\n    \n    this.analysisHistory.push(mapping);\n    if (this.analysisHistory.length > 100) this.analysisHistory.shift();\n    \n    return mapping;\n  }\n  \n  /**\n   * Calculate alignment score between Greeks and chess position\n   * Higher alignment = higher confidence in the parallel\n   */\n  private calculateAlignmentScore(greeks: GreeksProfile, constraints: ChessConstraints): number {\n    let score = 0;\n    \n    // Theta-time control alignment\n    const expectedTheta = TIME_CONTROL_GREEKS[constraints.timeControl]?.theta || 0.5;\n    const thetaAlignment = 1 - Math.abs(greeks.theta - expectedTheta);\n    score += thetaAlignment * 0.25;\n    \n    // Delta-material alignment (strong material = strong delta)\n    const materialStrength = Math.abs(constraints.materialBalance) / 20;\n    const deltaStrength = Math.abs(greeks.delta);\n    const deltaAlignment = 1 - Math.abs(materialStrength - deltaStrength);\n    score += deltaAlignment * 0.25;\n    \n    // Gamma-tactical alignment\n    const gammaAlignment = 1 - Math.abs(greeks.gamma - constraints.tacticalSharpness);\n    score += gammaAlignment * 0.20;\n    \n    // Vega-activity alignment\n    const vegaAlignment = 1 - Math.abs(greeks.vega - constraints.pieceActivity);\n    score += vegaAlignment * 0.15;\n    \n    // Rho-structure alignment\n    const rhoAlignment = 1 - Math.abs(greeks.rho - constraints.pawnStructure);\n    score += rhoAlignment * 0.15;\n    \n    return Math.max(0, Math.min(0.15, score * 0.15)); // Max 15% boost\n  }\n  \n  /**\n   * Get trading recommendation from current market Greeks\n   */\n  getChessInsightFromMarketGreeks(delta: number, gamma: number, theta: number, vega: number, rho: number): {\n    chessAnalogy: string;\n    strategicInsight: string;\n    timeControlEquivalent: string;\n  } {\n    const greeks: GreeksProfile = { delta, gamma, theta, vega, rho };\n    const chess = this.greeksToChess(greeks);\n    \n    let chessAnalogy: string;\n    let strategicInsight: string;\n    \n    // Generate human-readable insights\n    if (Math.abs(delta) > 0.7) {\n      chessAnalogy = delta > 0 ? \n        \"White is up a Rook - pressing for the win\" :\n        \"Black is up a Rook - converting advantage\";\n      strategicInsight = \"Strong directional edge. Press the advantage like a chess master converting material.\";\n    } else if (gamma > 0.7) {\n      chessAnalogy = \"Tactical fireworks! Every move creates threats.\";\n      strategicInsight = \"High gamma = sharp position. One wrong move decides the game. Position for explosive moves.\";\n    } else if (theta > 0.8) {\n      chessAnalogy = \"Bullet chess! Clock is your enemy.\";\n      strategicInsight = \"Extreme time decay. Act fast or time erodes your edge like a chess clock flagging.\";\n    } else if (vega > 0.7) {\n      chessAnalogy = \"Complex middlegame. Many pieces, many plans.\";\n      strategicInsight = \"High complexity benefits those who thrive in chaos. Volatility is your friend.\";\n    } else {\n      chessAnalogy = \"Quiet positional maneuvering. Long-term plans matter.\";\n      strategicInsight = \"Low volatility environment. Focus on structure and patience like a classical game.\";\n    }\n    \n    return {\n      chessAnalogy,\n      strategicInsight,\n      timeControlEquivalent: chess.timeControl,\n    };\n  }\n  \n  /**\n   * Get historical analysis statistics\n   */\n  getAnalysisStats(): {\n    totalAnalyses: number;\n    averageConfidenceBoost: number;\n    strategyDistribution: Record<string, number>;\n  } {\n    if (this.analysisHistory.length === 0) {\n      return { totalAnalyses: 0, averageConfidenceBoost: 0, strategyDistribution: {} };\n    }\n    \n    const avgBoost = this.analysisHistory.reduce((sum, m) => sum + m.confidenceBoost, 0) / this.analysisHistory.length;\n    \n    const strategyDist: Record<string, number> = {};\n    for (const mapping of this.analysisHistory) {\n      const strat = mapping.optionsImplication.preferredStrategy;\n      strategyDist[strat] = (strategyDist[strat] || 0) + 1;\n    }\n    \n    return {\n      totalAnalyses: this.analysisHistory.length,\n      averageConfidenceBoost: avgBoost,\n      strategyDistribution: strategyDist,\n    };\n  }\n}\n\nexport const greeksChessAdapter = new GreeksChessAdapter();\nconsole.log('[v1.0-GREEKS-CHESS] Options Greeks ↔ Chess Constraints Adapter LOADED');\n";export{e as default};
