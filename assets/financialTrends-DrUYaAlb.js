const n="import { supabase } from '@/integrations/supabase/client';\n\nexport interface FinancialTrend {\n  date: string;\n  dailySubscriptionRevenueCents: number;\n  dailyPrintRevenueCents: number;\n  dailyBookRevenueCents: number;\n  dailyMarketplaceFeeCents: number;\n  dailyStripeFeesCents: number;\n  dailyShopifyFeesCents: number;\n  dailyPrintifyCostsCents: number;\n  dailyLuluCostsCents: number;\n  dailyCreatorRoyaltiesCents: number;\n  dailyEducationFundCents: number;\n  dailyPalettePoolCents: number;\n  dailyGamecardPoolCents: number;\n  dailyNewUsers: number;\n  dailyNewSubscribers: number;\n  dailyChurnedSubscribers: number;\n  dailyVisionsCreated: number;\n  dailyMarketplaceSales: number;\n  dailyPrintOrders: number;\n  dailyViews: number;\n  dailyDownloads: number;\n  dailyTrades: number;\n  totalPalettePoolValueCents: number;\n  totalGamecardPoolValueCents: number;\n  totalMarketCapCents: number;\n}\n\nexport interface ValuePool {\n  id: string;\n  name: string;\n  baseValueCents: number;\n  earnedValueCents: number;\n  totalValueCents: number;\n  usageCount: number;\n  interactionCount: number;\n  rarityTier?: string;\n}\n\n/**\n * Fetch financial trends for admin dashboard\n */\nexport async function getFinancialTrends(days: number = 30): Promise<FinancialTrend[]> {\n  const { data, error } = await supabase\n    .from('financial_trends')\n    .select('*')\n    .order('date', { ascending: false })\n    .limit(days);\n\n  if (error) {\n    console.error('Error fetching financial trends:', error);\n    return [];\n  }\n\n  return (data || []).map(row => ({\n    date: row.date,\n    dailySubscriptionRevenueCents: row.daily_subscription_revenue_cents || 0,\n    dailyPrintRevenueCents: row.daily_print_revenue_cents || 0,\n    dailyBookRevenueCents: row.daily_book_revenue_cents || 0,\n    dailyMarketplaceFeeCents: row.daily_marketplace_fee_cents || 0,\n    dailyStripeFeesCents: row.daily_stripe_fees_cents || 0,\n    dailyShopifyFeesCents: row.daily_shopify_fees_cents || 0,\n    dailyPrintifyCostsCents: row.daily_printify_costs_cents || 0,\n    dailyLuluCostsCents: row.daily_lulu_costs_cents || 0,\n    dailyCreatorRoyaltiesCents: row.daily_creator_royalties_cents || 0,\n    dailyEducationFundCents: row.daily_education_fund_cents || 0,\n    dailyPalettePoolCents: row.daily_palette_pool_cents || 0,\n    dailyGamecardPoolCents: row.daily_gamecard_pool_cents || 0,\n    dailyNewUsers: row.daily_new_users || 0,\n    dailyNewSubscribers: row.daily_new_subscribers || 0,\n    dailyChurnedSubscribers: row.daily_churned_subscribers || 0,\n    dailyVisionsCreated: row.daily_visions_created || 0,\n    dailyMarketplaceSales: row.daily_marketplace_sales || 0,\n    dailyPrintOrders: row.daily_print_orders || 0,\n    dailyViews: row.daily_views || 0,\n    dailyDownloads: row.daily_downloads || 0,\n    dailyTrades: row.daily_trades || 0,\n    totalPalettePoolValueCents: row.total_palette_pool_value_cents || 0,\n    totalGamecardPoolValueCents: row.total_gamecard_pool_value_cents || 0,\n    totalMarketCapCents: row.total_market_cap_cents || 0,\n  }));\n}\n\n/**\n * Fetch palette value pools\n */\nexport async function getPaletteValuePools(): Promise<ValuePool[]> {\n  const { data, error } = await supabase\n    .from('palette_value_pool')\n    .select('*')\n    .order('earned_value_cents', { ascending: false });\n\n  if (error) {\n    console.error('Error fetching palette pools:', error);\n    return [];\n  }\n\n  return (data || []).map(row => ({\n    id: row.palette_id,\n    name: row.palette_name,\n    baseValueCents: row.base_value_cents,\n    earnedValueCents: row.earned_value_cents,\n    totalValueCents: row.base_value_cents + row.earned_value_cents,\n    usageCount: row.total_visions_using,\n    interactionCount: row.total_interactions,\n  }));\n}\n\n/**\n * Fetch gamecard value pools\n */\nexport async function getGamecardValuePools(): Promise<ValuePool[]> {\n  const { data, error } = await supabase\n    .from('gamecard_value_pool')\n    .select('*')\n    .order('earned_value_cents', { ascending: false });\n\n  if (error) {\n    console.error('Error fetching gamecard pools:', error);\n    return [];\n  }\n\n  return (data || []).map(row => ({\n    id: row.game_id,\n    name: row.game_title,\n    baseValueCents: row.base_value_cents,\n    earnedValueCents: row.earned_value_cents,\n    totalValueCents: row.base_value_cents + row.earned_value_cents,\n    usageCount: row.total_visions,\n    interactionCount: row.total_interactions,\n    rarityTier: row.rarity_tier,\n  }));\n}\n\n/**\n * Trigger daily financial snapshot (admin only)\n */\nexport async function triggerDailySnapshot(): Promise<boolean> {\n  const { error } = await supabase.rpc('snapshot_daily_financials');\n  \n  if (error) {\n    console.error('Error triggering snapshot:', error);\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Generate premium analytics for a user\n */\nexport async function generatePremiumAnalytics(\n  analyticsType: 'market_trends' | 'engagement_insights' | 'portfolio_analysis'\n): Promise<{ id: string; data: Record<string, unknown> } | null> {\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) return null;\n\n  const { data, error } = await supabase.rpc('generate_premium_analytics', {\n    p_user_id: user.id,\n    p_analytics_type: analyticsType,\n  });\n\n  if (error) {\n    console.error('Error generating premium analytics:', error);\n    return null;\n  }\n\n  // Fetch the generated analytics\n  const { data: analytics } = await supabase\n    .from('premium_analytics')\n    .select('*')\n    .eq('id', data)\n    .single();\n\n  if (!analytics) return null;\n\n  return {\n    id: analytics.id,\n    data: analytics.data as Record<string, unknown>,\n  };\n}\n\n/**\n * Get user's premium analytics history\n */\nexport async function getPremiumAnalyticsHistory(): Promise<{\n  id: string;\n  analyticsType: string;\n  generatedAt: string;\n  expiresAt: string;\n}[]> {\n  const { data, error } = await supabase\n    .from('premium_analytics')\n    .select('id, analytics_type, generated_at, expires_at')\n    .order('generated_at', { ascending: false })\n    .limit(10);\n\n  if (error) {\n    console.error('Error fetching analytics history:', error);\n    return [];\n  }\n\n  return (data || []).map(row => ({\n    id: row.id,\n    analyticsType: row.analytics_type,\n    generatedAt: row.generated_at,\n    expiresAt: row.expires_at,\n  }));\n}\n\n/**\n * Record a palette interaction (load/preview) to build value pool data\n * This tracks usage even before a vision is saved\n */\nexport async function recordPaletteInteraction(paletteId: string): Promise<boolean> {\n  try {\n    // First check if it exists\n    const { data: existing } = await supabase\n      .from('palette_value_pool')\n      .select('total_interactions')\n      .eq('palette_id', paletteId)\n      .single();\n\n    if (existing) {\n      // Increment existing\n      await supabase\n        .from('palette_value_pool')\n        .update({\n          total_interactions: (existing.total_interactions || 0) + 1,\n          last_interaction_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .eq('palette_id', paletteId);\n    }\n    // If doesn't exist, it will be created by seed data - don't create new entries\n    return true;\n  } catch (err) {\n    console.error('Error recording palette interaction:', err);\n    return false;\n  }\n}\n\n/**\n * Record a gamecard interaction (load/preview) to build value pool data\n */\nexport async function recordGamecardInteraction(gameId: string): Promise<boolean> {\n  try {\n    // First check if it exists\n    const { data: existing } = await supabase\n      .from('gamecard_value_pool')\n      .select('total_interactions')\n      .eq('game_id', gameId)\n      .single();\n\n    if (existing) {\n      // Increment existing\n      await supabase\n        .from('gamecard_value_pool')\n        .update({\n          total_interactions: (existing.total_interactions || 0) + 1,\n          last_interaction_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .eq('game_id', gameId);\n    }\n    // If doesn't exist, it will be created by seed data - don't create new entries\n    return true;\n  } catch (err) {\n    console.error('Error recording gamecard interaction:', err);\n    return false;\n  }\n}\n\n/**\n * Increment interaction count for a palette (SQL-side increment to avoid race conditions)\n */\nexport async function incrementPaletteUsage(paletteId: string): Promise<void> {\n  const { data: existing } = await supabase\n    .from('palette_value_pool')\n    .select('total_interactions')\n    .eq('palette_id', paletteId)\n    .single();\n\n  if (existing) {\n    await supabase\n      .from('palette_value_pool')\n      .update({\n        total_interactions: (existing.total_interactions || 0) + 1,\n        last_interaction_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('palette_id', paletteId);\n  }\n}\n\n/**\n * Increment interaction count for a gamecard\n */\nexport async function incrementGamecardUsage(gameId: string): Promise<void> {\n  const { data: existing } = await supabase\n    .from('gamecard_value_pool')\n    .select('total_interactions')\n    .eq('game_id', gameId)\n    .single();\n\n  if (existing) {\n    await supabase\n      .from('gamecard_value_pool')\n      .update({\n        total_interactions: (existing.total_interactions || 0) + 1,\n        last_interaction_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('game_id', gameId);\n  }\n}\n";export{n as default};
