const e="/**\n * Similarity Detection for Chess Visualizations\n * \n * This module protects the uniqueness of complete visions and color palettes by:\n * 1. Detecting if colors match 30% or more AND moves match exactly\n * 2. Preventing saves of visualizations too similar to existing ones\n * 3. Supporting palette inheritance for featured palettes\n * 4. Checking against famous game cards to protect En Pensent intrinsic value\n * 5. Auto-detecting intrinsic game cards for analytics and data collection\n */\n\nimport { colorPalettes, PaletteId, PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { GameData } from '@/lib/chess/gameSimulator';\nimport { supabase } from '@/integrations/supabase/client';\nimport { detectGameCard, GameCardMatch } from '@/lib/chess/gameCardDetection';\n\n// Admin user IDs whose seeded visions can be claimed by premium users\n// This supports the \"starting phase\" where genesis games are seeded for marketplace\nconst GENESIS_CREATOR_IDS = [\n  '2029eb39-ff40-416f-8b07-f065964ff8eb', // a.arthur.shelton@gmail.com (primary admin)\n];\n\n// All piece types for comparison\nconst PIECE_TYPES: PieceType[] = ['k', 'q', 'r', 'b', 'n', 'p'];\nconst PIECE_COLORS: PieceColor[] = ['w', 'b'];\n\n/**\n * Convert hex color to RGB components (0-255 range)\n */\nfunction hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16),\n  } : null;\n}\n\n/**\n * Convert RGB to XYZ color space (intermediate step for LAB)\n */\nfunction rgbToXyz(r: number, g: number, b: number): { x: number; y: number; z: number } {\n  // Normalize RGB values\n  let rn = r / 255;\n  let gn = g / 255;\n  let bn = b / 255;\n\n  // Apply gamma correction (sRGB)\n  rn = rn > 0.04045 ? Math.pow((rn + 0.055) / 1.055, 2.4) : rn / 12.92;\n  gn = gn > 0.04045 ? Math.pow((gn + 0.055) / 1.055, 2.4) : gn / 12.92;\n  bn = bn > 0.04045 ? Math.pow((bn + 0.055) / 1.055, 2.4) : bn / 12.92;\n\n  rn *= 100;\n  gn *= 100;\n  bn *= 100;\n\n  // Convert to XYZ using sRGB matrix\n  return {\n    x: rn * 0.4124564 + gn * 0.3575761 + bn * 0.1804375,\n    y: rn * 0.2126729 + gn * 0.7151522 + bn * 0.0721750,\n    z: rn * 0.0193339 + gn * 0.1191920 + bn * 0.9503041,\n  };\n}\n\n/**\n * Convert XYZ to CIELAB color space (perceptually uniform)\n * Uses D65 illuminant (standard daylight)\n */\nfunction xyzToLab(x: number, y: number, z: number): { l: number; a: number; b: number } {\n  // D65 reference white\n  const refX = 95.047;\n  const refY = 100.0;\n  const refZ = 108.883;\n\n  let xn = x / refX;\n  let yn = y / refY;\n  let zn = z / refZ;\n\n  const epsilon = 0.008856;\n  const kappa = 903.3;\n\n  xn = xn > epsilon ? Math.pow(xn, 1/3) : (kappa * xn + 16) / 116;\n  yn = yn > epsilon ? Math.pow(yn, 1/3) : (kappa * yn + 16) / 116;\n  zn = zn > epsilon ? Math.pow(zn, 1/3) : (kappa * zn + 16) / 116;\n\n  return {\n    l: 116 * yn - 16,\n    a: 500 * (xn - yn),\n    b: 200 * (yn - zn),\n  };\n}\n\n/**\n * Convert hex color to CIELAB for perceptual comparison\n */\nfunction hexToLab(hex: string): { l: number; a: number; b: number } | null {\n  const rgb = hexToRgb(hex);\n  if (!rgb) return null;\n  \n  const xyz = rgbToXyz(rgb.r, rgb.g, rgb.b);\n  return xyzToLab(xyz.x, xyz.y, xyz.z);\n}\n\n/**\n * Calculate perceptual color distance using CIEDE2000 (simplified)\n * This is much better at matching human perception than RGB distance\n * Returns a value where <2.3 is \"just noticeable difference\" (JND)\n * and <10 is \"very similar\" to human eyes\n */\nexport function perceptualColorDistance(hex1: string, hex2: string): number {\n  const lab1 = hexToLab(hex1);\n  const lab2 = hexToLab(hex2);\n  \n  if (!lab1 || !lab2) return 100; // Max distance if invalid\n  \n  // Simplified CIEDE2000 using Euclidean distance in LAB space\n  // Full CIEDE2000 is more complex but this gives 90%+ accuracy\n  const deltaL = lab1.l - lab2.l;\n  const deltaA = lab1.a - lab2.a;\n  const deltaB = lab1.b - lab2.b;\n  \n  return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);\n}\n\n/**\n * Calculate color distance using Euclidean distance in RGB space (legacy)\n * Returns a value between 0 (identical) and ~441 (max distance)\n */\nexport function colorDistance(hex1: string, hex2: string): number {\n  const rgb1 = hexToRgb(hex1);\n  const rgb2 = hexToRgb(hex2);\n  \n  if (!rgb1 || !rgb2) return 441; // Max distance if invalid\n  \n  return Math.sqrt(\n    Math.pow(rgb1.r - rgb2.r, 2) +\n    Math.pow(rgb1.g - rgb2.g, 2) +\n    Math.pow(rgb1.b - rgb2.b, 2)\n  );\n}\n\n/**\n * Check if two colors are perceptually similar using CIELAB\n * JND (Just Noticeable Difference) is ~2.3 in CIELAB\n * We use a threshold of 10 for \"similar\" colors (visible but not dramatically different)\n */\nfunction areColorsSimilar(hex1: string, hex2: string, threshold: number = 10): boolean {\n  return perceptualColorDistance(hex1, hex2) < threshold;\n}\n\n/**\n * Check if colors are \"knockoff similar\" - slightly tweaked to seem different\n * This catches attempts to make colors 5-15 units apart (noticeable but not dramatic)\n * Returns true if colors are in the \"knockoff zone\" - similar enough to confuse\n */\nfunction isKnockoffColor(hex1: string, hex2: string): boolean {\n  const distance = perceptualColorDistance(hex1, hex2);\n  // Knockoff zone: different enough to not be \"identical\" but similar enough to confuse\n  // Less than 25 CIELAB units is \"same general color\" to most humans\n  return distance < 25;\n}\n\nexport interface PaletteColors {\n  white: Record<PieceType, string>;\n  black: Record<PieceType, string>;\n}\n\n/**\n * Calculate the percentage of matching colors between two palettes\n * Uses perceptual color distance (CIELAB) for human-accurate comparison\n * A color \"matches\" if it's within the perceptual threshold (default 15 CIELAB units)\n */\nexport function calculatePaletteSimilarity(\n  palette1: PaletteColors,\n  palette2: PaletteColors,\n  perceptualThreshold: number = 15\n): number {\n  let matchingColors = 0;\n  const totalColors = PIECE_TYPES.length * PIECE_COLORS.length; // 12 total colors\n  \n  for (const pieceType of PIECE_TYPES) {\n    for (const pieceColor of PIECE_COLORS) {\n      const color1 = pieceColor === 'w' ? palette1.white[pieceType] : palette1.black[pieceType];\n      const color2 = pieceColor === 'w' ? palette2.white[pieceType] : palette2.black[pieceType];\n      \n      if (areColorsSimilar(color1, color2, perceptualThreshold)) {\n        matchingColors++;\n      }\n    }\n  }\n  \n  return (matchingColors / totalColors) * 100;\n}\n\n/**\n * Calculate knockoff similarity - how many colors are \"close but not identical\"\n * This catches attempts to slightly tweak colors to bypass similarity detection\n * Returns percentage of colors in the \"knockoff zone\" (perceptually similar but tweaked)\n */\nexport function calculateKnockoffSimilarity(\n  palette1: PaletteColors,\n  palette2: PaletteColors\n): { knockoffPercentage: number; averageDistance: number; suspiciousColors: number } {\n  let knockoffColors = 0;\n  let totalDistance = 0;\n  let suspiciousColors = 0; // Colors tweaked just enough to bypass basic detection\n  const totalColors = PIECE_TYPES.length * PIECE_COLORS.length;\n  \n  for (const pieceType of PIECE_TYPES) {\n    for (const pieceColor of PIECE_COLORS) {\n      const color1 = pieceColor === 'w' ? palette1.white[pieceType] : palette1.black[pieceType];\n      const color2 = pieceColor === 'w' ? palette2.white[pieceType] : palette2.black[pieceType];\n      \n      const distance = perceptualColorDistance(color1, color2);\n      totalDistance += distance;\n      \n      // Knockoff zone: 5-30 CIELAB units (noticeable but not dramatic)\n      if (isKnockoffColor(color1, color2)) {\n        knockoffColors++;\n      }\n      \n      // Suspicious zone: 10-20 CIELAB units (deliberate slight tweaks)\n      if (distance >= 10 && distance <= 20) {\n        suspiciousColors++;\n      }\n    }\n  }\n  \n  return {\n    knockoffPercentage: (knockoffColors / totalColors) * 100,\n    averageDistance: totalDistance / totalColors,\n    suspiciousColors,\n  };\n}\n\n/**\n * Check if a palette is similar to any featured palette (>80% match)\n */\nexport function findSimilarFeaturedPalette(\n  customColors: PaletteColors\n): { paletteId: PaletteId; similarity: number } | null {\n  const featuredPalettes = colorPalettes.filter(p => p.id !== 'custom');\n  \n  let bestMatch: { paletteId: PaletteId; similarity: number } | null = null;\n  \n  for (const palette of featuredPalettes) {\n    const similarity = calculatePaletteSimilarity(customColors, palette);\n    \n    // If 80%+ similar to a featured palette, it's essentially that palette\n    if (similarity >= 80) {\n      if (!bestMatch || similarity > bestMatch.similarity) {\n        bestMatch = { paletteId: palette.id, similarity };\n      }\n    }\n  }\n  \n  return bestMatch;\n}\n\n/**\n * Normalize PGN for comparison (remove comments, variations, whitespace)\n */\nfunction normalizePgn(pgn: string | undefined | null): string {\n  if (!pgn) return '';\n  \n  return pgn\n    .replace(/\\{[^}]*\\}/g, '') // Remove comments\n    .replace(/\\([^)]*\\)/g, '') // Remove variations\n    .replace(/\\s+/g, ' ')      // Normalize whitespace\n    .replace(/\\d+\\.\\s*/g, '')  // Remove move numbers\n    .trim()\n    .toLowerCase();\n}\n\n/**\n * Check if two games have identical moves (from start to finish)\n */\nexport function areMovesIdentical(\n  pgn1: string | undefined | null,\n  gameData1: GameData,\n  pgn2: string | undefined | null,\n  gameData2: GameData\n): boolean {\n  // Compare normalized PGNs\n  const normalized1 = normalizePgn(pgn1 || gameData1.pgn);\n  const normalized2 = normalizePgn(pgn2 || gameData2.pgn);\n  \n  if (normalized1 && normalized2) {\n    return normalized1 === normalized2;\n  }\n  \n  // If no PGN, compare moves array\n  const moves1 = gameData1.moves || [];\n  const moves2 = gameData2.moves || [];\n  \n  if (moves1.length !== moves2.length) return false;\n  \n  return moves1.every((move, idx) => move.toLowerCase() === (moves2[idx] || '').toLowerCase());\n}\n\nexport interface SimilarityCheckResult {\n  isTooSimilar: boolean;\n  colorSimilarity: number;\n  movesMatch: boolean;\n  matchedPaletteId?: PaletteId;\n  matchedPaletteSimilarity?: number;\n  isIntrinsicPalette?: boolean; // True if using/close to a featured En Pensent palette\n  isIntrinsicGame?: boolean; // True if the game matches a famous game card\n  matchedGameCard?: { id: string; title: string; similarity?: number; matchType?: 'exact' | 'partial' | 'none' }; // The matched famous game\n  existingVisualizationId?: string;\n  ownerDisplayName?: string;\n  ownedByCurrentUser?: boolean;\n  reason?: string;\n  existingColors?: PaletteColors; // For color comparison preview\n  isKnockoff?: boolean; // True if this appears to be a knockoff attempt\n  knockoffDetails?: { // Details about potential knockoff\n    knockoffPercentage: number;\n    averageDistance: number;\n    suspiciousColors: number;\n  };\n  isGenesisClaimable?: boolean; // True if this is genesis content that can be claimed by premium users\n}\n\n/**\n * Check if the PGN matches any famous game card using our detection utility\n */\nexport function findMatchingFamousGame(pgn: string | undefined, gameData: GameData): { id: string; title: string; similarity: number; matchType: 'exact' | 'partial' | 'none' } | null {\n  const pgnToCheck = pgn || gameData.pgn;\n  if (!pgnToCheck && !gameData.moves?.length) return null;\n  \n  // Use the centralized game card detection\n  const match = detectGameCard(pgnToCheck || '');\n  \n  if (match.isMatch && match.matchedGame) {\n    return { \n      id: match.matchedGame.id, \n      title: match.matchedGame.title,\n      similarity: match.similarity,\n      matchType: match.matchType,\n    };\n  }\n  \n  return null;\n}\n\nexport interface VisualizationWithPalette {\n  id: string;\n  user_id: string;\n  pgn: string | null;\n  game_data: GameData & { \n    visualizationState?: { \n      paletteId?: string;\n      customColors?: PaletteColors;\n    };\n  };\n}\n\n/**\n * Main similarity check function\n * Returns true if visualization is too similar to an existing one:\n * - Moves match exactly AND colors match 30% or higher\n * - OR colors match an existing featured palette too closely\n */\nexport async function checkVisualizationSimilarity(\n  userId: string,\n  pgn: string | undefined,\n  gameData: GameData,\n  paletteId: PaletteId,\n  customColors?: PaletteColors\n): Promise<SimilarityCheckResult> {\n  try {\n    // Get the colors to compare\n    const currentPalette = customColors || colorPalettes.find(p => p.id === paletteId) || colorPalettes[0];\n    const colorsToCompare: PaletteColors = {\n      white: currentPalette.white,\n      black: currentPalette.black,\n    };\n    \n    // Check if using a featured En Pensent palette (intrinsic value)\n    let isIntrinsicPalette = false;\n    let matchedPaletteId: PaletteId | undefined;\n    let matchedPaletteSimilarity: number | undefined;\n    \n    // If using a featured palette directly, it's intrinsic\n    if (paletteId !== 'custom') {\n      isIntrinsicPalette = true;\n      matchedPaletteId = paletteId;\n      matchedPaletteSimilarity = 100;\n    } else if (customColors) {\n      // Check if custom colors are close to any featured palette\n      const matchedPalette = findSimilarFeaturedPalette(customColors);\n      if (matchedPalette && matchedPalette.similarity >= 30) {\n        isIntrinsicPalette = matchedPalette.similarity >= 80; // Only truly intrinsic at 80%+\n        matchedPaletteId = matchedPalette.paletteId;\n        matchedPaletteSimilarity = matchedPalette.similarity;\n      }\n    }\n    \n    // Check if the game matches any famous game card\n    const matchedGameCard = findMatchingFamousGame(pgn, gameData);\n    const isIntrinsicGame = matchedGameCard !== null;\n    \n    // Fetch all saved visualizations\n    const { data: existingViz, error } = await supabase\n      .from('saved_visualizations')\n      .select('id, user_id, pgn, game_data');\n    \n    if (error) {\n      console.error('Error fetching visualizations for similarity check:', error);\n      return { \n        isTooSimilar: false, \n        colorSimilarity: 0, \n        movesMatch: false,\n        isIntrinsicPalette,\n        isIntrinsicGame,\n        matchedGameCard: matchedGameCard || undefined,\n        matchedPaletteId,\n        matchedPaletteSimilarity,\n      };\n    }\n    \n    // Check against each existing visualization\n    for (const viz of existingViz || []) {\n      const vizGameData = viz.game_data as unknown as VisualizationWithPalette['game_data'];\n      const vizState = vizGameData.visualizationState;\n      \n      // Get the existing visualization's colors\n      let existingColors: PaletteColors;\n      if (vizState?.customColors) {\n        existingColors = vizState.customColors;\n      } else {\n        const existingPalette = colorPalettes.find(p => p.id === (vizState?.paletteId || 'modern')) || colorPalettes[0];\n        existingColors = {\n          white: existingPalette.white,\n          black: existingPalette.black,\n        };\n      }\n      \n      // Check if moves match\n      const movesMatch = areMovesIdentical(pgn, gameData, viz.pgn, vizGameData);\n      \n      if (!movesMatch) continue; // Only check color similarity if moves match\n      \n      // Calculate standard color similarity\n      const colorSimilarity = calculatePaletteSimilarity(colorsToCompare, existingColors);\n      \n      // Calculate knockoff similarity (catches slight color tweaks)\n      const knockoffDetails = calculateKnockoffSimilarity(colorsToCompare, existingColors);\n      \n      // Determine if this is a knockoff attempt:\n      // - High knockoff percentage (70%+ colors are \"close but not identical\")\n      // - Low average distance (colors are all slightly tweaked)\n      // - Multiple suspicious colors (deliberate small tweaks)\n      const isKnockoff = knockoffDetails.knockoffPercentage >= 50 && \n                         knockoffDetails.averageDistance < 30 &&\n                         knockoffDetails.suspiciousColors >= 4;\n      \n      // Block if:\n      // 1. Standard similarity >= 30% (traditional threshold)\n      // 2. OR knockoff detected (colors deliberately tweaked to bypass detection)\n      const shouldBlock = colorSimilarity >= 30 || isKnockoff;\n      \n      // GENESIS PHASE: Allow claiming visions that are:\n      // 1. Unclaimed (user_id is null)\n      // 2. Or owned by a genesis creator (admin-seeded marketplace content)\n      // This enables premium users to claim genesis games during the starting phase\n      const isGenesisVision = !viz.user_id || GENESIS_CREATOR_IDS.includes(viz.user_id);\n      \n      if (movesMatch && shouldBlock) {\n        // If this is a genesis vision, don't block - allow the claim\n        if (isGenesisVision && viz.user_id !== userId) {\n          // Return with a special flag indicating this is claimable genesis content\n          return {\n            isTooSimilar: false, // Don't block - it's genesis content\n            colorSimilarity,\n            movesMatch: true,\n            isIntrinsicPalette,\n            isIntrinsicGame,\n            matchedGameCard: matchedGameCard || undefined,\n            matchedPaletteId,\n            matchedPaletteSimilarity,\n            isGenesisClaimable: true, // Special flag for genesis content\n            existingVisualizationId: viz.id,\n          };\n        }\n        \n        const ownedByCurrentUser = viz.user_id === userId;\n        \n        // Get owner's display name\n        let ownerDisplayName: string | undefined;\n        if (!ownedByCurrentUser && viz.user_id) {\n          const { data: profileData } = await supabase\n            .from('profiles')\n            .select('display_name')\n            .eq('user_id', viz.user_id)\n            .single();\n          ownerDisplayName = profileData?.display_name || 'Another collector';\n        }\n        \n        // Craft appropriate message\n        let reason: string;\n        if (isKnockoff && colorSimilarity < 30) {\n          reason = `This visualization appears to be a near-replica of an existing vision. ${knockoffDetails.suspiciousColors} colors are slightly tweaked versions of the original. Please create a more distinctive colorway.`;\n        } else {\n          reason = `This visualization is ${Math.round(colorSimilarity)}% similar to an existing vision of the same game`;\n        }\n        \n        return {\n          isTooSimilar: true,\n          colorSimilarity,\n          movesMatch: true,\n          isIntrinsicPalette,\n          isIntrinsicGame,\n          matchedGameCard: matchedGameCard || undefined,\n          matchedPaletteId,\n          matchedPaletteSimilarity,\n          existingVisualizationId: viz.id,\n          ownerDisplayName,\n          ownedByCurrentUser,\n          reason,\n          existingColors,\n          isKnockoff,\n          knockoffDetails,\n        };\n      }\n    }\n    \n    // Return result with intrinsic palette and game info\n    return { \n      isTooSimilar: false, \n      colorSimilarity: 0, \n      movesMatch: false,\n      isIntrinsicPalette,\n      isIntrinsicGame,\n      matchedGameCard: matchedGameCard || undefined,\n      matchedPaletteId,\n      matchedPaletteSimilarity,\n    };\n  } catch (error) {\n    console.error('Error in similarity check:', error);\n    return { isTooSimilar: false, colorSimilarity: 0, movesMatch: false };\n  }\n}\n\n/**\n * Get featured palette ID from custom colors if they match 80%+\n * Used for palette inheritance - links custom colors to the closest featured palette\n */\nexport function getFeaturedPaletteForColors(colors: PaletteColors): PaletteId | null {\n  const match = findSimilarFeaturedPalette(colors);\n  return match?.paletteId || null;\n}\n\n/**\n * Update all visualizations linked to a featured palette\n * Called when a creator modifies a featured palette's colors\n */\nexport async function propagatePaletteChanges(\n  paletteId: PaletteId,\n  newColors: PaletteColors\n): Promise<{ updated: number; error: Error | null }> {\n  try {\n    // This would be called from an admin function when palette colors change\n    // For now, visualizations store their state and re-render with current palette colors\n    // The palette inheritance happens at render time, not storage time\n    \n    console.log(`Palette ${paletteId} colors would be propagated to linked visualizations`);\n    \n    return { updated: 0, error: null };\n  } catch (error) {\n    return { updated: 0, error: error as Error };\n  }\n}\n\n/**\n * Generate a fingerprint for Creative Mode board data\n * Compares paint data structure rather than PGN/moves\n */\nfunction generateCreativeBoardFingerprint(\n  paintData: Map<string, Array<{ piece: string; color: string; hexColor: string }>>,\n  whitePalette: Record<PieceType, string>,\n  blackPalette: Record<PieceType, string>\n): string {\n  // Create sorted representation of paint data\n  const paintEntries = Array.from(paintData.entries())\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([key, visits]) => `${key}:${visits.map(v => `${v.piece}${v.color}${v.hexColor}`).join(',')}`);\n  \n  const paletteStr = Object.entries(whitePalette).sort().map(([k, v]) => `w${k}${v}`).join('') +\n                     Object.entries(blackPalette).sort().map(([k, v]) => `b${k}${v}`).join('');\n  \n  return `creative:${paintEntries.join('|')}::${paletteStr}`;\n}\n\n/**\n * Calculate similarity between two creative board states\n * Uses perceptual color distance for accurate human-perception matching\n * Returns percentage of matching squares (by color content)\n */\nexport function calculateCreativeBoardSimilarity(\n  board1: Array<Array<{ visits: Array<{ hexColor: string }> }>>,\n  board2: Array<Array<{ visits: Array<{ hexColor: string }> }>>\n): number {\n  let matchingSquares = 0;\n  let totalActiveSquares = 0;\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const visits1 = board1[rank]?.[file]?.visits || [];\n      const visits2 = board2[rank]?.[file]?.visits || [];\n      \n      // If both have visits, compare them\n      if (visits1.length > 0 || visits2.length > 0) {\n        totalActiveSquares++;\n        \n        // Compare color sets using perceptual distance\n        const colors1 = visits1.map(v => v.hexColor.toLowerCase());\n        const colors2 = visits2.map(v => v.hexColor.toLowerCase());\n        \n        // Check if all colors in one set have a perceptually similar match in the other\n        if (colors1.length === colors2.length && colors1.length > 0) {\n          let allSimilar = true;\n          for (const c1 of colors1) {\n            // Find if any color in colors2 is perceptually similar\n            const hasSimilar = colors2.some(c2 => perceptualColorDistance(c1, c2) < 20);\n            if (!hasSimilar) {\n              allSimilar = false;\n              break;\n            }\n          }\n          if (allSimilar) matchingSquares++;\n        }\n      }\n    }\n  }\n  \n  if (totalActiveSquares === 0) return 0;\n  return (matchingSquares / totalActiveSquares) * 100;\n}\n\nexport interface CreativeSimilarityResult {\n  isTooSimilar: boolean;\n  similarity: number;\n  existingVisualizationId?: string;\n  ownerDisplayName?: string;\n  ownedByCurrentUser?: boolean;\n  reason?: string;\n}\n\n/**\n * Check if a Creative Mode visualization is too similar to existing ones\n * Blocks save if 70%+ of painted squares match existing vision\n */\nexport async function checkCreativeSimilarity(\n  userId: string,\n  visualizationBoard: Array<Array<{ visits: Array<{ hexColor: string }> }>>,\n  whitePalette: Record<PieceType, string>,\n  blackPalette: Record<PieceType, string>\n): Promise<CreativeSimilarityResult> {\n  try {\n    // Fetch all creative mode visualizations (marked by having 'Creative' as white player)\n    const { data: existingViz, error } = await supabase\n      .from('saved_visualizations')\n      .select('id, user_id, game_data');\n    \n    if (error) {\n      console.error('Error fetching visualizations for creative similarity check:', error);\n      return { isTooSimilar: false, similarity: 0 };\n    }\n    \n    let highestSimilarity = 0;\n    let mostSimilarViz: typeof existingViz[0] | null = null;\n    \n    // Check against each existing visualization\n    for (const viz of existingViz || []) {\n      const vizGameData = viz.game_data as unknown as { \n        board?: Array<Array<{ visits: Array<{ hexColor: string }> }>>;\n        gameData?: { white?: string };\n      };\n      \n      // Only compare with saved visualizations that have board data\n      if (!vizGameData.board) continue;\n      \n      const similarity = calculateCreativeBoardSimilarity(visualizationBoard, vizGameData.board);\n      \n      if (similarity > highestSimilarity) {\n        highestSimilarity = similarity;\n        mostSimilarViz = viz;\n      }\n    }\n    \n    // If 70%+ similar, it's too close\n    if (highestSimilarity >= 70 && mostSimilarViz) {\n      const ownedByCurrentUser = mostSimilarViz.user_id === userId;\n      \n      let ownerDisplayName: string | undefined;\n      if (!ownedByCurrentUser) {\n        const { data: profileData } = await supabase\n          .from('profiles')\n          .select('display_name')\n          .eq('user_id', mostSimilarViz.user_id)\n          .single();\n        ownerDisplayName = profileData?.display_name || 'Another collector';\n      }\n      \n      return {\n        isTooSimilar: true,\n        similarity: highestSimilarity,\n        existingVisualizationId: mostSimilarViz.id,\n        ownerDisplayName,\n        ownedByCurrentUser,\n        reason: `This design is ${Math.round(highestSimilarity)}% similar to an existing vision`,\n      };\n    }\n    \n    return { \n      isTooSimilar: false, \n      similarity: highestSimilarity,\n    };\n  } catch (error) {\n    console.error('Error in creative similarity check:', error);\n    return { isTooSimilar: false, similarity: 0 };\n  }\n}\n\n/**\n * Get real-time similarity warning level for Creative Mode\n * Returns warning info without blocking (for live feedback)\n */\nexport async function getCreativeSimilarityWarning(\n  userId: string,\n  visualizationBoard: Array<Array<{ visits: Array<{ hexColor: string }> }>>\n): Promise<{ level: 'none' | 'low' | 'medium' | 'high' | 'blocked'; similarity: number; ownerName?: string }> {\n  try {\n    const { data: existingViz, error } = await supabase\n      .from('saved_visualizations')\n      .select('id, user_id, game_data');\n    \n    if (error || !existingViz) {\n      return { level: 'none', similarity: 0 };\n    }\n    \n    let highestSimilarity = 0;\n    let ownerUserId: string | null = null;\n    \n    for (const viz of existingViz) {\n      const vizGameData = viz.game_data as unknown as { \n        board?: Array<Array<{ visits: Array<{ hexColor: string }> }>>;\n      };\n      \n      if (!vizGameData.board) continue;\n      \n      const similarity = calculateCreativeBoardSimilarity(visualizationBoard, vizGameData.board);\n      \n      if (similarity > highestSimilarity) {\n        highestSimilarity = similarity;\n        ownerUserId = viz.user_id;\n      }\n    }\n    \n    // Get owner name if not current user\n    let ownerName: string | undefined;\n    if (ownerUserId && ownerUserId !== userId && highestSimilarity >= 40) {\n      const { data: profileData } = await supabase\n        .from('profiles')\n        .select('display_name')\n        .eq('user_id', ownerUserId)\n        .single();\n      ownerName = profileData?.display_name || 'Another collector';\n    }\n    \n    // Determine warning level\n    if (highestSimilarity >= 70) {\n      return { level: 'blocked', similarity: highestSimilarity, ownerName };\n    } else if (highestSimilarity >= 55) {\n      return { level: 'high', similarity: highestSimilarity, ownerName };\n    } else if (highestSimilarity >= 40) {\n      return { level: 'medium', similarity: highestSimilarity, ownerName };\n    } else if (highestSimilarity >= 25) {\n      return { level: 'low', similarity: highestSimilarity };\n    }\n    \n    return { level: 'none', similarity: highestSimilarity };\n  } catch (error) {\n    return { level: 'none', similarity: 0 };\n  }\n}\n";export{e as default};
