const n="/**\n * En Pensent Core SDK - Strategic Guidance Generator\n * \n * Generates strategic recommendations from analysis\n */\n\nimport { TemporalSignature, ArchetypeDefinition } from '../types';\n\n/**\n * Generate strategic guidance based on analysis\n */\nexport function generateStrategicGuidance(\n  signature: TemporalSignature,\n  archetypeDefinition: ArchetypeDefinition | null,\n  outcomeProbabilities: Record<string, number>\n): string {\n  const parts: string[] = [];\n  \n  addArchetypeGuidance(parts, archetypeDefinition);\n  addFlowGuidance(parts, signature);\n  addDominantForceGuidance(parts, signature);\n  addProbabilityGuidance(parts, outcomeProbabilities);\n  \n  return parts.join('. ') + '.';\n}\n\nfunction addArchetypeGuidance(\n  parts: string[],\n  archetypeDefinition: ArchetypeDefinition | null\n): void {\n  if (archetypeDefinition) {\n    parts.push(`Pattern matches \"${archetypeDefinition.name}\" archetype`);\n    if (archetypeDefinition.successRate > 0.6) {\n      parts.push(`historically successful ${Math.round(archetypeDefinition.successRate * 100)}% of the time`);\n    }\n  }\n}\n\nfunction addFlowGuidance(parts: string[], signature: TemporalSignature): void {\n  switch (signature.temporalFlow.trend) {\n    case 'accelerating':\n      parts.push('Momentum is building - capitalize on current trajectory');\n      break;\n    case 'declining':\n      parts.push('Activity declining - consider repositioning or intervention');\n      break;\n    case 'volatile':\n      parts.push('High volatility detected - exercise caution');\n      break;\n    case 'stable':\n      parts.push('Stable trajectory - maintain current course');\n      break;\n  }\n}\n\nfunction addDominantForceGuidance(parts: string[], signature: TemporalSignature): void {\n  if (signature.dominantForce !== 'balanced') {\n    parts.push(`${signature.dominantForce === 'primary' ? 'Primary' : 'Secondary'} force has initiative`);\n  }\n}\n\nfunction addProbabilityGuidance(\n  parts: string[],\n  outcomeProbabilities: Record<string, number>\n): void {\n  const topOutcome = Object.entries(outcomeProbabilities)\n    .sort((a, b) => b[1] - a[1])[0];\n  \n  if (topOutcome && topOutcome[1] > 0.5) {\n    parts.push(`${Math.round(topOutcome[1] * 100)}% trajectory toward ${formatOutcome(topOutcome[0])}`);\n  }\n}\n\n/**\n * Format outcome for display\n */\nexport function formatOutcome(outcome: string): string {\n  return outcome\n    .replace(/_/g, ' ')\n    .split(' ')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(' ');\n}\n";export{n as default};
