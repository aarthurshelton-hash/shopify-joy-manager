const n="/**\n * Cross-Asset Correlation Lag - v7.53-ACCURACY\n * \n * Uses leading indicators from correlated assets to improve predictions.\n * BTC often leads equity risk, VIX leads reversals, etc.\n */\n\nexport type AssetClass = 'equity' | 'crypto' | 'bond' | 'commodity' | 'forex' | 'volatility';\n\nexport interface LeadLagRelationship {\n  leader: string;       // Ticker of leading asset\n  follower: string;     // Ticker of following asset\n  lagMinutes: number;   // How many minutes follower lags\n  correlation: number;  // Correlation strength (-1 to 1)\n  reliability: number;  // How reliable this relationship is (0-1)\n  regime: 'risk_on' | 'risk_off' | 'all';  // When this relationship holds\n}\n\n/**\n * Known lead-lag relationships from market microstructure\n */\nexport const LEAD_LAG_RELATIONSHIPS: LeadLagRelationship[] = [\n  // Crypto leads equity risk\n  {\n    leader: 'BTC',\n    follower: 'SPY',\n    lagMinutes: 15,\n    correlation: 0.65,\n    reliability: 0.7,\n    regime: 'risk_on',\n  },\n  {\n    leader: 'BTC',\n    follower: 'QQQ',\n    lagMinutes: 10,\n    correlation: 0.72,\n    reliability: 0.75,\n    regime: 'risk_on',\n  },\n  // VIX leads reversals\n  {\n    leader: 'VIX',\n    follower: 'SPY',\n    lagMinutes: 5,\n    correlation: -0.85,\n    reliability: 0.9,\n    regime: 'all',\n  },\n  // Bonds lead equity in risk-off\n  {\n    leader: 'TLT',\n    follower: 'SPY',\n    lagMinutes: 30,\n    correlation: -0.5,\n    reliability: 0.6,\n    regime: 'risk_off',\n  },\n  // Dollar strength\n  {\n    leader: 'DXY',\n    follower: 'SPY',\n    lagMinutes: 60,\n    correlation: -0.4,\n    reliability: 0.55,\n    regime: 'all',\n  },\n  // Gold as safe haven\n  {\n    leader: 'GLD',\n    follower: 'SPY',\n    lagMinutes: 20,\n    correlation: -0.35,\n    reliability: 0.5,\n    regime: 'risk_off',\n  },\n  // Sector rotation\n  {\n    leader: 'XLF',\n    follower: 'SPY',\n    lagMinutes: 15,\n    correlation: 0.8,\n    reliability: 0.7,\n    regime: 'risk_on',\n  },\n  // Tech leads market\n  {\n    leader: 'NVDA',\n    follower: 'QQQ',\n    lagMinutes: 5,\n    correlation: 0.85,\n    reliability: 0.8,\n    regime: 'all',\n  },\n];\n\nexport interface AssetSignal {\n  ticker: string;\n  direction: 'up' | 'down' | 'neutral';\n  magnitude: number;  // Percentage move\n  timestamp: number;\n}\n\n/**\n * Find relevant lead signals for a target asset\n */\nexport function findLeadSignals(\n  targetTicker: string,\n  currentSignals: AssetSignal[],\n  regime: 'risk_on' | 'risk_off' | 'neutral' = 'neutral'\n): { relationship: LeadLagRelationship; signal: AssetSignal; expectedMove: number }[] {\n  const relationships = LEAD_LAG_RELATIONSHIPS.filter(r => \n    r.follower === targetTicker && \n    (r.regime === 'all' || r.regime === regime || regime === 'neutral')\n  );\n  \n  const leadSignals: { relationship: LeadLagRelationship; signal: AssetSignal; expectedMove: number }[] = [];\n  \n  for (const rel of relationships) {\n    const leaderSignal = currentSignals.find(s => s.ticker === rel.leader);\n    if (leaderSignal) {\n      // Calculate expected move based on correlation and leader move\n      const expectedMove = leaderSignal.magnitude * rel.correlation * rel.reliability;\n      leadSignals.push({ relationship: rel, signal: leaderSignal, expectedMove });\n    }\n  }\n  \n  return leadSignals.sort((a, b) => Math.abs(b.expectedMove) - Math.abs(a.expectedMove));\n}\n\n/**\n * Aggregate lead signals into a prediction adjustment\n */\nexport function aggregateLeadSignals(\n  leadSignals: { relationship: LeadLagRelationship; signal: AssetSignal; expectedMove: number }[]\n): { direction: 'up' | 'down' | 'neutral'; confidence: number; expectedMagnitude: number } {\n  if (leadSignals.length === 0) {\n    return { direction: 'neutral', confidence: 0, expectedMagnitude: 0 };\n  }\n  \n  let weightedSum = 0;\n  let totalWeight = 0;\n  \n  for (const ls of leadSignals) {\n    const weight = ls.relationship.reliability * Math.abs(ls.relationship.correlation);\n    const directionSign = ls.signal.direction === 'up' ? 1 : ls.signal.direction === 'down' ? -1 : 0;\n    \n    weightedSum += directionSign * ls.expectedMove * weight;\n    totalWeight += weight;\n  }\n  \n  const avgExpectedMove = totalWeight > 0 ? weightedSum / totalWeight : 0;\n  const direction: 'up' | 'down' | 'neutral' = \n    avgExpectedMove > 0.1 ? 'up' : avgExpectedMove < -0.1 ? 'down' : 'neutral';\n  \n  // Confidence based on agreement between signals\n  const upSignals = leadSignals.filter(s => s.signal.direction === 'up').length;\n  const downSignals = leadSignals.filter(s => s.signal.direction === 'down').length;\n  const agreement = Math.abs(upSignals - downSignals) / leadSignals.length;\n  \n  const avgReliability = leadSignals.reduce((sum, s) => sum + s.relationship.reliability, 0) / leadSignals.length;\n  const confidence = agreement * avgReliability;\n  \n  return { direction, confidence, expectedMagnitude: Math.abs(avgExpectedMove) };\n}\n\n/**\n * Detect regime based on cross-asset signals\n */\nexport function detectMarketRegime(\n  signals: AssetSignal[]\n): 'risk_on' | 'risk_off' | 'neutral' {\n  const vixSignal = signals.find(s => s.ticker === 'VIX');\n  const btcSignal = signals.find(s => s.ticker === 'BTC');\n  const tltSignal = signals.find(s => s.ticker === 'TLT');\n  const gldSignal = signals.find(s => s.ticker === 'GLD');\n  \n  let riskOnScore = 0;\n  let riskOffScore = 0;\n  \n  // VIX down = risk on\n  if (vixSignal?.direction === 'down') riskOnScore += 2;\n  if (vixSignal?.direction === 'up') riskOffScore += 2;\n  \n  // BTC up = risk on\n  if (btcSignal?.direction === 'up') riskOnScore += 1.5;\n  if (btcSignal?.direction === 'down') riskOffScore += 1.5;\n  \n  // TLT up (bonds rallying) = risk off\n  if (tltSignal?.direction === 'up') riskOffScore += 1;\n  if (tltSignal?.direction === 'down') riskOnScore += 1;\n  \n  // GLD up = risk off\n  if (gldSignal?.direction === 'up') riskOffScore += 0.5;\n  if (gldSignal?.direction === 'down') riskOnScore += 0.5;\n  \n  if (riskOnScore > riskOffScore + 1) return 'risk_on';\n  if (riskOffScore > riskOnScore + 1) return 'risk_off';\n  return 'neutral';\n}\n\n/**\n * Calculate correlation-adjusted prediction\n */\nexport function getCorrelationAdjustedPrediction(\n  basePrediction: { direction: 'up' | 'down' | 'neutral'; confidence: number; magnitude: number },\n  targetTicker: string,\n  crossAssetSignals: AssetSignal[]\n): { direction: 'up' | 'down' | 'neutral'; confidence: number; magnitude: number; leadingIndicators: string[] } {\n  const regime = detectMarketRegime(crossAssetSignals);\n  const leadSignals = findLeadSignals(targetTicker, crossAssetSignals, regime);\n  const aggregated = aggregateLeadSignals(leadSignals);\n  \n  // Blend base prediction with cross-asset intelligence\n  const blendWeight = 0.7; // 70% base, 30% cross-asset\n  \n  let { direction, confidence, magnitude } = basePrediction;\n  \n  // If cross-asset signals strongly disagree, reduce confidence\n  if (aggregated.direction !== 'neutral' && aggregated.direction !== direction) {\n    confidence *= (1 - aggregated.confidence * 0.5);\n    \n    // If cross-asset is very confident, flip direction\n    if (aggregated.confidence > 0.7) {\n      direction = aggregated.direction;\n      confidence = aggregated.confidence * 0.6;\n      magnitude = aggregated.expectedMagnitude;\n    }\n  } else if (aggregated.direction === direction) {\n    // Agreement boosts confidence\n    confidence = Math.min(1, confidence * (1 + aggregated.confidence * 0.3));\n    magnitude = (magnitude * blendWeight) + (aggregated.expectedMagnitude * (1 - blendWeight));\n  }\n  \n  const leadingIndicators = leadSignals.map(ls => \n    `${ls.relationship.leader} (${ls.signal.direction}, ${ls.relationship.lagMinutes}m lag)`\n  );\n  \n  return { direction, confidence, magnitude, leadingIndicators };\n}\n";export{n as default};
