const n="/**\n * Scalping Predictor Hook\n * Integrates tick stream with prediction engine, heartbeat, and self-evolution\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useLiveHeartbeat } from './useLiveHeartbeat';\nimport { useTickDataStream, type TickStreamConfig } from './useTickDataStream';\nimport { \n  TickPredictionEngine,\n  type Tick,\n  type TickPrediction,\n  type LearningState\n} from '@/lib/pensent-core/domains/finance/tickPredictionEngine';\nimport { \n  selfEvolvingSystem,\n  type EvolutionState \n} from '@/lib/pensent-core/domains/finance/selfEvolvingSystem';\n\nexport interface ScalpingConfig extends Omit<TickStreamConfig, 'pollInterval'> {\n  predictionIntervalMs: number; // How often to generate new predictions\n  autoPredict: boolean;\n  pollInterval?: number; // v7.51: Real data poll interval\n}\n\nexport interface ScalpingState {\n  // Engine state\n  learningState: LearningState;\n  \n  // Evolution state\n  evolutionState: EvolutionState;\n  \n  // Current prediction\n  currentPrediction: TickPrediction | null;\n  \n  // Recent predictions\n  pendingPredictions: TickPrediction[];\n  recentPredictions: TickPrediction[];\n  \n  // Stats\n  stats: {\n    totalPredictions: number;\n    accuracy: number;\n    recentAccuracy: number;\n    currentStreak: number;\n    bestStreak: number;\n    upPredictions: { total: number; correct: number; accuracy: number };\n    downPredictions: { total: number; correct: number; accuracy: number };\n    flatPredictions: { total: number; correct: number; accuracy: number };\n  };\n  \n  // Stream info\n  tickCount: number;\n  latestPrice: number | null;\n  priceChange: number;\n  priceChangePercent: number;\n}\n\nconst DEFAULT_LEARNING_STATE: LearningState = {\n  totalPredictions: 0,\n  correctPredictions: 0,\n  accuracy: 0,\n  streak: 0,\n  bestStreak: 0,\n  recentAccuracy: 0,\n  confidenceMultiplier: 1.0,\n  adaptiveHorizonMs: 5000,\n  volatilityState: 'medium',\n  momentumBias: 0,\n  lastUpdate: Date.now(),\n  multiLevel: {\n    direction: { correct: 0, total: 0, accuracy: 0 },\n    magnitude: { avgScore: 0, samples: 0 },\n    timing: { avgScore: 0, samples: 0 },\n    confidenceCalibration: { predicted: 0, actual: 0, calibrationError: 0 },\n    composite: { avgScore: 0, trend: 0 }\n  }\n};\n\nexport function useScalpingPredictor(config: ScalpingConfig) {\n  const engineRef = useRef<TickPredictionEngine>(new TickPredictionEngine());\n  const startPriceRef = useRef<number | null>(null);\n  \n  const [scalpingState, setScalpingState] = useState<ScalpingState>({\n    learningState: DEFAULT_LEARNING_STATE,\n    evolutionState: selfEvolvingSystem.getState(),\n    currentPrediction: null,\n    pendingPredictions: [],\n    recentPredictions: [],\n    stats: {\n      totalPredictions: 0,\n      accuracy: 0,\n      recentAccuracy: 0,\n      currentStreak: 0,\n      bestStreak: 0,\n      upPredictions: { total: 0, correct: 0, accuracy: 0 },\n      downPredictions: { total: 0, correct: 0, accuracy: 0 },\n      flatPredictions: { total: 0, correct: 0, accuracy: 0 }\n    },\n    tickCount: 0,\n    latestPrice: null,\n    priceChange: 0,\n    priceChangePercent: 0\n  });\n  \n  // Track resolved predictions to feed evolution system\n  const lastResolvedCountRef = useRef(0);\n  \n  // Connect to tick stream - v7.51: REAL DATA ONLY\n  const tickStream = useTickDataStream({\n    symbol: config.symbol,\n    mode: config.mode === 'websocket' ? 'websocket' : 'real', // v7.51: No demo mode\n    wsUrl: config.wsUrl,\n    apiKey: config.apiKey,\n    pollInterval: config.pollInterval || 1500\n  });\n  \n  // Process incoming ticks\n  useEffect(() => {\n    const unsubscribe = tickStream.addTickListener((tick: Tick) => {\n      engineRef.current.processTick(tick);\n      \n      // Track starting price for session stats\n      if (startPriceRef.current === null) {\n        startPriceRef.current = tick.price;\n      }\n      \n      const priceChange = tick.price - (startPriceRef.current || tick.price);\n      const priceChangePercent = startPriceRef.current \n        ? ((tick.price - startPriceRef.current) / startPriceRef.current) * 100 \n        : 0;\n      \n      // Get recent predictions and feed resolved ones to evolution system\n      const recentPredictions = engineRef.current.getRecentPredictions(20);\n      const resolvedPredictions = recentPredictions.filter(p => p.wasCorrect !== undefined);\n      \n      // Process newly resolved predictions through evolution system\n      if (resolvedPredictions.length > lastResolvedCountRef.current) {\n        const newResolved = resolvedPredictions.slice(lastResolvedCountRef.current);\n        newResolved.forEach(pred => {\n        if (pred.wasCorrect !== undefined) {\n          // Map 'flat' to 'neutral' for evolution system\n          const mapDirection = (d: 'up' | 'down' | 'flat'): 'up' | 'down' | 'neutral' => \n            d === 'flat' ? 'neutral' : d;\n          \n          selfEvolvingSystem.processOutcome({\n            predicted: mapDirection(pred.predictedDirection),\n            actual: mapDirection(pred.actualDirection || pred.predictedDirection),\n              confidence: pred.confidence,\n              marketConditions: {\n                correlationStrength: 0.5, // Would come from cross-market engine\n                volatility: pred.predictedMagnitude,\n                momentum: pred.predictedDirection === 'up' ? 0.5 : -0.5,\n                leadingSignals: 0.5\n              }\n            });\n          }\n        });\n        lastResolvedCountRef.current = resolvedPredictions.length;\n      }\n      \n      // Update state with latest engine data and evolution state\n      setScalpingState(prev => ({\n        ...prev,\n        learningState: engineRef.current.getState(),\n        evolutionState: selfEvolvingSystem.getState(),\n        pendingPredictions: engineRef.current.getPendingPredictions(),\n        recentPredictions,\n        stats: engineRef.current.getStats(),\n        tickCount: engineRef.current.getTickCount(),\n        latestPrice: tick.price,\n        priceChange,\n        priceChangePercent\n      }));\n    });\n    \n    return unsubscribe;\n  }, [tickStream]);\n  \n  // Generate prediction\n  const generatePrediction = useCallback((horizonMs?: number) => {\n    const prediction = engineRef.current.generatePrediction(horizonMs);\n    if (prediction) {\n      setScalpingState(prev => ({\n        ...prev,\n        currentPrediction: prediction,\n        pendingPredictions: engineRef.current.getPendingPredictions()\n      }));\n    }\n    return prediction;\n  }, []);\n  \n  // Heartbeat for auto-predictions\n  const { isAlive, pulse, start, stop, restart, pulseCount, nextPulseIn, isProcessing, lastPulse } = useLiveHeartbeat({\n    interval: config.predictionIntervalMs,\n    autoStart: config.autoPredict,\n    enabled: config.autoPredict,\n    onPulse: () => {\n      if (config.autoPredict && tickStream.connected) {\n        generatePrediction();\n      }\n    }\n  });\n  \n  // Reset engine\n  const reset = useCallback(() => {\n    engineRef.current.reset();\n    startPriceRef.current = null;\n    lastResolvedCountRef.current = 0;\n    setScalpingState({\n      learningState: DEFAULT_LEARNING_STATE,\n      evolutionState: selfEvolvingSystem.getState(),\n      currentPrediction: null,\n      pendingPredictions: [],\n      recentPredictions: [],\n      stats: {\n        totalPredictions: 0,\n        accuracy: 0,\n        recentAccuracy: 0,\n        currentStreak: 0,\n        bestStreak: 0,\n        upPredictions: { total: 0, correct: 0, accuracy: 0 },\n        downPredictions: { total: 0, correct: 0, accuracy: 0 },\n        flatPredictions: { total: 0, correct: 0, accuracy: 0 }\n      },\n      tickCount: 0,\n      latestPrice: null,\n      priceChange: 0,\n      priceChangePercent: 0\n    });\n  }, []);\n  \n  return {\n    // State\n    ...scalpingState,\n    \n    // Stream state\n    connected: tickStream.connected,\n    ticksPerSecond: tickStream.ticksPerSecond,\n    streamError: tickStream.error,\n    \n    // Heartbeat state\n    heartbeatAlive: isAlive,\n    isProcessing,\n    lastPulse,\n    pulseCount,\n    nextPulseIn,\n    \n    // Actions\n    generatePrediction,\n    reset,\n    startHeartbeat: start,\n    stopHeartbeat: stop,\n    restartHeartbeat: restart,\n    manualPulse: pulse,\n    disconnect: tickStream.disconnect,\n    reconnect: tickStream.reconnect\n  };\n}\n";export{n as default};
