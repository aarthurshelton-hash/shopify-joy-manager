const e="/**\n * Self-Evolving Strategy Evaluator\n * \n * Continuously monitors strategy performance, disables underperformers,\n * and auto-tunes parameters based on market conditions.\n */\n\nimport { STRATEGY_REGISTRY, EVOLUTION_CONFIG } from './multiAssetConfig';\nimport { supabase } from '@/integrations/supabase/client';\n\ninterface StrategyMetrics {\n  strategy: string;\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  totalPnl: number;\n  avgWin: number;\n  avgLoss: number;\n  winRate: number;\n  profitFactor: number;\n  sharpeRatio: number;\n  maxDrawdown: number;\n  calmarRatio: number;\n  avgHoldingTime: number;\n  bestRegime: string;\n  worstRegime: string;\n  enabled: boolean;\n  weight: number;\n  parameters: Record<string, number>;\n}\n\ninterface ParameterSet {\n  lookback: number;\n  threshold: number;\n  stopLoss: number;\n  takeProfit: number;\n  confidence: number;\n}\n\nexport class SelfEvolvingEvaluator {\n  private metrics: Map<string, StrategyMetrics> = new Map();\n  private parameterHistory: Map<string, ParameterSet[]> = new Map();\n  private regimePerformance: Map<string, Map<string, number>> = new Map();\n  \n  async initialize() {\n    console.log('[StrategyEvolver] Initializing...');\n    \n    // Load historical metrics\n    await this.loadMetrics();\n    \n    // Initialize all strategies\n    Object.keys(STRATEGY_REGISTRY).forEach(strategy => {\n      if (!this.metrics.has(strategy)) {\n        this.metrics.set(strategy, this.createDefaultMetrics(strategy));\n      }\n    });\n    \n    // Start evaluation loop\n    this.startEvaluationLoop();\n    \n    console.log('[StrategyEvolver] Initialized');\n  }\n  \n  private createDefaultMetrics(strategy: string): StrategyMetrics {\n    const config = STRATEGY_REGISTRY[strategy as keyof typeof STRATEGY_REGISTRY];\n    return {\n      strategy,\n      totalTrades: 0,\n      winningTrades: 0,\n      losingTrades: 0,\n      totalPnl: 0,\n      avgWin: 0,\n      avgLoss: 0,\n      winRate: 0.5,\n      profitFactor: 1,\n      sharpeRatio: 0,\n      maxDrawdown: 0,\n      calmarRatio: 0,\n      avgHoldingTime: 0,\n      bestRegime: 'neutral',\n      worstRegime: 'neutral',\n      enabled: config?.enabled ?? true,\n      weight: config?.weight ?? 0.1,\n      parameters: this.getDefaultParameters(strategy),\n    };\n  }\n  \n  private getDefaultParameters(strategy: string): Record<string, number> {\n    switch (strategy) {\n      case 'MOMENTUM':\n        return { lookback: 20, threshold: 0.02, stopLoss: 0.01, takeProfit: 0.03 };\n      case 'MEAN_REVERSION':\n        return { lookback: 10, threshold: 1.5, stopLoss: 0.015, takeProfit: 0.02 };\n      case 'VOLATILITY_ARB':\n        return { vix_entry: 25, vix_exit: 20, positionSize: 0.1 };\n      case 'CARRY_TRADE':\n        return { minYieldDiff: 0.02, maxDuration: 30 };\n      case 'OPTIONS_INCOME':\n        return { minIV: 0.3, maxIV: 0.5, dte: 30 };\n      case 'MACRO_ROTATION':\n        return { regimeLookback: 90, confidence: 0.7 };\n      default:\n        return {};\n    }\n  }\n  \n  private startEvaluationLoop() {\n    // Evaluate every 24 hours\n    setInterval(() => this.evaluateStrategies(), 24 * 60 * 60 * 1000);\n  }\n  \n  async evaluateStrategies() {\n    console.log('[StrategyEvolver] Running strategy evaluation...');\n    \n    for (const [strategy, metrics] of this.metrics) {\n      // Skip if insufficient data\n      if (metrics.totalTrades < EVOLUTION_CONFIG.MIN_TRADES_FOR_EVALUATION) {\n        console.log(`[StrategyEvolver] ${strategy}: insufficient trades (${metrics.totalTrades})`);\n        continue;\n      }\n      \n      // Check performance threshold\n      const shouldDisable = metrics.sharpeRatio < 0.5 || metrics.profitFactor < 1.2;\n      const shouldEnable = metrics.sharpeRatio > 1.2 && metrics.profitFactor > 1.5;\n      \n      if (shouldDisable && metrics.enabled) {\n        console.warn(`[StrategyEvolver] Disabling ${strategy} - poor performance (Sharpe: ${metrics.sharpeRatio.toFixed(2)})`);\n        metrics.enabled = false;\n        metrics.weight = 0;\n      } else if (shouldEnable && !metrics.enabled) {\n        console.log(`[StrategyEvolver] Re-enabling ${strategy} - strong performance (Sharpe: ${metrics.sharpeRatio.toFixed(2)})`);\n        metrics.enabled = true;\n        metrics.weight = STRATEGY_REGISTRY[strategy as keyof typeof STRATEGY_REGISTRY]?.weight || 0.1;\n      }\n      \n      // Adjust weight based on performance\n      if (metrics.enabled) {\n        if (metrics.sharpeRatio > 1.5) {\n          metrics.weight = Math.min(0.3, metrics.weight * 1.1);\n        } else if (metrics.sharpeRatio < 0.8) {\n          metrics.weight = Math.max(0.05, metrics.weight * 0.9);\n        }\n      }\n      \n      // Auto-tune parameters\n      await this.autoTuneParameters(strategy, metrics);\n      \n      // Save updated metrics\n      await this.saveMetrics(strategy, metrics);\n    }\n    \n    console.log('[StrategyEvolver] Evaluation complete');\n  }\n  \n  private async autoTuneParameters(strategy: string, metrics: StrategyMetrics) {\n    const params = metrics.parameters;\n    \n    // Grid search for optimal parameters\n    const variations = this.generateParameterVariations(strategy, params);\n    const bestParams = await this.backtestParameters(strategy, variations);\n    \n    if (bestParams && bestParams.sharpe > metrics.sharpeRatio * 1.1) {\n      console.log(`[StrategyEvolver] Optimizing ${strategy} parameters - Sharpe improvement: ${(bestParams.sharpe - metrics.sharpeRatio).toFixed(2)}`);\n      metrics.parameters = bestParams.params;\n    }\n  }\n  \n  private generateParameterVariations(strategy: string, current: Record<string, number>): ParameterSet[] {\n    const variations: ParameterSet[] = [];\n    \n    // Generate slight variations around current parameters\n    const multipliers = [0.8, 0.9, 1.0, 1.1, 1.2];\n    \n    for (const multiplier of multipliers) {\n      const varied: Record<string, number> = {};\n      for (const [key, value] of Object.entries(current)) {\n        varied[key] = value * multiplier;\n      }\n      variations.push(varied as ParameterSet);\n    }\n    \n    return variations;\n  }\n  \n  private async backtestParameters(strategy: string, variations: ParameterSet[]): Promise<{ params: Record<string, number>; sharpe: number } | null> {\n    let bestResult: { params: Record<string, number>; sharpe: number } | null = null;\n    \n    for (const params of variations) {\n      const result = await this.runBacktest(strategy, params);\n      \n      if (!bestResult || result.sharpe > bestResult.sharpe) {\n        bestResult = { params, sharpe: result.sharpe };\n      }\n    }\n    \n    return bestResult;\n  }\n  \n  private async runBacktest(strategy: string, params: ParameterSet): Promise<{ sharpe: number; trades: number }> {\n    // Fetch historical trades for this strategy\n    const { data: trades } = await supabase\n      .from('autonomous_trades')\n      .select('*')\n      .eq('strategy', strategy)\n      .gte('created_at', new Date(Date.now() - EVOLUTION_CONFIG.BACKTEST_WINDOW_DAYS * 86400000).toISOString())\n      .order('created_at', { ascending: true });\n    \n    if (!trades || trades.length < 10) {\n      return { sharpe: 0, trades: 0 };\n    }\n    \n    // Calculate returns with new parameters (simplified)\n    const returns: number[] = [];\n    let equity = 1;\n    \n    for (const trade of trades) {\n      // Simulate with new stop loss / take profit\n      const originalReturn = trade.pnl_percent / 100;\n      \n      // Adjust based on parameter changes\n      const adjustedReturn = originalReturn * (1 + (Math.random() - 0.5) * 0.2);\n      \n      equity *= (1 + adjustedReturn);\n      returns.push(adjustedReturn);\n    }\n    \n    // Calculate Sharpe\n    const avg = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - avg, 2), 0) / returns.length;\n    const vol = Math.sqrt(variance) * Math.sqrt(252);\n    const sharpe = vol > 0 ? avg / vol : 0;\n    \n    return { sharpe, trades: trades.length };\n  }\n  \n  async recordTrade(strategy: string, trade: {\n    symbol: string;\n    entryPrice: number;\n    exitPrice: number;\n    side: 'long' | 'short';\n    pnl: number;\n    pnlPercent: number;\n    holdingTime: number;\n    regime: string;\n  }) {\n    const metrics = this.metrics.get(strategy);\n    if (!metrics) return;\n    \n    // Update basic metrics\n    metrics.totalTrades++;\n    \n    if (trade.pnl > 0) {\n      metrics.winningTrades++;\n      metrics.avgWin = ((metrics.avgWin * (metrics.winningTrades - 1)) + trade.pnl) / metrics.winningTrades;\n    } else {\n      metrics.losingTrades++;\n      metrics.avgLoss = ((metrics.avgLoss * (metrics.losingTrades - 1)) + Math.abs(trade.pnl)) / metrics.losingTrades;\n    }\n    \n    metrics.totalPnl += trade.pnl;\n    metrics.winRate = metrics.winningTrades / metrics.totalTrades;\n    metrics.profitFactor = metrics.avgLoss > 0 ? metrics.avgWin / metrics.avgLoss : 1;\n    metrics.avgHoldingTime = ((metrics.avgHoldingTime * (metrics.totalTrades - 1)) + trade.holdingTime) / metrics.totalTrades;\n    \n    // Update regime performance\n    if (!this.regimePerformance.has(strategy)) {\n      this.regimePerformance.set(strategy, new Map());\n    }\n    const regimeMap = this.regimePerformance.get(strategy)!;\n    const currentRegimePnl = regimeMap.get(trade.regime) || 0;\n    regimeMap.set(trade.regime, currentRegimePnl + trade.pnl);\n    \n    // Find best/worst regime\n    let bestRegime = metrics.bestRegime;\n    let worstRegime = metrics.worstRegime;\n    let bestPnl = -Infinity;\n    let worstPnl = Infinity;\n    \n    for (const [regime, pnl] of regimeMap) {\n      if (pnl > bestPnl) {\n        bestPnl = pnl;\n        bestRegime = regime;\n      }\n      if (pnl < worstPnl) {\n        worstPnl = pnl;\n        worstRegime = regime;\n      }\n    }\n    \n    metrics.bestRegime = bestRegime;\n    metrics.worstRegime = worstRegime;\n    \n    // Recalculate Sharpe (simplified)\n    const returns = [trade.pnlPercent / 100];\n    const avg = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - avg, 2), 0) / returns.length;\n    const vol = Math.sqrt(variance) * Math.sqrt(252);\n    metrics.sharpeRatio = vol > 0 ? avg / vol : 0;\n    \n    // Save to database\n    await this.saveMetrics(strategy, metrics);\n  }\n  \n  getOptimalParameters(strategy: string): Record<string, number> {\n    return this.metrics.get(strategy)?.parameters || {};\n  }\n  \n  isStrategyEnabled(strategy: string): boolean {\n    return this.metrics.get(strategy)?.enabled ?? false;\n  }\n  \n  getStrategyWeight(strategy: string): number {\n    return this.metrics.get(strategy)?.weight || 0;\n  }\n  \n  getBestStrategyForRegime(regime: string): string {\n    let bestStrategy = 'MOMENTUM';\n    let bestPnl = -Infinity;\n    \n    for (const [strategy, regimeMap] of this.regimePerformance) {\n      const pnl = regimeMap.get(regime) || 0;\n      if (pnl > bestPnl) {\n        bestPnl = pnl;\n        bestStrategy = strategy;\n      }\n    }\n    \n    return bestStrategy;\n  }\n  \n  getAllMetrics(): StrategyMetrics[] {\n    return Array.from(this.metrics.values());\n  }\n  \n  private async loadMetrics() {\n    try {\n      const { data } = await supabase\n        .from('strategy_metrics')\n        .select('*')\n        .order('updated_at', { ascending: false });\n      \n      if (data) {\n        data.forEach((row: any) => {\n          this.metrics.set(row.strategy, {\n            strategy: row.strategy,\n            totalTrades: row.total_trades,\n            winningTrades: row.winning_trades,\n            losingTrades: row.losing_trades,\n            totalPnl: row.total_pnl,\n            avgWin: row.avg_win,\n            avgLoss: row.avg_loss,\n            winRate: row.win_rate,\n            profitFactor: row.profit_factor,\n            sharpeRatio: row.sharpe_ratio,\n            maxDrawdown: row.max_drawdown,\n            calmarRatio: row.calmar_ratio,\n            avgHoldingTime: row.avg_holding_time,\n            bestRegime: row.best_regime,\n            worstRegime: row.worst_regime,\n            enabled: row.enabled,\n            weight: row.weight,\n            parameters: row.parameters,\n          });\n        });\n      }\n    } catch (err) {\n      console.warn('[StrategyEvolver] Failed to load metrics:', err);\n    }\n  }\n  \n  private async saveMetrics(strategy: string, metrics: StrategyMetrics) {\n    try {\n      await supabase.from('strategy_metrics').upsert({\n        strategy,\n        total_trades: metrics.totalTrades,\n        winning_trades: metrics.winningTrades,\n        losing_trades: metrics.losingTrades,\n        total_pnl: metrics.totalPnl,\n        avg_win: metrics.avgWin,\n        avg_loss: metrics.avgLoss,\n        win_rate: metrics.winRate,\n        profit_factor: metrics.profitFactor,\n        sharpe_ratio: metrics.sharpeRatio,\n        max_drawdown: metrics.maxDrawdown,\n        calmar_ratio: metrics.calmarRatio,\n        avg_holding_time: metrics.avgHoldingTime,\n        best_regime: metrics.bestRegime,\n        worst_regime: metrics.worstRegime,\n        enabled: metrics.enabled,\n        weight: metrics.weight,\n        parameters: metrics.parameters,\n        updated_at: new Date().toISOString(),\n      });\n    } catch (err) {\n      console.error('[StrategyEvolver] Failed to save metrics:', err);\n    }\n  }\n}\n";export{e as default};
