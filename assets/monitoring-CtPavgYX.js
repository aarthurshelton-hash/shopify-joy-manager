const n="/**\n * Marketplace Monitoring and Alerting\n * \n * Tracks key metrics and triggers alerts for heavy business load\n */\n\nimport { supabase } from '@/integrations/supabase/client';\n\n// Alert thresholds\nconst THRESHOLDS = {\n  errorRate: 0.05,        // 5% error rate\n  responseTime: 5000,     // 5 seconds\n  queueDepth: 100,        // 100 pending items\n  memoryUsage: 0.9,       // 90% memory\n  checkoutFailures: 10,   // 10 failures in 5 minutes\n};\n\ninterface MetricEntry {\n  timestamp: number;\n  value: number;\n  metadata?: Record<string, unknown>;\n}\n\n// In-memory metrics storage (in production, use time-series DB)\nconst metricsStore = new Map<string, MetricEntry[]>();\nconst MAX_METRICS_PER_KEY = 1000;\n\n/**\n * Record a metric\n */\nexport function recordMetric(\n  name: string,\n  value: number,\n  metadata?: Record<string, unknown>\n): void {\n  const entry: MetricEntry = {\n    timestamp: Date.now(),\n    value,\n    metadata,\n  };\n  \n  if (!metricsStore.has(name)) {\n    metricsStore.set(name, []);\n  }\n  \n  const metrics = metricsStore.get(name)!;\n  metrics.push(entry);\n  \n  // Keep only recent metrics\n  if (metrics.length > MAX_METRICS_PER_KEY) {\n    metrics.shift();\n  }\n}\n\n/**\n * Get metrics for a time range\n */\nexport function getMetrics(\n  name: string,\n  timeRangeMs: number = 5 * 60 * 1000\n): MetricEntry[] {\n  const metrics = metricsStore.get(name) || [];\n  const cutoff = Date.now() - timeRangeMs;\n  return metrics.filter(m => m.timestamp > cutoff);\n}\n\n/**\n * Calculate error rate for an operation\n */\nexport function calculateErrorRate(operation: string): number {\n  const total = getMetrics(`${operation}:total`).length;\n  const errors = getMetrics(`${operation}:error`).length;\n  \n  if (total === 0) return 0;\n  return errors / total;\n}\n\n/**\n * Check if any thresholds are breached\n */\nexport async function checkHealth(): Promise<{\n  healthy: boolean;\n  issues: string[];\n}> {\n  const issues: string[] = [];\n  \n  // Check error rates\n  const checkoutErrorRate = calculateErrorRate('checkout');\n  if (checkoutErrorRate > THRESHOLDS.errorRate) {\n    issues.push(`High checkout error rate: ${(checkoutErrorRate * 100).toFixed(1)}%`);\n  }\n  \n  const purchaseErrorRate = calculateErrorRate('marketplace_purchase');\n  if (purchaseErrorRate > THRESHOLDS.errorRate) {\n    issues.push(`High purchase error rate: ${(purchaseErrorRate * 100).toFixed(1)}%`);\n  }\n  \n  // Check queue depths\n  try {\n    const { data: queueStats } = await supabase\n      .from('processing_queue')\n      .select('status')\n      .in('status', ['pending', 'failed']);\n    \n    const pending = queueStats?.filter(i => i.status === 'pending').length || 0;\n    const failed = queueStats?.filter(i => i.status === 'failed').length || 0;\n    \n    if (pending > THRESHOLDS.queueDepth) {\n      issues.push(`High queue depth: ${pending} pending items`);\n    }\n    \n    if (failed > 10) {\n      issues.push(`High failure count: ${failed} failed jobs`);\n    }\n  } catch {\n    // Ignore errors in health check\n  }\n  \n  // Check recent checkout failures\n  const recentFailures = getMetrics('checkout:failure', 5 * 60 * 1000).length;\n  if (recentFailures > THRESHOLDS.checkoutFailures) {\n    issues.push(`High checkout failure count: ${recentFailures} in 5 minutes`);\n  }\n  \n  return {\n    healthy: issues.length === 0,\n    issues,\n  };\n}\n\n/**\n * Log alert to database\n */\nexport async function logAlert(\n  severity: 'warning' | 'critical',\n  message: string,\n  metadata?: Record<string, unknown>\n): Promise<void> {\n  try {\n    await supabase.from('system_alerts').insert({\n      severity,\n      message,\n      metadata,\n      created_at: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('[Monitor] Failed to log alert:', error);\n  }\n}\n\n/**\n * Track operation start\n */\nexport function trackOperationStart(operation: string): void {\n  recordMetric(`${operation}:total`, 1);\n  recordMetric(`${operation}:start_time`, Date.now());\n}\n\n/**\n * Track operation success\n */\nexport function trackOperationSuccess(operation: string, durationMs: number): void {\n  recordMetric(`${operation}:success`, 1);\n  recordMetric(`${operation}:duration`, durationMs);\n}\n\n/**\n * Track operation failure\n */\nexport function trackOperationFailure(operation: string, error: Error): void {\n  recordMetric(`${operation}:error`, 1);\n  recordMetric(`${operation}:failure`, 1, { message: error.message });\n}\n\n/**\n * Wrap function with monitoring\n */\nexport async function withMonitoring<T>(\n  operation: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  const startTime = Date.now();\n  trackOperationStart(operation);\n  \n  try {\n    const result = await fn();\n    trackOperationSuccess(operation, Date.now() - startTime);\n    return result;\n  } catch (error) {\n    trackOperationFailure(operation, error instanceof Error ? error : new Error(String(error)));\n    throw error;\n  }\n}\n\n/**\n * Run periodic health checks\n */\nexport function startHealthChecks(intervalMs: number = 60000): () => void {\n  const check = async () => {\n    const health = await checkHealth();\n    \n    if (!health.healthy) {\n      for (const issue of health.issues) {\n        console.warn('[HealthCheck] Issue detected:', issue);\n        await logAlert('warning', issue);\n      }\n    }\n  };\n  \n  // Run immediately\n  check();\n  \n  // Schedule periodic checks\n  const interval = setInterval(check, intervalMs);\n  \n  // Return cleanup function\n  return () => clearInterval(interval);\n}\n\n/**\n * Get system status summary\n */\nexport async function getSystemStatus(): Promise<{\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  metrics: Record<string, number>;\n  issues: string[];\n}> {\n  const health = await checkHealth();\n  \n  const metrics = {\n    checkoutErrorRate: calculateErrorRate('checkout'),\n    purchaseErrorRate: calculateErrorRate('marketplace_purchase'),\n    avgCheckoutDuration: calculateAverage('checkout:duration'),\n    pendingQueue: getMetrics('queue:pending').length,\n  };\n  \n  let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n  if (health.issues.length > 2) {\n    status = 'unhealthy';\n  } else if (health.issues.length > 0) {\n    status = 'degraded';\n  }\n  \n  return {\n    status,\n    metrics,\n    issues: health.issues,\n  };\n}\n\nfunction calculateAverage(metric: string): number {\n  const metrics = getMetrics(metric);\n  if (metrics.length === 0) return 0;\n  \n  const sum = metrics.reduce((acc, m) => acc + m.value, 0);\n  return sum / metrics.length;\n}\n";export{n as default};
