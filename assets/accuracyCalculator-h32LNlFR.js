const n="/**\n * Accuracy Calculator - Multi-level accuracy scoring for predictions\n */\n\nimport { TickPrediction, MultiLevelAccuracy } from './types';\n\nexport function calculateMultiLevelAccuracy(\n  prediction: TickPrediction,\n  actualDirection: 'up' | 'down' | 'flat',\n  actualMagnitude: number\n): MultiLevelAccuracy {\n  // Level 1: Direction accuracy (binary)\n  const directionScore = prediction.predictedDirection === actualDirection ? 100 : 0;\n  \n  // Level 2: Magnitude accuracy\n  const predictedMagnitude = prediction.predictedMagnitude || \n    (prediction.targetPrice \n      ? Math.abs((prediction.targetPrice - prediction.priceAtPrediction) / prediction.priceAtPrediction) * 100\n      : 0);\n  \n  let magnitudeScore = 0;\n  if (predictedMagnitude > 0) {\n    const magnitudeError = Math.abs(actualMagnitude - predictedMagnitude);\n    magnitudeScore = Math.max(0, 100 - (magnitudeError / predictedMagnitude) * 100);\n  } else if (actualMagnitude < 0.01) {\n    magnitudeScore = 80;\n  }\n  \n  // Level 3: Timing accuracy\n  const timingElapsed = Date.now() - prediction.timestamp;\n  const timingError = Math.abs(timingElapsed - prediction.horizonMs);\n  const timingTolerance = prediction.horizonMs * 0.3;\n  const timingScore = Math.max(0, 100 - (timingError / timingTolerance) * 50);\n  \n  // Level 4: Confidence calibration\n  const wasCorrect = prediction.predictedDirection === actualDirection;\n  const confidenceAligned = wasCorrect ? prediction.confidence : (100 - prediction.confidence);\n  const confidenceScore = confidenceAligned;\n  \n  // Composite score (weighted average)\n  const composite = (\n    directionScore * 0.40 +\n    magnitudeScore * 0.25 +\n    timingScore * 0.15 +\n    confidenceScore * 0.20\n  );\n  \n  return {\n    direction: directionScore,\n    magnitude: Math.round(magnitudeScore),\n    timing: Math.round(timingScore),\n    confidence: Math.round(confidenceScore),\n    composite: Math.round(composite)\n  };\n}\n";export{n as default};
