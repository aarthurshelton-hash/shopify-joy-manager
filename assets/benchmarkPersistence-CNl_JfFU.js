const n="/**\n * Benchmark Persistence & Learning\n * \n * Stores all benchmark results for:\n * 1. Historical tracking of accuracy improvement\n * 2. Pattern learning from predictions\n * 3. Archetype-specific refinement\n * 4. Public proof of our claims\n * 5. Cross-run deduplication for data integrity\n */\n\nimport { supabase } from '@/integrations/supabase/client';\nimport type { BenchmarkResult, PredictionAttempt } from './cloudBenchmark';\n\n/**\n * Normalize FEN to position-only part for consistent matching\n * Removes move clocks which don't affect position identity\n */\nexport function normalizeFen(fen: string): string {\n  // Handle moves: format from edge function - extract move sequence\n  if (fen.startsWith('moves:')) {\n    return fen; // Already normalized for move-based FENs\n  }\n  return fen.split(' ').slice(0, 4).join(' ');\n}\n\n/**\n * Generate a unique hash for a chess position\n * Uses SHA256-like hash of normalized FEN (first 16 chars)\n * This MUST match the database hash format for deduplication\n */\nexport function hashPosition(fen: string): string {\n  const positionPart = normalizeFen(fen);\n  \n  // Use SHA256-like hash (matches database migration)\n  // Simple but consistent hash - djb2 with 16-char hex output\n  let hash1 = 5381;\n  let hash2 = 52711;\n  for (let i = 0; i < positionPart.length; i++) {\n    const char = positionPart.charCodeAt(i);\n    hash1 = ((hash1 << 5) + hash1) ^ char;\n    hash2 = ((hash2 << 5) + hash2) ^ char;\n    hash1 = hash1 >>> 0;\n    hash2 = hash2 >>> 0;\n  }\n  return hash1.toString(16).padStart(8, '0') + hash2.toString(16).padStart(8, '0');\n}\n\n/**\n * Fetch all previously analyzed GAMES (not positions)\n * \n * CRITICAL INSIGHT: Deduplication is GAME-BASED ONLY\n * - Same position in DIFFERENT games = VALUABLE (strengthens pattern recognition)\n * - Same GAME (same Lichess ID) = SKIP (already predicted)\n * \n * We ONLY deduplicate by Lichess game ID to ensure we never analyze the same \n * game twice, but identical positions appearing in different games are welcome.\n */\n/**\n * Check if a game ID is a REAL external ID (Lichess or Chess.com)\n * v6.57: Now supports prefixed IDs (li_XXXXXXXX, cc_XXXXXXXXX)\n * Real IDs: \"ZhoooCoY\", \"li_ZhoooCoY\", \"cc_123456789\"\n * NOT real: \"benchmark-1234567890-0\", \"internal_sfvsf_0\"\n */\nexport function isRealLichessId(gameId: string): boolean {\n  // Strip prefix if present\n  const rawId = gameId.replace(/^(li_|cc_)/, '');\n  const hasValidPrefix = gameId.startsWith('li_') || gameId.startsWith('cc_');\n  \n  // Lichess: 8 alphanumeric chars\n  const isLichess = rawId.length === 8 && /^[a-zA-Z0-9]+$/.test(rawId);\n  // Chess.com: numeric IDs of varying length\n  const isChessCom = gameId.startsWith('cc_') && /^\\d+$/.test(rawId);\n  \n  return isLichess || isChessCom || (hasValidPrefix && rawId.length >= 6);\n}\n\n/**\n * Fetch all previously analyzed REAL Lichess games for deduplication\n * \n * v4.0: COMPLETELY ELIMINATES synthetic ID tracking.\n * We ONLY care about real 8-char Lichess IDs for deduplication.\n * All other IDs are treated as noise and ignored.\n */\nexport async function getAlreadyAnalyzedData(): Promise<{\n  gameIds: Set<string>;          // Contains ONLY real 8-char Lichess IDs now\n  realLichessIds: Set<string>;   // Same as gameIds (kept for backwards compat)\n  positionHashes: Set<string>;   // For pattern learning cross-reference (NOT deduplication)\n  fenStrings: Set<string>;       // For pattern learning (NOT deduplication)\n}> {\n  const gameIds = new Set<string>();        // NOW contains ONLY real Lichess IDs\n  const positionHashes = new Set<string>(); // For learning, NOT deduplication\n  const fenStrings = new Set<string>();     // For learning, NOT deduplication\n\n  // CRITICAL: Paginate through ALL records to bypass 1000 row limit\n  let from = 0;\n  const pageSize = 1000;\n  let hasMore = true;\n  let totalFetched = 0;\n  let syntheticSkipped = 0;\n\n  while (hasMore) {\n    const { data, error } = await supabase\n      .from('chess_prediction_attempts')\n      .select('position_hash, game_id, fen')\n      .range(from, from + pageSize - 1);\n\n    if (error) {\n      console.warn('[v4.0-DEDUP] Error fetching games:', error);\n      break;\n    }\n\n    if (!data || data.length === 0) {\n      hasMore = false;\n      break;\n    }\n\n    for (const row of data) {\n      if (row.game_id) {\n        // v6.57: Add BOTH raw and prefixed forms for dedup matching\n        if (isRealLichessId(row.game_id)) {\n          gameIds.add(row.game_id);\n          // Also add raw form for cross-matching\n          const rawId = row.game_id.replace(/^(li_|cc_)/, '');\n          if (rawId !== row.game_id) {\n            gameIds.add(rawId);\n          }\n        } else {\n          syntheticSkipped++;\n        }\n      }\n      \n      // Position data for pattern learning (NOT used for deduplication)\n      if (row.position_hash) positionHashes.add(row.position_hash);\n      if (row.fen) fenStrings.add(normalizeFen(row.fen));\n    }\n\n    totalFetched += data.length;\n    from += pageSize;\n    hasMore = data.length === pageSize;\n  }\n\n  console.log(`[v4.0-DEDUP] Database: ${totalFetched} records, ${gameIds.size} real Lichess IDs, ${syntheticSkipped} synthetic skipped`);\n  \n  // Return gameIds as the canonical set - realLichessIds is the same reference for compatibility\n  return { gameIds, realLichessIds: gameIds, positionHashes, fenStrings };\n}\n\n/**\n * Check if a specific position has already been analyzed.\n * SYNCHRONOUS for in-memory check, fires background reaffirmation.\n * When a duplicate is found, we reaffirm our existing knowledge\n * (increment confidence) without re-analyzing - Stockfish doesn't \n * have this compounding advantage.\n */\nexport function isPositionAlreadyAnalyzed(\n  fen: string, \n  analyzedData: { positionHashes: Set<string>; fenStrings: Set<string> },\n  reaffirmOnDuplicate: boolean = true\n): boolean {\n  const hash = hashPosition(fen);\n  const normalizedFen = normalizeFen(fen);\n  \n  // Check BOTH hash AND normalized FEN for maximum duplicate detection\n  const isDuplicate = analyzedData.positionHashes.has(hash) || analyzedData.fenStrings.has(normalizedFen);\n  \n  if (isDuplicate && reaffirmOnDuplicate) {\n    // Fire-and-forget reaffirmation - don't block the check\n    reaffirmExistingPrediction(fen, hash).catch(() => {});\n  }\n  \n  return isDuplicate;\n}\n\n/**\n * Check if a specific game has already been analyzed (v4.0).\n * \n * ONLY checks real 8-char Lichess IDs. Synthetic IDs always return false\n * because we don't track them for deduplication purposes.\n */\nexport function isGameAlreadyAnalyzed(\n  gameId: string, \n  analyzedData: { gameIds: Set<string> }\n): boolean {\n  // v4.0: First verify this is even a real Lichess ID format\n  // If not, we can't have analyzed it as a \"real\" game\n  if (!isRealLichessId(gameId)) {\n    return false;\n  }\n  return analyzedData.gameIds.has(gameId);\n}\n\n/**\n * Reaffirm existing prediction data when we encounter a duplicate.\n * This compounds our knowledge without re-analyzing - we already know\n * the outcome, Stockfish doesn't have this memory advantage.\n */\nexport async function reaffirmExistingPrediction(fen: string, hash: string): Promise<void> {\n  try {\n    // Find the existing prediction for this position\n    const { data: existing } = await supabase\n      .from('chess_prediction_attempts')\n      .select('id, hybrid_confidence, hybrid_correct, lesson_learned')\n      .or(`position_hash.eq.${hash},fen.eq.${fen}`)\n      .limit(1)\n      .single();\n    \n    if (existing) {\n      // Boost confidence slightly for validated patterns (max 0.99)\n      const boostedConfidence = Math.min(0.99, (existing.hybrid_confidence || 0.5) + 0.01);\n      \n      // Update with reaffirmed confidence\n      await supabase\n        .from('chess_prediction_attempts')\n        .update({ \n          hybrid_confidence: boostedConfidence,\n          lesson_learned: {\n            ...(existing.lesson_learned as Record<string, unknown> || {}),\n            reaffirmed_count: ((existing.lesson_learned as Record<string, unknown>)?.reaffirmed_count as number || 0) + 1,\n            last_reaffirmed: new Date().toISOString()\n          }\n        })\n        .eq('id', existing.id);\n      \n      console.log(`[Reaffirm] Position ${hash.slice(0, 8)}... reaffirmed (conf: ${boostedConfidence.toFixed(3)})`);\n    }\n  } catch (error) {\n    // Silent fail - reaffirmation is enhancement, not critical\n    console.debug('[Reaffirm] Could not reaffirm position:', error);\n  }\n}\n\n/**\n * Analyze what can be learned from a prediction\n * Returns a JSON-compatible object\n */\nfunction analyzeLessonLearned(attempt: PredictionAttempt): {\n  timestamp: string;\n  type: string;\n  insight: string;\n  archetype: string;\n  [key: string]: string | number | boolean | undefined;\n} {\n  const base = {\n    timestamp: new Date().toISOString(),\n    type: 'unknown',\n    insight: '',\n    archetype: attempt.hybridArchetype || 'Unknown',\n  };\n\n  // Case 1: Hybrid was right, Stockfish was wrong\n  if (attempt.hybridCorrect && !attempt.stockfishCorrect) {\n    return {\n      ...base,\n      type: 'hybrid_superiority',\n      insight: 'Color Flow detected strategic pattern that pure tactics missed',\n      stockfishMiss: attempt.stockfishEval,\n      confidence: attempt.hybridConfidence,\n    };\n  }\n  // Case 2: Stockfish was right, Hybrid was wrong\n  if (!attempt.hybridCorrect && attempt.stockfishCorrect) {\n    return {\n      ...base,\n      type: 'hybrid_failure',\n      insight: 'Tactical considerations outweighed strategic patterns',\n      needsImprovement: true,\n      stockfishEval: attempt.stockfishEval,\n    };\n  }\n  // Case 3: Both wrong\n  if (!attempt.hybridCorrect && !attempt.stockfishCorrect) {\n    return {\n      ...base,\n      type: 'position_chaos',\n      insight: 'Position too chaotic for either system',\n      unpredictable: true,\n    };\n  }\n  // Case 4: Both right\n  return {\n    ...base,\n    type: 'consensus',\n    insight: 'Clear position correctly evaluated by both systems',\n    reliable: true,\n  };\n}\n\n/**\n * Save benchmark results to database for learning\n */\nexport async function saveBenchmarkResults(result: BenchmarkResult): Promise<string | null> {\n  const runId = `benchmark-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n  \n  try {\n    // Calculate duration\n    const durationMs = result.completedAt \n      ? result.completedAt.getTime() - result.startedAt.getTime()\n      : 0;\n\n    // Insert main benchmark result with TCEC calibration markers\n    const { data: benchmarkData, error: benchmarkError } = await supabase\n      .from('chess_benchmark_results')\n      .insert({\n        run_id: runId,\n        data_source: result.dataSource,\n        total_games: result.totalGames,\n        completed_games: result.completedGames,\n        prediction_move_number: 20,\n        stockfish_accuracy: result.stockfishAccuracy,\n        hybrid_accuracy: result.hybridAccuracy,\n        stockfish_wins: result.stockfishWins,\n        hybrid_wins: result.hybridWins,\n        both_correct: result.bothCorrect,\n        both_wrong: result.bothWrong,\n        p_value: result.pValue,\n        confidence: result.confidence,\n        archetype_performance: result.archetypePerformance,\n        games_analyzed: result.gamesAnalyzed,\n        duration_ms: durationMs,\n        stockfish_version: 'TCEC Stockfish 17 NNUE (ELO 3600) Unlimited',\n        hybrid_version: 'En Pensent Hybrid v2.0 (TCEC Calibrated)',\n        data_quality_tier: 'tcec_calibrated',\n        stockfish_mode: 'tcec_unlimited',\n      })\n      .select('id')\n      .single();\n\n    if (benchmarkError) {\n      console.error('Failed to save benchmark:', benchmarkError);\n      return null;\n    }\n\n    const benchmarkId = benchmarkData.id;\n\n    // v6.65-COMPLETE-ONLY: Filter to ONLY save attempts with COMPLETE predictions\n    // Invalid predictions block the game_id from re-capture in future runs\n    const VALID_PREDICTIONS = ['white', 'black', 'draw', 'white_wins', 'black_wins'];\n    \n    const validAttempts = result.predictionPoints.filter(attempt => {\n      const hybridPred = String(attempt.hybridPrediction || '');\n      const sfPred = String(attempt.stockfishPrediction || '');\n      \n      const hasValidHybrid = hybridPred && hybridPred !== 'unknown' && VALID_PREDICTIONS.includes(hybridPred);\n      const hasValidStockfish = sfPred && sfPred !== 'unknown' && VALID_PREDICTIONS.includes(sfPred);\n      \n      if (!hasValidHybrid || !hasValidStockfish) {\n        console.log(`[v6.65] Skipping incomplete prediction for ${attempt.gameId}: hybrid=${hybridPred}, sf=${sfPred}`);\n        return false;\n      }\n      return true;\n    });\n\n    // Insert individual prediction attempts for learning\n    const attempts = validAttempts.map(attempt => {\n      // v8.0-SOURCE: Determine data_source based on game ID prefix\n      let dataSource: string = 'web_client';\n      if (attempt.gameId?.startsWith('li_')) {\n        dataSource = 'lichess_live';\n      } else if (attempt.gameId?.startsWith('cc_')) {\n        dataSource = 'chesscom_live';\n      } else if (attempt.gameId?.startsWith('term_')) {\n        dataSource = 'farm_terminal';\n      }\n      \n      return {\n        benchmark_id: benchmarkId,\n        game_id: attempt.gameId,\n        game_name: attempt.gameName,\n        move_number: attempt.moveNumber,\n        fen: attempt.fen,\n        pgn: attempt.pgn,\n        stockfish_eval: attempt.stockfishEval,\n        stockfish_depth: attempt.stockfishDepth,\n        stockfish_prediction: attempt.stockfishPrediction,\n        stockfish_confidence: attempt.stockfishConfidence,\n        hybrid_prediction: attempt.hybridPrediction,\n        hybrid_confidence: attempt.hybridConfidence,\n        hybrid_archetype: attempt.hybridArchetype,\n        actual_result: attempt.actualResult,\n        stockfish_correct: attempt.stockfishCorrect,\n        hybrid_correct: attempt.hybridCorrect,\n        position_hash: hashPosition(attempt.fen),\n        lesson_learned: JSON.parse(JSON.stringify(analyzeLessonLearned(attempt))),\n        data_quality_tier: 'tcec_calibrated',\n        data_source: dataSource, // v8.0: Dynamic source based on game origin\n        engine_version: 'TCEC Stockfish 17 NNUE (ELO 3600)',\n        hybrid_engine: 'En Pensent Universal v2.1',\n        lichess_id_verified: true,\n      };\n    });\n    \n    console.log(`[v6.65] Saving ${attempts.length}/${result.predictionPoints.length} complete predictions (${result.predictionPoints.length - attempts.length} incomplete filtered out)`);\n\n    // CRITICAL: Use batch inserts for large sets to avoid timeout issues\n    const BATCH_SIZE = 25;\n    let savedCount = 0;\n    \n    for (let i = 0; i < attempts.length; i += BATCH_SIZE) {\n      const batch = attempts.slice(i, i + BATCH_SIZE);\n      const { error: attemptsError } = await supabase\n        .from('chess_prediction_attempts')\n        .insert(batch);\n\n      if (attemptsError) {\n        console.error(`Failed to save prediction batch ${i / BATCH_SIZE + 1}:`, attemptsError);\n        \n        // CRITICAL FIX: If predictions fail to save, delete the benchmark result\n        // This prevents orphaned benchmark records that inflate total counts\n        await supabase.from('chess_benchmark_results').delete().eq('id', benchmarkId);\n        console.error('[Benchmark] Rolled back benchmark result due to prediction save failure');\n        return null;\n      }\n      \n      savedCount += batch.length;\n    }\n\n    console.log(`[Benchmark] Saved run ${runId} with ${savedCount}/${attempts.length} predictions`);\n    return runId;\n\n  } catch (error) {\n    console.error('Error saving benchmark results:', error);\n    return null;\n  }\n}\n\n/**\n * Get historical benchmark accuracy trend\n */\nexport async function getBenchmarkHistory(limit: number = 20): Promise<{\n  dates: string[];\n  hybridAccuracy: number[];\n  stockfishAccuracy: number[];\n  totalGames: number;\n}> {\n  const { data, error } = await supabase\n    .from('chess_benchmark_results')\n    .select('created_at, hybrid_accuracy, stockfish_accuracy, completed_games')\n    .order('created_at', { ascending: true })\n    .limit(limit);\n\n  if (error || !data) {\n    return { dates: [], hybridAccuracy: [], stockfishAccuracy: [], totalGames: 0 };\n  }\n\n  return {\n    dates: data.map(r => new Date(r.created_at).toLocaleDateString()),\n    hybridAccuracy: data.map(r => Number(r.hybrid_accuracy)),\n    stockfishAccuracy: data.map(r => Number(r.stockfish_accuracy)),\n    totalGames: data.reduce((sum, r) => sum + (r.completed_games || 0), 0),\n  };\n}\n\n/**\n * Get archetype performance statistics across all benchmarks\n * Uses pagination to fetch ALL records beyond 1000 row limit\n */\nexport async function getArchetypeStats(): Promise<Record<string, {\n  totalPredictions: number;\n  correctPredictions: number;\n  accuracy: number;\n  stockfishBeats: number;\n  hybridBeats: number;\n}>> {\n  const stats: Record<string, {\n    totalPredictions: number;\n    correctPredictions: number;\n    accuracy: number;\n    stockfishBeats: number;\n    hybridBeats: number;\n  }> = {};\n\n  // Paginate through all records to bypass 1000 row limit\n  let from = 0;\n  const pageSize = 1000;\n  let hasMore = true;\n\n  while (hasMore) {\n    const { data, error } = await supabase\n      .from('chess_prediction_attempts')\n      .select('hybrid_archetype, hybrid_correct, stockfish_correct, stockfish_prediction')\n      .range(from, from + pageSize - 1);\n\n    if (error || !data || data.length === 0) {\n      hasMore = false;\n      break;\n    }\n\n    for (const attempt of data) {\n      const hasValidStockfishPrediction = attempt.stockfish_prediction && \n        attempt.stockfish_prediction !== 'unknown' &&\n        ['white_wins', 'black_wins', 'draw', 'white', 'black'].includes(attempt.stockfish_prediction);\n      \n      const arch = attempt.hybrid_archetype || 'Unknown';\n      if (!stats[arch]) {\n        stats[arch] = {\n          totalPredictions: 0,\n          correctPredictions: 0,\n          accuracy: 0,\n          stockfishBeats: 0,\n          hybridBeats: 0,\n        };\n      }\n\n      stats[arch].totalPredictions++;\n      if (attempt.hybrid_correct) {\n        stats[arch].correctPredictions++;\n      }\n      \n      if (hasValidStockfishPrediction) {\n        if (attempt.hybrid_correct && !attempt.stockfish_correct) {\n          stats[arch].hybridBeats++;\n        }\n        if (attempt.stockfish_correct && !attempt.hybrid_correct) {\n          stats[arch].stockfishBeats++;\n        }\n      }\n    }\n\n    from += pageSize;\n    hasMore = data.length === pageSize;\n  }\n\n  // Calculate accuracies\n  for (const arch of Object.keys(stats)) {\n    stats[arch].accuracy = stats[arch].totalPredictions > 0\n      ? (stats[arch].correctPredictions / stats[arch].totalPredictions) * 100\n      : 0;\n  }\n\n  return stats;\n}\n\n/**\n * Find positions where hybrid beat stockfish (for learning what works)\n */\nexport async function getHybridWinPatterns(limit: number = 50): Promise<{\n  fen: string;\n  archetype: string;\n  hybridConfidence: number;\n  lesson: Record<string, unknown>;\n}[]> {\n  const { data, error } = await supabase\n    .from('chess_prediction_attempts')\n    .select('fen, hybrid_archetype, hybrid_confidence, lesson_learned')\n    .eq('hybrid_correct', true)\n    .eq('stockfish_correct', false)\n    .order('hybrid_confidence', { ascending: false })\n    .limit(limit);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map(d => ({\n    fen: d.fen,\n    archetype: d.hybrid_archetype || 'Unknown',\n    hybridConfidence: Number(d.hybrid_confidence) || 0,\n    lesson: d.lesson_learned as Record<string, unknown> || {},\n  }));\n}\n\n/**\n * Find positions where hybrid failed (for improvement)\n */\nexport async function getHybridFailurePatterns(limit: number = 50): Promise<{\n  fen: string;\n  archetype: string;\n  stockfishEval: number;\n  lesson: Record<string, unknown>;\n}[]> {\n  const { data, error } = await supabase\n    .from('chess_prediction_attempts')\n    .select('fen, hybrid_archetype, stockfish_eval, lesson_learned')\n    .eq('hybrid_correct', false)\n    .eq('stockfish_correct', true)\n    .order('created_at', { ascending: false })\n    .limit(limit);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map(d => ({\n    fen: d.fen,\n    archetype: d.hybrid_archetype || 'Unknown',\n    stockfishEval: Number(d.stockfish_eval) || 0,\n    lesson: d.lesson_learned as Record<string, unknown> || {},\n  }));\n}\n\n/**\n * Calculate cumulative statistics across all runs\n * v7.26-AUDIT-SYNC: Unified with useRealtimeAccuracy calculations\n * Uses ALL predictions (no exclusions) for accurate totals\n */\nexport async function getCumulativeStats(): Promise<{\n  totalRuns: number;\n  totalGamesAnalyzed: number;\n  overallHybridAccuracy: number;\n  overallStockfishAccuracy: number;\n  hybridNetWins: number;\n  hybridWins: number;\n  stockfishWins: number;\n  bothCorrect: number;\n  bothWrong: number;\n  bestArchetype: string | null;\n  worstArchetype: string | null;\n  validPredictionCount: number;\n  invalidPredictionCount: number;\n}> {\n  // v7.26: Query ALL predictions without filters to match DB truth exactly\n  const [\n    { count: totalPredictions },\n    { count: hybridCorrectCount },\n    { count: sfCorrectCount },\n    { count: bothCorrectCount },\n    { count: bothWrongCount },\n    { count: hybridExclusiveWins },\n    { count: sfExclusiveWins },\n    { count: totalRuns },\n  ] = await Promise.all([\n    // Total predictions (ALL records)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true }),\n    // Hybrid correct (includes both_correct)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true),\n    // Stockfish correct (includes both_correct)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('stockfish_correct', true),\n    // Both correct\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true)\n      .eq('stockfish_correct', true),\n    // Both wrong\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', false)\n      .eq('stockfish_correct', false),\n    // Hybrid exclusive wins (hybrid correct, SF wrong)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', true)\n      .eq('stockfish_correct', false),\n    // SF exclusive wins (SF correct, hybrid wrong)\n    supabase\n      .from('chess_prediction_attempts')\n      .select('*', { count: 'exact', head: true })\n      .eq('hybrid_correct', false)\n      .eq('stockfish_correct', true),\n    // Total benchmark runs\n    supabase\n      .from('chess_benchmark_results')\n      .select('*', { count: 'exact', head: true }),\n  ]);\n\n  const total = totalPredictions || 0;\n  const hybridTotal = hybridCorrectCount || 0;\n  const sfTotal = sfCorrectCount || 0;\n  const bothC = bothCorrectCount || 0;\n  const bothW = bothWrongCount || 0;\n  const hybridWinsExclusive = hybridExclusiveWins || 0;\n  const sfWinsExclusive = sfExclusiveWins || 0;\n\n  console.log('[v7.26-CUMULATIVE] DB Truth:', {\n    total,\n    hybridCorrect: hybridTotal,\n    sfCorrect: sfTotal,\n    bothCorrect: bothC,\n    bothWrong: bothW,\n    hybridExclusive: hybridWinsExclusive,\n    sfExclusive: sfWinsExclusive,\n    runs: totalRuns\n  });\n  \n  const archetypeStats = await getArchetypeStats();\n\n  // Find best/worst archetypes\n  let bestArch: string | null = null;\n  let worstArch: string | null = null;\n  let bestAcc = 0;\n  let worstAcc = 100;\n\n  for (const [arch, stats] of Object.entries(archetypeStats)) {\n    if (stats.totalPredictions >= 5) {\n      if (stats.accuracy > bestAcc) {\n        bestAcc = stats.accuracy;\n        bestArch = arch;\n      }\n      if (stats.accuracy < worstAcc) {\n        worstAcc = stats.accuracy;\n        worstArch = arch;\n      }\n    }\n  }\n\n  // v7.26: Return EXACT DB values - no filtering or transformations\n  return {\n    totalRuns: totalRuns || 0,\n    totalGamesAnalyzed: total,\n    overallHybridAccuracy: total > 0 ? (hybridTotal / total) * 100 : 0,\n    overallStockfishAccuracy: total > 0 ? (sfTotal / total) * 100 : 0,\n    hybridNetWins: hybridWinsExclusive - sfWinsExclusive,\n    hybridWins: hybridWinsExclusive,\n    stockfishWins: sfWinsExclusive,\n    bothCorrect: bothC,\n    bothWrong: bothW,\n    bestArchetype: bestArch,\n    worstArchetype: worstArch,\n    validPredictionCount: total,\n    invalidPredictionCount: 0, // All predictions are valid in v7.26\n  };\n}\n";export{n as default};
