const n="/**\n * Color Flow Signature Extractor\n * \n * Core signature extraction from board visualization data\n * v7.52-PROPHYLACTIC: Enhanced with sub-archetype variation detection\n */\n\nimport { SquareData, GameData } from '../gameSimulator';\nimport { \n  ColorFlowSignature, \n  QuadrantProfile, \n  TemporalFlow, \n  CriticalMoment,\n  StrategicArchetype \n} from './types';\nimport { \n  classifyProphylacticVariation, \n  ProphylacticAnalysis \n} from './prophylacticVariations';\n\n// Store last prophylactic analysis for external access\nlet lastProphylacticAnalysis: ProphylacticAnalysis | null = null;\n\n/**\n * Get the last prophylactic variation analysis (if archetype was prophylactic_defense)\n */\nexport function getLastProphylacticAnalysis(): ProphylacticAnalysis | null {\n  return lastProphylacticAnalysis;\n}\n\n/**\n * Extract the complete Color Flow Signature from a visualization\n */\nexport function extractColorFlowSignature(\n  board: SquareData[][],\n  gameData: GameData,\n  totalMoves: number\n): ColorFlowSignature {\n  // Generate fingerprint hash\n  const fingerprint = generateColorFingerprint(board);\n  \n  // Calculate quadrant profile\n  const quadrantProfile = calculateQuadrantProfile(board);\n  \n  // Determine flow direction\n  const flowDirection = determineFlowDirection(quadrantProfile);\n  \n  // Calculate temporal flow from move progression\n  const temporalFlow = calculateTemporalFlow(board, totalMoves);\n  \n  // Find critical color shift moments\n  const criticalMoments = findCriticalMoments(board, totalMoves);\n  \n  // Classify strategic archetype\n  const archetype = classifyArchetype(quadrantProfile, temporalFlow, criticalMoments, totalMoves);\n  \n  // v7.52-PROPHYLACTIC: Deep analysis for prophylactic defense archetype\n  if (archetype === 'prophylactic_defense') {\n    lastProphylacticAnalysis = classifyProphylacticVariation(\n      quadrantProfile, \n      temporalFlow, \n      criticalMoments, \n      totalMoves\n    );\n  } else {\n    lastProphylacticAnalysis = null;\n  }\n  \n  // Calculate overall intensity\n  const intensity = calculateOverallIntensity(board);\n  \n  // Determine dominant side\n  const dominantSide = determineDominantSide(quadrantProfile);\n  \n  return {\n    fingerprint,\n    dominantSide,\n    flowDirection,\n    intensity,\n    archetype,\n    quadrantProfile,\n    temporalFlow,\n    criticalMoments,\n  };\n}\n\n/**\n * Generate a unique fingerprint hash from the board color state\n */\nfunction generateColorFingerprint(board: SquareData[][]): string {\n  const colorMap: string[] = [];\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const square = board[rank][file];\n      const visitCount = square.visits.length;\n      const dominantColor = square.visits.length > 0 \n        ? square.visits[square.visits.length - 1].color \n        : 'x';\n      colorMap.push(`${visitCount}${dominantColor}`);\n    }\n  }\n  \n  const mapString = colorMap.join('');\n  let hash = 0;\n  for (let i = 0; i < mapString.length; i++) {\n    const char = mapString.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  \n  return `cf-${Math.abs(hash).toString(36)}`;\n}\n\n/**\n * Calculate color dominance in each board quadrant\n */\nfunction calculateQuadrantProfile(board: SquareData[][]): QuadrantProfile {\n  let kingsideWhite = 0, kingsideBlack = 0;\n  let queensideWhite = 0, queensideBlack = 0;\n  let center = 0;\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const square = board[rank][file];\n      \n      let whiteVisits = 0, blackVisits = 0;\n      for (const visit of square.visits) {\n        if (visit.color === 'w') whiteVisits++;\n        else blackVisits++;\n      }\n      \n      const balance = whiteVisits - blackVisits;\n      \n      const isKingside = file >= 4;\n      const isWhiteSide = rank < 4;\n      const isCenter = (file >= 3 && file <= 4) && (rank >= 3 && rank <= 4);\n      \n      if (isCenter) {\n        center += balance;\n      } else if (isKingside && isWhiteSide) {\n        kingsideWhite += balance;\n      } else if (isKingside && !isWhiteSide) {\n        kingsideBlack += balance;\n      } else if (!isKingside && isWhiteSide) {\n        queensideWhite += balance;\n      } else {\n        queensideBlack += balance;\n      }\n    }\n  }\n  \n  const normalize = (val: number) => Math.max(-100, Math.min(100, val * 5));\n  \n  return {\n    kingsideWhite: normalize(kingsideWhite),\n    kingsideBlack: normalize(kingsideBlack),\n    queensideWhite: normalize(queensideWhite),\n    queensideBlack: normalize(queensideBlack),\n    center: normalize(center),\n  };\n}\n\n/**\n * Determine the primary direction of color flow\n */\nfunction determineFlowDirection(\n  profile: QuadrantProfile\n): 'kingside' | 'queenside' | 'central' | 'balanced' | 'diagonal' {\n  const kingsideTotal = Math.abs(profile.kingsideWhite) + Math.abs(profile.kingsideBlack);\n  const queensideTotal = Math.abs(profile.queensideWhite) + Math.abs(profile.queensideBlack);\n  const centerIntensity = Math.abs(profile.center);\n  \n  const diagonalA = Math.abs(profile.kingsideWhite) + Math.abs(profile.queensideBlack);\n  const diagonalB = Math.abs(profile.queensideWhite) + Math.abs(profile.kingsideBlack);\n  \n  if (Math.max(diagonalA, diagonalB) > kingsideTotal * 1.5 && \n      Math.max(diagonalA, diagonalB) > queensideTotal * 1.5) {\n    return 'diagonal';\n  }\n  \n  if (centerIntensity > kingsideTotal && centerIntensity > queensideTotal) {\n    return 'central';\n  }\n  \n  if (kingsideTotal > queensideTotal * 1.5) {\n    return 'kingside';\n  }\n  \n  if (queensideTotal > kingsideTotal * 1.5) {\n    return 'queenside';\n  }\n  \n  return 'balanced';\n}\n\n/**\n * Calculate how color intensity evolved through game phases\n */\nfunction calculateTemporalFlow(board: SquareData[][], totalMoves: number): TemporalFlow {\n  let openingBalance = 0, middlegameBalance = 0, endgameBalance = 0;\n  let volatility = 0;\n  let prevBalance = 0;\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const square = board[rank][file];\n      \n      for (const visit of square.visits) {\n        const balance = visit.color === 'w' ? 1 : -1;\n        \n        if (visit.moveNumber <= 10) {\n          openingBalance += balance;\n        } else if (visit.moveNumber <= 25) {\n          middlegameBalance += balance;\n        } else {\n          endgameBalance += balance;\n        }\n        \n        volatility += Math.abs(balance - prevBalance);\n        prevBalance = balance;\n      }\n    }\n  }\n  \n  const normalize = (val: number, phase: number) => \n    Math.max(-100, Math.min(100, (val / Math.max(phase, 1)) * 10));\n  \n  return {\n    opening: normalize(openingBalance, 10),\n    middlegame: normalize(middlegameBalance, 15),\n    endgame: normalize(endgameBalance, Math.max(0, totalMoves - 25)),\n    volatility: Math.min(100, (volatility / totalMoves) * 5),\n  };\n}\n\n/**\n * Identify critical moments where color balance shifted dramatically\n */\nfunction findCriticalMoments(board: SquareData[][], totalMoves: number): CriticalMoment[] {\n  const moments: CriticalMoment[] = [];\n  const moveBalances: number[] = new Array(totalMoves + 1).fill(0);\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const square = board[rank][file];\n      for (const visit of square.visits) {\n        moveBalances[visit.moveNumber] += visit.color === 'w' ? 1 : -1;\n      }\n    }\n  }\n  \n  for (let move = 2; move <= totalMoves; move++) {\n    const shift = Math.abs(moveBalances[move] - moveBalances[move - 1]);\n    if (shift >= 3) {\n      moments.push({\n        moveNumber: move,\n        shiftMagnitude: shift,\n        description: moveBalances[move] > moveBalances[move - 1] \n          ? 'White territorial surge'\n          : 'Black territorial surge',\n        squaresAffected: [],\n      });\n    }\n  }\n  \n  return moments.slice(0, 5);\n}\n\n/**\n * Classify the game into a strategic archetype based on color patterns\n * v6.83-DIVERSE: Lowered thresholds + added missing archetypes for better distribution\n */\nfunction classifyArchetype(\n  quadrant: QuadrantProfile,\n  temporal: TemporalFlow,\n  moments: CriticalMoment[],\n  totalMoves: number\n): StrategicArchetype {\n  // Calculate aggregate metrics for smarter classification\n  const kingsideTotal = Math.abs(quadrant.kingsideWhite) + Math.abs(quadrant.kingsideBlack);\n  const queensideTotal = Math.abs(quadrant.queensideWhite) + Math.abs(quadrant.queensideBlack);\n  const totalActivity = kingsideTotal + queensideTotal + Math.abs(quadrant.center);\n  const avgMomentMagnitude = moments.length > 0 \n    ? moments.reduce((sum, m) => sum + m.shiftMagnitude, 0) / moments.length \n    : 0;\n  \n  // 1. Opposite castling - asymmetric flank activity (NEW)\n  const kingsideImbalance = Math.abs(quadrant.kingsideWhite - quadrant.kingsideBlack);\n  const queensideImbalance = Math.abs(quadrant.queensideWhite - quadrant.queensideBlack);\n  if (kingsideImbalance > 30 && queensideImbalance > 30 && temporal.volatility > 35) {\n    return 'opposite_castling';\n  }\n  \n  // 2. Pawn storm - linear progression with increasing endgame pressure (NEW)\n  if (temporal.endgame > temporal.opening + 25 && temporal.endgame > temporal.middlegame) {\n    return 'pawn_storm';\n  }\n  \n  // 3. Kingside attack - high kingside activity (lowered threshold)\n  if (kingsideTotal > 80 && kingsideTotal > queensideTotal * 1.3) {\n    return 'kingside_attack';\n  }\n  \n  // 4. Queenside expansion - clear queenside focus (lowered threshold)\n  if (queensideTotal > 70 && queensideTotal > kingsideTotal * 1.3) {\n    return 'queenside_expansion';\n  }\n  \n  // 5. Central domination - strong center control (lowered threshold)\n  if (Math.abs(quadrant.center) > 45 && Math.abs(quadrant.center) > kingsideTotal * 0.5) {\n    return 'central_domination';\n  }\n  \n  // 6. Sacrificial attack - dramatic shifts with high average magnitude\n  if (moments.length >= 3 && avgMomentMagnitude > 4) {\n    return 'sacrificial_attack';\n  }\n  \n  // 7. Open tactical - high volatility games (lowered threshold)\n  if (temporal.volatility > 40 && moments.length >= 2) {\n    return 'open_tactical';\n  }\n  \n  // 8. Endgame technique - long games with late-game focus\n  if (totalMoves > 35 && Math.abs(temporal.endgame) > 15) {\n    return 'endgame_technique';\n  }\n  \n  // 9. Closed maneuvering - low volatility in longer games (lowered thresholds)\n  if (temporal.volatility < 30 && totalMoves > 30) {\n    return 'closed_maneuvering';\n  }\n  \n  // 10. Positional squeeze - gradual improvement over phases\n  if (temporal.middlegame > temporal.opening && temporal.endgame > temporal.middlegame) {\n    return 'positional_squeeze';\n  }\n  \n  // 11. Piece harmony - moderate center with balanced activity\n  if (quadrant.center > 20 && temporal.volatility >= 25 && temporal.volatility <= 55) {\n    return 'piece_harmony';\n  }\n  \n  // 12. Prophylactic defense - TIGHTENED: requires truly defensive characteristics\n  // v7.85: Much stricter criteria - must show actual defensive patterns not just low activity\n  const hasDefensiveCharacter = (\n    // Black must have genuine territorial presence (not just white being passive)\n    (quadrant.kingsideBlack < -10 || quadrant.queensideBlack < -10) &&\n    // Temporal shows black gaining or maintaining (not white building advantage)\n    (temporal.middlegame <= temporal.opening || temporal.endgame <= temporal.middlegame) &&\n    // Low crisis moments - true prophylaxis prevents tactics\n    moments.length <= 2\n  );\n  \n  if (totalActivity < 120 && temporal.volatility < 25 && hasDefensiveCharacter) {\n    return 'prophylactic_defense';\n  }\n  \n  // v8.07: ELIMINATE FALLBACK/unknown - always assign specific archetype\n  // Use activity ratios + volatility to pick the most appropriate archetype\n  \n  if (temporal.volatility > 35) {\n    // High volatility = tactical nature\n    if (kingsideTotal > queensideTotal) {\n      return 'kingside_attack';\n    } else if (queensideTotal > kingsideTotal) {\n      return 'queenside_expansion';\n    }\n    return 'open_tactical';\n  }\n  \n  // Low-medium volatility = positional nature\n  if (kingsideTotal > queensideTotal * 1.2) {\n    return 'kingside_attack';\n  } else if (queensideTotal > kingsideTotal * 1.2) {\n    return 'queenside_expansion';\n  }\n  \n  // Balanced activity - use center control as tiebreaker\n  if (Math.abs(quadrant.center) > 20) {\n    return 'central_domination';\n  }\n  \n  // Default to best-performing archetype (piece_harmony at 53%)\n  return 'piece_harmony';\n}\n\n/**\n * Calculate overall color intensity across the board\n */\nfunction calculateOverallIntensity(board: SquareData[][]): number {\n  let totalVisits = 0;\n  \n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      totalVisits += board[rank][file].visits.length;\n    }\n  }\n  \n  return Math.min(100, (totalVisits / 200) * 50);\n}\n\n/**\n * Determine which side has overall color dominance\n * v8.06-EQUILIBRIUM: Balanced detection after learning from v8.05 over-correction\n * \n * v8.05 LEARNING: We went from 66% white predictions to 69% black predictions\n * Neither extreme works - need TRUE balance\n * \n * SOLUTION: Equal weights for both colors, use multiple signals symmetrically\n */\nfunction determineDominantSide(profile: QuadrantProfile): 'white' | 'black' | 'contested' {\n  // Calculate total activity for threshold checks\n  const totalActivity = \n    Math.abs(profile.kingsideWhite) + \n    Math.abs(profile.kingsideBlack) + \n    Math.abs(profile.queensideWhite) + \n    Math.abs(profile.queensideBlack) + \n    Math.abs(profile.center);\n  \n  // Low activity = not enough signal\n  if (totalActivity < 50) {\n    return 'contested';\n  }\n  \n  // ===== SIGNAL 1: Territory Invasion (SYMMETRIC) =====\n  // Black pieces in WHITE's territory\n  const blackInWhiteTerritory = Math.max(0, -profile.kingsideWhite) + Math.max(0, -profile.queensideWhite);\n  // White pieces in BLACK's territory\n  const whiteInBlackTerritory = Math.max(0, profile.kingsideBlack) + Math.max(0, profile.queensideBlack);\n  \n  // ===== SIGNAL 2: Center Control =====\n  const centerControl = profile.center; // positive = white, negative = black\n  \n  // ===== SIGNAL 3: Overall Balance =====\n  const rawBalance = \n    profile.kingsideWhite + profile.kingsideBlack + \n    profile.queensideWhite + profile.queensideBlack + \n    profile.center;\n  \n  // v8.06: Moderate first-move offset (between v8.04's 15 and v8.05's 25)\n  const FIRST_MOVE_OFFSET = 20;\n  const adjustedBalance = rawBalance - FIRST_MOVE_OFFSET;\n  \n  // ===== SYMMETRIC SCORING =====\n  // v8.06: Equal weights for both colors (2.0x invasion weight for both)\n  const whiteScore = (whiteInBlackTerritory * 2.0) + \n                     Math.max(0, centerControl * 0.8) + \n                     Math.max(0, adjustedBalance * 0.4);\n  \n  const blackScore = (blackInWhiteTerritory * 2.0) + \n                     Math.max(0, -centerControl * 0.8) + \n                     Math.max(0, -adjustedBalance * 0.4);\n  \n  // ===== DECISION with moderate gap requirement =====\n  const DOMINANCE_GAP = 18; // Require clear separation\n  const difference = whiteScore - blackScore;\n  \n  if (difference > DOMINANCE_GAP) {\n    return 'white';\n  } else if (difference < -DOMINANCE_GAP) {\n    return 'black';\n  }\n  \n  // v8.06: Only use invasion tiebreaker when one side has CLEAR advantage\n  if (blackInWhiteTerritory > 25 && blackInWhiteTerritory > whiteInBlackTerritory * 1.5) {\n    return 'black';\n  }\n  if (whiteInBlackTerritory > 25 && whiteInBlackTerritory > blackInWhiteTerritory * 1.5) {\n    return 'white';\n  }\n  \n  return 'contested';\n}\n";export{n as default};
