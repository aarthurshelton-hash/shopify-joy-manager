const n="import { Chess, Square } from 'chess.js';\nimport { SquareData, SquareVisit } from './gameSimulator';\nimport { PieceType, PieceColor, getPieceColor } from './pieceColors';\n\n/**\n * FEN Utilities for En Pensent\n * \n * FEN (Forsyth-Edwards Notation) describes a single chess position.\n * This module provides utilities for:\n * - Validating FEN strings\n * - Converting FEN to visualization board data\n * - Exporting current position to FEN\n * - Position-based puzzle mode support\n */\n\nexport interface FenValidationResult {\n  isValid: boolean;\n  error?: string;\n  fen?: string;\n  pieceCount?: number;\n  sideToMove?: 'w' | 'b';\n  fullMoveNumber?: number;\n}\n\nexport interface PositionData {\n  board: SquareData[][];\n  fen: string;\n  sideToMove: 'w' | 'b';\n  canCastleKingsideWhite: boolean;\n  canCastleQueensideWhite: boolean;\n  canCastleKingsideBlack: boolean;\n  canCastleQueensideBlack: boolean;\n  enPassantSquare: string | null;\n  halfMoveClock: number;\n  fullMoveNumber: number;\n  pieceCount: number;\n}\n\n// Standard starting position FEN\nexport const STARTING_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n\n// Common puzzle/example FENs\nexport const EXAMPLE_FENS = [\n  {\n    name: 'Starting Position',\n    fen: STARTING_FEN,\n    description: 'The initial setup of a chess game',\n  },\n  {\n    name: 'Fool\\'s Mate',\n    fen: 'rnb1kbnr/pppp1ppp/4p3/8/6Pq/5P2/PPPPP2P/RNBQKBNR w KQkq - 1 3',\n    description: 'Checkmate in 2 moves - the shortest possible game',\n  },\n  {\n    name: 'Scholar\\'s Mate',\n    fen: 'r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4',\n    description: 'The famous 4-move checkmate',\n  },\n  {\n    name: 'Endgame Study - King & Rook',\n    fen: '8/8/8/8/8/4K3/R7/4k3 w - - 0 1',\n    description: 'White to move and checkmate',\n  },\n  {\n    name: 'Queen Sacrifice Position',\n    fen: 'r1bqkb1r/pppp1ppp/2n2n2/4p2Q/2B1P3/8/PPPP1PPP/RNB1K1NR w KQkq - 4 4',\n    description: 'White threatens Qxf7#',\n  },\n  {\n    name: 'Complex Middlegame',\n    fen: 'r1bq1rk1/ppp2ppp/2np1n2/2b1p3/2B1P3/3P1N2/PPP2PPP/RNBQ1RK1 w - - 4 7',\n    description: 'Italian Game structure',\n  },\n  {\n    name: 'Endgame - Lucena Position',\n    fen: '1K1k4/1P6/8/8/8/8/r7/2R5 w - - 0 1',\n    description: 'Famous rook endgame winning technique',\n  },\n  {\n    name: 'Zugzwang Example',\n    fen: '8/8/p1p5/1p5p/1P5p/8/PPP2K1k/8 w - - 0 1',\n    description: 'Whoever moves loses!',\n  },\n];\n\n/**\n * Validate a FEN string\n */\nexport function validateFen(fen: string): FenValidationResult {\n  if (!fen || !fen.trim()) {\n    return { isValid: false, error: 'FEN string is empty' };\n  }\n\n  const trimmedFen = fen.trim();\n\n  try {\n    const chess = new Chess();\n    chess.load(trimmedFen);\n    \n    // Count pieces\n    let pieceCount = 0;\n    for (const char of trimmedFen.split(' ')[0]) {\n      if (/[pnbrqkPNBRQK]/.test(char)) {\n        pieceCount++;\n      }\n    }\n\n    // Parse FEN parts\n    const parts = trimmedFen.split(' ');\n    const sideToMove = parts[1] as 'w' | 'b' || 'w';\n    const fullMoveNumber = parseInt(parts[5]) || 1;\n\n    return {\n      isValid: true,\n      fen: trimmedFen,\n      pieceCount,\n      sideToMove,\n      fullMoveNumber,\n    };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: error instanceof Error ? error.message : 'Invalid FEN format',\n    };\n  }\n}\n\n/**\n * Parse FEN to a 2D array of pieces (for piece display)\n */\nexport function fenToPieceBoard(fen: string): (string | null)[][] {\n  const rows = fen.split(' ')[0].split('/');\n  return rows.map(row => {\n    const squares: (string | null)[] = [];\n    for (const char of row) {\n      if (/\\d/.test(char)) {\n        for (let i = 0; i < parseInt(char); i++) squares.push(null);\n      } else {\n        squares.push(char);\n      }\n    }\n    return squares;\n  });\n}\n\n/**\n * Convert a FEN position to SquareData[][] for visualization\n * Each piece's current square becomes a \"visit\"\n */\nexport function fenToVisualizationBoard(fen: string): SquareData[][] {\n  const validation = validateFen(fen);\n  if (!validation.isValid) {\n    // Return empty board on invalid FEN\n    return createEmptyBoard();\n  }\n\n  const pieceBoard = fenToPieceBoard(fen);\n  const board: SquareData[][] = [];\n\n  for (let rank = 0; rank < 8; rank++) {\n    board[rank] = [];\n    for (let file = 0; file < 8; file++) {\n      const isLight = (file + rank) % 2 === 1;\n      const visits: SquareVisit[] = [];\n\n      // Get piece at this position (FEN is from rank 8 to 1, so invert)\n      const piece = pieceBoard[7 - rank]?.[file];\n      \n      if (piece) {\n        const isWhite = piece === piece.toUpperCase();\n        const pieceType = piece.toLowerCase() as PieceType;\n        const pieceColor: PieceColor = isWhite ? 'w' : 'b';\n        const hexColor = getPieceColor(pieceType, pieceColor);\n\n        visits.push({\n          piece: pieceType,\n          color: pieceColor,\n          moveNumber: 1,\n          hexColor,\n        });\n      }\n\n      board[rank][file] = {\n        file,\n        rank,\n        visits,\n        isLight,\n      };\n    }\n  }\n\n  return board;\n}\n\n/**\n * Create an empty visualization board\n */\nexport function createEmptyBoard(): SquareData[][] {\n  const board: SquareData[][] = [];\n  for (let rank = 0; rank < 8; rank++) {\n    board[rank] = [];\n    for (let file = 0; file < 8; file++) {\n      const isLight = (file + rank) % 2 === 1;\n      board[rank][file] = {\n        file,\n        rank,\n        visits: [],\n        isLight,\n      };\n    }\n  }\n  return board;\n}\n\n/**\n * Extract the FEN at a specific move number from a PGN\n */\nexport function getFenAtMove(pgn: string, moveNumber: number): string | null {\n  try {\n    const chess = new Chess();\n    chess.loadPgn(pgn);\n    const history = chess.history({ verbose: true });\n    \n    // Reset and replay up to the specified move\n    chess.reset();\n    \n    const targetMoves = Math.min(moveNumber, history.length);\n    for (let i = 0; i < targetMoves; i++) {\n      chess.move(history[i].san);\n    }\n    \n    return chess.fen();\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get the FEN at the current board position\n * This is used for exporting/sharing a specific position\n */\nexport function getBoardPositionFen(\n  pgn: string | undefined,\n  moveNumber: number\n): string {\n  if (!pgn) {\n    return STARTING_FEN;\n  }\n\n  const fen = getFenAtMove(pgn, moveNumber);\n  return fen || STARTING_FEN;\n}\n\n/**\n * Parse full FEN to get detailed position data\n */\nexport function parseFenDetails(fen: string): PositionData | null {\n  const validation = validateFen(fen);\n  if (!validation.isValid) {\n    return null;\n  }\n\n  const parts = fen.split(' ');\n  \n  // Count pieces\n  let pieceCount = 0;\n  for (const char of parts[0]) {\n    if (/[pnbrqkPNBRQK]/.test(char)) {\n      pieceCount++;\n    }\n  }\n\n  const castling = parts[2] || '-';\n\n  return {\n    board: fenToVisualizationBoard(fen),\n    fen,\n    sideToMove: (parts[1] || 'w') as 'w' | 'b',\n    canCastleKingsideWhite: castling.includes('K'),\n    canCastleQueensideWhite: castling.includes('Q'),\n    canCastleKingsideBlack: castling.includes('k'),\n    canCastleQueensideBlack: castling.includes('q'),\n    enPassantSquare: parts[3] !== '-' ? parts[3] : null,\n    halfMoveClock: parseInt(parts[4]) || 0,\n    fullMoveNumber: parseInt(parts[5]) || 1,\n    pieceCount,\n  };\n}\n\n/**\n * Generate a minimal FEN (just piece placement, for display)\n */\nexport function getMinimalFen(fen: string): string {\n  return fen.split(' ')[0];\n}\n\n/**\n * Check if a FEN represents the starting position\n */\nexport function isStartingPosition(fen: string): boolean {\n  const minimal = getMinimalFen(fen);\n  const startingMinimal = getMinimalFen(STARTING_FEN);\n  return minimal === startingMinimal;\n}\n\n/**\n * Create a shareable FEN URL\n */\nexport function createFenShareUrl(fen: string, baseUrl?: string): string {\n  const base = baseUrl || window.location.origin;\n  const encodedFen = encodeURIComponent(fen);\n  return `${base}/position?fen=${encodedFen}`;\n}\n\n/**\n * Parse FEN from URL parameter\n */\nexport function parseFenFromUrl(searchParams: URLSearchParams): string | null {\n  const fen = searchParams.get('fen');\n  if (fen) {\n    const decoded = decodeURIComponent(fen);\n    const validation = validateFen(decoded);\n    if (validation.isValid) {\n      return decoded;\n    }\n  }\n  return null;\n}\n\n/**\n * Get a descriptive name for a position\n */\nexport function getPositionDescription(fen: string): string {\n  if (isStartingPosition(fen)) {\n    return 'Starting Position';\n  }\n\n  const details = parseFenDetails(fen);\n  if (!details) {\n    return 'Invalid Position';\n  }\n\n  const toMove = details.sideToMove === 'w' ? 'White' : 'Black';\n  const moveNum = details.fullMoveNumber;\n\n  return `${toMove} to move (Move ${moveNum})`;\n}\n";export{n as default};
