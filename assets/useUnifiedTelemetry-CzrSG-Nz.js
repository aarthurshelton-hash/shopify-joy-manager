const e="/**\n * Unified Telemetry Hook\n * \n * React hook for consuming real-time telemetry data from all systems.\n * Provides reactive access to code analysis, adapter signals, evolution events,\n * and cross-domain resonances.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport {\n  subscribeToTelemetry,\n  getTelemetryState,\n  recordCodeAnalysis,\n  recordIssueDetected,\n  recordHealApplied,\n  initializeTelemetryHub,\n  type UnifiedTelemetryState,\n  type CodeTelemetryData,\n  type AdapterTelemetryData,\n  type ResonanceTelemetryData,\n  type IssueTelemetryData,\n  type HealTelemetryData\n} from '@/lib/pensent-core/telemetry';\n\n// Extended hook state with computed metrics\ninterface TelemetryHookState extends UnifiedTelemetryState {\n  // Computed aggregates\n  totalAdapters: number;\n  activeAdapters: number;\n  totalSignals: number;\n  averageHealth: number;\n  issueCounts: { critical: number; high: number; medium: number; low: number };\n  recentResonances: ResonanceTelemetryData[];\n  topDomains: Array<{ domain: string; count: number; signals: number }>;\n  isLive: boolean;\n}\n\nexport function useUnifiedTelemetry() {\n  const [state, setState] = useState<TelemetryHookState>(() => {\n    const initial = getTelemetryState();\n    return computeDerivedMetrics(initial, false);\n  });\n\n  const hubInitialized = useRef(false);\n\n  // Initialize telemetry hub on mount\n  useEffect(() => {\n    if (!hubInitialized.current) {\n      const cleanup = initializeTelemetryHub();\n      hubInitialized.current = true;\n\n      return () => {\n        cleanup();\n        hubInitialized.current = false;\n      };\n    }\n  }, []);\n\n  // Subscribe to telemetry updates\n  useEffect(() => {\n    const unsubscribe = subscribeToTelemetry((telemetryState) => {\n      setState(computeDerivedMetrics(telemetryState, true));\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // Manual recording functions\n  const reportCodeAnalysis = useCallback((data: CodeTelemetryData) => {\n    recordCodeAnalysis(data);\n  }, []);\n\n  const reportIssue = useCallback((data: IssueTelemetryData) => {\n    recordIssueDetected(data);\n  }, []);\n\n  const reportHeal = useCallback((data: HealTelemetryData) => {\n    recordHealApplied(data);\n  }, []);\n\n  return {\n    ...state,\n    reportCodeAnalysis,\n    reportIssue,\n    reportHeal,\n    isInitialized: hubInitialized.current\n  };\n}\n\n// Compute derived metrics from base state\nfunction computeDerivedMetrics(\n  base: UnifiedTelemetryState,\n  isLive: boolean\n): TelemetryHookState {\n  const adapters = Array.from(base.adapters.values());\n  const activeAdapters = adapters.filter(a => a.isActive);\n  const totalSignals = adapters.reduce((sum, a) => sum + a.signalCount, 0);\n  \n  // Calculate average health\n  const healthValues = adapters.map(a => a.resonanceScore);\n  const averageHealth = healthValues.length > 0\n    ? healthValues.reduce((a, b) => a + b, 0) / healthValues.length\n    : base.code?.health || 0;\n\n  // Count issues by severity\n  const issueCounts = base.issues.reduce((counts, issue) => {\n    counts[issue.severity]++;\n    return counts;\n  }, { critical: 0, high: 0, medium: 0, low: 0 });\n\n  // Get recent resonances (last 10)\n  const recentResonances = base.resonances.slice(0, 10);\n\n  // Aggregate by domain\n  const domainMap = new Map<string, { count: number; signals: number }>();\n  adapters.forEach(adapter => {\n    const existing = domainMap.get(adapter.domain) || { count: 0, signals: 0 };\n    existing.count++;\n    existing.signals += adapter.signalCount;\n    domainMap.set(adapter.domain, existing);\n  });\n\n  const topDomains = Array.from(domainMap.entries())\n    .map(([domain, stats]) => ({ domain, ...stats }))\n    .sort((a, b) => b.signals - a.signals)\n    .slice(0, 6);\n\n  return {\n    ...base,\n    adapters: new Map(base.adapters),\n    totalAdapters: adapters.length,\n    activeAdapters: activeAdapters.length,\n    totalSignals,\n    averageHealth,\n    issueCounts,\n    recentResonances,\n    topDomains,\n    isLive\n  };\n}\n\n// Hook for code-specific telemetry\nexport function useCodeTelemetry() {\n  const { code, issueCounts, issues, heals, reportCodeAnalysis, reportIssue, reportHeal } = useUnifiedTelemetry();\n\n  return {\n    analysis: code,\n    issues: {\n      all: issues,\n      counts: issueCounts\n    },\n    heals,\n    reportAnalysis: reportCodeAnalysis,\n    reportIssue,\n    reportHeal\n  };\n}\n\n// Hook for adapter-specific telemetry\nexport function useAdapterTelemetry() {\n  const {\n    adapters,\n    totalAdapters,\n    activeAdapters,\n    totalSignals,\n    averageHealth,\n    recentResonances,\n    topDomains\n  } = useUnifiedTelemetry();\n\n  return {\n    adapters: Array.from(adapters.values()),\n    totalAdapters,\n    activeAdapters,\n    totalSignals,\n    averageHealth,\n    resonances: recentResonances,\n    topDomains\n  };\n}\n\n// Hook for evolution event stream\nexport function useEvolutionTelemetry() {\n  const { evolution } = useUnifiedTelemetry();\n\n  const recentEvents = evolution.slice(0, 20);\n  \n  const eventsByType = recentEvents.reduce((acc, event) => {\n    acc[event.eventType] = (acc[event.eventType] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n\n  const crossDomainEvents = recentEvents.filter(e => \n    e.eventType === 'cross_domain_learning' || \n    e.eventType === 'market_sync' ||\n    e.eventType === 'resonance_detected'\n  );\n\n  return {\n    allEvents: evolution,\n    recentEvents,\n    eventsByType,\n    crossDomainEvents,\n    eventCount: evolution.length\n  };\n}\n";export{e as default};
