const n="/**\n * Simulated Positions Hook\n * Track $1000 paper trades with live P&L and correlative data\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { FUTURES_CONTRACTS, FuturesContract, getAllContracts } from '@/lib/pensent-core/domains/finance/futuresCorrelations';\n\nexport interface SimulatedPosition {\n  id: string;\n  symbol: string;\n  direction: 'long' | 'short';\n  entryPrice: number;\n  entryTime: number;\n  entryAmount: number; // Always $1000\n  shares: number;\n  currentPrice: number;\n  pnl: number;\n  pnlPercent: number;\n  correlatedAssets: CorrelatedAssetPnL[];\n  peakPnl: number;\n  troughPnl: number;\n  status: 'open' | 'closed';\n  closePrice?: number;\n  closeTime?: number;\n  closePnl?: number;\n}\n\nexport interface CorrelatedAssetPnL {\n  symbol: string;\n  name: string;\n  correlation: number;\n  entryPrice: number;\n  currentPrice: number;\n  hypotheticalPnl: number; // If you had entered this instead\n  pnlPercent: number;\n  isAligned: boolean; // Moving in expected direction based on correlation\n}\n\nexport interface PositionStats {\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  winRate: number;\n  totalPnl: number;\n  averagePnl: number;\n  bestTrade: number;\n  worstTrade: number;\n  currentOpenPnl: number;\n}\n\nconst ENTRY_AMOUNT = 1000; // $1000 per position\n\nexport function useSimulatedPositions() {\n  const [positions, setPositions] = useState<SimulatedPosition[]>([]);\n  const [stats, setStats] = useState<PositionStats>({\n    totalTrades: 0,\n    winningTrades: 0,\n    losingTrades: 0,\n    winRate: 0,\n    totalPnl: 0,\n    averagePnl: 0,\n    bestTrade: 0,\n    worstTrade: 0,\n    currentOpenPnl: 0\n  });\n  \n  const correlatedPricesRef = useRef<Map<string, number>>(new Map());\n  \n  // Get correlated assets for a symbol\n  const getCorrelatedAssets = useCallback((symbol: string): FuturesContract[] => {\n    const contract = FUTURES_CONTRACTS[symbol];\n    if (!contract) return [];\n    \n    return contract.correlations\n      .filter(c => Math.abs(c.baseCorrelation) > 0.3)\n      .map(c => FUTURES_CONTRACTS[c.withSymbol])\n      .filter((c): c is FuturesContract => c !== undefined)\n      .slice(0, 5);\n  }, []);\n  \n  // Open a new position\n  const openPosition = useCallback((\n    symbol: string,\n    direction: 'long' | 'short',\n    currentPrice: number,\n    correlatedPrices: Map<string, number>\n  ): SimulatedPosition => {\n    const shares = ENTRY_AMOUNT / currentPrice;\n    const correlatedAssets = getCorrelatedAssets(symbol);\n    \n    // Store correlated prices at entry\n    correlatedPrices.forEach((price, sym) => {\n      correlatedPricesRef.current.set(sym, price);\n    });\n    \n    const contract = FUTURES_CONTRACTS[symbol];\n    \n    const position: SimulatedPosition = {\n      id: `pos_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      symbol,\n      direction,\n      entryPrice: currentPrice,\n      entryTime: Date.now(),\n      entryAmount: ENTRY_AMOUNT,\n      shares,\n      currentPrice,\n      pnl: 0,\n      pnlPercent: 0,\n      correlatedAssets: correlatedAssets.map(asset => {\n        const entryPrice = correlatedPrices.get(asset.symbol) || 100;\n        const correlation = contract?.correlations.find(c => c.withSymbol === asset.symbol)?.baseCorrelation || 0;\n        \n        return {\n          symbol: asset.symbol,\n          name: asset.name,\n          correlation,\n          entryPrice,\n          currentPrice: entryPrice,\n          hypotheticalPnl: 0,\n          pnlPercent: 0,\n          isAligned: true\n        };\n      }),\n      peakPnl: 0,\n      troughPnl: 0,\n      status: 'open'\n    };\n    \n    setPositions(prev => [...prev, position]);\n    return position;\n  }, [getCorrelatedAssets]);\n  \n  // Update position with new prices\n  const updatePosition = useCallback((\n    positionId: string,\n    currentPrice: number,\n    correlatedPrices: Map<string, number>\n  ) => {\n    setPositions(prev => prev.map(pos => {\n      if (pos.id !== positionId || pos.status === 'closed') return pos;\n      \n      // Calculate main position P&L\n      const priceChange = currentPrice - pos.entryPrice;\n      const pnl = pos.direction === 'long' \n        ? priceChange * pos.shares \n        : -priceChange * pos.shares;\n      const pnlPercent = (pnl / ENTRY_AMOUNT) * 100;\n      \n      // Update correlated assets\n      const updatedCorrelatedAssets = pos.correlatedAssets.map(asset => {\n        const newPrice = correlatedPrices.get(asset.symbol) || asset.currentPrice;\n        const assetPriceChange = newPrice - asset.entryPrice;\n        const assetShares = ENTRY_AMOUNT / asset.entryPrice;\n        const hypotheticalPnl = pos.direction === 'long'\n          ? assetPriceChange * assetShares\n          : -assetPriceChange * assetShares;\n        const assetPnlPercent = (hypotheticalPnl / ENTRY_AMOUNT) * 100;\n        \n        // Check if movement aligns with correlation\n        const mainDirection = currentPrice > pos.entryPrice ? 1 : -1;\n        const assetDirection = newPrice > asset.entryPrice ? 1 : -1;\n        const expectedDirection = asset.correlation > 0 ? mainDirection : -mainDirection;\n        const isAligned = assetDirection === expectedDirection || assetPriceChange === 0;\n        \n        return {\n          ...asset,\n          currentPrice: newPrice,\n          hypotheticalPnl,\n          pnlPercent: assetPnlPercent,\n          isAligned\n        };\n      });\n      \n      return {\n        ...pos,\n        currentPrice,\n        pnl,\n        pnlPercent,\n        peakPnl: Math.max(pos.peakPnl, pnl),\n        troughPnl: Math.min(pos.troughPnl, pnl),\n        correlatedAssets: updatedCorrelatedAssets\n      };\n    }));\n  }, []);\n  \n  // Close a position\n  const closePosition = useCallback((positionId: string, closePrice: number) => {\n    setPositions(prev => prev.map(pos => {\n      if (pos.id !== positionId || pos.status === 'closed') return pos;\n      \n      const priceChange = closePrice - pos.entryPrice;\n      const closePnl = pos.direction === 'long'\n        ? priceChange * pos.shares\n        : -priceChange * pos.shares;\n      \n      return {\n        ...pos,\n        status: 'closed',\n        closePrice,\n        closeTime: Date.now(),\n        closePnl,\n        currentPrice: closePrice,\n        pnl: closePnl,\n        pnlPercent: (closePnl / ENTRY_AMOUNT) * 100\n      };\n    }));\n  }, []);\n  \n  // Calculate stats whenever positions change\n  useEffect(() => {\n    const closedPositions = positions.filter(p => p.status === 'closed');\n    const openPositions = positions.filter(p => p.status === 'open');\n    \n    const winningTrades = closedPositions.filter(p => (p.closePnl || 0) > 0).length;\n    const losingTrades = closedPositions.filter(p => (p.closePnl || 0) < 0).length;\n    const totalClosedPnl = closedPositions.reduce((sum, p) => sum + (p.closePnl || 0), 0);\n    const currentOpenPnl = openPositions.reduce((sum, p) => sum + p.pnl, 0);\n    \n    const allPnls = closedPositions.map(p => p.closePnl || 0);\n    \n    setStats({\n      totalTrades: closedPositions.length,\n      winningTrades,\n      losingTrades,\n      winRate: closedPositions.length > 0 ? (winningTrades / closedPositions.length) * 100 : 0,\n      totalPnl: totalClosedPnl,\n      averagePnl: closedPositions.length > 0 ? totalClosedPnl / closedPositions.length : 0,\n      bestTrade: allPnls.length > 0 ? Math.max(...allPnls) : 0,\n      worstTrade: allPnls.length > 0 ? Math.min(...allPnls) : 0,\n      currentOpenPnl\n    });\n  }, [positions]);\n  \n  // Get open positions\n  const openPositions = positions.filter(p => p.status === 'open');\n  const closedPositions = positions.filter(p => p.status === 'closed');\n  \n  return {\n    positions,\n    openPositions,\n    closedPositions,\n    stats,\n    openPosition,\n    updatePosition,\n    closePosition,\n    entryAmount: ENTRY_AMOUNT\n  };\n}\n";export{n as default};
