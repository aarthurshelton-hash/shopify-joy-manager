const n="/**\n * Edge Function Rate Limiting - Shared utilities\n * \n * Copy this pattern into edge functions for consistent rate limiting.\n * Uses sliding window with bounded memory.\n */\n\ninterface RateLimitEntry {\n  timestamps: number[];\n}\n\ninterface RateLimitConfig {\n  maxRequests: number;\n  windowMs: number;\n  maxCacheSize?: number;\n}\n\ninterface RateLimitResult {\n  allowed: boolean;\n  remaining: number;\n  resetInMs: number;\n}\n\n/**\n * Create a rate limiter instance for edge functions\n * \n * Usage in edge function:\n * ```ts\n * const limiter = createEdgeRateLimiter({ maxRequests: 30, windowMs: 60_000 });\n * \n * // In request handler:\n * const clientIp = req.headers.get('x-forwarded-for') || 'unknown';\n * const { allowed, resetInMs } = limiter.check(clientIp);\n * if (!allowed) {\n *   return new Response(JSON.stringify({ error: 'Rate limited', resetInMs }), {\n *     status: 429,\n *     headers: { ...corsHeaders, 'Retry-After': String(Math.ceil(resetInMs / 1000)) }\n *   });\n * }\n * ```\n */\nexport function createEdgeRateLimiter(config: RateLimitConfig) {\n  const cache = new Map<string, RateLimitEntry>();\n  const maxSize = config.maxCacheSize ?? 500;\n  let lastCleanup = Date.now();\n\n  function cleanup(now: number): void {\n    const windowStart = now - config.windowMs;\n    for (const [key, entry] of cache) {\n      entry.timestamps = entry.timestamps.filter(t => t > windowStart);\n      if (entry.timestamps.length === 0) {\n        cache.delete(key);\n      }\n    }\n    lastCleanup = now;\n  }\n\n  function check(identifier: string): RateLimitResult {\n    const now = Date.now();\n\n    // Periodic cleanup (every minute)\n    if (now - lastCleanup > 60_000) {\n      cleanup(now);\n    }\n\n    let entry = cache.get(identifier);\n    if (!entry) {\n      // Evict oldest if at capacity\n      if (cache.size >= maxSize) {\n        const oldestKey = cache.keys().next().value;\n        if (oldestKey) cache.delete(oldestKey);\n      }\n      entry = { timestamps: [] };\n      cache.set(identifier, entry);\n    }\n\n    // Sliding window filter\n    const windowStart = now - config.windowMs;\n    entry.timestamps = entry.timestamps.filter(t => t > windowStart);\n\n    const allowed = entry.timestamps.length < config.maxRequests;\n    if (allowed) {\n      entry.timestamps.push(now);\n    }\n\n    const oldestInWindow = entry.timestamps[0] || now;\n    const resetInMs = Math.max(0, (oldestInWindow + config.windowMs) - now);\n\n    return {\n      allowed,\n      remaining: Math.max(0, config.maxRequests - entry.timestamps.length),\n      resetInMs,\n    };\n  }\n\n  function recordExternalLimit(identifier: string, retryAfterSec: number): void {\n    // When external API returns 429, block this identifier\n    const now = Date.now();\n    let entry = cache.get(identifier);\n    if (!entry) {\n      entry = { timestamps: [] };\n      cache.set(identifier, entry);\n    }\n    // Fill timestamps to max to ensure blocking\n    const futureTime = now + (retryAfterSec * 1000);\n    entry.timestamps = Array(config.maxRequests).fill(futureTime);\n  }\n\n  function getStats() {\n    return { size: cache.size, maxSize };\n  }\n\n  return { check, recordExternalLimit, getStats, cleanup: () => cleanup(Date.now()) };\n}\n\n/**\n * Standard rate limit response for edge functions\n */\nexport function rateLimitResponse(\n  resetInMs: number,\n  corsHeaders: Record<string, string>\n): Response {\n  const retryAfter = Math.ceil(resetInMs / 1000);\n  return new Response(\n    JSON.stringify({ \n      error: 'Rate limited', \n      resetInMs,\n      retryAfter,\n    }),\n    {\n      status: 429,\n      headers: {\n        ...corsHeaders,\n        'Content-Type': 'application/json',\n        'Retry-After': String(retryAfter),\n      },\n    }\n  );\n}\n\n/**\n * Extract client identifier from request\n */\nexport function getClientIdentifier(req: Request): string {\n  const forwarded = req.headers.get('x-forwarded-for');\n  const ip = forwarded?.split(',')[0]?.trim() || 'unknown';\n  const ua = req.headers.get('user-agent') || '';\n  \n  // Simple hash\n  const raw = `${ip}:${ua}`;\n  let hash = 0;\n  for (let i = 0; i < raw.length; i++) {\n    hash = ((hash << 5) - hash) + raw.charCodeAt(i);\n    hash |= 0;\n  }\n  return Math.abs(hash).toString(36);\n}\n";export{n as default};
