const e="import React, { useMemo } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { PieceType, PieceColor, getCurrentPalette } from '@/lib/chess/pieceColors';\nimport { useEnPensentPatterns, getFlowAnimation } from '@/hooks/useEnPensentPatterns';\nimport type { TemporalSignature } from '@/lib/pensent-core/types/core';\n\nexport interface MoveHistoryEntry {\n  square: string;\n  piece: PieceType;\n  color: PieceColor;\n  moveNumber: number;\n}\n\ninterface EnPensentOverlayProps {\n  moveHistory: MoveHistoryEntry[];\n  whitePalette: Record<string, string>;\n  blackPalette: Record<string, string>;\n  opacity: number;\n  isEnabled: boolean;\n  flipped?: boolean;\n  signature?: TemporalSignature | null;\n}\n\n// Parse square notation to grid position\nconst squareToPosition = (square: string, flipped: boolean): { row: number; col: number } => {\n  const col = square.charCodeAt(0) - 97; // 'a' = 0, 'h' = 7\n  const row = 8 - parseInt(square[1]); // '8' = 0, '1' = 7\n  \n  if (flipped) {\n    return { row: 7 - row, col: 7 - col };\n  }\n  return { row, col };\n};\n\n// Group moves by square and get color layers - uses provided palettes\nconst buildSquareColorLayers = (\n  moveHistory: MoveHistoryEntry[],\n  whitePalette: Record<string, string>,\n  blackPalette: Record<string, string>\n): Map<string, string[]> => {\n  const squareLayers = new Map<string, string[]>();\n  \n  // Validate palettes - fall back to current active palette if empty\n  const effectiveWhite = Object.keys(whitePalette).length > 0 \n    ? whitePalette \n    : getCurrentPalette().white;\n  const effectiveBlack = Object.keys(blackPalette).length > 0 \n    ? blackPalette \n    : getCurrentPalette().black;\n  \n  for (const move of moveHistory) {\n    const palette = move.color === 'w' ? effectiveWhite : effectiveBlack;\n    const color = palette[move.piece] || '#888888';\n    \n    if (!squareLayers.has(move.square)) {\n      squareLayers.set(move.square, []);\n    }\n    \n    const layers = squareLayers.get(move.square)!;\n    // Add color if not already the last one (avoid duplicates)\n    if (layers[layers.length - 1] !== color) {\n      layers.push(color);\n    }\n  }\n  \n  return squareLayers;\n};\n\nexport const EnPensentOverlay: React.FC<EnPensentOverlayProps> = ({\n  moveHistory,\n  whitePalette,\n  blackPalette,\n  opacity,\n  isEnabled,\n  flipped = false,\n  signature = null,\n}) => {\n  // En Pensent pattern integration\n  const pattern = useEnPensentPatterns(signature);\n  \n  // Build color layers for each square\n  const squareColorLayers = useMemo(() => \n    buildSquareColorLayers(moveHistory, whitePalette, blackPalette),\n    [moveHistory, whitePalette, blackPalette]\n  );\n  \n  // Get flow animation based on pattern\n  const flowAnim = useMemo(() => \n    getFlowAnimation(pattern.flowDirection, pattern.momentum),\n    [pattern.flowDirection, pattern.momentum]\n  );\n\n  if (!isEnabled) {\n    return null;\n  }\n\n  // Render solid color fills for a single square (trademark PrintReady style)\n  const renderSquareVisualization = (square: string, colors: string[]) => {\n    const { row, col } = squareToPosition(square, flipped);\n    const maxLayers = Math.min(colors.length, 6);\n    \n    // Use full opacity for solid colors (trademark look)\n    const effectiveOpacity = opacity;\n    \n    return (\n      <div\n        key={square}\n        className=\"absolute\"\n        style={{\n          top: `${row * 12.5}%`,\n          left: `${col * 12.5}%`,\n          width: '12.5%',\n          height: '12.5%',\n          opacity: effectiveOpacity,\n          pointerEvents: 'none',\n        }}\n      >\n        <AnimatePresence mode=\"sync\">\n          {colors.slice(0, maxLayers).map((color, layerIndex) => {\n            // Calculate nested sizing (outermost = largest)\n            const padding = 8; // percentage padding\n            const layerSize = 100 - padding - (layerIndex * (70 / maxLayers));\n            const offset = (100 - layerSize) / 2;\n            \n            return (\n              <motion.div\n                key={`${square}-layer-${layerIndex}`}\n                initial={{ scale: 0, opacity: 0 }}\n                animate={{ \n                  scale: 1, \n                  opacity: 1,\n                  x: signature ? flowAnim.x : [0, 0, 0],\n                  y: signature ? flowAnim.y : [0, 0, 0],\n                }}\n                transition={{\n                  type: 'spring',\n                  stiffness: 300,\n                  damping: 20,\n                  delay: layerIndex * 0.05,\n                  x: { duration: flowAnim.duration, repeat: Infinity },\n                  y: { duration: flowAnim.duration, repeat: Infinity },\n                }}\n                className=\"absolute\"\n                style={{\n                  backgroundColor: color,\n                  top: `${offset}%`,\n                  left: `${offset}%`,\n                  width: `${layerSize}%`,\n                  height: `${layerSize}%`,\n                  borderRadius: '2px',\n                  boxShadow: signature && pattern.intensity > 0.5 \n                    ? `0 0 ${4 * pattern.intensity}px ${pattern.dominantColor}40`\n                    : undefined,\n                }}\n              />\n            );\n          })}\n        </AnimatePresence>\n      </div>\n    );\n  };\n\n  return (\n    <div \n      className=\"absolute inset-0 pointer-events-none z-[5]\"\n      style={{\n        transition: 'opacity 0.3s ease-in-out',\n      }}\n    >\n      {Array.from(squareColorLayers.entries()).map(([square, colors]) =>\n        renderSquareVisualization(square, colors)\n      )}\n    </div>\n  );\n};\n";export{e as default};
