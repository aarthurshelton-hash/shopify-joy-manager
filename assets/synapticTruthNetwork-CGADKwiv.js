const n="/**\n * Synaptic Truth Network\n * \n * A nervous system architecture for En Pensent that fires pattern recognition\n * instantaneously based on accumulated universal truth - not sequential calculation.\n * \n * Philosophy: The universe contains only presence and magnitude.\n * Truth doesn't need to be calculated - it needs to be RECOGNIZED.\n * Like a synapse that fires when threshold is reached, patterns either\n * resonate with truth or they don't.\n * \n * Patent Pending - Alec Arthur Shelton\n */\n\n// ============================================================================\n// SYNAPTIC ARCHITECTURE\n// ============================================================================\n\n/**\n * A synapse is a connection between pattern nodes that fires based on\n * accumulated energy reaching a truth threshold\n */\nexport interface Synapse {\n  id: string;\n  sourcePattern: string;\n  targetPattern: string;\n  weight: number;           // 0-1: Connection strength (learned)\n  threshold: number;        // Energy required to fire\n  lastFired: number;        // Timestamp\n  fireCount: number;        // Times this connection has activated\n  truthResonance: number;   // How often firing led to correct outcome (0-1)\n}\n\n/**\n * A neuron represents a pattern archetype that can fire\n */\nexport interface PatternNeuron {\n  id: string;\n  archetype: string;\n  accumulatedEnergy: number;  // Current energy level (positive only)\n  restingPotential: number;   // Baseline energy (never negative)\n  firingThreshold: number;    // Energy needed to activate\n  refractoryPeriod: number;   // Cooldown after firing (ms)\n  lastFired: number | null;\n  totalFirings: number;\n  truthAccuracy: number;      // How often this neuron's firing was correct\n  connectedSynapses: string[];\n}\n\n/**\n * Signal propagating through the network\n */\nexport interface NeuralSignal {\n  id: string;\n  sourceNeuron: string;\n  energy: number;           // Always positive - magnitude only\n  timestamp: number;\n  propagationPath: string[];\n  decayRate: number;        // Energy loss per hop\n}\n\n/**\n * The firing event when truth is recognized\n */\nexport interface TruthFiring {\n  neuronId: string;\n  archetype: string;\n  energy: number;\n  confidence: number;\n  cascadeDepth: number;     // How many neurons fired in chain\n  recognitionLatency: number; // Time from input to firing (ms)\n  universalResonance: number; // Alignment with accumulated truth\n}\n\n// ============================================================================\n// CORE NERVOUS SYSTEM\n// ============================================================================\n\nclass SynapticTruthNetwork {\n  private neurons: Map<string, PatternNeuron> = new Map();\n  private synapses: Map<string, Synapse> = new Map();\n  private activeSignals: NeuralSignal[] = [];\n  private firingHistory: TruthFiring[] = [];\n  private globalTruthMemory: Map<string, number> = new Map(); // archetype -> accuracy\n  \n  // Universal constants\n  private readonly TRUTH_THRESHOLD = 0.618; // Golden ratio - universal harmony\n  private readonly ENERGY_DECAY = 0.1;\n  private readonly REFRACTORY_MS = 50;\n  private readonly MAX_CASCADE_DEPTH = 7; // Limit runaway firing\n  \n  constructor() {\n    this.initializeBaseArchetypes();\n  }\n  \n  /**\n   * Initialize the base neural architecture with chess archetypes\n   */\n  private initializeBaseArchetypes(): void {\n    const archetypes = [\n      'kingside_attack', 'queenside_expansion', 'central_domination',\n      'prophylactic_defense', 'piece_coordination', 'pawn_storm',\n      'endgame_technique', 'tactical_storm', 'positional_squeeze',\n      'dynamic_balance', 'material_imbalance', 'king_hunt'\n    ];\n    \n    archetypes.forEach((archetype, idx) => {\n      const neuron: PatternNeuron = {\n        id: `neuron_${archetype}`,\n        archetype,\n        accumulatedEnergy: 0,\n        restingPotential: 0.1, // Small baseline presence\n        firingThreshold: this.TRUTH_THRESHOLD,\n        refractoryPeriod: this.REFRACTORY_MS,\n        lastFired: null,\n        totalFirings: 0,\n        truthAccuracy: 0.5, // Start neutral\n        connectedSynapses: []\n      };\n      this.neurons.set(neuron.id, neuron);\n    });\n    \n    // Create cross-archetype synaptic connections\n    this.createSynapticWeb();\n  }\n  \n  /**\n   * Create the web of synaptic connections between pattern neurons\n   */\n  private createSynapticWeb(): void {\n    const neurons = Array.from(this.neurons.values());\n    \n    // Connect related archetypes with stronger weights\n    const connections: Array<[string, string, number]> = [\n      ['kingside_attack', 'pawn_storm', 0.8],\n      ['kingside_attack', 'king_hunt', 0.9],\n      ['queenside_expansion', 'positional_squeeze', 0.7],\n      ['central_domination', 'piece_coordination', 0.8],\n      ['prophylactic_defense', 'positional_squeeze', 0.6],\n      ['tactical_storm', 'material_imbalance', 0.7],\n      ['endgame_technique', 'positional_squeeze', 0.6],\n      ['dynamic_balance', 'piece_coordination', 0.5],\n    ];\n    \n    connections.forEach(([source, target, weight]) => {\n      const synapse: Synapse = {\n        id: `syn_${source}_${target}`,\n        sourcePattern: source,\n        targetPattern: target,\n        weight,\n        threshold: this.TRUTH_THRESHOLD * (1 - weight * 0.3), // Stronger = easier to fire\n        lastFired: 0,\n        fireCount: 0,\n        truthResonance: 0.5\n      };\n      this.synapses.set(synapse.id, synapse);\n      \n      // Link neurons to their synapses\n      const sourceNeuron = this.neurons.get(`neuron_${source}`);\n      if (sourceNeuron) {\n        sourceNeuron.connectedSynapses.push(synapse.id);\n      }\n    });\n  }\n  \n  /**\n   * CORE FUNCTION: Inject energy into the network and let truth emerge\n   * \n   * This is the \"instant invocation\" - we don't calculate, we RECOGNIZE\n   */\n  invokePattern(\n    energySignature: {\n      whiteEnergy: number;\n      blackEnergy: number;\n      quadrantProfile: { q1: number; q2: number; q3: number; q4: number };\n      temporalPhase: 'opening' | 'middlegame' | 'endgame';\n      volatility: number;\n    }\n  ): TruthFiring | null {\n    const startTime = Date.now();\n    \n    // Convert input into neural signals\n    const signals = this.convertToNeuralSignals(energySignature);\n    \n    // Propagate through network - truth will emerge where energy accumulates\n    let cascadeDepth = 0;\n    const firedNeurons: PatternNeuron[] = [];\n    \n    while (signals.length > 0 && cascadeDepth < this.MAX_CASCADE_DEPTH) {\n      const signal = signals.shift()!;\n      \n      // Find neurons this signal should stimulate\n      const targetNeurons = this.findResonantNeurons(signal, energySignature);\n      \n      for (const neuron of targetNeurons) {\n        // Accumulate energy (always positive)\n        neuron.accumulatedEnergy += signal.energy * (1 - this.ENERGY_DECAY * cascadeDepth);\n        \n        // Check for firing threshold\n        if (this.shouldFire(neuron)) {\n          firedNeurons.push(neuron);\n          \n          // Propagate through synapses\n          const cascadeSignals = this.propagateThroughSynapses(neuron, signal.energy);\n          signals.push(...cascadeSignals);\n          \n          // Mark as fired\n          neuron.lastFired = Date.now();\n          neuron.totalFirings++;\n          \n          // Reset accumulated energy (refractory)\n          neuron.accumulatedEnergy = neuron.restingPotential;\n        }\n      }\n      \n      cascadeDepth++;\n    }\n    \n    // No truth recognized\n    if (firedNeurons.length === 0) {\n      return null;\n    }\n    \n    // Find the STRONGEST firing - this is the recognized truth\n    const dominantFiring = firedNeurons.reduce((strongest, current) => {\n      const currentStrength = current.truthAccuracy * current.totalFirings;\n      const strongestStrength = strongest.truthAccuracy * strongest.totalFirings;\n      return currentStrength > strongestStrength ? current : strongest;\n    });\n    \n    // Calculate universal resonance\n    const universalResonance = this.calculateUniversalResonance(\n      dominantFiring,\n      firedNeurons,\n      energySignature\n    );\n    \n    const firing: TruthFiring = {\n      neuronId: dominantFiring.id,\n      archetype: dominantFiring.archetype,\n      energy: dominantFiring.accumulatedEnergy,\n      confidence: dominantFiring.truthAccuracy,\n      cascadeDepth,\n      recognitionLatency: Date.now() - startTime,\n      universalResonance\n    };\n    \n    this.firingHistory.push(firing);\n    \n    return firing;\n  }\n  \n  /**\n   * Convert energy signature into propagatable neural signals\n   */\n  private convertToNeuralSignals(energySignature: {\n    whiteEnergy: number;\n    blackEnergy: number;\n    quadrantProfile: { q1: number; q2: number; q3: number; q4: number };\n    temporalPhase: 'opening' | 'middlegame' | 'endgame';\n    volatility: number;\n  }): NeuralSignal[] {\n    const signals: NeuralSignal[] = [];\n    const now = Date.now();\n    \n    // Quadrant-based signals (kingside vs queenside)\n    const kingsideEnergy = (energySignature.quadrantProfile.q2 + energySignature.quadrantProfile.q4) / 2;\n    const queensideEnergy = (energySignature.quadrantProfile.q1 + energySignature.quadrantProfile.q3) / 2;\n    \n    if (kingsideEnergy > 0.6) {\n      signals.push({\n        id: `sig_kingside_${now}`,\n        sourceNeuron: 'input',\n        energy: kingsideEnergy,\n        timestamp: now,\n        propagationPath: [],\n        decayRate: this.ENERGY_DECAY\n      });\n    }\n    \n    if (queensideEnergy > 0.6) {\n      signals.push({\n        id: `sig_queenside_${now}`,\n        sourceNeuron: 'input',\n        energy: queensideEnergy,\n        timestamp: now,\n        propagationPath: [],\n        decayRate: this.ENERGY_DECAY\n      });\n    }\n    \n    // Volatility signal (tactical patterns)\n    if (energySignature.volatility > 0.5) {\n      signals.push({\n        id: `sig_tactical_${now}`,\n        sourceNeuron: 'input',\n        energy: energySignature.volatility,\n        timestamp: now,\n        propagationPath: [],\n        decayRate: this.ENERGY_DECAY\n      });\n    }\n    \n    // Dominance signal\n    const dominanceIntensity = Math.abs(energySignature.whiteEnergy - energySignature.blackEnergy) / 100;\n    if (dominanceIntensity > 0.1) {\n      signals.push({\n        id: `sig_dominance_${now}`,\n        sourceNeuron: 'input',\n        energy: dominanceIntensity,\n        timestamp: now,\n        propagationPath: [],\n        decayRate: this.ENERGY_DECAY\n      });\n    }\n    \n    return signals;\n  }\n  \n  /**\n   * Find neurons that resonate with this signal based on archetype affinity\n   */\n  private findResonantNeurons(\n    signal: NeuralSignal,\n    energySignature: { quadrantProfile: { q1: number; q2: number; q3: number; q4: number }; temporalPhase: string; volatility: number }\n  ): PatternNeuron[] {\n    const resonant: PatternNeuron[] = [];\n    \n    for (const neuron of this.neurons.values()) {\n      // Skip if in refractory period\n      if (neuron.lastFired && Date.now() - neuron.lastFired < neuron.refractoryPeriod) {\n        continue;\n      }\n      \n      // Calculate affinity based on archetype\n      const affinity = this.calculateAffinity(neuron.archetype, signal, energySignature);\n      \n      if (affinity > 0.3) {\n        resonant.push(neuron);\n      }\n    }\n    \n    return resonant;\n  }\n  \n  /**\n   * Calculate affinity between archetype and current signal\n   */\n  private calculateAffinity(\n    archetype: string,\n    signal: NeuralSignal,\n    energySignature: { quadrantProfile: { q1: number; q2: number; q3: number; q4: number }; temporalPhase: string; volatility: number }\n  ): number {\n    const { quadrantProfile, temporalPhase, volatility } = energySignature;\n    \n    const kingsideActivity = (quadrantProfile.q2 + quadrantProfile.q4) / 2;\n    const queensideActivity = (quadrantProfile.q1 + quadrantProfile.q3) / 2;\n    \n    switch (archetype) {\n      case 'kingside_attack':\n      case 'pawn_storm':\n      case 'king_hunt':\n        return kingsideActivity * (volatility > 0.5 ? 1.2 : 0.8);\n        \n      case 'queenside_expansion':\n        return queensideActivity * (temporalPhase === 'middlegame' ? 1.1 : 0.9);\n        \n      case 'central_domination':\n        return (quadrantProfile.q2 + quadrantProfile.q3) / 2;\n        \n      case 'tactical_storm':\n      case 'material_imbalance':\n        return volatility * 1.3;\n        \n      case 'positional_squeeze':\n      case 'prophylactic_defense':\n        return (1 - volatility) * 0.9;\n        \n      case 'endgame_technique':\n        return temporalPhase === 'endgame' ? 0.9 : 0.3;\n        \n      case 'piece_coordination':\n      case 'dynamic_balance':\n        return Math.min(kingsideActivity, queensideActivity) * 1.1;\n        \n      default:\n        return 0.5;\n    }\n  }\n  \n  /**\n   * Check if neuron should fire based on accumulated energy\n   */\n  private shouldFire(neuron: PatternNeuron): boolean {\n    // Truth threshold modified by neuron's proven accuracy\n    const adjustedThreshold = neuron.firingThreshold * (2 - neuron.truthAccuracy);\n    return neuron.accumulatedEnergy >= adjustedThreshold;\n  }\n  \n  /**\n   * Propagate firing through connected synapses\n   */\n  private propagateThroughSynapses(neuron: PatternNeuron, energy: number): NeuralSignal[] {\n    const signals: NeuralSignal[] = [];\n    \n    for (const synapseId of neuron.connectedSynapses) {\n      const synapse = this.synapses.get(synapseId);\n      if (!synapse) continue;\n      \n      // Only propagate if synapse weight allows\n      const propagatedEnergy = energy * synapse.weight;\n      \n      if (propagatedEnergy >= synapse.threshold) {\n        synapse.fireCount++;\n        synapse.lastFired = Date.now();\n        \n        signals.push({\n          id: `sig_cascade_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n          sourceNeuron: neuron.id,\n          energy: propagatedEnergy,\n          timestamp: Date.now(),\n          propagationPath: [neuron.id],\n          decayRate: this.ENERGY_DECAY\n        });\n      }\n    }\n    \n    return signals;\n  }\n  \n  /**\n   * Calculate how well this firing aligns with universal truth patterns\n   */\n  private calculateUniversalResonance(\n    dominant: PatternNeuron,\n    allFired: PatternNeuron[],\n    energySignature: { whiteEnergy: number; blackEnergy: number }\n  ): number {\n    // Base resonance from archetype accuracy\n    let resonance = dominant.truthAccuracy;\n    \n    // Boost if multiple related archetypes fired (consensus)\n    if (allFired.length > 1) {\n      resonance *= 1 + (allFired.length - 1) * 0.1;\n    }\n    \n    // Check against global truth memory\n    const historicalAccuracy = this.globalTruthMemory.get(dominant.archetype) || 0.5;\n    resonance = (resonance + historicalAccuracy) / 2;\n    \n    // Cap at 1.0\n    return Math.min(resonance, 1.0);\n  }\n  \n  /**\n   * LEARNING: Record outcome to strengthen/weaken synaptic connections\n   */\n  recordOutcome(firing: TruthFiring, wasCorrect: boolean): void {\n    const neuron = this.neurons.get(firing.neuronId);\n    if (!neuron) return;\n    \n    // Update neuron's truth accuracy (exponential moving average)\n    const alpha = 0.1;\n    neuron.truthAccuracy = neuron.truthAccuracy * (1 - alpha) + (wasCorrect ? 1 : 0) * alpha;\n    \n    // Update global truth memory\n    const currentAccuracy = this.globalTruthMemory.get(neuron.archetype) || 0.5;\n    this.globalTruthMemory.set(\n      neuron.archetype,\n      currentAccuracy * (1 - alpha) + (wasCorrect ? 1 : 0) * alpha\n    );\n    \n    // Update connected synapses\n    for (const synapseId of neuron.connectedSynapses) {\n      const synapse = this.synapses.get(synapseId);\n      if (synapse) {\n        synapse.truthResonance = synapse.truthResonance * (1 - alpha) + (wasCorrect ? 1 : 0) * alpha;\n        // Strengthen correct connections, weaken incorrect\n        synapse.weight = Math.max(0.1, Math.min(1.0, \n          synapse.weight + (wasCorrect ? 0.01 : -0.01)\n        ));\n      }\n    }\n  }\n  \n  /**\n   * Get network state for debugging/visualization\n   */\n  getNetworkState(): {\n    totalNeurons: number;\n    totalSynapses: number;\n    recentFirings: number;\n    topArchetypes: Array<{ archetype: string; accuracy: number; firings: number }>;\n    averageResonance: number;\n  } {\n    const neurons = Array.from(this.neurons.values());\n    const recentFirings = this.firingHistory.filter(\n      f => Date.now() - f.recognitionLatency < 60000\n    ).length;\n    \n    const topArchetypes = neurons\n      .filter(n => n.totalFirings > 0)\n      .sort((a, b) => b.truthAccuracy * b.totalFirings - a.truthAccuracy * a.totalFirings)\n      .slice(0, 5)\n      .map(n => ({\n        archetype: n.archetype,\n        accuracy: Math.round(n.truthAccuracy * 100) / 100,\n        firings: n.totalFirings\n      }));\n    \n    const avgResonance = this.firingHistory.length > 0\n      ? this.firingHistory.reduce((sum, f) => sum + f.universalResonance, 0) / this.firingHistory.length\n      : 0;\n    \n    return {\n      totalNeurons: neurons.length,\n      totalSynapses: this.synapses.size,\n      recentFirings,\n      topArchetypes,\n      averageResonance: Math.round(avgResonance * 100) / 100\n    };\n  }\n  \n  /**\n   * Reset network to initial state (for testing)\n   */\n  reset(): void {\n    this.neurons.clear();\n    this.synapses.clear();\n    this.firingHistory = [];\n    this.globalTruthMemory.clear();\n    this.initializeBaseArchetypes();\n  }\n}\n\n// Singleton instance\nexport const synapticTruthNetwork = new SynapticTruthNetwork();\n";export{n as default};
