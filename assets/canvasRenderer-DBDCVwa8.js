const n="import { SquareData, SquareVisit } from './gameSimulator';\nimport { boardColors, getPieceColor } from './pieceColors';\nimport enPensentLogo from '@/assets/en-pensent-logo-new.png';\n\n// High DPI scaling for maximum quality downloads - 5x\nconst DPI_SCALE = 5;\n\n// Format date from PGN format (YYYY.MM.DD) to display format\nfunction formatDate(dateStr: string): string {\n  if (!dateStr || dateStr === 'Unknown' || dateStr === '????.??.??') {\n    return dateStr; // Keep as-is for display\n  }\n  return dateStr;\n}\n\n// Wait for fonts to be loaded\nasync function ensureFontsLoaded(): Promise<void> {\n  if (document.fonts && document.fonts.ready) {\n    await document.fonts.ready;\n  }\n  await new Promise(resolve => setTimeout(resolve, 150));\n}\n\n/**\n * Generates SVG string for the chess board - matches ChessBoardVisualization exactly\n */\nfunction generateBoardSVG(board: SquareData[][], size: number): string {\n  const squareSize = size / 8;\n  const borderWidth = size * 0.02;\n  const totalSize = size + borderWidth * 2;\n  \n  let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${totalSize}\" height=\"${totalSize}\" viewBox=\"0 0 ${totalSize} ${totalSize}\">`;\n  \n  // Border\n  svg += `<rect x=\"0\" y=\"0\" width=\"${totalSize}\" height=\"${totalSize}\" fill=\"${boardColors.border}\"/>`;\n  \n  // Board squares\n  for (let rowIndex = 0; rowIndex < 8; rowIndex++) {\n    const rank = 7 - rowIndex;\n    for (let file = 0; file < 8; file++) {\n      const square = board[rank][file];\n      const baseColor = square.isLight ? boardColors.light : boardColors.dark;\n      const x = borderWidth + file * squareSize;\n      const y = borderWidth + rowIndex * squareSize;\n      \n      // Base square\n      svg += `<rect x=\"${x}\" y=\"${y}\" width=\"${squareSize}\" height=\"${squareSize}\" fill=\"${baseColor}\"/>`;\n      \n      // Nested squares for piece visits\n      if (square.visits.length > 0) {\n        const padding = squareSize * 0.08;\n        const uniqueColors: string[] = [];\n        for (const visit of square.visits) {\n          const color = getPieceColor(visit.piece, visit.color);\n          if (!uniqueColors.includes(color)) {\n            uniqueColors.push(color);\n          }\n        }\n        \n        const maxNesting = Math.min(uniqueColors.length, 6);\n        const layers: { color: string; layerSize: number }[] = [];\n        let currentSize = squareSize - padding * 2;\n        const sizeReduction = (currentSize * 0.7) / maxNesting;\n        \n        for (let i = 0; i < maxNesting; i++) {\n          layers.push({ color: uniqueColors[i], layerSize: currentSize });\n          currentSize -= sizeReduction;\n          if (currentSize < squareSize * 0.1) break;\n        }\n        \n        for (const layer of layers) {\n          const offset = (squareSize - layer.layerSize) / 2;\n          svg += `<rect x=\"${x + offset}\" y=\"${y + offset}\" width=\"${layer.layerSize}\" height=\"${layer.layerSize}\" fill=\"${layer.color}\"/>`;\n        }\n      }\n    }\n  }\n  \n  svg += '</svg>';\n  return svg;\n}\n\n/**\n * Converts SVG string to canvas at high resolution\n */\nasync function svgToCanvas(svgString: string, width: number, height: number): Promise<HTMLCanvasElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\n    const url = URL.createObjectURL(blob);\n    \n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = width * DPI_SCALE;\n      canvas.height = height * DPI_SCALE;\n      const ctx = canvas.getContext('2d')!;\n      ctx.scale(DPI_SCALE, DPI_SCALE);\n      ctx.drawImage(img, 0, 0, width, height);\n      URL.revokeObjectURL(url);\n      resolve(canvas);\n    };\n    \n    img.onerror = () => {\n      URL.revokeObjectURL(url);\n      reject(new Error('Failed to load SVG'));\n    };\n    \n    img.src = url;\n  });\n}\n\n/**\n * Generates QR code data URL\n */\nasync function generateQRCodeDataUrl(darkMode: boolean): Promise<string> {\n  const QRCode = (await import('qrcode')).default;\n  return QRCode.toDataURL('https://enpensent.com', {\n    width: 200,\n    margin: 1,\n    color: {\n      dark: darkMode ? '#FAFAFA' : '#1A1A1A',\n      light: 'transparent',\n    },\n    errorCorrectionLevel: 'M',\n  });\n}\n\n/**\n * Load the logo image\n */\nasync function loadLogoImage(): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = enPensentLogo;\n  });\n}\n\n/**\n * Generates a complete print-ready image with board and game info\n * Matches the preview exactly by using the same SVG rendering\n */\nexport async function generatePrintCanvas(\n  board: SquareData[][],\n  gameData: {\n    white?: string;\n    black?: string;\n    event?: string;\n    date?: string;\n    moves?: string[];\n  },\n  options: {\n    boardSize?: number;\n    darkMode?: boolean;\n    withWatermark?: boolean;\n    title?: string;\n  } = {}\n): Promise<HTMLCanvasElement> {\n  await ensureFontsLoaded();\n  \n  const {\n    boardSize = 600,\n    darkMode = false,\n    withWatermark = false,\n    title,\n  } = options;\n  \n  // Generate SVG for the board\n  const svgString = generateBoardSVG(board, boardSize);\n  const borderWidth = boardSize * 0.02;\n  const boardTotalSize = boardSize + borderWidth * 2;\n  \n  // Convert SVG to high-res canvas\n  const boardCanvas = await svgToCanvas(svgString, boardTotalSize, boardTotalSize);\n  \n  // Calculate final dimensions\n  const padding = 60;\n  const infoHeight = 220;\n  const brandingHeight = 60;\n  \n  const totalWidth = boardTotalSize + padding * 2;\n  const totalHeight = boardTotalSize + infoHeight + brandingHeight + padding * 2;\n  \n  // Create final canvas at high resolution\n  const canvas = document.createElement('canvas');\n  canvas.width = totalWidth * DPI_SCALE;\n  canvas.height = totalHeight * DPI_SCALE;\n  \n  const ctx = canvas.getContext('2d')!;\n  ctx.scale(DPI_SCALE, DPI_SCALE);\n  \n  // Enable smooth rendering\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n  \n  // Background - exact match to preview\n  ctx.fillStyle = darkMode ? '#0A0A0A' : '#FDFCFB';\n  ctx.fillRect(0, 0, totalWidth, totalHeight);\n  \n  // Draw the board from SVG canvas\n  ctx.drawImage(\n    boardCanvas,\n    0, 0, boardCanvas.width, boardCanvas.height,\n    padding, padding, boardTotalSize, boardTotalSize\n  );\n  \n  // Separator line\n  const separatorY = padding + boardTotalSize + 28;\n  ctx.strokeStyle = darkMode ? '#292524' : '#e7e5e4';\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  ctx.moveTo(padding, separatorY);\n  ctx.lineTo(totalWidth - padding, separatorY);\n  ctx.stroke();\n  \n  // Text colors matching preview exactly\n  const primaryText = darkMode ? '#fafaf9' : '#292524';\n  const secondaryText = darkMode ? '#a8a29e' : '#78716c';\n  const mutedText = darkMode ? '#78716c' : '#a8a29e';\n  const vsColor = darkMode ? '#78716c' : '#a8a29e';\n  \n  const centerX = totalWidth / 2;\n  let textY = separatorY + 55;\n  \n  // Player names - Cinzel font, exact preview style\n  const whiteName = gameData.white || 'White';\n  const blackName = gameData.black || 'Black';\n  \n  ctx.textBaseline = 'middle';\n  \n  // Measure text widths\n  ctx.font = \"600 24px 'Cinzel', 'Times New Roman', serif\";\n  const whiteWidth = ctx.measureText(whiteName).width;\n  const blackWidth = ctx.measureText(blackName).width;\n  \n  ctx.font = \"italic 500 20px 'Cormorant', Georgia, serif\";\n  const vsText = ' vs ';\n  const vsWidth = ctx.measureText(vsText).width;\n  \n  const totalTextWidth = whiteWidth + vsWidth + blackWidth;\n  const startX = centerX - totalTextWidth / 2;\n  \n  // Draw white player name\n  ctx.font = \"600 24px 'Cinzel', 'Times New Roman', serif\";\n  ctx.fillStyle = primaryText;\n  ctx.textAlign = 'left';\n  ctx.fillText(whiteName, startX, textY);\n  \n  // Draw \"vs\"\n  ctx.font = \"italic 500 20px 'Cormorant', Georgia, serif\";\n  ctx.fillStyle = vsColor;\n  ctx.fillText(vsText, startX + whiteWidth, textY);\n  \n  // Draw black player name\n  ctx.font = \"600 24px 'Cinzel', 'Times New Roman', serif\";\n  ctx.fillStyle = primaryText;\n  ctx.fillText(blackName, startX + whiteWidth + vsWidth, textY);\n  \n  textY += 36;\n  \n  // Event - Cormorant italic\n  if (gameData.event && gameData.event !== 'Unknown') {\n    ctx.fillStyle = secondaryText;\n    ctx.font = \"italic 500 18px 'Cormorant', Georgia, serif\";\n    ctx.textAlign = 'center';\n    ctx.fillText(gameData.event, centerX, textY);\n    textY += 32;\n  }\n  \n  // Title and Date - Inter font with letter-spacing\n  const displayTitle = title;\n  const dateStr = gameData.date || '';\n  if (displayTitle || dateStr) {\n    ctx.fillStyle = mutedText;\n    ctx.font = \"500 12px 'Inter', sans-serif\";\n    ctx.textAlign = 'center';\n    \n    let labelText = '';\n    if (displayTitle) {\n      labelText = displayTitle.toUpperCase();\n      if (dateStr) labelText += '  •  ' + dateStr;\n    } else {\n      labelText = dateStr;\n    }\n    \n    // Manual letter-spacing\n    const spacing = 2;\n    const chars = labelText.split('');\n    const totalCharWidth = chars.reduce((sum, c) => sum + ctx.measureText(c).width, 0);\n    const totalSpacing = (chars.length - 1) * spacing;\n    let charX = centerX - (totalCharWidth + totalSpacing) / 2;\n    \n    for (const char of chars) {\n      ctx.textAlign = 'left';\n      ctx.fillText(char, charX, textY);\n      charX += ctx.measureText(char).width + spacing;\n    }\n    textY += 28;\n  }\n  \n  // Moves - Times New Roman\n  if (gameData.moves && gameData.moves.length > 0) {\n    ctx.fillStyle = mutedText;\n    ctx.font = \"400 10px 'Times New Roman', Times, serif\";\n    ctx.textAlign = 'center';\n    \n    const movesText = gameData.moves.join(' ');\n    const truncatedMoves = movesText.length > 400 ? movesText.substring(0, 400) + '...' : movesText;\n    \n    const maxWidth = totalWidth - padding * 2 - 40;\n    const words = truncatedMoves.split(' ');\n    let line = '';\n    let lineY = textY;\n    const lineHeight = 15;\n    const maxLines = 4;\n    let lineCount = 0;\n    \n    for (const word of words) {\n      const testLine = line + (line ? ' ' : '') + word;\n      if (ctx.measureText(testLine).width > maxWidth && line) {\n        ctx.fillText(line, centerX, lineY);\n        line = word;\n        lineY += lineHeight;\n        lineCount++;\n        if (lineCount >= maxLines) break;\n      } else {\n        line = testLine;\n      }\n    }\n    if (line && lineCount < maxLines) {\n      ctx.fillText(line, centerX, lineY);\n    }\n  }\n  \n  // Branding at bottom\n  const brandingY = totalHeight - padding - 20;\n  ctx.fillStyle = mutedText;\n  ctx.font = \"500 11px 'Inter', sans-serif\";\n  ctx.textAlign = 'center';\n  \n  const brandText = '♔ EN PENSENT ♚';\n  const brandSpacing = 4;\n  const brandChars = brandText.split('');\n  const brandCharWidth = brandChars.reduce((sum, c) => sum + ctx.measureText(c).width, 0);\n  const brandTotalWidth = brandCharWidth + (brandChars.length - 1) * brandSpacing;\n  let brandX = centerX - brandTotalWidth / 2;\n  \n  for (const char of brandChars) {\n    ctx.textAlign = 'left';\n    ctx.fillText(char, brandX, brandingY);\n    brandX += ctx.measureText(char).width + brandSpacing;\n  }\n  \n  // Watermark for free downloads - matching reference image exactly\n  if (withWatermark) {\n    // Load assets in parallel\n    const [qrDataUrl, logoImg] = await Promise.all([\n      generateQRCodeDataUrl(false), // Always use dark QR for visibility\n      loadLogoImage(),\n    ]);\n    \n    const wmWidth = 220;\n    const wmHeight = 65;\n    const wmX = padding + boardTotalSize - wmWidth - 12;\n    const wmY = padding + boardTotalSize - wmHeight - 12;\n    \n    // Background with rounded corners - semi-transparent white\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';\n    ctx.beginPath();\n    ctx.roundRect(wmX, wmY, wmWidth, wmHeight, 6);\n    ctx.fill();\n    \n    // Subtle border\n    ctx.strokeStyle = '#e7e5e4';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n    \n    // Draw the actual logo image (circular, gold-rimmed)\n    const logoSize = 48;\n    const logoX = wmX + 12;\n    const logoY = wmY + (wmHeight - logoSize) / 2;\n    \n    // Draw logo with circular clip\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(logoX + logoSize/2, logoY + logoSize/2, logoSize/2, 0, Math.PI * 2);\n    ctx.clip();\n    ctx.drawImage(logoImg, logoX, logoY, logoSize, logoSize);\n    ctx.restore();\n    \n    // Brand text - positioned to the right of logo\n    const textX = logoX + logoSize + 10;\n    \n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'alphabetic';\n    ctx.fillStyle = '#44403c';\n    ctx.font = \"600 13px 'Inter', sans-serif\";\n    ctx.fillText('EN PENSENT', textX, wmY + 28);\n    \n    ctx.fillStyle = '#78716c';\n    ctx.font = \"400 11px 'Inter', sans-serif\";\n    ctx.fillText('enpensent.com', textX, wmY + 46);\n    \n    // QR Code - positioned on the right\n    const qrSize = 50;\n    const qrX = wmX + wmWidth - qrSize - 10;\n    const qrY = wmY + (wmHeight - qrSize) / 2;\n    \n    const qrImg = new Image();\n    await new Promise<void>((resolve) => {\n      qrImg.onload = () => {\n        ctx.drawImage(qrImg, qrX, qrY, qrSize, qrSize);\n        resolve();\n      };\n      qrImg.onerror = () => resolve();\n      qrImg.src = qrDataUrl;\n    });\n  }\n  \n  return canvas;\n}\n";export{n as default};
