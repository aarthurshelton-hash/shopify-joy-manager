const n="/**\n * Hybrid Confidence Calculator v3.0 (COMPOUND INTELLIGENCE)\n * \n * v3.0: Integrated with Intelligence Compounding System\n * - Live confidence calibration from rolling accuracy\n * - Disagreement amplifier for archetypes that beat Stockfish\n * - Temporal decay weighting (recent predictions matter more)\n */\n\nimport { PositionAnalysis } from '../stockfishEngine';\nimport { ColorFlowSignature, ARCHETYPE_DEFINITIONS } from '../colorFlowAnalysis';\nimport { TacticalInsight, StrategicInsight, HybridConfidence } from './types';\nimport { \n  getCalibratedConfidence, \n  getIntelligenceMetrics,\n  initializeFromDatabase \n} from '../accuracy/intelligenceCompounding';\n\n// In-memory accuracy tracker (gets populated from database on first load)\nlet accuracyCache: {\n  totalPredictions: number;\n  correctPredictions: number;\n  lastUpdated: number;\n} = {\n  totalPredictions: 0,\n  correctPredictions: 0,\n  lastUpdated: 0,\n};\n\n// Initialize intelligence system on module load\nlet initPromise: Promise<void> | null = null;\nfunction ensureInitialized(): Promise<void> {\n  if (!initPromise) {\n    initPromise = initializeFromDatabase();\n  }\n  return initPromise;\n}\n\n/**\n * Update accuracy cache from external source (called by benchmark system)\n */\nexport function updateAccuracyCache(total: number, correct: number): void {\n  accuracyCache = {\n    totalPredictions: total,\n    correctPredictions: correct,\n    lastUpdated: Date.now(),\n  };\n  console.log(`[ConfidenceCalc] Accuracy cache updated: ${correct}/${total} = ${total > 0 ? ((correct/total)*100).toFixed(1) : 0}%`);\n}\n\n/**\n * Get current actual accuracy (0-100)\n */\nfunction getActualAccuracy(): number {\n  if (accuracyCache.totalPredictions < 10) {\n    // Not enough data - return baseline (random would be ~33.3% for 3-way)\n    return 33.3;\n  }\n  return (accuracyCache.correctPredictions / accuracyCache.totalPredictions) * 100;\n}\n\n/**\n * Calculate hybrid prediction confidence metrics\n * \n * v2.0: Confidence is now GROUNDED in actual performance:\n * - Base confidence starts at actual accuracy %\n * - Theoretical factors can only SLIGHTLY modify, not override\n * - Until accuracy exceeds 50%, confidence stays capped\n */\nexport function calculateHybridConfidence(\n  analysis: PositionAnalysis,\n  signature: ColorFlowSignature,\n  tactical: TacticalInsight,\n  strategic: StrategicInsight\n): HybridConfidence {\n  const factors: string[] = [];\n  \n  // Ensure intelligence system is initializing\n  ensureInitialized();\n  \n  // PRIMARY: Actual accuracy is the foundation\n  const actualAccuracy = getActualAccuracy();\n  factors.push(`Historical accuracy: ${actualAccuracy.toFixed(1)}%`);\n  \n  // SECONDARY: Tactical quality (minor modifier, max ±5%)\n  const depthQuality = Math.min(1, analysis.evaluation.depth / 25); // 0-1 scale\n  const tacticalModifier = (depthQuality - 0.5) * 10; // -5 to +5\n  const tacticalConf = Math.max(20, Math.min(95, actualAccuracy + tacticalModifier));\n  factors.push(`Depth ${analysis.evaluation.depth} (${tacticalModifier > 0 ? '+' : ''}${tacticalModifier.toFixed(1)}%)`);\n  \n  // SECONDARY: Archetype clarity (minor modifier, max ±5%)\n  const archetypeDef = ARCHETYPE_DEFINITIONS[signature.archetype];\n  const archetypeModifier = signature.archetype !== 'unknown' \n    ? (archetypeDef.historicalWinRate - 0.5) * 10 + signature.intensity / 20\n    : -5;\n  const strategicConf = Math.max(20, Math.min(95, actualAccuracy + archetypeModifier));\n  factors.push(`${archetypeDef.name} archetype (${archetypeModifier > 0 ? '+' : ''}${archetypeModifier.toFixed(1)}%)`);\n  \n  // Alignment: do tactics and strategy point same direction?\n  const alignment = calculateAlignment(analysis, signature, factors);\n  const alignmentModifier = (alignment - 50) / 10; // -1 to +3.5\n  \n  // BASE: Actual accuracy + small modifiers\n  const baseConfidence = actualAccuracy + (tacticalModifier + archetypeModifier + alignmentModifier) / 3;\n  \n  // v3.0: APPLY COMPOUND INTELLIGENCE CALIBRATION\n  const calibrated = getCalibratedConfidence(signature.archetype, baseConfidence);\n  factors.push(...calibrated.factors);\n  \n  // Log intelligence metrics periodically\n  const metrics = getIntelligenceMetrics();\n  if (metrics.isLearning && Math.random() < 0.1) {\n    console.log(`[Intelligence] Learning active: ${metrics.archetypeCount} archetypes, ${(metrics.globalDisagreementWinRate * 100).toFixed(0)}% disagreement wins`);\n  }\n  \n  const maxConfidence = Math.min(95, actualAccuracy + 15); // Allow +15% with compounding\n  const overall = Math.round(Math.max(20, Math.min(maxConfidence, calibrated.confidence)));\n  \n  return {\n    overall,\n    tactical: Math.round(tacticalConf),\n    strategic: Math.round(strategicConf),\n    alignment,\n    factors,\n  };\n}\n\nfunction calculateAlignment(\n  analysis: PositionAnalysis,\n  signature: ColorFlowSignature,\n  factors: string[]\n): number {\n  const tacticsPreferWhite = analysis.evaluation.score > 0;\n  const strategyPreferWhite = signature.dominantSide === 'white';\n  \n  if ((tacticsPreferWhite && strategyPreferWhite) || \n      (!tacticsPreferWhite && !strategyPreferWhite)) {\n    factors.push('Tactics and strategy aligned');\n    return 85;\n  }\n  \n  if (signature.dominantSide === 'contested') {\n    factors.push('Strategy contested, tactics decisive');\n    return 65;\n  }\n  \n  factors.push('Tactics and strategy diverge - complex position');\n  return 40;\n}\n\n/**\n * Calculate combined score from all analysis factors\n */\nexport function calculateCombinedScore(\n  analysis: PositionAnalysis,\n  signature: ColorFlowSignature,\n  confidence: HybridConfidence\n): number {\n  const tacticalScore = analysis.evaluation.score;\n  \n  const archetypeDef = ARCHETYPE_DEFINITIONS[signature.archetype];\n  const strategicBias = (archetypeDef.historicalWinRate - 0.5) * 100;\n  \n  const alignmentFactor = confidence.alignment / 100;\n  \n  return Math.round(\n    tacticalScore * 0.7 + \n    strategicBias * signature.intensity / 100 * 0.3 * alignmentFactor\n  );\n}\n";export{n as default};
