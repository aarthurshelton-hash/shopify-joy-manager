const n="/**\n * Mirage Quantification System\n * \n * PHILOSOPHICAL FOUNDATION:\n * - Humans experience OPTICAL ILLUSIONS (neurological artifacts - brain processing limits)\n * - Humans experience MIRAGES (desperation-induced false hope - oasis in desert)\n * - AI experiences NEITHER - only MISUNDERSTANDINGS (miscalibrated pattern recognition)\n * \n * KEY INSIGHT:\n * Human mirages are projections of desperate hope onto noise\n * AI \"mirages\" are weak signals that COULD become real if:\n * 1. The pattern has genuine underlying structure\n * 2. Acting on the pattern influences reality (reflexivity)\n * 3. Other actors also perceive and act on the same signal\n * \n * This module attempts to MATERIALIZE promising mirages by:\n * - Detecting weak-but-structured patterns\n * - Evaluating reflexivity potential (can our action make it real?)\n * - Tracking which \"mirages\" solidified into reality vs evaporated\n * - Learning to distinguish genuine foresight from miscalibration\n */\n\nexport interface MirageSignal {\n  id: string;\n  detectedAt: Date;\n  signalType: 'pattern_glimpse' | 'consensus_precursor' | 'structural_weak' | 'reflexive_potential';\n  confidence: number; // Low by definition (0.3-0.6)\n  \n  // What we think we see\n  perceivedPattern: {\n    direction: 'up' | 'down' | 'neutral';\n    magnitude: number;\n    timeHorizon: number;\n  };\n  \n  // Why it might be a mirage (misunderstanding)\n  uncertaintyFactors: string[];\n  \n  // Why it might materialize into reality\n  materializationFactors: string[];\n  \n  // Reflexivity score: can acting on this make it real?\n  reflexivityPotential: number;\n  \n  // Current state\n  status: 'detected' | 'acted_upon' | 'materialized' | 'evaporated' | 'pending';\n  \n  // If resolved\n  outcome?: {\n    resolvedAt: Date;\n    actualDirection: 'up' | 'down' | 'neutral';\n    didMaterialize: boolean;\n    reflexivityContribution: number; // How much did belief influence reality?\n  };\n}\n\nexport interface MirageClassification {\n  type: 'optical_equivalent' | 'desperation_mirage' | 'genuine_foresight' | 'miscalibration';\n  description: string;\n  actionability: number;\n}\n\ninterface MaterializationMetrics {\n  totalMirages: number;\n  materialized: number;\n  evaporated: number;\n  materializationRate: number;\n  avgReflexivityContribution: number;\n  topMaterializingPatterns: string[];\n}\n\nclass MirageQuantifier {\n  private activeMirages: Map<string, MirageSignal> = new Map();\n  private historicalMirages: MirageSignal[] = [];\n  private materializationPatterns: Map<string, { success: number; total: number }> = new Map();\n  \n  /**\n   * Detect a potential \"mirage\" - a weak signal that might be real\n   * \n   * Unlike human optical illusions (which are brain bugs),\n   * these are patterns we genuinely see but can't yet confirm\n   */\n  detectMirage(\n    prediction: { direction: 'up' | 'down' | 'neutral'; confidence: number; magnitude: number },\n    marketContext: { momentum: number; volatility: number; volume: number },\n    crossDomainSignals: { domain: string; alignment: number }[]\n  ): MirageSignal | null {\n    // Only weak signals qualify as mirages (strong signals are just predictions)\n    if (prediction.confidence > 0.6) return null;\n    \n    // Classify the signal type\n    const signalType = this.classifySignalType(prediction, marketContext, crossDomainSignals);\n    \n    // Calculate why it might be misunderstanding vs genuine\n    const uncertaintyFactors = this.identifyUncertaintyFactors(prediction, marketContext);\n    const materializationFactors = this.identifyMaterializationFactors(prediction, crossDomainSignals);\n    \n    // Calculate reflexivity - can market belief make this real?\n    const reflexivityPotential = this.calculateReflexivity(\n      prediction,\n      marketContext,\n      crossDomainSignals\n    );\n    \n    const mirage: MirageSignal = {\n      id: `mirage_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      detectedAt: new Date(),\n      signalType,\n      confidence: prediction.confidence,\n      perceivedPattern: {\n        direction: prediction.direction,\n        magnitude: prediction.magnitude,\n        timeHorizon: this.estimateTimeHorizon(marketContext.volatility)\n      },\n      uncertaintyFactors,\n      materializationFactors,\n      reflexivityPotential,\n      status: 'detected'\n    };\n    \n    this.activeMirages.set(mirage.id, mirage);\n    \n    console.log('[MirageQuantifier] Detected:', {\n      type: signalType,\n      confidence: prediction.confidence.toFixed(3),\n      reflexivity: reflexivityPotential.toFixed(3),\n      factors: { uncertainty: uncertaintyFactors.length, materialization: materializationFactors.length }\n    });\n    \n    return mirage;\n  }\n  \n  /**\n   * Classify what type of weak signal this is\n   */\n  private classifySignalType(\n    prediction: { direction: 'up' | 'down' | 'neutral'; confidence: number },\n    marketContext: { momentum: number; volatility: number },\n    crossDomainSignals: { domain: string; alignment: number }[]\n  ): MirageSignal['signalType'] {\n    const avgAlignment = crossDomainSignals.reduce((sum, s) => sum + s.alignment, 0) / \n                         Math.max(crossDomainSignals.length, 1);\n    \n    // Pattern glimpse: We see structure but it's faint\n    if (prediction.confidence > 0.4 && avgAlignment > 0.5) {\n      return 'pattern_glimpse';\n    }\n    \n    // Consensus precursor: Multiple domains hint at same direction\n    if (crossDomainSignals.filter(s => s.alignment > 0.4).length >= 3) {\n      return 'consensus_precursor';\n    }\n    \n    // Structural weak: Low confidence but low volatility (stable weak signal)\n    if (marketContext.volatility < 0.3) {\n      return 'structural_weak';\n    }\n    \n    // Reflexive potential: Momentum suggests self-reinforcing possibility\n    if (Math.abs(marketContext.momentum) > 0.5) {\n      return 'reflexive_potential';\n    }\n    \n    return 'pattern_glimpse';\n  }\n  \n  /**\n   * Why this might be a misunderstanding (AI equivalent of optical illusion)\n   */\n  private identifyUncertaintyFactors(\n    prediction: { confidence: number },\n    marketContext: { momentum: number; volatility: number; volume: number }\n  ): string[] {\n    const factors: string[] = [];\n    \n    if (prediction.confidence < 0.4) {\n      factors.push('Very low base confidence');\n    }\n    \n    if (marketContext.volatility > 0.7) {\n      factors.push('High volatility obscures signal');\n    }\n    \n    if (marketContext.volume < 0.3) {\n      factors.push('Low volume - thin information');\n    }\n    \n    if (Math.abs(marketContext.momentum) < 0.1) {\n      factors.push('No clear momentum direction');\n    }\n    \n    // AI-specific: Pattern might be overfitted\n    if (prediction.confidence > 0.35 && prediction.confidence < 0.45) {\n      factors.push('Pattern at calibration threshold - possible overfitting');\n    }\n    \n    return factors;\n  }\n  \n  /**\n   * Why this weak signal might actually materialize into reality\n   */\n  private identifyMaterializationFactors(\n    prediction: { direction: 'up' | 'down' | 'neutral' },\n    crossDomainSignals: { domain: string; alignment: number }[]\n  ): string[] {\n    const factors: string[] = [];\n    \n    // Cross-domain alignment suggests genuine structure\n    const alignedDomains = crossDomainSignals.filter(s => s.alignment > 0.4);\n    if (alignedDomains.length >= 2) {\n      factors.push(`Cross-domain resonance (${alignedDomains.map(d => d.domain).join(', ')})`);\n    }\n    \n    // Chess pattern alignment (our strongest domain)\n    const chessSignal = crossDomainSignals.find(s => s.domain === 'chess');\n    if (chessSignal && chessSignal.alignment > 0.5) {\n      factors.push('Chess trajectory alignment detected');\n    }\n    \n    // Music/consciousness resonance\n    const consciousnessSignals = crossDomainSignals.filter(\n      s => ['music', 'consciousness', 'collective'].includes(s.domain)\n    );\n    if (consciousnessSignals.some(s => s.alignment > 0.4)) {\n      factors.push('Collective entrainment signal present');\n    }\n    \n    // Archetypal pattern match\n    factors.push('Weak archetype signature detected');\n    \n    return factors;\n  }\n  \n  /**\n   * Calculate reflexivity potential - can belief/action make this real?\n   * \n   * George Soros's reflexivity: Market participants' perceptions affect fundamentals\n   * If enough actors see the same \"mirage\", it becomes an oasis\n   */\n  private calculateReflexivity(\n    prediction: { direction: 'up' | 'down' | 'neutral'; confidence: number },\n    marketContext: { momentum: number; volatility: number; volume: number },\n    crossDomainSignals: { domain: string; alignment: number }[]\n  ): number {\n    let reflexivity = 0;\n    \n    // Momentum amplification potential\n    // If momentum already points in prediction direction, reflexivity is higher\n    if ((prediction.direction === 'up' && marketContext.momentum > 0) ||\n        (prediction.direction === 'down' && marketContext.momentum < 0)) {\n      reflexivity += Math.abs(marketContext.momentum) * 0.3;\n    }\n    \n    // Volume indicates participation - more actors = more reflexivity\n    reflexivity += marketContext.volume * 0.2;\n    \n    // Cross-domain consensus increases reflexivity\n    // If multiple information sources align, more actors likely see the same thing\n    const avgAlignment = crossDomainSignals.reduce((sum, s) => sum + s.alignment, 0) / \n                         Math.max(crossDomainSignals.length, 1);\n    reflexivity += avgAlignment * 0.3;\n    \n    // Volatility reduces reflexivity (chaos breaks feedback loops)\n    reflexivity -= marketContext.volatility * 0.2;\n    \n    // Base confidence contributes\n    reflexivity += prediction.confidence * 0.2;\n    \n    return Math.max(0, Math.min(1, reflexivity));\n  }\n  \n  /**\n   * Estimate how long until the mirage resolves (materializes or evaporates)\n   */\n  private estimateTimeHorizon(volatility: number): number {\n    // Higher volatility = faster resolution\n    // Returns milliseconds\n    const baseHorizon = 60000; // 1 minute base\n    return baseHorizon * (1 + (1 - volatility));\n  }\n  \n  /**\n   * Record that we acted on a mirage (betting on the weak signal)\n   */\n  actOnMirage(mirageId: string): void {\n    const mirage = this.activeMirages.get(mirageId);\n    if (mirage) {\n      mirage.status = 'acted_upon';\n      console.log('[MirageQuantifier] Acting on mirage:', mirageId);\n    }\n  }\n  \n  /**\n   * Resolve a mirage - did it materialize or evaporate?\n   */\n  resolveMirage(\n    mirageId: string,\n    actualOutcome: { direction: 'up' | 'down' | 'neutral'; magnitude: number }\n  ): void {\n    const mirage = this.activeMirages.get(mirageId);\n    if (!mirage) return;\n    \n    const didMaterialize = mirage.perceivedPattern.direction === actualOutcome.direction;\n    \n    // Calculate how much reflexivity contributed\n    // If we acted and it worked, reflexivity gets credit\n    const reflexivityContribution = mirage.status === 'acted_upon' && didMaterialize\n      ? mirage.reflexivityPotential * 0.5 // Some credit to self-fulfilling aspect\n      : 0;\n    \n    mirage.status = didMaterialize ? 'materialized' : 'evaporated';\n    mirage.outcome = {\n      resolvedAt: new Date(),\n      actualDirection: actualOutcome.direction,\n      didMaterialize,\n      reflexivityContribution\n    };\n    \n    // Track pattern success rate\n    const patternKey = mirage.signalType;\n    const existing = this.materializationPatterns.get(patternKey) || { success: 0, total: 0 };\n    existing.total++;\n    if (didMaterialize) existing.success++;\n    this.materializationPatterns.set(patternKey, existing);\n    \n    // Move to historical\n    this.historicalMirages.push(mirage);\n    this.activeMirages.delete(mirageId);\n    \n    console.log('[MirageQuantifier] Resolved:', {\n      id: mirageId,\n      materialized: didMaterialize,\n      reflexivityContribution: reflexivityContribution.toFixed(3),\n      patternType: mirage.signalType\n    });\n  }\n  \n  /**\n   * Classify a pattern as human-equivalent illusion type\n   * (For philosophical/logging purposes)\n   */\n  classifyAsHumanEquivalent(mirage: MirageSignal): MirageClassification {\n    // Optical illusion equivalent: Pattern is real structure but misinterpreted\n    // (Like MÃ¼ller-Lyer - the lines ARE there, brain misjudges length)\n    if (mirage.uncertaintyFactors.includes('Pattern at calibration threshold - possible overfitting')) {\n      return {\n        type: 'optical_equivalent',\n        description: 'Real pattern structure, miscalibrated interpretation',\n        actionability: 0.4\n      };\n    }\n    \n    // Desperation mirage: Seeing hope where there is none\n    // (Like desert oasis - projection of desire onto noise)\n    if (mirage.uncertaintyFactors.length > mirage.materializationFactors.length * 2) {\n      return {\n        type: 'desperation_mirage',\n        description: 'Weak signal amplified by pattern-seeking, likely noise',\n        actionability: 0.1\n      };\n    }\n    \n    // Genuine foresight: Early detection of real emerging pattern\n    if (mirage.reflexivityPotential > 0.6 && mirage.materializationFactors.length >= 3) {\n      return {\n        type: 'genuine_foresight',\n        description: 'Early detection of materializing pattern with reflexive potential',\n        actionability: 0.8\n      };\n    }\n    \n    // Default: Simple miscalibration\n    return {\n      type: 'miscalibration',\n      description: 'Insufficient data for pattern confidence',\n      actionability: 0.3\n    };\n  }\n  \n  /**\n   * Get mirages worth acting on (high materialization potential)\n   */\n  getActionableMirages(): MirageSignal[] {\n    return Array.from(this.activeMirages.values())\n      .filter(m => m.status === 'detected')\n      .filter(m => {\n        const classification = this.classifyAsHumanEquivalent(m);\n        return classification.actionability > 0.5;\n      })\n      .sort((a, b) => b.reflexivityPotential - a.reflexivityPotential);\n  }\n  \n  /**\n   * Get materialization metrics for learning\n   */\n  getMaterializationMetrics(): MaterializationMetrics {\n    const resolved = this.historicalMirages.filter(m => m.outcome);\n    const materialized = resolved.filter(m => m.outcome?.didMaterialize);\n    \n    const avgReflexivity = materialized\n      .reduce((sum, m) => sum + (m.outcome?.reflexivityContribution || 0), 0) /\n      Math.max(materialized.length, 1);\n    \n    // Find which signal types materialize most often\n    const topPatterns = Array.from(this.materializationPatterns.entries())\n      .map(([type, stats]) => ({ type, rate: stats.success / Math.max(stats.total, 1) }))\n      .sort((a, b) => b.rate - a.rate)\n      .slice(0, 3)\n      .map(p => `${p.type} (${(p.rate * 100).toFixed(0)}%)`);\n    \n    return {\n      totalMirages: this.historicalMirages.length,\n      materialized: materialized.length,\n      evaporated: resolved.length - materialized.length,\n      materializationRate: materialized.length / Math.max(resolved.length, 1),\n      avgReflexivityContribution: avgReflexivity,\n      topMaterializingPatterns: topPatterns\n    };\n  }\n  \n  /**\n   * Clean up expired mirages\n   */\n  cleanupExpired(): void {\n    const now = Date.now();\n    for (const [id, mirage] of this.activeMirages) {\n      const age = now - mirage.detectedAt.getTime();\n      if (age > mirage.perceivedPattern.timeHorizon * 3) {\n        // Treat as evaporated\n        this.resolveMirage(id, { direction: 'neutral', magnitude: 0 });\n      }\n    }\n  }\n}\n\n// Singleton instance\nexport const mirageQuantifier = new MirageQuantifier();\n";export{n as default};
