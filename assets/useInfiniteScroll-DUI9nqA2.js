const n="import { useState, useCallback, useEffect, useRef } from 'react';\n\ninterface UseInfiniteScrollOptions<T> {\n  fetchFn: (page: number, limit: number) => Promise<{\n    data: T[];\n    hasMore: boolean;\n    total: number;\n    error: Error | null;\n  }>;\n  limit?: number;\n  enabled?: boolean;\n}\n\ninterface UseInfiniteScrollReturn<T> {\n  items: T[];\n  isLoading: boolean;\n  isLoadingMore: boolean;\n  hasMore: boolean;\n  total: number;\n  error: Error | null;\n  loadMore: () => void;\n  refresh: () => void;\n  sentinelRef: (node: HTMLElement | null) => void;\n}\n\nexport function useInfiniteScroll<T>({\n  fetchFn,\n  limit = 20,\n  enabled = true,\n}: UseInfiniteScrollOptions<T>): UseInfiniteScrollReturn<T> {\n  const [items, setItems] = useState<T[]>([]);\n  const [page, setPage] = useState(1);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isLoadingMore, setIsLoadingMore] = useState(false);\n  const [hasMore, setHasMore] = useState(true);\n  const [total, setTotal] = useState(0);\n  const [error, setError] = useState<Error | null>(null);\n  \n  const observerRef = useRef<IntersectionObserver | null>(null);\n  const loadingRef = useRef(false);\n\n  // Initial load\n  const loadInitial = useCallback(async () => {\n    if (!enabled) return;\n    \n    setIsLoading(true);\n    setError(null);\n    \n    const result = await fetchFn(1, limit);\n    \n    if (result.error) {\n      setError(result.error);\n    } else {\n      setItems(result.data);\n      setHasMore(result.hasMore);\n      setTotal(result.total);\n    }\n    \n    setPage(1);\n    setIsLoading(false);\n  }, [fetchFn, limit, enabled]);\n\n  // Load more\n  const loadMore = useCallback(async () => {\n    if (!enabled || !hasMore || loadingRef.current) return;\n    \n    loadingRef.current = true;\n    setIsLoadingMore(true);\n    \n    const nextPage = page + 1;\n    const result = await fetchFn(nextPage, limit);\n    \n    if (result.error) {\n      setError(result.error);\n    } else {\n      setItems(prev => [...prev, ...result.data]);\n      setHasMore(result.hasMore);\n      setTotal(result.total);\n      setPage(nextPage);\n    }\n    \n    setIsLoadingMore(false);\n    loadingRef.current = false;\n  }, [fetchFn, page, limit, hasMore, enabled]);\n\n  // Refresh\n  const refresh = useCallback(() => {\n    setItems([]);\n    setPage(1);\n    setHasMore(true);\n    loadInitial();\n  }, [loadInitial]);\n\n  // Initial load on mount\n  useEffect(() => {\n    loadInitial();\n  }, [loadInitial]);\n\n  // Sentinel ref for intersection observer\n  const sentinelRef = useCallback((node: HTMLElement | null) => {\n    if (observerRef.current) {\n      observerRef.current.disconnect();\n    }\n\n    if (!node || !hasMore || isLoading) return;\n\n    observerRef.current = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting && hasMore && !isLoadingMore) {\n          loadMore();\n        }\n      },\n      { \n        rootMargin: '200px',\n        threshold: 0.1 \n      }\n    );\n\n    observerRef.current.observe(node);\n  }, [hasMore, isLoading, isLoadingMore, loadMore]);\n\n  // Cleanup observer on unmount\n  useEffect(() => {\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n    };\n  }, []);\n\n  return {\n    items,\n    isLoading,\n    isLoadingMore,\n    hasMore,\n    total,\n    error,\n    loadMore,\n    refresh,\n    sentinelRef,\n  };\n}\n";export{n as default};
