const e='/**\n * Multi-Source Game Fetcher v7.15-SIMPLE-DEDUP\n * VERSION: 7.15-SIMPLE-DEDUP (2026-01-22)\n * \n * v7.15 CHANGES (Simple Deduplication):\n * - Uses simpleDedup module for ONE check: isKnown(id) → accept/reject\n * - No complex multi-layer ID tracking\n * - Fresh ID = fresh game, period\n * \n * v6.87 CHANGES (Dynamic Leaderboard Sourcing):\n * - NEW: Fetches live top players from Lichess leaderboards\n * - Pulls from daily/weekly rankings across bullet, blitz, rapid, classical\n * - Combines dynamic leaderboard players with static verified pool\n * - Constantly refreshing source of high-caliber players\n * \n * SOURCES:\n * - Lichess (via Edge Function proxy) - 5+ billion games\n * - Chess.com (public API) - billions more\n * \n * TARGET: 100+ unique games per batch\n */\n\nimport { supabase } from "@/integrations/supabase/client";\nimport { fetchChessComGames, ChessComGame, getChessComResult } from "./chesscomApi";\nimport { isKnown, toRawId } from "../simpleDedup";\n\nexport interface UnifiedGameData {\n  pgn: string;\n  moves?: string;\n  gameId: string;           // Unique ID (prefixed by source)\n  source: \'lichess\' | \'chesscom\';\n  // Result fields\n  winner?: \'white\' | \'black\';\n  status?: string;\n  result?: \'1-0\' | \'0-1\' | \'1/2-1/2\' | \'*\';\n  // Player context\n  whiteName?: string;\n  blackName?: string;\n  whiteElo?: number;\n  blackElo?: number;\n  // Time control\n  timeControl?: string;\n  speed?: string;\n  rated?: boolean;\n  // Temporal\n  playedAt?: string;\n  gameYear?: number;\n  gameMonth?: number;\n  // Opening\n  openingEco?: string;\n  openingName?: string;\n  // Termination\n  termination?: string;\n}\n\n// Chess.com top players (VERIFIED active accounts)\nconst CHESSCOM_TOP_PLAYERS = [\n  "Hikaru", "MagnusCarlsen", "nihalsarin", "FabianoCaruana", "LevonAronian",\n  "Firouzja2003", "DanielNaroditsky", "GothamChess", "AnishGiri", "WesleySo",\n  "Praggnanandhaa", "DominguezPerez", "Grischuk", "JanNepomniachtchi", "MVL",\n  "BogdanDeac", "RichardRapport", "VladimirFedoseev", "AlirezaFirouzja", "Duda",\n  "Caruana", "Nepo", "HansNiemann", "EricRosen", "chess24"\n];\n\n/**\n * v6.59-VERIFIED-POOL: Static fallback pool of verified active Lichess accounts\n * Used when leaderboard fetch fails or as supplement\n */\nconst LICHESS_FALLBACK_PLAYERS = [\n  // TIER 1: Super GMs with verified high activity\n  "DrNykterstein", "nihalsarin2004", "penguingm1", "Msb2", "Fins",\n  "TemurKuybokarov", "Zhigalko_Sergei", "DrDrunkenstein", "Firouzja2003",\n  "Alireza2003", "BogdanDeac", "RaunakSadhwani2005", "Arjun_Erigaisi",\n  \n  // TIER 2: Active titled players\n  "chessbrah", "opperwezen", "EricRosen", "ChessNetwork", "GM_Srinath",\n  "Oleksandr_Bortnyk", "chesswarrior7197", "SethiChess", "duhless",\n  "howitzer14", "rajabboy", "Jospem", "lance5500", "Navaraok",\n  "Nodirbek2004", "VincentKeymer2004", "WesleyS8", "NeverEnough",\n  \n  // TIER 3: Known active accounts\n  "lovlas", "nepoking", "BakhtiyarIbadov", "Andrej_Esipenko",\n  "Naroditsky", "GMSrinathNarayanan", "alexandrpredke", "Fenrisulfur",\n  "greennight", "KontraJaKO", "NameTheGame", "SindarovGM", "skif134",\n  "Iwasinelectrical", "dimochka_tsoi", "tornike_sanikidze", "S2Pac",\n  "wonderfultime", "may6enexttime", "Saintlaurent", "neslansen",\n  "defenceboy1", "dalmatinac101", "Erow", "Chesssknock", "Chess4ever"\n];\n\n// Cache for leaderboard players (refreshed every 30 minutes)\nlet cachedLeaderboardPlayers: string[] = [];\nlet leaderboardCacheTime = 0;\nconst LEADERBOARD_CACHE_TTL = 30 * 60 * 1000; // 30 minutes\n\n/**\n * v6.87-DYNAMIC-LEADERBOARD: Fetch live top players from Lichess leaderboards\n * Returns players across bullet, blitz, rapid, classical rankings\n */\nasync function fetchLeaderboardPlayers(): Promise<string[]> {\n  // Check cache first\n  if (cachedLeaderboardPlayers.length > 0 && Date.now() - leaderboardCacheTime < LEADERBOARD_CACHE_TTL) {\n    console.log(`[v6.87] Using cached leaderboard: ${cachedLeaderboardPlayers.length} players`);\n    return cachedLeaderboardPlayers;\n  }\n\n  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\n  const supabaseKey = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;\n\n  try {\n    console.log(`[v6.87] Fetching live leaderboard players...`);\n    \n    const response = await fetch(`${supabaseUrl}/functions/v1/lichess-leaderboard`, {\n      method: \'POST\',\n      headers: {\n        \'Content-Type\': \'application/json\',\n        \'Authorization\': `Bearer ${supabaseKey}`,\n        \'apikey\': supabaseKey\n      },\n      body: JSON.stringify({\n        perfTypes: [\'bullet\', \'blitz\', \'rapid\', \'classical\'],\n        count: 50 // Top 50 from each mode\n      })\n    });\n\n    if (!response.ok) {\n      console.warn(`[v6.87] Leaderboard fetch failed: ${response.status}`);\n      return LICHESS_FALLBACK_PLAYERS;\n    }\n\n    const data = await response.json();\n    \n    if (data.players && Array.isArray(data.players)) {\n      const players = data.players.map((p: { username: string }) => p.username);\n      console.log(`[v6.87] ✓ Leaderboard: ${players.length} live players (${data.perfTypes?.join(\', \')})`);\n      \n      // Update cache\n      cachedLeaderboardPlayers = players;\n      leaderboardCacheTime = Date.now();\n      \n      return players;\n    }\n  } catch (e) {\n    console.warn(`[v6.87] Leaderboard error:`, e);\n  }\n\n  // Fallback to static pool\n  console.log(`[v6.87] Using fallback pool: ${LICHESS_FALLBACK_PLAYERS.length} players`);\n  return LICHESS_FALLBACK_PLAYERS;\n}\n\n/**\n * v6.87: Get combined player pool - leaderboard + verified fallback\n * Ensures we always have a robust set of players\n */\nasync function getLichessPlayerPool(): Promise<string[]> {\n  const leaderboardPlayers = await fetchLeaderboardPlayers();\n  \n  // Combine leaderboard with fallback, removing duplicates\n  const combined = new Set<string>();\n  \n  // Add leaderboard players first (prioritized)\n  for (const p of leaderboardPlayers) {\n    combined.add(p);\n  }\n  \n  // Add fallback players\n  for (const p of LICHESS_FALLBACK_PLAYERS) {\n    combined.add(p);\n  }\n  \n  const pool = Array.from(combined);\n  console.log(`[v6.87] Combined pool: ${pool.length} players (${leaderboardPlayers.length} from leaderboard)`);\n  return pool;\n}\n\nexport interface FetchOptions {\n  targetCount: number;\n  batchNumber: number;\n  excludeIds?: Set<string>;\n  sources?: (\'lichess\' | \'chesscom\')[];\n}\n\nexport interface FetchResult {\n  games: UnifiedGameData[];\n  lichessCount: number;\n  chesscomCount: number;\n  errors: string[];\n}\n\n/**\n * Extract moves from PGN string\n * v6.53: Critical for Chess.com games which only have PGN\n */\nfunction extractMovesFromPgn(pgn: string): string {\n  // Remove headers (lines starting with [)\n  const lines = pgn.split(\'\\n\');\n  const moveLines: string[] = [];\n  \n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (trimmed.startsWith(\'[\')) continue;\n    if (trimmed.length === 0) continue;\n    moveLines.push(trimmed);\n  }\n  \n  const movesStr = moveLines.join(\' \');\n  \n  // Remove result at end (1-0, 0-1, 1/2-1/2, *)\n  const cleaned = movesStr\n    .replace(/1-0\\s*$/, \'\')\n    .replace(/0-1\\s*$/, \'\')\n    .replace(/1\\/2-1\\/2\\s*$/, \'\')\n    .replace(/\\*\\s*$/, \'\')\n    .trim();\n  \n  return cleaned;\n}\n\n/**\n * Convert Chess.com game to unified format\n * v6.53: Now extracts moves from PGN for reliable processing\n */\nfunction chesscomToUnified(game: ChessComGame, username: string): UnifiedGameData | null {\n  // v6.57-ID-ONLY: Only require a URL/ID exists - absorb everything else\n  // Extract game ID from URL: https://www.chess.com/game/live/123456789\n  const urlMatch = game.url?.match(/\\/(\\d+)$/);\n  if (!urlMatch) return null; // Must have valid game ID\n  const gameId = `cc_${urlMatch[1]}`;\n  \n  // v6.57: Extract moves - handle empty PGN gracefully\n  const moves = game.pgn ? extractMovesFromPgn(game.pgn) : \'\';\n  \n  // Determine winner\n  let winner: \'white\' | \'black\' | undefined;\n  if (game.white.result === \'win\') winner = \'white\';\n  else if (game.black.result === \'win\') winner = \'black\';\n  \n  const result = getChessComResult(game);\n  \n  // Extract time control category\n  const speed = game.time_class || \'unknown\';\n  \n  return {\n    pgn: game.pgn || \'\',  // v6.57: Allow empty PGN\n    moves,  // v6.57: May be empty - universal intelligence handles\n    gameId,\n    source: \'chesscom\',\n    winner,\n    status: game.white.result === \'checkmated\' || game.black.result === \'checkmated\' ? \'mate\' : \n            game.white.result === \'resigned\' || game.black.result === \'resigned\' ? \'resign\' :\n            game.white.result === \'timeout\' || game.black.result === \'timeout\' ? \'timeout\' : \n            result === \'1/2-1/2\' ? \'draw\' : \'unknown\',\n    result,\n    whiteName: game.white.username,\n    blackName: game.black.username,\n    whiteElo: game.white.rating,\n    blackElo: game.black.rating,\n    timeControl: game.time_control,\n    speed,\n    rated: game.rated,\n    playedAt: new Date(game.end_time * 1000).toISOString(),\n    gameYear: new Date(game.end_time * 1000).getFullYear(),\n    gameMonth: new Date(game.end_time * 1000).getMonth() + 1,\n    termination: game.white.result || game.black.result,\n  };\n}\n\n/**\n * Fetch games from Chess.com - HIGH VOLUME\n * v6.47: Parallel player fetching + higher limits\n */\nasync function fetchFromChessCom(\n  targetCount: number,\n  batchNumber: number,\n  excludeIds: Set<string>\n): Promise<{ games: UnifiedGameData[]; errors: string[] }> {\n  const games: UnifiedGameData[] = [];\n  const errors: string[] = [];\n  const localIds = new Set<string>();\n  \n  // v6.73-WINDOW-ISOLATION: Prime-based rotation for player coverage\n  // But sequential window isolation for time periods\n  const startOffset = (batchNumber * 11) % CHESSCOM_TOP_PLAYERS.length;\n  const shuffledPlayers = [\n    ...CHESSCOM_TOP_PLAYERS.slice(startOffset), \n    ...CHESSCOM_TOP_PLAYERS.slice(0, startOffset)\n  ];\n  \n  console.log(`[ChessCom v6.73] Batch ${batchNumber}: Targeting ${targetCount} games from ${shuffledPlayers.slice(0, 8).join(\', \')}...`);\n  \n  // v6.73-WINDOW-ISOLATION: Sequential non-overlapping month windows\n  // Each batch explores different historical period\n  const maxPlayers = Math.min(20, shuffledPlayers.length);\n  const gamesPerPlayer = Math.ceil(targetCount / 4);\n  // v6.73: Sequential months - batch 1 = last 3 months, batch 2 = 3-6 months ago, etc.\n  const monthsStart = (batchNumber - 1) * 3;\n  const monthsToFetch = 3; // 3-month windows\n  \n  // v6.47: Parallel fetching - split into chunks of 4\n  const playerChunks: string[][] = [];\n  for (let i = 0; i < maxPlayers; i += 4) {\n    playerChunks.push(shuffledPlayers.slice(i, i + 4));\n  }\n  \n  for (const chunk of playerChunks) {\n    if (games.length >= targetCount) break;\n    \n    // v6.73: Fetch chunk in parallel with window offset\n    const chunkPromises = chunk.map(async (player) => {\n      try {\n        // v6.73-WINDOW-ISOLATION: Pass month offset to explore sequential periods\n        const result = await fetchChessComGames(player, { \n          max: gamesPerPlayer,\n          months: monthsToFetch,\n          monthOffset: monthsStart // Skip first N months to get different window\n        });\n        return { player, result };\n      } catch (e) {\n        return { player, error: e instanceof Error ? e.message : \'Unknown error\' };\n      }\n    });\n    \n    const chunkResults = await Promise.all(chunkPromises);\n    \n    for (const res of chunkResults) {\n      if (\'error\' in res) {\n        errors.push(`[ChessCom ${res.player}] ${res.error}`);\n        continue;\n      }\n      \n      const { player, result } = res;\n      \n      if (result.errors.length > 0) {\n        errors.push(...result.errors.map(e => `[ChessCom ${player}] ${e}`));\n      }\n      \n      let addedFromPlayer = 0;\n      for (const game of result.games) {\n        // v7.15-SIMPLE-DEDUP: Accept ANY game with a valid ID if not known\n        const unified = chesscomToUnified(game, player);\n        if (!unified) continue; // Only fails if no game ID extractable\n        \n        // v7.15: Simple check - is this ID already in our system?\n        if (isKnown(unified.gameId)) continue;\n        if (excludeIds.has(unified.gameId)) continue; // Also check passed-in set\n        if (localIds.has(unified.gameId)) continue;\n        \n        localIds.add(unified.gameId);\n        games.push(unified);\n        addedFromPlayer++;\n        \n        if (games.length >= targetCount) break;\n      }\n      \n      if (addedFromPlayer > 0) {\n        console.log(`[ChessCom] ✓ ${player}: +${addedFromPlayer} games`);\n      }\n    }\n    \n    // v7.90-TURBO: Minimal delay for throughput (Chess.com is less rate-limited)\n    await new Promise(r => setTimeout(r, 200));\n  }\n  \n  console.log(`[ChessCom] Batch complete: ${games.length} games`);\n  return { games, errors };\n}\n\n/**\n * Fetch games from Lichess (via Edge Function) - HIGH VOLUME\n * v6.67-RATELIMIT-MEMORY: Respects server-side rate limit memory\n */\nasync function fetchFromLichess(\n  targetCount: number,\n  batchNumber: number,\n  excludeIds: Set<string>\n): Promise<{ games: UnifiedGameData[]; errors: string[] }> {\n  const games: UnifiedGameData[] = [];\n  const errors: string[] = [];\n  const localIds = new Set<string>();\n  \n  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\n  const supabaseKey = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;\n  \n  // v6.67: Client-side rate limit tracking to avoid spamming during cooldown\n  let serverRateLimited = false;\n  let serverResetMs = 0;\n  \n  // v6.87-DYNAMIC-LEADERBOARD: Get combined pool from live leaderboard + fallback\n  const playerPool = await getLichessPlayerPool();\n  \n  // v6.62: Prime-based rotation to maximize player coverage\n  const startOffset = (batchNumber * 17) % playerPool.length;\n  const shuffledPlayers = [\n    ...playerPool.slice(startOffset),\n    ...playerPool.slice(0, startOffset)\n  ];\n  \n  console.log(`[Lichess v6.87] Batch ${batchNumber}: Dynamic pool (${playerPool.length} players)`);\n  console.log(`[Lichess v6.87] First 6: ${shuffledPlayers.slice(0, 6).join(\', \')}`);\n  console.log(`[Lichess v6.87] Window: ${(batchNumber - 1) * 60}-${batchNumber * 60} days ago (isolated)`);\n  \n  // v6.59: Process more players but with smarter windows\n  const maxPlayers = Math.min(30, shuffledPlayers.length);\n  const gamesPerPlayer = 20; // Fixed request size\n  let rateLimitHits = 0;\n  let backoffMs = 800;\n  \n  // v6.59: Chunks of 3 for better throughput\n  const playerChunks: string[][] = [];\n  for (let i = 0; i < maxPlayers; i += 3) {\n    playerChunks.push(shuffledPlayers.slice(i, i + 3));\n  }\n  \n  for (const chunk of playerChunks) {\n    if (games.length >= targetCount) break;\n    \n    // v6.86-PATIENT-WAIT: If server is rate limited, WAIT for cooldown then continue\n    // Previously this would BREAK, losing all remaining player fetches\n    // Now we patiently wait and resume - every game matters!\n    if (serverRateLimited && serverResetMs > 0) {\n      const waitSec = Math.ceil(serverResetMs / 1000);\n      console.warn(`[Lichess v6.86] Rate limited - WAITING ${waitSec}s then resuming (not breaking!)`);\n      errors.push(`[Lichess] Rate limit pause: ${waitSec}s (will resume)`);\n      \n      // v7.90-TURBO: Wait for cooldown with minimal safety margin\n      await new Promise(r => setTimeout(r, serverResetMs + 500)); // +500ms safety\n      \n      // Reset rate limit state after waiting\n      serverRateLimited = false;\n      serverResetMs = 0;\n      rateLimitHits = 0;\n      backoffMs = 3000; // Reset to conservative backoff\n      console.log(`[Lichess v6.86] Cooldown complete - resuming fetches`);\n    }\n    \n    if (rateLimitHits >= 3) {\n      const waitTime = Math.min(backoffMs * Math.pow(1.5, rateLimitHits), 30000);\n      console.warn(`[Lichess v6.86] Backoff wait: ${Math.ceil(waitTime/1000)}s`);\n      await new Promise(r => setTimeout(r, waitTime));\n      rateLimitHits = 0;\n    }\n    \n    // v6.73-WINDOW-ISOLATION: Strictly non-overlapping windows per batch\n    const chunkPromises = chunk.map(async (player) => {\n      // v6.86: Don\'t skip - we\'ve already waited if needed\n      \n      const now = Date.now();\n      const oneDay = 24 * 60 * 60 * 1000;\n      \n      // v6.73-WINDOW-ISOLATION: Sequential non-overlapping windows\n      // Window duration is fixed - each batch advances by this amount\n      // This guarantees no overlap between batches, maximizing unique game yield\n      const windowDuration = 60; // 60-day fixed windows\n      const playerOffset = (player.charCodeAt(0) % 10); // 0-9 days per-player offset\n      \n      // CRITICAL: batchNumber directly controls window position\n      // Batch 1: 0-60 days ago, Batch 2: 60-120 days ago, etc.\n      const baseDaysBack = (batchNumber - 1) * windowDuration + playerOffset;\n      const until = now - (baseDaysBack * oneDay);\n      const since = until - (windowDuration * oneDay);\n      \n      console.log(`[v6.73] ${player}: Window ${batchNumber} → ${Math.round(baseDaysBack)}-${Math.round(baseDaysBack + windowDuration)} days ago`);\n      \n      try {\n        const response = await fetch(`${supabaseUrl}/functions/v1/lichess-games`, {\n          method: \'POST\',\n          headers: {\n            \'Content-Type\': \'application/json\',\n            \'Authorization\': `Bearer ${supabaseKey}`,\n            \'apikey\': supabaseKey\n          },\n          body: JSON.stringify({ player, since, until, max: gamesPerPlayer })\n        });\n        \n        if (response.status === 429) {\n          // v6.67: Parse the server\'s rate limit response\n          try {\n            const data = await response.json();\n            if (data.resetInMs) {\n              serverRateLimited = true;\n              serverResetMs = data.resetInMs;\n            }\n          } catch { /* ignore parse errors */ }\n          return { player, rateLimit: true, resetMs: serverResetMs };\n        }\n        \n        if (!response.ok) {\n          return { player, error: `HTTP ${response.status}` };\n        }\n        \n        const data = await response.json();\n        \n        // v6.67: Check if response indicates rate limiting even with 200 status\n        if (data.rateLimited && data.resetInMs) {\n          serverRateLimited = true;\n          serverResetMs = data.resetInMs;\n          return { player, rateLimit: true, resetMs: serverResetMs };\n        }\n        \n        return { player, games: data.games || [] };\n      } catch (e) {\n        return { player, error: e instanceof Error ? e.message : \'Unknown error\' };\n      }\n    });\n    \n    const chunkResults = await Promise.all(chunkPromises);\n    \n    for (const res of chunkResults) {\n      if (\'rateLimit\' in res && res.rateLimit) {\n        rateLimitHits++;\n        backoffMs = Math.min(backoffMs * 1.5, 10000); // Increase backoff\n        const resetInfo = \'resetMs\' in res ? ` (server cooldown: ${Math.ceil((res.resetMs || 0) / 1000)}s)` : \'\';\n        errors.push(`[Lichess ${res.player}] Rate limited${resetInfo}`);\n        continue;\n      }\n      \n      if (\'error\' in res) {\n        errors.push(`[Lichess ${res.player}] ${res.error}`);\n        continue;\n      }\n      \n      const { player, games: fetchedGames } = res;\n      \n      let addedFromPlayer = 0;\n      for (const game of fetchedGames) {\n        const lichessId = game.id;\n        // v7.15-SIMPLE-DEDUP: ONLY requirement is a valid game ID\n        if (!lichessId) continue;\n        \n        const gameId = `li_${lichessId}`;\n        \n        // v7.15: Simple check - is this ID already in our system?\n        if (isKnown(gameId) || isKnown(lichessId)) continue;\n        if (excludeIds.has(gameId) || excludeIds.has(lichessId)) continue;\n        if (localIds.has(gameId)) continue;\n        \n        const pgn = game.pgn || game.moves || \'\';\n        \n        localIds.add(gameId);\n        \n        games.push({\n          pgn,\n          moves: game.moves,\n          gameId,\n          source: \'lichess\',\n          winner: game.winner,\n          status: game.status,\n          result: game.result,\n          whiteName: game.whiteName,\n          blackName: game.blackName,\n          whiteElo: game.whiteElo,\n          blackElo: game.blackElo,\n          timeControl: game.timeControl,\n          speed: game.speed,\n          rated: game.rated,\n          playedAt: game.playedAt,\n          gameYear: game.gameYear,\n          gameMonth: game.gameMonth,\n          openingEco: game.openingEco,\n          openingName: game.openingName,\n          termination: game.status || game.termination,\n        });\n        addedFromPlayer++;\n        \n        if (games.length >= targetCount) break;\n      }\n      \n      if (addedFromPlayer > 0) {\n        console.log(`[Lichess v6.86] ✓ ${player}: +${addedFromPlayer} games`);\n        rateLimitHits = 0;\n        backoffMs = Math.max(backoffMs * 0.9, 2000); // Reduce backoff on success\n      }\n    }\n    \n    // v7.90-TURBO: Fast chunks - rate limiting is handled per-request, not per-chunk\n    const chunkDelay = rateLimitHits > 0 ? 1500 : 300; // 1.5s after issues, 300ms normally\n    if (games.length < targetCount) {\n      await new Promise(r => setTimeout(r, chunkDelay));\n    }\n  }\n  \n  console.log(`[Lichess] Batch complete: ${games.length} games`);\n  return { games, errors };\n}\n\n/**\n * Fetch games from multiple sources in parallel\n */\nexport async function fetchMultiSourceGames(options: FetchOptions): Promise<FetchResult> {\n  const { targetCount, batchNumber, excludeIds = new Set(), sources = [\'lichess\', \'chesscom\'] } = options;\n  \n  console.log(`[MultiSource] ========== BATCH ${batchNumber} ==========`);\n  console.log(`[MultiSource] Target: ${targetCount} games from ${sources.join(\' + \')}`);\n  console.log(`[MultiSource] Excluded IDs: ${excludeIds.size}`);\n  \n  const halfTarget = Math.ceil(targetCount / 2);\n  const results: { games: UnifiedGameData[]; errors: string[] }[] = [];\n  \n  // Fetch from both sources in parallel\n  const fetchPromises: Promise<{ games: UnifiedGameData[]; errors: string[] }>[] = [];\n  \n  if (sources.includes(\'lichess\')) {\n    fetchPromises.push(fetchFromLichess(halfTarget, batchNumber, excludeIds));\n  }\n  \n  if (sources.includes(\'chesscom\')) {\n    fetchPromises.push(fetchFromChessCom(halfTarget, batchNumber, excludeIds));\n  }\n  \n  const fetchResults = await Promise.all(fetchPromises);\n  \n  // Combine results\n  let allGames: UnifiedGameData[] = [];\n  let allErrors: string[] = [];\n  let lichessCount = 0;\n  let chesscomCount = 0;\n  \n  for (const result of fetchResults) {\n    allGames = [...allGames, ...result.games];\n    allErrors = [...allErrors, ...result.errors];\n    \n    // Count by source\n    for (const game of result.games) {\n      if (game.source === \'lichess\') lichessCount++;\n      if (game.source === \'chesscom\') chesscomCount++;\n    }\n  }\n  \n  // Shuffle combined games\n  allGames = allGames.sort(() => Math.random() - 0.5);\n  \n  console.log(`[MultiSource] RESULT: ${allGames.length} total (Lichess: ${lichessCount}, Chess.com: ${chesscomCount})`);\n  \n  return {\n    games: allGames,\n    lichessCount,\n    chesscomCount,\n    errors: allErrors\n  };\n}\n\n/**\n * Get statistics about available game sources\n * v6.87: Now includes dynamic leaderboard info\n */\nexport function getSourceStats() {\n  const lichessPoolSize = cachedLeaderboardPlayers.length > 0 \n    ? cachedLeaderboardPlayers.length + LICHESS_FALLBACK_PLAYERS.length \n    : LICHESS_FALLBACK_PLAYERS.length;\n    \n  return {\n    lichess: {\n      playerCount: lichessPoolSize,\n      leaderboardPlayers: cachedLeaderboardPlayers.length,\n      fallbackPlayers: LICHESS_FALLBACK_PLAYERS.length,\n      estimatedGamesPerPlayer: 5000,\n      totalEstimated: lichessPoolSize * 5000,\n    },\n    chesscom: {\n      playerCount: CHESSCOM_TOP_PLAYERS.length,\n      estimatedGamesPerPlayer: 3000,\n      totalEstimated: CHESSCOM_TOP_PLAYERS.length * 3000,\n    },\n    combined: {\n      totalPlayers: lichessPoolSize + CHESSCOM_TOP_PLAYERS.length,\n      totalEstimated: (lichessPoolSize * 5000) + (CHESSCOM_TOP_PLAYERS.length * 3000),\n    }\n  };\n}\n\n/**\n * Force refresh the leaderboard cache\n */\nexport async function refreshLeaderboardCache(): Promise<number> {\n  leaderboardCacheTime = 0; // Force cache invalidation\n  const players = await fetchLeaderboardPlayers();\n  return players.length;\n}\n';export{e as default};
