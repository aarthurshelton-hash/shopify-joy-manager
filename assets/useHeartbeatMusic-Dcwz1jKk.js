const n="/**\n * Heartbeat Music System\n * Generates synchronized audio that pulses with the En Pensent heartbeat\n * The blood (code) and nervous system (market) unified through sound\n */\n\nimport { useCallback, useRef, useEffect, useState } from 'react';\n\nexport interface HeartbeatMusicConfig {\n  enabled?: boolean;\n  volume?: number;\n  tempo?: number; // BPM synced with heartbeat\n  intensity?: number; // 0-1, driven by market volatility or code complexity\n}\n\nexport function useHeartbeatMusic(config: HeartbeatMusicConfig = {}) {\n  const { enabled = true, volume = 0.3, tempo = 60, intensity = 0.5 } = config;\n  \n  const audioContextRef = useRef<AudioContext | null>(null);\n  const gainNodeRef = useRef<GainNode | null>(null);\n  const isInitializedRef = useRef(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const oscillatorsRef = useRef<OscillatorNode[]>([]);\n  \n  // Initialize audio context on user interaction\n  const initAudio = useCallback(() => {\n    if (isInitializedRef.current) return true;\n    \n    try {\n      audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();\n      gainNodeRef.current = audioContextRef.current.createGain();\n      gainNodeRef.current.gain.value = volume;\n      gainNodeRef.current.connect(audioContextRef.current.destination);\n      isInitializedRef.current = true;\n      return true;\n    } catch (e) {\n      console.error('[HeartbeatMusic] Failed to initialize:', e);\n      return false;\n    }\n  }, [volume]);\n  \n  // Play a heartbeat pulse sound\n  const playHeartbeatPulse = useCallback((pulseIntensity: number = intensity) => {\n    if (!enabled || !initAudio()) return;\n    \n    const ctx = audioContextRef.current!;\n    const gain = gainNodeRef.current!;\n    \n    const now = ctx.currentTime;\n    \n    // Create the \"lub-dub\" heartbeat sound\n    const createBeat = (delay: number, freq: number, duration: number) => {\n      const osc = ctx.createOscillator();\n      const oscGain = ctx.createGain();\n      \n      osc.type = 'sine';\n      osc.frequency.setValueAtTime(freq, now + delay);\n      osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + delay + duration);\n      \n      oscGain.gain.setValueAtTime(0, now + delay);\n      oscGain.gain.linearRampToValueAtTime(pulseIntensity * volume, now + delay + 0.02);\n      oscGain.gain.exponentialRampToValueAtTime(0.001, now + delay + duration);\n      \n      osc.connect(oscGain);\n      oscGain.connect(gain);\n      \n      osc.start(now + delay);\n      osc.stop(now + delay + duration);\n    };\n    \n    // \"Lub\" - first beat\n    createBeat(0, 80 + (pulseIntensity * 40), 0.15);\n    // \"Dub\" - second beat\n    createBeat(0.12, 60 + (pulseIntensity * 30), 0.1);\n  }, [enabled, initAudio, intensity, volume]);\n  \n  // Play evolution/mutation sound\n  const playEvolutionSound = useCallback((type: 'mutate' | 'evolve' | 'sync') => {\n    if (!enabled || !initAudio()) return;\n    \n    const ctx = audioContextRef.current!;\n    const gain = gainNodeRef.current!;\n    const now = ctx.currentTime;\n    \n    const freqMap = {\n      mutate: [220, 330, 440], // Rising sequence\n      evolve: [440, 550, 660, 880], // Major chord progression\n      sync: [440, 440 * 1.5, 440 * 2] // Perfect fifth + octave\n    };\n    \n    const freqs = freqMap[type];\n    \n    freqs.forEach((freq, i) => {\n      const osc = ctx.createOscillator();\n      const oscGain = ctx.createGain();\n      \n      osc.type = type === 'sync' ? 'triangle' : 'sine';\n      osc.frequency.value = freq;\n      \n      const delay = i * 0.08;\n      oscGain.gain.setValueAtTime(0, now + delay);\n      oscGain.gain.linearRampToValueAtTime(volume * 0.5, now + delay + 0.05);\n      oscGain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);\n      \n      osc.connect(oscGain);\n      oscGain.connect(gain);\n      \n      osc.start(now + delay);\n      osc.stop(now + delay + 0.35);\n    });\n  }, [enabled, initAudio, volume]);\n  \n  // Play prediction sound (up/down/neutral)\n  const playPredictionSound = useCallback((direction: 'up' | 'down' | 'neutral', confidence: number) => {\n    if (!enabled || !initAudio()) return;\n    \n    const ctx = audioContextRef.current!;\n    const gain = gainNodeRef.current!;\n    const now = ctx.currentTime;\n    \n    const osc = ctx.createOscillator();\n    const oscGain = ctx.createGain();\n    \n    const baseFreq = direction === 'up' ? 440 : direction === 'down' ? 220 : 330;\n    \n    osc.type = 'sine';\n    osc.frequency.setValueAtTime(baseFreq, now);\n    \n    if (direction === 'up') {\n      osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, now + 0.2);\n    } else if (direction === 'down') {\n      osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.7, now + 0.2);\n    }\n    \n    oscGain.gain.setValueAtTime(0, now);\n    oscGain.gain.linearRampToValueAtTime(volume * confidence, now + 0.03);\n    oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);\n    \n    osc.connect(oscGain);\n    oscGain.connect(gain);\n    \n    osc.start(now);\n    osc.stop(now + 0.3);\n  }, [enabled, initAudio, volume]);\n  \n  // Play success/failure sound\n  const playOutcomeSound = useCallback((success: boolean) => {\n    if (!enabled || !initAudio()) return;\n    \n    const ctx = audioContextRef.current!;\n    const gain = gainNodeRef.current!;\n    const now = ctx.currentTime;\n    \n    if (success) {\n      // Major chord - happy\n      [523.25, 659.25, 783.99].forEach((freq, i) => {\n        const osc = ctx.createOscillator();\n        const oscGain = ctx.createGain();\n        \n        osc.type = 'triangle';\n        osc.frequency.value = freq;\n        \n        oscGain.gain.setValueAtTime(0, now);\n        oscGain.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);\n        oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);\n        \n        osc.connect(oscGain);\n        oscGain.connect(gain);\n        \n        osc.start(now + i * 0.03);\n        osc.stop(now + 0.5);\n      });\n    } else {\n      // Minor chord - sad\n      [440, 523.25, 659.25].forEach((freq, i) => {\n        const osc = ctx.createOscillator();\n        const oscGain = ctx.createGain();\n        \n        osc.type = 'sawtooth';\n        osc.frequency.value = freq * 0.5;\n        \n        oscGain.gain.setValueAtTime(0, now);\n        oscGain.gain.linearRampToValueAtTime(volume * 0.2, now + 0.05);\n        oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);\n        \n        osc.connect(oscGain);\n        oscGain.connect(gain);\n        \n        osc.start(now + i * 0.02);\n        osc.stop(now + 0.35);\n      });\n    }\n  }, [enabled, initAudio, volume]);\n  \n  // Ambient drone for continuous monitoring\n  const startAmbientDrone = useCallback((baseFreq: number = 55) => {\n    if (!enabled || !initAudio()) return;\n    \n    const ctx = audioContextRef.current!;\n    const gain = gainNodeRef.current!;\n    \n    // Stop any existing drones\n    oscillatorsRef.current.forEach(osc => {\n      try { osc.stop(); } catch {}\n    });\n    oscillatorsRef.current = [];\n    \n    // Create layered drone\n    [1, 1.5, 2, 3].forEach((mult) => {\n      const osc = ctx.createOscillator();\n      const oscGain = ctx.createGain();\n      const filter = ctx.createBiquadFilter();\n      \n      osc.type = 'sine';\n      osc.frequency.value = baseFreq * mult;\n      \n      filter.type = 'lowpass';\n      filter.frequency.value = 200;\n      \n      oscGain.gain.value = volume * 0.05 / mult;\n      \n      osc.connect(filter);\n      filter.connect(oscGain);\n      oscGain.connect(gain);\n      \n      osc.start();\n      oscillatorsRef.current.push(osc);\n    });\n    \n    setIsPlaying(true);\n  }, [enabled, initAudio, volume]);\n  \n  const stopAmbientDrone = useCallback(() => {\n    oscillatorsRef.current.forEach(osc => {\n      try { osc.stop(); } catch {}\n    });\n    oscillatorsRef.current = [];\n    setIsPlaying(false);\n  }, []);\n  \n  // Update volume\n  useEffect(() => {\n    if (gainNodeRef.current) {\n      gainNodeRef.current.gain.value = volume;\n    }\n  }, [volume]);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopAmbientDrone();\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n      }\n    };\n  }, [stopAmbientDrone]);\n  \n  return {\n    initAudio,\n    playHeartbeatPulse,\n    playEvolutionSound,\n    playPredictionSound,\n    playOutcomeSound,\n    startAmbientDrone,\n    stopAmbientDrone,\n    isPlaying,\n    isInitialized: isInitializedRef.current\n  };\n}\n";export{n as default};
