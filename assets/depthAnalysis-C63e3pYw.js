const e="/**\n * En Pensent™ Effective Depth Calculator\n * \n * Measures our \"moves ahead\" capability compared to Stockfish's depth.\n * \n * Stockfish depth = how many half-moves (plies) it searches\n * En Pensent depth = effective lookahead based on pattern trajectory accuracy\n * \n * The key insight: We don't search moves - we RECOGNIZE patterns that\n * indicate outcomes many moves in the future.\n */\n\nimport { Chess } from 'chess.js';\nimport { extractColorFlowSignature, predictFromColorFlow } from './colorFlowAnalysis';\nimport { simulateGame } from './gameSimulator';\nimport { evaluatePosition, type PositionEvaluation } from './lichessCloudEval';\n\nexport interface DepthMetrics {\n  // Stockfish's depth in plies (half-moves)\n  stockfishDepth: number;\n  stockfishKnodes: number;\n  \n  // En Pensent's effective depth (calculated from accuracy at various horizons)\n  enPensentEffectiveDepth: number;\n  \n  // Depth comparison\n  depthAdvantage: number; // positive = En Pensent deeper\n  depthRatio: number;     // > 1 = En Pensent advantage\n  \n  // Horizon analysis (how far ahead we can see accurately)\n  horizonAccuracy: HorizonAccuracy[];\n  maxAccurateHorizon: number; // moves ahead with >60% accuracy\n  \n  // Pattern-based depth equivalence\n  patternDepthEquivalent: number;\n  \n  // Confidence metrics\n  depthConfidence: number;\n}\n\nexport interface HorizonAccuracy {\n  movesAhead: number;\n  accuracy: number;\n  sampleSize: number;\n  stockfishAccuracyAtHorizon: number;\n}\n\nexport interface PositionDepthReport {\n  fen: string;\n  stockfish: {\n    depth: number;\n    evaluation: number;\n    bestMove: string;\n    pv: string[];\n    pvDepth: number;\n  };\n  enPensent: {\n    effectiveDepth: number;\n    predictedOutcome: string;\n    confidence: number;\n    archetype: string;\n    trajectoryHorizon: number;\n  };\n  comparison: {\n    depthDifference: number;\n    stockfishPvHorizon: number;\n    enPensentPatternHorizon: number;\n    effectiveAdvantage: string;\n  };\n}\n\n/**\n * Calculate effective depth for En Pensent based on pattern recognition range\n * \n * The formula considers:\n * 1. Color flow pattern span (how many moves the pattern encompasses)\n * 2. Archetype confidence (stronger archetypes = deeper effective vision)\n * 3. Trajectory prediction horizon (how far ahead we predict)\n * 4. Historical accuracy at different horizons\n */\nexport function calculateEffectiveDepth(\n  patternSpan: number,\n  archetypeConfidence: number,\n  trajectoryHorizon: number,\n  historicalAccuracy: number = 0.65\n): number {\n  // Base depth from pattern span (each pattern covers ~3-5 effective plies)\n  const patternPlyEquivalent = patternSpan * 4;\n  \n  // Confidence multiplier (high confidence = more reliable depth)\n  const confidenceMultiplier = 0.5 + (archetypeConfidence / 100) * 0.8;\n  \n  // Trajectory extension (how far our predictions reach)\n  const trajectoryPlyEquivalent = trajectoryHorizon * 2;\n  \n  // Accuracy calibration (reduce depth if accuracy is low)\n  const accuracyFactor = Math.pow(historicalAccuracy, 0.5);\n  \n  // Combined effective depth\n  const rawDepth = (patternPlyEquivalent + trajectoryPlyEquivalent) * confidenceMultiplier;\n  const calibratedDepth = rawDepth * accuracyFactor;\n  \n  return Math.round(calibratedDepth);\n}\n\n/**\n * Convert Stockfish search depth to \"moves ahead\" understanding\n */\nexport function stockfishDepthToMoves(plies: number): number {\n  // 1 ply = 1 half-move, 2 plies = 1 full move\n  return Math.floor(plies / 2);\n}\n\n/**\n * Analyze a position and generate comprehensive depth report\n */\nexport async function analyzePositionDepth(\n  pgn: string,\n  currentMove?: number\n): Promise<PositionDepthReport | null> {\n  try {\n    const chess = new Chess();\n    \n    // Load and potentially truncate PGN\n    chess.loadPgn(pgn);\n    const history = chess.history();\n    \n    if (currentMove !== undefined) {\n      chess.reset();\n      for (let i = 0; i < Math.min(currentMove, history.length); i++) {\n        chess.move(history[i]);\n      }\n    }\n    \n    const fen = chess.fen();\n    \n    // Get Stockfish evaluation\n    const stockfishEval = await evaluatePosition(fen);\n    \n    // Get En Pensent analysis\n    const simulation = simulateGame(chess.pgn());\n    const colorSignature = extractColorFlowSignature(\n      simulation.board,\n      simulation.gameData,\n      simulation.totalMoves\n    );\n    const colorPrediction = predictFromColorFlow(colorSignature, simulation.totalMoves);\n    \n    // Calculate En Pensent effective depth\n    const patternSpan = simulation.totalMoves;\n    const archetypeConfidence = colorSignature.intensity * 100;\n    const trajectoryHorizon = colorPrediction.lookaheadMoves;\n    const effectiveDepth = calculateEffectiveDepth(\n      patternSpan,\n      archetypeConfidence,\n      trajectoryHorizon\n    );\n    \n    // Stockfish metrics\n    const sfDepth = stockfishEval?.depth || 0;\n    const sfPvLength = stockfishEval?.pv?.length || 0;\n    \n    // Calculate depth comparison\n    const depthDifference = effectiveDepth - sfDepth;\n    const stockfishMovesAhead = stockfishDepthToMoves(sfDepth);\n    const enPensentMovesAhead = Math.floor(effectiveDepth / 2);\n    \n    return {\n      fen,\n      stockfish: {\n        depth: sfDepth,\n        evaluation: stockfishEval?.evaluation || 0,\n        bestMove: stockfishEval?.bestMoveSan || 'N/A',\n        pv: stockfishEval?.pv || [],\n        pvDepth: sfPvLength,\n      },\n      enPensent: {\n        effectiveDepth,\n        predictedOutcome: colorPrediction.predictedWinner || 'unclear',\n        confidence: colorPrediction.confidence,\n        archetype: colorSignature.archetype,\n        trajectoryHorizon,\n      },\n      comparison: {\n        depthDifference,\n        stockfishPvHorizon: stockfishMovesAhead,\n        enPensentPatternHorizon: enPensentMovesAhead,\n        effectiveAdvantage: depthDifference > 0 \n          ? `En Pensent +${depthDifference} plies`\n          : depthDifference < 0 \n            ? `Stockfish +${-depthDifference} plies`\n            : 'Equal depth',\n      },\n    };\n  } catch (error) {\n    console.error('[DepthAnalysis] Error:', error);\n    return null;\n  }\n}\n\n/**\n * Calculate depth metrics from benchmark results\n */\nexport function calculateDepthMetricsFromBenchmark(\n  benchmarkResults: Array<{\n    stockfishDepth: number;\n    stockfishCorrect: boolean;\n    hybridCorrect: boolean;\n    hybridConfidence: number;\n    hybridArchetype: string;\n    moveNumber: number;\n    gameMoveCount?: number;\n  }>\n): DepthMetrics {\n  if (benchmarkResults.length === 0) {\n    return {\n      stockfishDepth: 0,\n      stockfishKnodes: 0,\n      enPensentEffectiveDepth: 0,\n      depthAdvantage: 0,\n      depthRatio: 1,\n      horizonAccuracy: [],\n      maxAccurateHorizon: 0,\n      patternDepthEquivalent: 0,\n      depthConfidence: 0,\n    };\n  }\n  \n  // Average Stockfish depth\n  const avgStockfishDepth = benchmarkResults.reduce((sum, r) => sum + r.stockfishDepth, 0) / benchmarkResults.length;\n  \n  // Calculate En Pensent accuracy at different horizons\n  const horizonGroups = new Map<number, { sfCorrect: number; epCorrect: number; total: number }>();\n  \n  for (const result of benchmarkResults) {\n    // Calculate how many moves ahead we were predicting\n    const movesAhead = result.gameMoveCount \n      ? result.gameMoveCount - result.moveNumber \n      : 30; // Assume average game length\n    \n    const horizonBucket = Math.floor(movesAhead / 5) * 5; // Group by 5-move buckets\n    \n    if (!horizonGroups.has(horizonBucket)) {\n      horizonGroups.set(horizonBucket, { sfCorrect: 0, epCorrect: 0, total: 0 });\n    }\n    \n    const group = horizonGroups.get(horizonBucket)!;\n    group.total++;\n    if (result.stockfishCorrect) group.sfCorrect++;\n    if (result.hybridCorrect) group.epCorrect++;\n  }\n  \n  // Convert to horizon accuracy array\n  const horizonAccuracy: HorizonAccuracy[] = [];\n  let maxAccurateHorizon = 0;\n  \n  for (const [movesAhead, stats] of horizonGroups.entries()) {\n    const accuracy = stats.total > 0 ? stats.epCorrect / stats.total : 0;\n    const sfAccuracy = stats.total > 0 ? stats.sfCorrect / stats.total : 0;\n    \n    horizonAccuracy.push({\n      movesAhead,\n      accuracy: accuracy * 100,\n      sampleSize: stats.total,\n      stockfishAccuracyAtHorizon: sfAccuracy * 100,\n    });\n    \n    if (accuracy > 0.6 && movesAhead > maxAccurateHorizon) {\n      maxAccurateHorizon = movesAhead;\n    }\n  }\n  \n  horizonAccuracy.sort((a, b) => a.movesAhead - b.movesAhead);\n  \n  // Calculate overall accuracies\n  const sfCorrectCount = benchmarkResults.filter(r => r.stockfishCorrect).length;\n  const epCorrectCount = benchmarkResults.filter(r => r.hybridCorrect).length;\n  const sfAccuracy = sfCorrectCount / benchmarkResults.length;\n  const epAccuracy = epCorrectCount / benchmarkResults.length;\n  \n  // Calculate effective depth based on accuracy advantage\n  // Formula: Depth advantage = log2(accuracyRatio) * baseDepth\n  const accuracyRatio = epAccuracy / Math.max(sfAccuracy, 0.01);\n  const avgConfidence = benchmarkResults.reduce((sum, r) => sum + r.hybridConfidence, 0) / benchmarkResults.length;\n  \n  // Pattern depth equivalent: how deep would Stockfish need to search to match our accuracy?\n  // Each doubling of depth roughly adds 5-10% accuracy\n  const depthEquivalentBonus = Math.log2(Math.max(accuracyRatio, 0.5)) * 10;\n  const patternDepthEquivalent = avgStockfishDepth + depthEquivalentBonus;\n  \n  // En Pensent effective depth (based on accuracy and horizon)\n  const baseEffectiveDepth = maxAccurateHorizon * 2; // Convert moves to plies\n  const confidenceBonus = (avgConfidence / 100) * 10;\n  const enPensentEffectiveDepth = Math.round(baseEffectiveDepth + confidenceBonus + depthEquivalentBonus);\n  \n  // Calculate advantage\n  const depthAdvantage = enPensentEffectiveDepth - avgStockfishDepth;\n  const depthRatio = enPensentEffectiveDepth / Math.max(avgStockfishDepth, 1);\n  \n  return {\n    stockfishDepth: Math.round(avgStockfishDepth),\n    stockfishKnodes: 0, // Would need to be tracked separately\n    enPensentEffectiveDepth,\n    depthAdvantage: Math.round(depthAdvantage),\n    depthRatio: Math.round(depthRatio * 100) / 100,\n    horizonAccuracy,\n    maxAccurateHorizon,\n    patternDepthEquivalent: Math.round(patternDepthEquivalent),\n    depthConfidence: avgConfidence,\n  };\n}\n\n/**\n * Generate a human-readable depth report\n */\nexport function generateDepthReport(metrics: DepthMetrics): string {\n  const lines: string[] = [\n    '═══════════════════════════════════════════════════════',\n    '       EN PENSENT™ vs STOCKFISH 17 DEPTH ANALYSIS      ',\n    '═══════════════════════════════════════════════════════',\n    '',\n    '┌─────────────────────────────────────────────────────┐',\n    '│                  DEPTH COMPARISON                   │',\n    '├─────────────────────────────────────────────────────┤',\n    `│  Stockfish 17 Search Depth:    ${metrics.stockfishDepth.toString().padStart(3)} plies             │`,\n    `│  Stockfish Moves Ahead:        ${stockfishDepthToMoves(metrics.stockfishDepth).toString().padStart(3)} moves             │`,\n    '├─────────────────────────────────────────────────────┤',\n    `│  En Pensent Effective Depth:   ${metrics.enPensentEffectiveDepth.toString().padStart(3)} plies             │`,\n    `│  En Pensent Moves Ahead:       ${Math.floor(metrics.enPensentEffectiveDepth / 2).toString().padStart(3)} moves             │`,\n    '├─────────────────────────────────────────────────────┤',\n    `│  DEPTH ADVANTAGE:              ${(metrics.depthAdvantage >= 0 ? '+' : '') + metrics.depthAdvantage} plies            │`,\n    `│  DEPTH RATIO:                  ${metrics.depthRatio.toFixed(2)}x                 │`,\n    '└─────────────────────────────────────────────────────┘',\n    '',\n    '┌─────────────────────────────────────────────────────┐',\n    '│              HORIZON ACCURACY ANALYSIS              │',\n    '├─────────────────────────────────────────────────────┤',\n  ];\n  \n  for (const horizon of metrics.horizonAccuracy) {\n    const epBar = '█'.repeat(Math.round(horizon.accuracy / 5));\n    const sfBar = '░'.repeat(Math.round(horizon.stockfishAccuracyAtHorizon / 5));\n    lines.push(\n      `│  ${horizon.movesAhead.toString().padStart(2)} moves: EP ${horizon.accuracy.toFixed(1).padStart(5)}% ${epBar.padEnd(20)}│`\n    );\n    lines.push(\n      `│          SF ${horizon.stockfishAccuracyAtHorizon.toFixed(1).padStart(5)}% ${sfBar.padEnd(20)}│`\n    );\n  }\n  \n  lines.push('├─────────────────────────────────────────────────────┤');\n  lines.push(`│  Max Accurate Horizon: ${metrics.maxAccurateHorizon.toString().padStart(2)} moves (>60% accuracy)    │`);\n  lines.push('└─────────────────────────────────────────────────────┘');\n  lines.push('');\n  lines.push('┌─────────────────────────────────────────────────────┐');\n  lines.push('│                   INTERPRETATION                    │');\n  lines.push('├─────────────────────────────────────────────────────┤');\n  \n  if (metrics.depthAdvantage > 0) {\n    lines.push(`│  En Pensent sees ${metrics.depthAdvantage} plies (~${Math.floor(metrics.depthAdvantage / 2)} moves) DEEPER    │`);\n    lines.push(`│  than Stockfish 17's ${metrics.stockfishDepth}-ply search.                  │`);\n    lines.push('│                                                     │');\n    lines.push('│  This is achieved through PATTERN RECOGNITION       │');\n    lines.push('│  rather than brute-force search.                    │');\n  } else if (metrics.depthAdvantage < 0) {\n    lines.push(`│  Stockfish 17 searches ${-metrics.depthAdvantage} plies deeper,            │`);\n    lines.push(`│  but En Pensent compensates with pattern insight.   │`);\n  } else {\n    lines.push('│  Both engines show equivalent effective depth.      │');\n  }\n  \n  lines.push('└─────────────────────────────────────────────────────┘');\n  lines.push('');\n  lines.push('═══════════════════════════════════════════════════════');\n  lines.push(`  Analysis confidence: ${metrics.depthConfidence.toFixed(1)}%`);\n  lines.push('═══════════════════════════════════════════════════════');\n  \n  return lines.join('\\n');\n}\n";export{e as default};
