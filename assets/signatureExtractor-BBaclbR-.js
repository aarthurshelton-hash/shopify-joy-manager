const n="/**\n * Signature Extraction for Chess Games\n * Extracted from archetypeAnalyzer.ts for modularity\n */\n\nimport type { TemporalSignature, QuadrantProfile, TemporalFlow, CriticalMoment } from '@/lib/pensent-core/types/core';\n\n/**\n * Convert a square string (e.g., \"e4\") to quadrant region\n */\nexport function squareToQuadrant(square: string): 'q1' | 'q2' | 'q3' | 'q4' {\n  const file = square.charCodeAt(0) - 97; // a=0, h=7\n  const rank = parseInt(square[1]) - 1; // 1=0, 8=7\n  \n  const isKingside = file >= 4;\n  const isWhiteSide = rank < 4;\n  \n  if (isKingside && !isWhiteSide) return 'q1'; // Top-right\n  if (!isKingside && !isWhiteSide) return 'q2'; // Top-left\n  if (!isKingside && isWhiteSide) return 'q3'; // Bottom-left\n  return 'q4'; // Bottom-right (kingside white)\n}\n\n/**\n * Calculate quadrant profile from move destinations\n */\nexport function calculateQuadrantProfile(\n  moveHistory: Array<{ to: string }>\n): QuadrantProfile {\n  const counts = { q1: 0, q2: 0, q3: 0, q4: 0 };\n  \n  for (const move of moveHistory) {\n    const quad = squareToQuadrant(move.to);\n    counts[quad]++;\n  }\n  \n  const total = Math.max(1, Object.values(counts).reduce((a, b) => a + b, 0));\n  \n  return {\n    q1: counts.q1 / total,\n    q2: counts.q2 / total,\n    q3: counts.q3 / total,\n    q4: counts.q4 / total\n  };\n}\n\n/**\n * Calculate temporal flow based on game phases\n */\nexport function calculateTemporalFlow(\n  moveHistory: Array<{ san: string }>,\n  totalMoves: number\n): TemporalFlow {\n  const openingMoves = moveHistory.slice(0, Math.min(10, totalMoves));\n  const middleMoves = moveHistory.slice(10, Math.min(30, totalMoves));\n  const endMoves = moveHistory.slice(30);\n  \n  return {\n    opening: openingMoves.length / 10,\n    middle: middleMoves.length / 20,\n    ending: endMoves.length / Math.max(1, totalMoves - 30),\n    trend: totalMoves > 40 ? 'stable' : totalMoves > 25 ? 'accelerating' : 'volatile',\n    momentum: (endMoves.length - openingMoves.length) / Math.max(1, totalMoves) * 2\n  };\n}\n\n/**\n * Detect critical moments (captures, checks, etc.)\n */\nexport function detectCriticalMoments(\n  moveHistory: Array<{ san: string }>\n): CriticalMoment[] {\n  const moments: CriticalMoment[] = [];\n  \n  for (let i = 0; i < moveHistory.length; i++) {\n    const move = moveHistory[i];\n    if (move.san.includes('x') || move.san.includes('+') || move.san.includes('#')) {\n      moments.push({\n        index: i,\n        type: move.san.includes('#') ? 'checkmate' : move.san.includes('+') ? 'check' : 'capture',\n        severity: move.san.includes('#') ? 1 : move.san.includes('+') ? 0.7 : 0.4,\n        description: `Move ${i + 1}: ${move.san}`\n      });\n    }\n  }\n  \n  return moments.slice(0, 10);\n}\n\n/**\n * Generate a unique fingerprint for a signature\n */\nexport function generateFingerprint(\n  totalMoves: number,\n  intensity: number,\n  quadrantProfile: QuadrantProfile\n): string {\n  const fingerprintData = `${totalMoves}-${intensity.toFixed(2)}-${Object.values(quadrantProfile).map(v => v.toFixed(2)).join('')}`;\n  let hash = 0;\n  for (let i = 0; i < fingerprintData.length; i++) {\n    hash = ((hash << 5) - hash) + fingerprintData.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return `ep-${Math.abs(hash).toString(36)}`;\n}\n\n/**\n * Extract temporal signature from chess move history\n */\nexport function extractChessSignature(\n  moveHistory: Array<{ from: string; to: string; san: string }>,\n  _finalFen: string\n): TemporalSignature {\n  const totalMoves = moveHistory.length;\n  \n  const quadrantProfile = calculateQuadrantProfile(moveHistory);\n  const temporalFlow = calculateTemporalFlow(moveHistory, totalMoves);\n  const criticalMoments = detectCriticalMoments(moveHistory);\n  \n  // Calculate intensity based on captures and checks\n  const intensity = Math.min(1, criticalMoments.length / (totalMoves * 0.3));\n  \n  // Determine dominant force\n  const whiteActivity = moveHistory.filter((_, i) => i % 2 === 0).length;\n  const blackActivity = moveHistory.filter((_, i) => i % 2 === 1).length;\n  const dominantForce = whiteActivity > blackActivity * 1.1 ? 'primary' : \n                        blackActivity > whiteActivity * 1.1 ? 'secondary' : 'balanced';\n  \n  // Determine flow direction\n  const forwardness = (quadrantProfile.q1 + quadrantProfile.q2) - (quadrantProfile.q3 + quadrantProfile.q4);\n  const flowDirection = Math.abs(forwardness) < 0.15 ? 'chaotic' : \n                        forwardness > 0 ? 'forward' : 'backward';\n  \n  const fingerprint = generateFingerprint(totalMoves, intensity, quadrantProfile);\n  \n  return {\n    fingerprint,\n    archetype: '', // Will be set by classifier\n    dominantForce,\n    flowDirection,\n    intensity,\n    quadrantProfile,\n    temporalFlow,\n    criticalMoments\n  };\n}\n\n/**\n * Extract moves from PGN string\n */\nexport function extractMovesFromPgn(pgn: string): string[] {\n  // Remove comments and variations\n  let cleanPgn = pgn.replace(/\\{[^}]*\\}/g, '');\n  cleanPgn = cleanPgn.replace(/\\([^)]*\\)/g, '');\n  \n  // Extract moves section (after headers)\n  const movesMatch = cleanPgn.match(/\\n\\n(.+)$/s) || cleanPgn.match(/\\n(.+)$/s);\n  const movesSection = movesMatch ? movesMatch[1] : cleanPgn;\n  \n  // Parse moves\n  const moves = movesSection\n    .replace(/\\d+\\.\\s*/g, '')\n    .replace(/1-0|0-1|1\\/2-1\\/2|\\*/g, '')\n    .trim()\n    .split(/\\s+/)\n    .filter(m => m.length > 0 && !m.includes('.'));\n  \n  return moves;\n}\n";export{n as default};
