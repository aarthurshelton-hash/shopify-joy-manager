const n="/**\n * Options Flow Integration - v7.53-ACCURACY\n * \n * Integrates unusual options activity as a leading indicator.\n * Large options trades often precede directional moves.\n */\n\nexport type OptionType = 'call' | 'put';\nexport type FlowType = 'sweep' | 'block' | 'split' | 'normal';\n\nexport interface OptionsFlow {\n  symbol: string;\n  optionType: OptionType;\n  flowType: FlowType;\n  strike: number;\n  expiry: string;\n  premium: number;        // Total premium in dollars\n  volume: number;         // Number of contracts\n  openInterest: number;\n  impliedVolatility: number;\n  delta: number;\n  side: 'bid' | 'ask' | 'mid';\n  timestamp: number;\n}\n\nexport interface FlowSignal {\n  symbol: string;\n  direction: 'bullish' | 'bearish' | 'neutral';\n  strength: number;       // 0-1\n  confidence: number;     // 0-1\n  timeToExpiry: number;   // Days\n  premiumConcentration: number;  // How concentrated the flow is\n  unusualActivity: boolean;\n}\n\n/**\n * Thresholds for unusual activity\n */\nexport const FLOW_THRESHOLDS = {\n  minPremium: 100000,           // $100k minimum for significance\n  unusualVolumeRatio: 3,        // 3x average volume\n  blockSize: 500,               // 500+ contracts = block trade\n  sweepSpeed: 60000,            // Sweep within 60 seconds\n  ivSpike: 0.2,                 // 20% IV increase\n};\n\n/**\n * Analyze options flow for directional bias\n */\nexport function analyzeOptionsFlow(flows: OptionsFlow[]): FlowSignal {\n  if (flows.length === 0) {\n    return {\n      symbol: '',\n      direction: 'neutral',\n      strength: 0,\n      confidence: 0,\n      timeToExpiry: 0,\n      premiumConcentration: 0,\n      unusualActivity: false,\n    };\n  }\n  \n  const symbol = flows[0].symbol;\n  \n  // Separate calls and puts\n  const calls = flows.filter(f => f.optionType === 'call');\n  const puts = flows.filter(f => f.optionType === 'put');\n  \n  // Calculate premium weighted direction\n  const callPremium = calls.reduce((sum, f) => sum + f.premium, 0);\n  const putPremium = puts.reduce((sum, f) => sum + f.premium, 0);\n  const totalPremium = callPremium + putPremium;\n  \n  if (totalPremium === 0) {\n    return {\n      symbol,\n      direction: 'neutral',\n      strength: 0,\n      confidence: 0,\n      timeToExpiry: 0,\n      premiumConcentration: 0,\n      unusualActivity: false,\n    };\n  }\n  \n  // Premium ratio determines direction\n  const callRatio = callPremium / totalPremium;\n  const direction: 'bullish' | 'bearish' | 'neutral' = \n    callRatio > 0.6 ? 'bullish' : callRatio < 0.4 ? 'bearish' : 'neutral';\n  \n  // Strength based on total premium and concentration\n  const strengthFromPremium = Math.min(1, totalPremium / 10000000);  // $10M = max strength\n  \n  // Check for unusual activity\n  const hasBlocks = flows.some(f => f.volume >= FLOW_THRESHOLDS.blockSize);\n  const hasSweeps = flows.filter(f => f.flowType === 'sweep').length >= 2;\n  const hasHighPremium = totalPremium >= FLOW_THRESHOLDS.minPremium * 5;\n  const unusualActivity = hasBlocks || hasSweeps || hasHighPremium;\n  \n  // Confidence based on flow type and ask-side activity\n  const askSideFlows = flows.filter(f => f.side === 'ask').length / flows.length;\n  const sweepRatio = flows.filter(f => f.flowType === 'sweep').length / flows.length;\n  const confidence = (askSideFlows * 0.5) + (sweepRatio * 0.3) + (unusualActivity ? 0.2 : 0);\n  \n  // Average time to expiry\n  const avgExpiry = flows.reduce((sum, f) => {\n    const expiryDate = new Date(f.expiry);\n    const now = new Date();\n    return sum + (expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24);\n  }, 0) / flows.length;\n  \n  // Premium concentration (Herfindahl index)\n  const premiumShares = flows.map(f => f.premium / totalPremium);\n  const concentration = premiumShares.reduce((sum, s) => sum + s * s, 0);\n  \n  return {\n    symbol,\n    direction,\n    strength: strengthFromPremium * (unusualActivity ? 1.5 : 1),\n    confidence: Math.min(1, confidence),\n    timeToExpiry: avgExpiry,\n    premiumConcentration: concentration,\n    unusualActivity,\n  };\n}\n\n/**\n * Detect smart money positioning from flow patterns\n */\nexport function detectSmartMoneyFlow(flows: OptionsFlow[]): {\n  isSmartMoney: boolean;\n  conviction: number;\n  expectedTimeframe: 'intraday' | 'swing' | 'position';\n  notes: string[];\n} {\n  const notes: string[] = [];\n  let smartMoneyScore = 0;\n  \n  // Large block trades at bid = smart money buying\n  const bidBlocks = flows.filter(f => f.side === 'bid' && f.volume >= FLOW_THRESHOLDS.blockSize);\n  if (bidBlocks.length > 0) {\n    smartMoneyScore += 0.3;\n    notes.push(`${bidBlocks.length} large block(s) at bid`);\n  }\n  \n  // Sweeps indicate urgency = smart money\n  const sweeps = flows.filter(f => f.flowType === 'sweep');\n  if (sweeps.length >= 2) {\n    smartMoneyScore += 0.3;\n    notes.push(`${sweeps.length} sweep orders detected`);\n  }\n  \n  // OTM options with high premium = informed speculation\n  const avgDelta = flows.reduce((sum, f) => sum + Math.abs(f.delta), 0) / flows.length;\n  if (avgDelta < 0.3) {\n    const otmPremium = flows.filter(f => Math.abs(f.delta) < 0.3)\n      .reduce((sum, f) => sum + f.premium, 0);\n    if (otmPremium > FLOW_THRESHOLDS.minPremium * 2) {\n      smartMoneyScore += 0.2;\n      notes.push('Heavy OTM positioning');\n    }\n  }\n  \n  // Short-dated with high premium = directional bet\n  const shortDated = flows.filter(f => {\n    const expiryDate = new Date(f.expiry);\n    const now = new Date();\n    return (expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24) < 7;\n  });\n  const shortDatedPremium = shortDated.reduce((sum, f) => sum + f.premium, 0);\n  if (shortDatedPremium > FLOW_THRESHOLDS.minPremium) {\n    smartMoneyScore += 0.2;\n    notes.push('Short-dated conviction trades');\n  }\n  \n  // Determine expected timeframe\n  const avgExpiry = flows.reduce((sum, f) => {\n    const expiryDate = new Date(f.expiry);\n    const now = new Date();\n    return sum + (expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24);\n  }, 0) / flows.length;\n  \n  const expectedTimeframe: 'intraday' | 'swing' | 'position' = \n    avgExpiry < 1 ? 'intraday' : avgExpiry < 14 ? 'swing' : 'position';\n  \n  return {\n    isSmartMoney: smartMoneyScore >= 0.5,\n    conviction: Math.min(1, smartMoneyScore),\n    expectedTimeframe,\n    notes,\n  };\n}\n\n/**\n * Integrate options flow into price prediction\n */\nexport function integrateOptionsFlowPrediction(\n  basePrediction: { direction: 'bullish' | 'bearish' | 'neutral'; confidence: number },\n  flowSignal: FlowSignal\n): { direction: 'bullish' | 'bearish' | 'neutral'; confidence: number; flowInfluence: number } {\n  if (!flowSignal.unusualActivity || flowSignal.strength < 0.3) {\n    return { ...basePrediction, flowInfluence: 0 };\n  }\n  \n  let { direction, confidence } = basePrediction;\n  const flowInfluence = flowSignal.strength * flowSignal.confidence;\n  \n  // If flow agrees with base prediction, boost confidence\n  if (flowSignal.direction === direction || flowSignal.direction === 'neutral') {\n    confidence = Math.min(1, confidence * (1 + flowInfluence * 0.5));\n  } else {\n    // Flow disagrees - reduce confidence or flip\n    if (flowInfluence > 0.6) {\n      // Strong flow signal overrides\n      direction = flowSignal.direction;\n      confidence = flowInfluence * 0.7;\n    } else {\n      // Moderate disagreement reduces confidence\n      confidence *= (1 - flowInfluence * 0.5);\n    }\n  }\n  \n  return { direction, confidence, flowInfluence };\n}\n";export{n as default};
