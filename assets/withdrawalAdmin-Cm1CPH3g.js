const e="import { supabase } from '@/integrations/supabase/client';\n\nexport interface WithdrawalRequest {\n  id: string;\n  user_id: string;\n  amount_cents: number;\n  status: 'pending' | 'approved' | 'rejected' | 'completed' | 'cancelled';\n  payout_method: string;\n  payout_details: {\n    method?: string;\n    email?: string;\n    notes?: string;\n  } | null;\n  admin_notes: string | null;\n  reviewed_by: string | null;\n  reviewed_at: string | null;\n  completed_at: string | null;\n  created_at: string;\n  updated_at: string;\n  // Joined data\n  user_email?: string;\n  user_display_name?: string;\n  wallet_total_earned?: number;\n  wallet_total_withdrawn?: number;\n}\n\n// Get all withdrawal requests (admin only)\nexport async function getAllWithdrawalRequests(\n  status?: string\n): Promise<{ data: WithdrawalRequest[]; error: Error | null }> {\n  try {\n    let query = supabase\n      .from('withdrawal_requests')\n      .select('*')\n      .order('created_at', { ascending: false });\n\n    if (status && status !== 'all') {\n      query = query.eq('status', status);\n    }\n\n    const { data, error } = await query;\n    if (error) throw error;\n\n    // Get user details for each request\n    const userIds = [...new Set((data || []).map(r => r.user_id))];\n    \n    // Get profiles\n    const { data: profiles } = await supabase\n      .from('profiles')\n      .select('user_id, display_name')\n      .in('user_id', userIds);\n\n    // Get wallets\n    const { data: wallets } = await supabase\n      .from('user_wallets')\n      .select('user_id, total_earned_cents, total_withdrawn_cents')\n      .in('user_id', userIds);\n\n    const profileMap = new Map(profiles?.map(p => [p.user_id, p]) || []);\n    const walletMap = new Map(wallets?.map(w => [w.user_id, w]) || []);\n\n    const enrichedData = (data || []).map(r => ({\n      ...r,\n      payout_details: r.payout_details as WithdrawalRequest['payout_details'],\n      user_display_name: profileMap.get(r.user_id)?.display_name || 'Unknown User',\n      wallet_total_earned: walletMap.get(r.user_id)?.total_earned_cents || 0,\n      wallet_total_withdrawn: walletMap.get(r.user_id)?.total_withdrawn_cents || 0,\n    })) as WithdrawalRequest[];\n\n    return { data: enrichedData, error: null };\n  } catch (error) {\n    return { data: [], error: error as Error };\n  }\n}\n\n// Approve a withdrawal request\nexport async function approveWithdrawal(\n  requestId: string,\n  adminNotes?: string\n): Promise<{ success: boolean; error: Error | null }> {\n  try {\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Not authenticated');\n\n    const { error } = await supabase\n      .from('withdrawal_requests')\n      .update({\n        status: 'approved',\n        admin_notes: adminNotes || null,\n        reviewed_by: user.id,\n        reviewed_at: new Date().toISOString(),\n      })\n      .eq('id', requestId)\n      .eq('status', 'pending');\n\n    if (error) throw error;\n    return { success: true, error: null };\n  } catch (error) {\n    return { success: false, error: error as Error };\n  }\n}\n\n// Reject a withdrawal request\nexport async function rejectWithdrawal(\n  requestId: string,\n  adminNotes: string\n): Promise<{ success: boolean; error: Error | null }> {\n  try {\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Not authenticated');\n\n    if (!adminNotes) {\n      throw new Error('Rejection reason is required');\n    }\n\n    const { error } = await supabase\n      .from('withdrawal_requests')\n      .update({\n        status: 'rejected',\n        admin_notes: adminNotes,\n        reviewed_by: user.id,\n        reviewed_at: new Date().toISOString(),\n      })\n      .eq('id', requestId)\n      .eq('status', 'pending');\n\n    if (error) throw error;\n    return { success: true, error: null };\n  } catch (error) {\n    return { success: false, error: error as Error };\n  }\n}\n\n// Mark withdrawal as completed (after manual payout)\nexport async function completeWithdrawal(\n  requestId: string,\n  adminNotes?: string\n): Promise<{ success: boolean; error: Error | null }> {\n  try {\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) throw new Error('Not authenticated');\n\n    // Get the request details first\n    const { data: request, error: fetchError } = await supabase\n      .from('withdrawal_requests')\n      .select('*')\n      .eq('id', requestId)\n      .eq('status', 'approved')\n      .single();\n\n    if (fetchError || !request) {\n      throw new Error('Request not found or not in approved status');\n    }\n\n    // Update request to completed\n    const { error: updateError } = await supabase\n      .from('withdrawal_requests')\n      .update({\n        status: 'completed',\n        admin_notes: adminNotes ? `${request.admin_notes || ''}\\n---\\n${adminNotes}` : request.admin_notes,\n        completed_at: new Date().toISOString(),\n      })\n      .eq('id', requestId);\n\n    if (updateError) throw updateError;\n\n    // Update user's wallet (deduct withdrawn amount)\n    // This needs to be done via service role, so we'll use an edge function\n    const { error: walletError } = await supabase.functions.invoke('process-withdrawal', {\n      body: { \n        request_id: requestId,\n        user_id: request.user_id,\n        amount_cents: request.amount_cents\n      }\n    });\n\n    if (walletError) {\n      console.error('Wallet update error:', walletError);\n      // Don't throw - the withdrawal is marked complete, wallet update can be retried\n    }\n\n    return { success: true, error: null };\n  } catch (error) {\n    return { success: false, error: error as Error };\n  }\n}\n\n// Get withdrawal stats\nexport async function getWithdrawalStats(): Promise<{\n  data: {\n    pending_count: number;\n    pending_amount: number;\n    approved_count: number;\n    approved_amount: number;\n    completed_total: number;\n    rejected_count: number;\n  } | null;\n  error: Error | null;\n}> {\n  try {\n    const { data, error } = await supabase\n      .from('withdrawal_requests')\n      .select('status, amount_cents');\n\n    if (error) throw error;\n\n    const stats = {\n      pending_count: 0,\n      pending_amount: 0,\n      approved_count: 0,\n      approved_amount: 0,\n      completed_total: 0,\n      rejected_count: 0,\n    };\n\n    (data || []).forEach(r => {\n      switch (r.status) {\n        case 'pending':\n          stats.pending_count++;\n          stats.pending_amount += r.amount_cents;\n          break;\n        case 'approved':\n          stats.approved_count++;\n          stats.approved_amount += r.amount_cents;\n          break;\n        case 'completed':\n          stats.completed_total += r.amount_cents;\n          break;\n        case 'rejected':\n          stats.rejected_count++;\n          break;\n      }\n    });\n\n    return { data: stats, error: null };\n  } catch (error) {\n    return { data: null, error: error as Error };\n  }\n}\n";export{e as default};
