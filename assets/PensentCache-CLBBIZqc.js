const n="/**\n * En Pensent Core SDK - Generic Cache Implementation\n */\n\nimport { CacheEntry, CacheStats, CacheConfig, DEFAULT_CACHE_CONFIG } from './types';\n\n/**\n * High-performance LRU cache with TTL support\n */\nexport class PensentCache<T> {\n  private cache: Map<string, CacheEntry<T>> = new Map();\n  private config: CacheConfig;\n  private stats: CacheStats;\n\n  constructor(config: Partial<CacheConfig> = {}) {\n    this.config = { ...DEFAULT_CACHE_CONFIG, ...config };\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      size: 0,\n      maxSize: this.config.maxSize,\n      hitRate: 0,\n      evictions: 0\n    };\n  }\n\n  /**\n   * Get a value from the cache\n   */\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      this.stats.misses++;\n      this.updateHitRate();\n      return undefined;\n    }\n    \n    // Check expiration\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      this.stats.misses++;\n      this.updateHitRate();\n      return undefined;\n    }\n    \n    // Update access stats\n    entry.accessCount++;\n    entry.lastAccessedAt = Date.now();\n    \n    // Move to end for LRU\n    if (this.config.evictionStrategy === 'lru') {\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n    }\n    \n    this.stats.hits++;\n    this.updateHitRate();\n    return entry.value;\n  }\n\n  /**\n   * Set a value in the cache\n   */\n  set(key: string, value: T, ttl?: number): void {\n    // Evict if at capacity\n    if (this.cache.size >= this.config.maxSize) {\n      this.evict();\n    }\n    \n    const now = Date.now();\n    const entry: CacheEntry<T> = {\n      value,\n      createdAt: now,\n      expiresAt: now + (ttl ?? this.config.defaultTtl),\n      accessCount: 1,\n      lastAccessedAt: now\n    };\n    \n    this.cache.set(key, entry);\n    this.stats.size = this.cache.size;\n  }\n\n  /**\n   * Check if key exists and is not expired\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n    \n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Delete a key from the cache\n   */\n  delete(key: string): boolean {\n    const result = this.cache.delete(key);\n    this.stats.size = this.cache.size;\n    return result;\n  }\n\n  /**\n   * Clear all entries\n   */\n  clear(): void {\n    this.cache.clear();\n    this.stats.size = 0;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Get or set with a factory function\n   */\n  async getOrSet(key: string, factory: () => T | Promise<T>, ttl?: number): Promise<T> {\n    const cached = this.get(key);\n    if (cached !== undefined) {\n      return cached;\n    }\n    \n    const value = await factory();\n    this.set(key, value, ttl);\n    return value;\n  }\n\n  /**\n   * Evict entries based on strategy\n   */\n  private evict(): void {\n    if (this.cache.size === 0) return;\n    \n    let keyToEvict: string | null = null;\n    \n    switch (this.config.evictionStrategy) {\n      case 'lru': {\n        keyToEvict = this.cache.keys().next().value ?? null;\n        break;\n      }\n      case 'lfu': {\n        let minCount = Infinity;\n        for (const [key, entry] of this.cache) {\n          if (entry.accessCount < minCount) {\n            minCount = entry.accessCount;\n            keyToEvict = key;\n          }\n        }\n        break;\n      }\n      case 'fifo': {\n        let oldestTime = Infinity;\n        for (const [key, entry] of this.cache) {\n          if (entry.createdAt < oldestTime) {\n            oldestTime = entry.createdAt;\n            keyToEvict = key;\n          }\n        }\n        break;\n      }\n    }\n    \n    if (keyToEvict) {\n      this.cache.delete(keyToEvict);\n      this.stats.evictions++;\n      this.stats.size = this.cache.size;\n    }\n  }\n\n  private updateHitRate(): void {\n    const total = this.stats.hits + this.stats.misses;\n    this.stats.hitRate = total > 0 ? this.stats.hits / total : 0;\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup(): number {\n    const now = Date.now();\n    let cleaned = 0;\n    \n    for (const [key, entry] of this.cache) {\n      if (now > entry.expiresAt) {\n        this.cache.delete(key);\n        cleaned++;\n      }\n    }\n    \n    this.stats.size = this.cache.size;\n    return cleaned;\n  }\n}\n";export{n as default};
