const n="/**\n * Predictive Chess Analysis Engine\n * \n * Combines Stockfish 17's deep analysis capabilities with En Pensent's\n * visualization data and color theory to provide:\n * - 30-move lookahead predictions\n * - Pattern recognition across game positions\n * - Best move suggestions with visual context\n * - Future potential visualization of any position\n * \n * This integrates engine analysis with our unique visual fingerprinting\n * to create predictive insights no other platform can offer.\n */\n\nimport { Chess, Square } from 'chess.js';\nimport { getStockfishEngine, PositionAnalysis, StockfishEvaluation } from './stockfishEngine';\nimport { SquareData, GameData } from './gameSimulator';\nimport { getPieceColor, PieceType, PieceColor, getActivePalette } from './pieceColors';\nimport { TemporalSignature, QuadrantProfile, TemporalFlow, CriticalMoment } from '@/lib/pensent-core/types';\nimport { classifyUniversalArchetype } from '@/lib/pensent-core/archetype';\n\n// ===================== TYPES =====================\n\nexport interface PredictedLine {\n  moves: string[];           // Array of SAN moves\n  evaluation: number;        // Final position eval in centipawns\n  winProbability: number;    // 0-100 for the side to move at start\n  isMate: boolean;\n  mateIn?: number;\n  visualComplexity: number;  // Predicted visual complexity (0-100)\n  territoryBalance: number;  // -100 (black dominates) to +100 (white dominates)\n}\n\nexport interface PositionPotential {\n  fen: string;\n  currentEval: number;\n  bestMove: string;\n  bestMoveReadable: string;  // SAN notation\n  principalVariation: PredictedLine;\n  alternativeLines: PredictedLine[];\n  futurePositions: FuturePosition[];\n  tacticalThemes: TacticalTheme[];\n  positionType: PositionType;\n  dynamism: number;          // 0-100, how much the position can change\n  criticalSquares: string[]; // Key squares to control\n  vulnerabilities: Vulnerability[];\n}\n\nexport interface FuturePosition {\n  moveNumber: number;        // Moves from current position\n  fen: string;\n  evaluation: number;\n  bestContinuation: string;\n  description: string;       // Human-readable position description\n  visualPattern: VisualPattern;\n}\n\nexport interface VisualPattern {\n  dominantColor: 'white' | 'black' | 'balanced';\n  controlledTerritory: number; // Squares controlled (0-64)\n  pieceActivity: number;       // 0-100 measure of piece mobility\n  kingSafety: { white: number; black: number };\n  centerControl: number;       // -100 to +100\n}\n\nexport interface TacticalTheme {\n  type: 'fork' | 'pin' | 'skewer' | 'discovered_attack' | 'double_attack' | \n        'back_rank' | 'sacrifice' | 'promotion' | 'mating_pattern' | 'zugzwang' | 'tactical';\n  likelihood: number;        // 0-100\n  targetSquares: string[];\n  description: string;\n}\n\nexport interface Vulnerability {\n  side: 'white' | 'black';\n  type: 'king_safety' | 'weak_pawns' | 'piece_trapped' | 'overloaded_piece' | \n        'exposed_king' | 'back_rank' | 'undefended_piece';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n}\n\nexport type PositionType = \n  | 'opening'\n  | 'closed_center'\n  | 'open_center'\n  | 'pawn_race'\n  | 'attack'\n  | 'defense'\n  | 'endgame_winning'\n  | 'endgame_drawing'\n  | 'tactical'\n  | 'positional'\n  | 'critical';\n\nexport interface MoveRecommendation {\n  move: string;\n  uci: string;\n  evaluation: number;\n  improvement: number;       // How much better than current position\n  confidence: number;        // 0-100\n  reasoning: string[];       // Why this move is recommended\n  visualImpact: string;      // How it changes the visualization\n  futureLines: PredictedLine[];\n}\n\n// ===================== ANALYSIS FUNCTIONS =====================\n\n/**\n * Analyze position potential with 30-move lookahead\n * Combines Stockfish analysis with visual pattern recognition\n */\nexport async function analyzePositionPotential(\n  fen: string,\n  options: {\n    depth?: number;\n    lines?: number;\n    lookahead?: number;\n    onProgress?: (stage: string, progress: number) => void;\n  } = {}\n): Promise<PositionPotential> {\n  const depth = options.depth || 20;\n  const lines = Math.min(options.lines || 3, 5);\n  const lookahead = Math.min(options.lookahead || 15, 30); // Cap at 30 moves\n  \n  const engine = getStockfishEngine();\n  await engine.waitReady();\n  \n  const chess = new Chess(fen);\n  options.onProgress?.('Analyzing current position', 10);\n  \n  // Get primary analysis\n  const primaryAnalysis = await engine.analyzePosition(fen, { depth, nodes: 100000 });\n  \n  options.onProgress?.('Computing principal variation', 30);\n  \n  // Build principal variation line\n  const pvLine = await buildPredictedLine(\n    fen, \n    primaryAnalysis.evaluation.pv, \n    primaryAnalysis.evaluation.score,\n    primaryAnalysis.evaluation.scoreType === 'mate',\n    primaryAnalysis.evaluation.mateIn\n  );\n  \n  options.onProgress?.('Analyzing future positions', 50);\n  \n  // Generate future position snapshots\n  const futurePositions = await generateFuturePositions(fen, pvLine.moves, lookahead);\n  \n  options.onProgress?.('Detecting tactical themes', 70);\n  \n  // Detect tactical themes\n  const tacticalThemes = detectTacticalThemes(chess, primaryAnalysis);\n  \n  // Detect vulnerabilities\n  const vulnerabilities = detectVulnerabilities(chess);\n  \n  // Determine position type\n  const positionType = classifyPosition(chess, primaryAnalysis);\n  \n  options.onProgress?.('Calculating dynamics', 90);\n  \n  // Calculate position dynamism\n  const dynamism = calculateDynamism(chess, primaryAnalysis);\n  \n  // Find critical squares\n  const criticalSquares = findCriticalSquares(chess, primaryAnalysis);\n  \n  options.onProgress?.('Complete', 100);\n  \n  return {\n    fen,\n    currentEval: primaryAnalysis.evaluation.score,\n    bestMove: primaryAnalysis.bestMove,\n    bestMoveReadable: convertUciToSan(chess, primaryAnalysis.bestMove),\n    principalVariation: pvLine,\n    alternativeLines: [], // TODO: Implement multi-PV\n    futurePositions,\n    tacticalThemes,\n    positionType,\n    dynamism,\n    criticalSquares,\n    vulnerabilities,\n  };\n}\n\n/**\n * Get best move recommendation with detailed reasoning\n */\nexport async function getBestMoveRecommendation(\n  fen: string,\n  depth: number = 20\n): Promise<MoveRecommendation> {\n  const engine = getStockfishEngine();\n  await engine.waitReady();\n  \n  const chess = new Chess(fen);\n  const analysis = await engine.analyzePosition(fen, { depth, nodes: 100000 });\n  \n  const bestMove = analysis.bestMove;\n  const bestMoveSan = convertUciToSan(chess, bestMove);\n  \n  // Play the move to see the result\n  const newChess = new Chess(fen);\n  newChess.move(bestMoveSan);\n  \n  // Analyze resulting position\n  const afterAnalysis = await engine.analyzePosition(newChess.fen(), { depth: depth - 2, nodes: 50000 });\n  \n  // Calculate improvement\n  const currentEval = analysis.evaluation.score;\n  const afterEval = -afterAnalysis.evaluation.score; // Flip perspective\n  \n  // Generate reasoning\n  const reasoning = generateMoveReasoning(chess, bestMoveSan, analysis, afterAnalysis);\n  \n  // Build future lines\n  const futureLines = await Promise.all([\n    buildPredictedLine(\n      newChess.fen(),\n      afterAnalysis.evaluation.pv,\n      afterAnalysis.evaluation.score,\n      afterAnalysis.evaluation.scoreType === 'mate',\n      afterAnalysis.evaluation.mateIn\n    )\n  ]);\n  \n  return {\n    move: bestMoveSan,\n    uci: bestMove,\n    evaluation: currentEval,\n    improvement: afterEval - currentEval,\n    confidence: calculateConfidence(analysis),\n    reasoning,\n    visualImpact: describeVisualImpact(chess, bestMoveSan),\n    futureLines,\n  };\n}\n\n/**\n * Predict visual pattern for a position\n */\nexport function predictVisualPattern(chess: Chess): VisualPattern {\n  const board = chess.board();\n  \n  let whiteControl = 0;\n  let blackControl = 0;\n  let whitePieceActivity = 0;\n  let blackPieceActivity = 0;\n  \n  // Count controlled squares and piece activity\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece) {\n        const square = (String.fromCharCode(97 + file) + (8 - rank)) as Square;\n        const moves = chess.moves({ square, verbose: true });\n        \n        if (piece.color === 'w') {\n          whitePieceActivity += moves.length;\n          whiteControl += moves.length * 0.5;\n        } else {\n          blackPieceActivity += moves.length;\n          blackControl += moves.length * 0.5;\n        }\n      }\n    }\n  }\n  \n  // Normalize activity scores\n  const totalMoves = chess.moves().length;\n  const activityScore = Math.min(100, (whitePieceActivity + blackPieceActivity) / 2);\n  \n  // Calculate center control\n  const centerSquares = ['d4', 'd5', 'e4', 'e5'] as Square[];\n  let centerScore = 0;\n  for (const sq of centerSquares) {\n    const piece = chess.get(sq);\n    if (piece) {\n      centerScore += piece.color === 'w' ? 25 : -25;\n    }\n  }\n  \n  // Assess king safety (simplified)\n  const whiteKingSafety = assessKingSafety(chess, 'w');\n  const blackKingSafety = assessKingSafety(chess, 'b');\n  \n  // Determine dominant color\n  const territoryDiff = whiteControl - blackControl;\n  const dominantColor = territoryDiff > 5 ? 'white' : territoryDiff < -5 ? 'black' : 'balanced';\n  \n  return {\n    dominantColor,\n    controlledTerritory: Math.round(whiteControl + blackControl),\n    pieceActivity: activityScore,\n    kingSafety: { white: whiteKingSafety, black: blackKingSafety },\n    centerControl: centerScore,\n  };\n}\n\n/**\n * Extract En Pensent temporal signature from a chess position\n * Enables cross-domain pattern matching and archetype classification\n */\nexport function extractPositionSignature(chess: Chess): TemporalSignature {\n  const board = chess.board();\n  const history = chess.history();\n  const visualPattern = predictVisualPattern(chess);\n  \n  // Calculate quadrant activity (divide board into 4 quadrants)\n  let q1 = 0, q2 = 0, q3 = 0, q4 = 0;\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece) {\n        const weight = piece.color === 'w' ? 1 : 0.8;\n        if (rank < 4 && file < 4) q1 += weight;\n        else if (rank < 4 && file >= 4) q2 += weight;\n        else if (rank >= 4 && file < 4) q3 += weight;\n        else q4 += weight;\n      }\n    }\n  }\n  \n  // Normalize quadrant values\n  const maxQ = Math.max(q1, q2, q3, q4, 1);\n  const quadrantProfile: QuadrantProfile = {\n    q1: q1 / maxQ,\n    q2: q2 / maxQ,\n    q3: q3 / maxQ,\n    q4: q4 / maxQ,\n    center: visualPattern.centerControl / 100 + 0.5\n  };\n  \n  // Calculate temporal flow based on game phase\n  const moveCount = history.length;\n  const phase = moveCount < 15 ? 'opening' : moveCount < 40 ? 'middle' : 'ending';\n  const temporalFlow: TemporalFlow = {\n    opening: phase === 'opening' ? 0.9 : 0.2,\n    middle: phase === 'middle' ? 0.9 : 0.3,\n    ending: phase === 'ending' ? 0.9 : 0.1,\n    trend: visualPattern.pieceActivity > 50 ? 'accelerating' : \n           visualPattern.pieceActivity < 30 ? 'declining' : 'stable',\n    momentum: (visualPattern.kingSafety.white - visualPattern.kingSafety.black) / 100\n  };\n  \n  // Calculate intensity from piece activity\n  const intensity = Math.min(1, visualPattern.pieceActivity / 80);\n  \n  // Generate fingerprint\n  const fingerprint = `pos_${chess.fen().split(' ')[0].replace(/\\//g, '_').slice(0, 20)}`;\n  \n  // Determine dominant force\n  const dominantForce: 'primary' | 'secondary' | 'balanced' = \n    visualPattern.dominantColor === 'white' ? 'primary' :\n    visualPattern.dominantColor === 'black' ? 'secondary' : 'balanced';\n  \n  // Detect critical moments\n  const criticalMoments: CriticalMoment[] = [];\n  if (chess.inCheck()) {\n    criticalMoments.push({\n      index: moveCount,\n      type: 'check',\n      severity: 0.7,\n      description: 'King in check - critical position'\n    });\n  }\n  \n  // Build signature\n  const signature: TemporalSignature = {\n    fingerprint,\n    archetype: 'unknown',\n    dominantForce,\n    flowDirection: temporalFlow.momentum > 0.2 ? 'forward' : \n                   temporalFlow.momentum < -0.2 ? 'backward' : 'lateral',\n    intensity,\n    quadrantProfile,\n    temporalFlow,\n    criticalMoments,\n    domainData: {\n      fen: chess.fen(),\n      visualPattern,\n      moveCount,\n      phase\n    }\n  };\n  \n  // Classify archetype using universal classifier\n  signature.archetype = classifyUniversalArchetype(signature);\n  \n  return signature;\n}\n\n// ===================== HELPER FUNCTIONS =====================\n\nasync function buildPredictedLine(\n  startFen: string,\n  pvMoves: string[],\n  finalEval: number,\n  isMate: boolean,\n  mateIn?: number\n): Promise<PredictedLine> {\n  const chess = new Chess(startFen);\n  const sanMoves: string[] = [];\n  \n  // Convert UCI moves to SAN\n  for (const uci of pvMoves.slice(0, 30)) { // Limit to 30 moves\n    try {\n      const from = uci.slice(0, 2) as Square;\n      const to = uci.slice(2, 4) as Square;\n      const promotion = uci.length > 4 ? uci[4] : undefined;\n      \n      const move = chess.move({ from, to, promotion });\n      if (move) {\n        sanMoves.push(move.san);\n      } else {\n        break;\n      }\n    } catch {\n      break;\n    }\n  }\n  \n  // Calculate visual complexity of final position\n  const visualPattern = predictVisualPattern(chess);\n  \n  // Convert eval to win probability\n  const K = 0.00368208;\n  const winProb = 50 + 50 * (2 / (1 + Math.exp(-K * finalEval)) - 1);\n  \n  return {\n    moves: sanMoves,\n    evaluation: finalEval,\n    winProbability: winProb,\n    isMate,\n    mateIn,\n    visualComplexity: visualPattern.pieceActivity,\n    territoryBalance: visualPattern.centerControl,\n  };\n}\n\nasync function generateFuturePositions(\n  startFen: string,\n  moves: string[],\n  count: number\n): Promise<FuturePosition[]> {\n  const positions: FuturePosition[] = [];\n  const chess = new Chess(startFen);\n  const engine = getStockfishEngine();\n  \n  // Sample positions at regular intervals\n  const interval = Math.max(1, Math.floor(moves.length / Math.min(count, moves.length)));\n  \n  for (let i = 0; i < moves.length && positions.length < count; i++) {\n    try {\n      chess.move(moves[i]);\n      \n      if ((i + 1) % interval === 0 || i === moves.length - 1) {\n        const analysis = await engine.analyzePosition(chess.fen(), { nodes: 20000 });\n        const pattern = predictVisualPattern(chess);\n        \n        positions.push({\n          moveNumber: i + 1,\n          fen: chess.fen(),\n          evaluation: analysis.evaluation.score,\n          bestContinuation: convertUciToSan(chess, analysis.bestMove),\n          description: describePosition(chess, analysis.evaluation.score),\n          visualPattern: pattern,\n        });\n      }\n    } catch {\n      break;\n    }\n  }\n  \n  return positions;\n}\n\nfunction detectTacticalThemes(chess: Chess, analysis: PositionAnalysis): TacticalTheme[] {\n  const themes: TacticalTheme[] = [];\n  \n  // Check for common tactical patterns\n  const moves = chess.moves({ verbose: true });\n  \n  // Fork detection\n  for (const move of moves) {\n    if (move.piece === 'n' || move.piece === 'q') {\n      // Knight or Queen moves - potential forks\n      const testChess = new Chess(chess.fen());\n      testChess.move(move);\n      \n      // Count attacked valuable pieces\n      const attacks = testChess.moves({ verbose: true }).filter(m => m.captured);\n      if (attacks.length >= 2) {\n        themes.push({\n          type: 'fork',\n          likelihood: 70,\n          targetSquares: [move.to, ...attacks.map(a => a.to)],\n          description: `${move.piece.toUpperCase()} fork opportunity on ${move.to}`,\n        });\n      }\n    }\n  }\n  \n  // Check if there's a forcing sequence (high eval change)\n  if (Math.abs(analysis.evaluation.score) > 300) {\n    themes.push({\n      type: 'tactical',\n      likelihood: 80,\n      targetSquares: [],\n      description: 'Forcing tactical sequence available',\n    });\n  }\n  \n  // Mating pattern detection\n  if (analysis.evaluation.scoreType === 'mate') {\n    themes.push({\n      type: 'mating_pattern',\n      likelihood: 100,\n      targetSquares: [],\n      description: `Checkmate in ${analysis.evaluation.mateIn} moves`,\n    });\n  }\n  \n  return themes;\n}\n\nfunction detectVulnerabilities(chess: Chess): Vulnerability[] {\n  const vulnerabilities: Vulnerability[] = [];\n  \n  // Back rank weakness\n  const whiteKingRank = findKing(chess, 'w')?.charAt(1);\n  const blackKingRank = findKing(chess, 'b')?.charAt(1);\n  \n  if (whiteKingRank === '1') {\n    // Check if back rank is weak\n    const backRankPieces = ['a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\n    const ownPieces = backRankPieces.filter(sq => {\n      const piece = chess.get(sq as Square);\n      return piece && piece.color === 'w' && piece.type !== 'k';\n    });\n    \n    if (ownPieces.length >= 3) {\n      vulnerabilities.push({\n        side: 'white',\n        type: 'back_rank',\n        severity: 'medium',\n        description: 'Potential back rank weakness for White',\n      });\n    }\n  }\n  \n  if (blackKingRank === '8') {\n    const backRankPieces = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8'];\n    const ownPieces = backRankPieces.filter(sq => {\n      const piece = chess.get(sq as Square);\n      return piece && piece.color === 'b' && piece.type !== 'k';\n    });\n    \n    if (ownPieces.length >= 3) {\n      vulnerabilities.push({\n        side: 'black',\n        type: 'back_rank',\n        severity: 'medium',\n        description: 'Potential back rank weakness for Black',\n      });\n    }\n  }\n  \n  return vulnerabilities;\n}\n\nfunction classifyPosition(chess: Chess, analysis: PositionAnalysis): PositionType {\n  const moveCount = chess.history().length;\n  const eval_ = analysis.evaluation.score;\n  const board = chess.board();\n  \n  // Count pieces for endgame detection\n  let pieceCount = 0;\n  let pawnCount = 0;\n  for (const row of board) {\n    for (const piece of row) {\n      if (piece) {\n        pieceCount++;\n        if (piece.type === 'p') pawnCount++;\n      }\n    }\n  }\n  \n  // Opening\n  if (moveCount < 10) return 'opening';\n  \n  // Endgame\n  if (pieceCount <= 10) {\n    return Math.abs(eval_) > 200 ? 'endgame_winning' : 'endgame_drawing';\n  }\n  \n  // Critical position\n  if (Math.abs(eval_) > 500) return 'critical';\n  \n  // Tactical vs positional\n  if (analysis.evaluation.pv.length > 5 && \n      analysis.evaluation.pv.some(m => m.includes('x'))) {\n    return 'tactical';\n  }\n  \n  return 'positional';\n}\n\nfunction calculateDynamism(chess: Chess, analysis: PositionAnalysis): number {\n  const moves = chess.moves();\n  const captures = moves.filter(m => m.includes('x')).length;\n  const checks = moves.filter(m => m.includes('+')).length;\n  \n  // More captures and checks = more dynamic\n  const baseScore = (captures * 3 + checks * 5) / moves.length * 100;\n  \n  // High eval swing in PV = dynamic\n  const evalMagnitude = Math.min(Math.abs(analysis.evaluation.score) / 500, 1) * 30;\n  \n  return Math.min(100, baseScore + evalMagnitude);\n}\n\nfunction findCriticalSquares(chess: Chess, analysis: PositionAnalysis): string[] {\n  const critical: string[] = [];\n  \n  // Best move destination\n  if (analysis.bestMove) {\n    critical.push(analysis.bestMove.slice(2, 4));\n  }\n  \n  // Center squares that are contested\n  const centerSquares = ['d4', 'd5', 'e4', 'e5'];\n  for (const sq of centerSquares) {\n    const piece = chess.get(sq as Square);\n    if (!piece) {\n      // Empty center square - often critical\n      critical.push(sq);\n    }\n  }\n  \n  return [...new Set(critical)].slice(0, 6);\n}\n\nfunction convertUciToSan(chess: Chess, uci: string): string {\n  if (!uci || uci.length < 4) return uci;\n  \n  try {\n    const from = uci.slice(0, 2) as Square;\n    const to = uci.slice(2, 4) as Square;\n    const promotion = uci.length > 4 ? uci[4] : undefined;\n    \n    // Create a copy to test the move\n    const testChess = new Chess(chess.fen());\n    const move = testChess.move({ from, to, promotion });\n    \n    return move?.san || uci;\n  } catch {\n    return uci;\n  }\n}\n\nfunction generateMoveReasoning(\n  chess: Chess,\n  move: string,\n  before: PositionAnalysis,\n  after: PositionAnalysis\n): string[] {\n  const reasons: string[] = [];\n  \n  // Check if it's a capture\n  if (move.includes('x')) {\n    reasons.push('Captures material');\n  }\n  \n  // Check if it gives check\n  if (move.includes('+')) {\n    reasons.push('Gives check, forcing response');\n  }\n  \n  // Checkmate\n  if (move.includes('#')) {\n    reasons.push('Delivers checkmate');\n  }\n  \n  // Castling\n  if (move === 'O-O' || move === 'O-O-O') {\n    reasons.push('Improves king safety and connects rooks');\n  }\n  \n  // Pawn promotion\n  if (move.includes('=')) {\n    reasons.push('Promotes pawn to stronger piece');\n  }\n  \n  // Center control\n  if (move.includes('d4') || move.includes('d5') || \n      move.includes('e4') || move.includes('e5')) {\n    reasons.push('Controls central squares');\n  }\n  \n  // Eval improvement\n  const evalDiff = before.evaluation.score - (-after.evaluation.score);\n  if (evalDiff > 50) {\n    reasons.push('Significantly improves position');\n  }\n  \n  if (reasons.length === 0) {\n    reasons.push('Maintains positional advantage');\n  }\n  \n  return reasons;\n}\n\nfunction calculateConfidence(analysis: PositionAnalysis): number {\n  // Higher depth = higher confidence\n  const depthScore = Math.min(analysis.evaluation.depth / 20, 1) * 40;\n  \n  // Clear advantage = higher confidence\n  const evalScore = Math.min(Math.abs(analysis.evaluation.score) / 200, 1) * 30;\n  \n  // Longer PV = more confident\n  const pvScore = Math.min(analysis.evaluation.pv.length / 10, 1) * 30;\n  \n  return Math.round(depthScore + evalScore + pvScore);\n}\n\nfunction describeVisualImpact(chess: Chess, move: string): string {\n  try {\n    chess.move(move);\n    const pattern = predictVisualPattern(chess);\n    chess.undo();\n    \n    if (pattern.dominantColor === 'white') {\n      return 'Expands White\\'s visual territory';\n    } else if (pattern.dominantColor === 'black') {\n      return 'Expands Black\\'s visual territory';\n    }\n    \n    return 'Creates balanced visual tension';\n  } catch {\n    return 'Alters board dynamics';\n  }\n}\n\nfunction describePosition(chess: Chess, eval_: number): string {\n  if (chess.isCheckmate()) {\n    return 'Checkmate';\n  }\n  if (chess.isDraw()) {\n    return 'Draw';\n  }\n  \n  const absEval = Math.abs(eval_);\n  const advantage = eval_ > 0 ? 'White' : 'Black';\n  \n  if (absEval < 30) return 'Equal position';\n  if (absEval < 100) return `Slight ${advantage} advantage`;\n  if (absEval < 300) return `Clear ${advantage} advantage`;\n  if (absEval < 700) return `Winning for ${advantage}`;\n  return `Decisive ${advantage} advantage`;\n}\n\nfunction assessKingSafety(chess: Chess, color: 'w' | 'b'): number {\n  const kingSquare = findKing(chess, color);\n  if (!kingSquare) return 0;\n  \n  // Count pieces around king\n  const file = kingSquare.charCodeAt(0) - 97;\n  const rank = parseInt(kingSquare[1]) - 1;\n  \n  let safety = 50;\n  \n  // Pawns in front of king increase safety\n  const pawnRank = color === 'w' ? rank + 1 : rank - 1;\n  for (let f = Math.max(0, file - 1); f <= Math.min(7, file + 1); f++) {\n    const sq = (String.fromCharCode(97 + f) + (pawnRank + 1)) as Square;\n    const piece = chess.get(sq);\n    if (piece && piece.type === 'p' && piece.color === color) {\n      safety += 15;\n    }\n  }\n  \n  // King in center is less safe in middlegame\n  if (file >= 2 && file <= 5 && chess.history().length > 10) {\n    safety -= 20;\n  }\n  \n  return Math.max(0, Math.min(100, safety));\n}\n\nfunction findKing(chess: Chess, color: 'w' | 'b'): string | null {\n  const board = chess.board();\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      const piece = board[rank][file];\n      if (piece && piece.type === 'k' && piece.color === color) {\n        return String.fromCharCode(97 + file) + (8 - rank);\n      }\n    }\n  }\n  return null;\n}\n\n// Default export\nexport default analyzePositionPotential;\n";export{n as default};
