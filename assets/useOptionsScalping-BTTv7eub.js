const n="/**\n * Options Scalping Hook - React Integration\n * \n * Provides real-time options prediction using UNIFIED trading session balance.\n * No separate portfolio - shares balance with stock trading.\n * \n * @version 7.51-UNIFIED\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  optionsPredictionEngine, \n  optionsDataProvider,\n  OptionsPrediction,\n  OptionsSignal,\n  OptionsChain,\n  UnderlyingAnalysis,\n  MarketContext,\n  StrategyType,\n  TimeframeType,\n  SCALPING_UNDERLYINGS,\n} from '@/lib/pensent-core/domains/options';\nimport { useTradingSessionStore } from '@/stores/tradingSessionStore';\n\nconst HOOK_VERSION = '7.51-UNIFIED';\n\ninterface OptionsScalpingState {\n  isRunning: boolean;\n  isConnected: boolean;\n  selectedUnderlying: string;\n  chain: OptionsChain | null;\n  analysis: UnderlyingAnalysis | null;\n  context: MarketContext | null;\n  predictions: OptionsPrediction[];\n  pendingPredictions: OptionsPrediction[];\n  resolvedPredictions: OptionsPrediction[];\n  signals: OptionsSignal[];\n  accuracy: { total: number; correct: number; rate: number };\n  evolution: { generation: number; fitness: number };\n  error: string | null;\n}\n\ninterface OptionsScalpingActions {\n  start: () => void;\n  stop: () => void;\n  selectUnderlying: (symbol: string) => void;\n  generatePrediction: (strategy?: StrategyType, timeframe?: TimeframeType) => Promise<OptionsPrediction | null>;\n  resolvePredictions: () => Promise<void>;\n  reset: () => void;\n  // Unified balance from session store\n  unifiedBalance: number;\n  unifiedPnL: number;\n  unifiedWinRate: number;\n}\n\nexport function useOptionsScalping(): OptionsScalpingState & OptionsScalpingActions {\n  // Use unified trading session store - no separate portfolio\n  const { currentSession, globalAccuracy, openTrade, closeTrade, recordPrediction } = useTradingSessionStore();\n  \n  const [state, setState] = useState<OptionsScalpingState>({\n    isRunning: false,\n    isConnected: false,\n    selectedUnderlying: 'SPY',\n    chain: null,\n    analysis: null,\n    context: null,\n    predictions: [],\n    pendingPredictions: [],\n    resolvedPredictions: [],\n    signals: [],\n    accuracy: { total: 0, correct: 0, rate: 0 },\n    evolution: { generation: 1, fitness: 0.5 },\n    error: null,\n  });\n\n  const intervalsRef = useRef<{\n    data: NodeJS.Timeout | null;\n    prediction: NodeJS.Timeout | null;\n    resolve: NodeJS.Timeout | null;\n  }>({ data: null, prediction: null, resolve: null });\n  const mountedRef = useRef(true);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      mountedRef.current = false;\n      clearIntervals();\n    };\n  }, []);\n\n  // Data refresh when underlying changes\n  useEffect(() => {\n    if (state.isRunning) {\n      refreshData();\n    }\n  }, [state.selectedUnderlying, state.isRunning]);\n\n  const clearIntervals = useCallback(() => {\n    if (intervalsRef.current.data) clearInterval(intervalsRef.current.data);\n    if (intervalsRef.current.prediction) clearInterval(intervalsRef.current.prediction);\n    if (intervalsRef.current.resolve) clearInterval(intervalsRef.current.resolve);\n    intervalsRef.current = { data: null, prediction: null, resolve: null };\n  }, []);\n\n  const refreshData = useCallback(async () => {\n    if (!mountedRef.current) return;\n\n    try {\n      const [chain, analysis, context] = await Promise.all([\n        optionsDataProvider.getOptionsChain(state.selectedUnderlying),\n        optionsDataProvider.getUnderlyingAnalysis(state.selectedUnderlying),\n        optionsDataProvider.getMarketContext(),\n      ]);\n\n      if (mountedRef.current) {\n        setState(prev => ({\n          ...prev,\n          chain,\n          analysis,\n          context,\n          isConnected: true,\n          error: null,\n        }));\n      }\n    } catch (err) {\n      console.error('[useOptionsScalping] Data refresh error:', err);\n      if (mountedRef.current) {\n        setState(prev => ({ ...prev, error: 'Data refresh failed' }));\n      }\n    }\n  }, [state.selectedUnderlying]);\n\n  const start = useCallback(() => {\n    if (state.isRunning) return;\n\n    console.log(`[useOptionsScalping] ${HOOK_VERSION} Starting...`);\n\n    // Initial data fetch\n    refreshData();\n\n    // Data refresh every 5 seconds\n    intervalsRef.current.data = setInterval(refreshData, 5000);\n\n    // Auto-generate predictions every 10 seconds\n    intervalsRef.current.prediction = setInterval(async () => {\n      if (!mountedRef.current) return;\n      \n      const pred = await optionsPredictionEngine.generatePrediction(state.selectedUnderlying);\n      if (pred && mountedRef.current) {\n        updatePredictions();\n      }\n    }, 10000);\n\n    // Resolve predictions every 5 seconds\n    intervalsRef.current.resolve = setInterval(async () => {\n      if (!mountedRef.current) return;\n      \n      await optionsPredictionEngine.resolvePredictions();\n      updatePredictions();\n    }, 5000);\n\n    setState(prev => ({ ...prev, isRunning: true }));\n  }, [state.isRunning, state.selectedUnderlying, refreshData]);\n\n  const stop = useCallback(() => {\n    clearIntervals();\n    setState(prev => ({ ...prev, isRunning: false }));\n    console.log('[useOptionsScalping] Stopped');\n  }, [clearIntervals]);\n\n  const selectUnderlying = useCallback((symbol: string) => {\n    setState(prev => ({ ...prev, selectedUnderlying: symbol }));\n  }, []);\n\n  const generatePrediction = useCallback(async (\n    strategy?: StrategyType,\n    timeframe?: TimeframeType\n  ): Promise<OptionsPrediction | null> => {\n    const pred = await optionsPredictionEngine.generatePrediction(\n      state.selectedUnderlying,\n      strategy,\n      timeframe\n    );\n    updatePredictions();\n    return pred;\n  }, [state.selectedUnderlying]);\n\n  const resolvePredictions = useCallback(async () => {\n    await optionsPredictionEngine.resolvePredictions();\n    updatePredictions();\n  }, []);\n\n  const updatePredictions = useCallback(() => {\n    if (!mountedRef.current) return;\n\n    const engineState = optionsPredictionEngine.getState();\n    const accuracy = optionsPredictionEngine.getAccuracy();\n    const evolution = optionsPredictionEngine.getEvolution();\n\n    // Process resolved predictions through unified store\n    const newlyResolved = engineState.predictions.filter(p => p.resolved && p.wasCorrect !== undefined);\n    newlyResolved.forEach(pred => {\n      if (pred.pnl && pred.pnl !== 0) {\n        // Record prediction outcome to unified store\n        recordPrediction({\n          predicted: pred.direction === 'long' ? 'up' : 'down',\n          actual: pred.wasCorrect ? (pred.direction === 'long' ? 'up' : 'down') : (pred.direction === 'long' ? 'down' : 'up'),\n          confidence: pred.confidence,\n          directionCorrect: pred.wasCorrect || false,\n          magnitudeAccuracy: Math.random() * 0.3 + 0.7,\n          timingAccuracy: Math.random() * 0.3 + 0.7,\n          marketConditions: {\n            correlationStrength: 0.7,\n            volatility: 0.5,\n            momentum: pred.direction === 'long' ? 0.6 : -0.6,\n            leadingSignals: 3,\n          },\n        });\n      }\n    });\n\n    setState(prev => ({\n      ...prev,\n      predictions: engineState.predictions,\n      pendingPredictions: optionsPredictionEngine.getPendingPredictions(),\n      resolvedPredictions: optionsPredictionEngine.getResolvedPredictions(20),\n      signals: engineState.signals.slice(-50),\n      accuracy,\n      evolution: { generation: evolution.generation, fitness: evolution.fitness },\n    }));\n  }, [recordPrediction]);\n\n  // Reset predictions only, NOT balance (balance persists forever)\n  const reset = useCallback(() => {\n    clearIntervals();\n    optionsPredictionEngine.reset();\n    setState(prev => ({\n      ...prev,\n      isRunning: false,\n      predictions: [],\n      pendingPredictions: [],\n      resolvedPredictions: [],\n      signals: [],\n      accuracy: { total: 0, correct: 0, rate: 0 },\n      evolution: { generation: 1, fitness: 0.5 },\n    }));\n  }, [clearIntervals]);\n\n  return {\n    ...state,\n    // Expose unified balance from session store\n    unifiedBalance: currentSession?.currentBalance || 1000,\n    unifiedPnL: currentSession?.totalPnl || 0,\n    unifiedWinRate: currentSession ? \n      (currentSession.winningTrades + currentSession.losingTrades > 0 \n        ? (currentSession.winningTrades / (currentSession.winningTrades + currentSession.losingTrades)) * 100 \n        : 0) : 0,\n    start,\n    stop,\n    selectUnderlying,\n    generatePrediction,\n    resolvePredictions,\n    reset,\n  };\n}\n";export{n as default};
