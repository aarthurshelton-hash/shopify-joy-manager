const e="/**\n * Multi-Market Data Stream Hook\n * v7.51-REAL: 100% REAL DATA from Multi-Broker Aggregator\n * NO SIMULATED DATA - Uses Alpaca, Polygon, Binance, Finnhub, Twelve Data, Tradier\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { crossMarketEngine, type MarketTick, type AssetClass, type BigPictureState, type MarketSnapshot } from '@/lib/pensent-core/domains/finance/crossMarketEngine';\nimport { multiBrokerAdapter } from '@/lib/pensent-core/domains/universal/adapters/multiBrokerAdapter';\n\nexport interface MarketConfig {\n  symbol: string;\n  assetClass: AssetClass;\n  basePrice: number;\n  pollInterval: number; // v7.51: How often to fetch real data (ms)\n}\n\nconst DEFAULT_MARKETS: MarketConfig[] = [\n  { symbol: 'SPY', assetClass: 'equity', basePrice: 580, pollInterval: 2000 },\n  { symbol: 'QQQ', assetClass: 'equity', basePrice: 500, pollInterval: 2000 },\n  { symbol: 'TLT', assetClass: 'bond', basePrice: 95, pollInterval: 5000 },\n  { symbol: 'GLD', assetClass: 'commodity', basePrice: 240, pollInterval: 3000 },\n  { symbol: 'BTCUSD', assetClass: 'crypto', basePrice: 100000, pollInterval: 1000 },\n  { symbol: 'ETHUSD', assetClass: 'crypto', basePrice: 3500, pollInterval: 1000 },\n];\n\nexport interface MultiMarketState {\n  connected: boolean;\n  markets: MarketConfig[];\n  snapshot: MarketSnapshot;\n  bigPicture: BigPictureState;\n  ticksPerSecond: number;\n  realDataSources: string[];\n  consensusConfidence: number;\n  dataQuality: 'real' | 'stale' | 'disconnected';\n  lastRealTick: number;\n  failedFetches: number;\n  successfulFetches: number;\n}\n\nexport function useMultiMarketStream(markets: MarketConfig[] = DEFAULT_MARKETS) {\n  const [state, setState] = useState<MultiMarketState>({\n    connected: false,\n    markets,\n    snapshot: {\n      equity: null,\n      bond: null,\n      future: null,\n      commodity: null,\n      forex: null,\n      crypto: null\n    },\n    bigPicture: crossMarketEngine.getState(),\n    ticksPerSecond: 0,\n    realDataSources: [],\n    consensusConfidence: 0,\n    dataQuality: 'disconnected',\n    lastRealTick: 0,\n    failedFetches: 0,\n    successfulFetches: 0\n  });\n\n  const pricesRef = useRef<Map<string, number>>(new Map());\n  const intervalsRef = useRef<NodeJS.Timeout[]>([]);\n  const tickCountRef = useRef(0);\n  const tpsIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const mountedRef = useRef(true);\n  const isStartedRef = useRef(false);\n\n  // Convert asset class to multi-broker format\n  const assetClassToBrokerType = (assetClass: AssetClass): 'stock' | 'forex' | 'crypto' => {\n    switch (assetClass) {\n      case 'equity': return 'stock';\n      case 'forex': return 'forex';\n      case 'crypto': return 'crypto';\n      case 'future':\n      case 'commodity': \n      case 'bond':\n      default: return 'stock';\n    }\n  };\n\n  // Fetch ONLY real data from multi-broker aggregator - NO FALLBACKS\n  const fetchRealData = useCallback(async (market: MarketConfig): Promise<MarketTick | null> => {\n    try {\n      const brokerType = assetClassToBrokerType(market.assetClass);\n      const data = await multiBrokerAdapter.fetchAggregatedData(market.symbol, brokerType);\n      \n      if (!data || !data.consensus.price || data.sources.length === 0) {\n        console.warn(`[MultiMarketStream] No real data for ${market.symbol}`);\n        setState(prev => ({\n          ...prev,\n          failedFetches: prev.failedFetches + 1,\n          dataQuality: Date.now() - prev.lastRealTick > 30000 ? 'stale' : prev.dataQuality\n        }));\n        return null;\n      }\n\n      const previousPrice = pricesRef.current.get(market.symbol) || market.basePrice;\n      const change = data.consensus.price - previousPrice;\n      const changePercent = previousPrice > 0 ? (change / previousPrice) * 100 : 0;\n\n      pricesRef.current.set(market.symbol, data.consensus.price);\n\n      // Update state with REAL data confirmation\n      setState(prev => ({\n        ...prev,\n        realDataSources: data.sources,\n        consensusConfidence: data.consensus.confidence,\n        dataQuality: 'real',\n        lastRealTick: Date.now(),\n        successfulFetches: prev.successfulFetches + 1\n      }));\n\n      return {\n        symbol: market.symbol,\n        assetClass: market.assetClass,\n        price: data.consensus.price,\n        change: Math.round(change * 100) / 100,\n        changePercent: Math.round(changePercent * 10000) / 10000,\n        volume: data.ticks.reduce((sum, t) => sum + (t.volume || 0), 0),\n        timestamp: data.timestamp\n      };\n    } catch (error) {\n      console.error(`[MultiMarketStream] Failed to fetch ${market.symbol}:`, error);\n      setState(prev => ({\n        ...prev,\n        failedFetches: prev.failedFetches + 1\n      }));\n      return null;\n    }\n  }, []);\n\n  // v7.51-REAL: REMOVED generateSimulatedTick - no simulation allowed\n\n  const startStreams = useCallback(() => {\n    if (isStartedRef.current) return;\n    \n    intervalsRef.current.forEach(clearInterval);\n    intervalsRef.current = [];\n\n    console.log('[MultiMarketStream] Starting REAL-ONLY data streams (v7.51-REAL)...');\n    isStartedRef.current = true;\n\n    // Initialize adapter\n    multiBrokerAdapter.initialize();\n\n    // Initial fetch of real data for all markets\n    const initializeRealData = async () => {\n      console.log('[MultiMarketStream] Fetching initial real data...');\n      let hasData = false;\n      \n      for (const market of markets) {\n        const tick = await fetchRealData(market);\n        if (tick && mountedRef.current) {\n          hasData = true;\n          tickCountRef.current++;\n          crossMarketEngine.processTick(tick);\n        }\n      }\n      \n      if (mountedRef.current) {\n        const initialSnapshot = crossMarketEngine.getSnapshot();\n        const initialBigPicture = crossMarketEngine.getState();\n        setState(prev => ({\n          ...prev,\n          connected: hasData,\n          snapshot: initialSnapshot,\n          bigPicture: initialBigPicture\n        }));\n      }\n    };\n\n    initializeRealData();\n\n    // Set up real data polling for each market at their configured intervals\n    markets.forEach(market => {\n      const realInterval = setInterval(async () => {\n        if (!mountedRef.current) return;\n        \n        try {\n          const tick = await fetchRealData(market);\n          if (tick) {\n            tickCountRef.current++;\n            const bigPicture = crossMarketEngine.processTick(tick);\n            const snapshot = crossMarketEngine.getSnapshot();\n            \n            setState(prev => ({\n              ...prev,\n              connected: true,\n              snapshot,\n              bigPicture\n            }));\n          }\n        } catch (error) {\n          console.error('[MultiMarketStream] Real data fetch error:', error);\n        }\n      }, market.pollInterval);\n      \n      intervalsRef.current.push(realInterval);\n    });\n\n    console.log('[MultiMarketStream] Real-only streams started (no simulation)');\n  }, [markets, fetchRealData]);\n\n  // Track TPS\n  useEffect(() => {\n    tpsIntervalRef.current = setInterval(() => {\n      if (mountedRef.current) {\n        setState(prev => ({\n          ...prev,\n          ticksPerSecond: tickCountRef.current\n        }));\n        tickCountRef.current = 0;\n      }\n    }, 1000);\n\n    return () => {\n      if (tpsIntervalRef.current) {\n        clearInterval(tpsIntervalRef.current);\n      }\n    };\n  }, []);\n\n  // Start streams on mount\n  useEffect(() => {\n    mountedRef.current = true;\n    \n    const startTimer = setTimeout(() => {\n      startStreams();\n    }, 50);\n\n    return () => {\n      mountedRef.current = false;\n      clearTimeout(startTimer);\n      intervalsRef.current.forEach(clearInterval);\n      intervalsRef.current = [];\n      isStartedRef.current = false;\n      setState(prev => ({ ...prev, connected: false }));\n    };\n  }, [startStreams]);\n\n  const disconnect = useCallback(() => {\n    intervalsRef.current.forEach(clearInterval);\n    intervalsRef.current = [];\n    isStartedRef.current = false;\n    setState(prev => ({ ...prev, connected: false, dataQuality: 'disconnected' }));\n  }, []);\n\n  const reconnect = useCallback(() => {\n    disconnect();\n    setTimeout(() => {\n      isStartedRef.current = false;\n      startStreams();\n    }, 100);\n  }, [disconnect, startStreams]);\n\n  const getDataIntegrityScore = useCallback(() => {\n    const { successfulFetches, failedFetches, lastRealTick } = state;\n    const totalFetches = successfulFetches + failedFetches;\n    if (totalFetches === 0) return 0;\n    \n    const successRate = successfulFetches / totalFetches;\n    const freshnessScore = Math.max(0, 1 - (Date.now() - lastRealTick) / 60000);\n    \n    return Math.round((successRate * 0.7 + freshnessScore * 0.3) * 100);\n  }, [state]);\n\n  return {\n    ...state,\n    disconnect,\n    reconnect,\n    getDataIntegrityScore,\n    isRealData: state.dataQuality === 'real' && state.realDataSources.length > 0\n  };\n}\n";export{e as default};
