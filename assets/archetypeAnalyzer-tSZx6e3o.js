const n="/**\n * Archetype Analysis for Imported Games\n * Matches historical games to En Pensent pattern library\n * Refactored to use modular signature extraction\n */\n\nimport { Chess } from 'chess.js';\nimport { classifyUniversalArchetype } from '@/lib/pensent-core/archetype/universalClassifier';\nimport type { TemporalSignature } from '@/lib/pensent-core/types/core';\nimport type { LichessGame } from './lichessApi';\nimport type { ChessComGame } from './chesscomApi';\nimport { extractChessSignature, extractMovesFromPgn } from './signatureExtractor';\n\n// ===================== TYPES =====================\n\nexport interface AnalyzedGame {\n  id: string;\n  source: 'lichess' | 'chesscom';\n  pgn: string;\n  white: string;\n  black: string;\n  result: string;\n  opening?: { eco: string; name: string };\n  playedAt: Date;\n  signature: TemporalSignature;\n  archetype: string;\n  moveCount: number;\n}\n\nexport interface ArchetypeDistribution {\n  archetype: string;\n  count: number;\n  percentage: number;\n  winRate: number;\n  avgIntensity: number;\n}\n\nexport interface GameAnalysisResult {\n  games: AnalyzedGame[];\n  totalAnalyzed: number;\n  archetypeDistribution: ArchetypeDistribution[];\n  dominantArchetype: string;\n  avgIntensity: number;\n  winRateByArchetype: Record<string, number>;\n}\n\n// ===================== GAME ANALYSIS =====================\n\n/**\n * Parse moves from a game and extract move history\n */\nfunction parseMoves(moves: string[]): Array<{ from: string; to: string; san: string }> | null {\n  if (moves.length < 10) return null;\n\n  const chess = new Chess();\n  const moveHistory: Array<{ from: string; to: string; san: string }> = [];\n  \n  for (const move of moves) {\n    try {\n      const result = chess.move(move);\n      if (result) {\n        moveHistory.push({ from: result.from, to: result.to, san: result.san });\n      }\n    } catch {\n      break;\n    }\n  }\n\n  return moveHistory.length >= 10 ? moveHistory : null;\n}\n\n/**\n * Analyze a Lichess game and extract signature\n */\nexport function analyzeLichessGame(game: LichessGame): AnalyzedGame | null {\n  try {\n    const moves = game.moves ? game.moves.split(' ') : [];\n    const moveHistory = parseMoves(moves);\n    if (!moveHistory) return null;\n\n    const chess = new Chess();\n    moves.forEach(m => { try { chess.move(m); } catch {} });\n\n    const signature = extractChessSignature(moveHistory, chess.fen());\n    const archetype = classifyUniversalArchetype(signature);\n    signature.archetype = archetype;\n\n    return {\n      id: game.id,\n      source: 'lichess',\n      pgn: game.pgn || '',\n      white: game.players.white.user?.name || 'Anonymous',\n      black: game.players.black.user?.name || 'Anonymous',\n      result: game.winner === 'white' ? '1-0' : game.winner === 'black' ? '0-1' : '1/2-1/2',\n      opening: game.opening ? { eco: game.opening.eco, name: game.opening.name } : undefined,\n      playedAt: new Date(game.createdAt),\n      signature,\n      archetype,\n      moveCount: moveHistory.length\n    };\n  } catch (error) {\n    console.error('Failed to analyze Lichess game:', game.id, error);\n    return null;\n  }\n}\n\n/**\n * Analyze a Chess.com game and extract signature\n */\nexport function analyzeChessComGame(game: ChessComGame): AnalyzedGame | null {\n  try {\n    const moves = extractMovesFromPgn(game.pgn);\n    const moveHistory = parseMoves(moves);\n    if (!moveHistory) return null;\n\n    const chess = new Chess();\n    moves.forEach(m => { try { chess.move(m); } catch {} });\n\n    const signature = extractChessSignature(moveHistory, chess.fen());\n    const archetype = classifyUniversalArchetype(signature);\n    signature.archetype = archetype;\n\n    const ecoMatch = game.pgn.match(/\\[ECO \"([^\"]+)\"\\]/);\n    const openingMatch = game.pgn.match(/\\[Opening \"([^\"]+)\"\\]/);\n\n    return {\n      id: game.url,\n      source: 'chesscom',\n      pgn: game.pgn,\n      white: game.white.username,\n      black: game.black.username,\n      result: game.white.result === 'win' ? '1-0' : game.black.result === 'win' ? '0-1' : '1/2-1/2',\n      opening: ecoMatch ? { eco: ecoMatch[1], name: openingMatch?.[1] || 'Unknown' } : undefined,\n      playedAt: new Date(game.end_time * 1000),\n      signature,\n      archetype,\n      moveCount: moveHistory.length\n    };\n  } catch (error) {\n    console.error('Failed to analyze Chess.com game:', game.url, error);\n    return null;\n  }\n}\n\n// ===================== BATCH ANALYSIS =====================\n\n/**\n * Analyze multiple games and compute distributions\n */\nexport function analyzeGameBatch(games: AnalyzedGame[]): GameAnalysisResult {\n  const archetypeCounts: Record<string, { count: number; wins: number; intensitySum: number }> = {};\n  \n  for (const game of games) {\n    if (!archetypeCounts[game.archetype]) {\n      archetypeCounts[game.archetype] = { count: 0, wins: 0, intensitySum: 0 };\n    }\n    archetypeCounts[game.archetype].count++;\n    archetypeCounts[game.archetype].intensitySum += game.signature.intensity;\n    \n    if (game.result === '1-0' || game.result === '0-1') {\n      archetypeCounts[game.archetype].wins++;\n    }\n  }\n\n  const total = games.length;\n  const archetypeDistribution: ArchetypeDistribution[] = Object.entries(archetypeCounts)\n    .map(([archetype, data]) => ({\n      archetype,\n      count: data.count,\n      percentage: (data.count / total) * 100,\n      winRate: (data.wins / data.count) * 100,\n      avgIntensity: data.intensitySum / data.count\n    }))\n    .sort((a, b) => b.count - a.count);\n\n  const dominantArchetype = archetypeDistribution[0]?.archetype || 'unknown';\n  const avgIntensity = games.reduce((sum, g) => sum + g.signature.intensity, 0) / total;\n\n  const winRateByArchetype: Record<string, number> = {};\n  for (const dist of archetypeDistribution) {\n    winRateByArchetype[dist.archetype] = dist.winRate;\n  }\n\n  return {\n    games,\n    totalAnalyzed: total,\n    archetypeDistribution,\n    dominantArchetype,\n    avgIntensity,\n    winRateByArchetype\n  };\n}\n";export{n as default};
