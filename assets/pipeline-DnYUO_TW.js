const n="/**\n * En Pensent Core SDK - Pipeline & Middleware\n * \n * Composable pipeline architecture for processing patterns.\n * Supports middleware for extending SDK functionality.\n */\n\nimport { \n  TemporalSignature, \n  PatternMatch, \n  TrajectoryPrediction,\n  DomainAdapter \n} from './types';\nimport { PensentEventBus, createEventBus } from './eventBus';\nimport { createCacheBundle } from './cache';\n\n// ===================== PIPELINE TYPES =====================\n\n/**\n * Context passed through the pipeline\n */\nexport interface PipelineContext<TInput = unknown> {\n  /** Original input */\n  input: TInput;\n  /** Extracted signature (populated after extraction step) */\n  signature?: TemporalSignature;\n  /** Pattern matches (populated after matching step) */\n  matches?: PatternMatch[];\n  /** Trajectory prediction (populated after prediction step) */\n  prediction?: TrajectoryPrediction;\n  /** Custom metadata added by middleware */\n  metadata: Record<string, unknown>;\n  /** Timing information */\n  timing: {\n    startTime: number;\n    extractionTime?: number;\n    matchingTime?: number;\n    predictionTime?: number;\n    totalTime?: number;\n  };\n  /** Error information if any step failed */\n  error?: Error;\n  /** Whether to skip remaining steps */\n  skipRemaining?: boolean;\n}\n\n/**\n * Middleware function signature\n */\nexport type PipelineMiddleware<TInput = unknown> = (\n  context: PipelineContext<TInput>,\n  next: () => Promise<void>\n) => Promise<void>;\n\n/**\n * Pipeline step definition\n */\nexport interface PipelineStep<TInput = unknown> {\n  name: string;\n  execute: (context: PipelineContext<TInput>) => Promise<void>;\n  condition?: (context: PipelineContext<TInput>) => boolean;\n}\n\n// ===================== PIPELINE IMPLEMENTATION =====================\n\n/**\n * Composable analysis pipeline\n */\nexport class AnalysisPipeline<TInput, TState> {\n  private steps: PipelineStep<TInput>[] = [];\n  private middleware: PipelineMiddleware<TInput>[] = [];\n  private adapter: DomainAdapter<TInput, TState>;\n  private eventBus: PensentEventBus;\n  private cache = createCacheBundle();\n\n  constructor(adapter: DomainAdapter<TInput, TState>) {\n    this.adapter = adapter;\n    this.eventBus = createEventBus(adapter.domain);\n    this.initializeDefaultSteps();\n  }\n\n  /**\n   * Initialize default pipeline steps\n   */\n  private initializeDefaultSteps(): void {\n    // Step 1: Extract signature\n    this.addStep({\n      name: 'extract',\n      execute: async (ctx) => {\n        const start = performance.now();\n        const states = this.adapter.parseInput(ctx.input);\n        ctx.signature = this.adapter.extractSignature(states);\n        ctx.timing.extractionTime = performance.now() - start;\n        \n        this.eventBus.emit('signature:extracted', {\n          signature: ctx.signature,\n          inputHash: ctx.signature.fingerprint,\n          extractionTimeMs: ctx.timing.extractionTime\n        });\n      }\n    });\n\n    // Step 2: Classify archetype\n    this.addStep({\n      name: 'classify',\n      execute: async (ctx) => {\n        if (!ctx.signature) return;\n        \n        const archetype = this.adapter.classifyArchetype(ctx.signature);\n        ctx.signature = { ...ctx.signature, archetype };\n        \n        this.eventBus.emit('archetype:classified', {\n          archetype,\n          fingerprint: ctx.signature.fingerprint\n        });\n      }\n    });\n  }\n\n  /**\n   * Add a step to the pipeline\n   */\n  addStep(step: PipelineStep<TInput>): this {\n    this.steps.push(step);\n    return this;\n  }\n\n  /**\n   * Insert a step at a specific position\n   */\n  insertStep(index: number, step: PipelineStep<TInput>): this {\n    this.steps.splice(index, 0, step);\n    return this;\n  }\n\n  /**\n   * Add middleware to the pipeline\n   */\n  use(middleware: PipelineMiddleware<TInput>): this {\n    this.middleware.push(middleware);\n    return this;\n  }\n\n  /**\n   * Execute the pipeline\n   */\n  async execute(input: TInput): Promise<PipelineContext<TInput>> {\n    const context: PipelineContext<TInput> = {\n      input,\n      metadata: {},\n      timing: { startTime: performance.now() }\n    };\n\n    try {\n      // Build middleware chain\n      const chain = this.buildMiddlewareChain(context);\n      await chain();\n      \n      context.timing.totalTime = performance.now() - context.timing.startTime;\n    } catch (error) {\n      context.error = error instanceof Error ? error : new Error(String(error));\n      this.eventBus.emit('error:extraction', {\n        error: context.error,\n        context: 'pipeline',\n        recoverable: false\n      });\n    }\n\n    return context;\n  }\n\n  /**\n   * Build the middleware chain\n   */\n  private buildMiddlewareChain(context: PipelineContext<TInput>): () => Promise<void> {\n    let index = 0;\n    const middlewareList = [...this.middleware];\n    \n    const runNext = async (): Promise<void> => {\n      if (context.skipRemaining) return;\n      \n      if (index < middlewareList.length) {\n        const middleware = middlewareList[index++];\n        await middleware(context, runNext);\n      } else {\n        // Run pipeline steps after all middleware\n        await this.executeSteps(context);\n      }\n    };\n    \n    return runNext;\n  }\n\n  /**\n   * Execute all pipeline steps\n   */\n  private async executeSteps(context: PipelineContext<TInput>): Promise<void> {\n    for (const step of this.steps) {\n      if (context.skipRemaining) break;\n      \n      // Check condition if present\n      if (step.condition && !step.condition(context)) {\n        continue;\n      }\n      \n      await step.execute(context);\n    }\n  }\n\n  /**\n   * Get the event bus for subscribing to events\n   */\n  getEventBus(): PensentEventBus {\n    return this.eventBus;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    return this.cache.getStats();\n  }\n\n  /**\n   * Clear all caches\n   */\n  clearCache(): void {\n    this.cache.clearAll();\n  }\n}\n\n// ===================== BUILT-IN MIDDLEWARE =====================\n\n/**\n * Logging middleware - logs each step execution\n */\nexport function loggingMiddleware<TInput>(): PipelineMiddleware<TInput> {\n  return async (ctx, next) => {\n    console.log(`[Pipeline] Starting analysis for input`);\n    const start = performance.now();\n    \n    await next();\n    \n    const duration = performance.now() - start;\n    console.log(`[Pipeline] Analysis complete in ${duration.toFixed(2)}ms`);\n    if (ctx.signature) {\n      console.log(`[Pipeline] Archetype: ${ctx.signature.archetype}`);\n    }\n    if (ctx.error) {\n      console.error(`[Pipeline] Error:`, ctx.error);\n    }\n  };\n}\n\n/**\n * Validation middleware - validates input before processing\n */\nexport function validationMiddleware<TInput>(\n  validator: (input: TInput) => boolean | string\n): PipelineMiddleware<TInput> {\n  return async (ctx, next) => {\n    const result = validator(ctx.input);\n    \n    if (result === false) {\n      ctx.error = new Error('Input validation failed');\n      ctx.skipRemaining = true;\n      return;\n    }\n    \n    if (typeof result === 'string') {\n      ctx.error = new Error(result);\n      ctx.skipRemaining = true;\n      return;\n    }\n    \n    await next();\n  };\n}\n\n/**\n * Caching middleware - caches results for repeated inputs\n */\nexport function cachingMiddleware<TInput>(\n  keyGenerator: (input: TInput) => string\n): PipelineMiddleware<TInput> {\n  const cache = new Map<string, TemporalSignature>();\n  \n  return async (ctx, next) => {\n    const key = keyGenerator(ctx.input);\n    \n    if (cache.has(key)) {\n      ctx.signature = cache.get(key);\n      ctx.metadata.fromCache = true;\n      return; // Skip remaining steps\n    }\n    \n    await next();\n    \n    if (ctx.signature) {\n      cache.set(key, ctx.signature);\n    }\n  };\n}\n\n/**\n * Retry middleware - retries failed steps\n */\nexport function retryMiddleware<TInput>(\n  maxRetries: number = 3,\n  delayMs: number = 100\n): PipelineMiddleware<TInput> {\n  return async (ctx, next) => {\n    let lastError: Error | undefined;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        await next();\n        return; // Success\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        \n        if (attempt < maxRetries) {\n          await new Promise(resolve => setTimeout(resolve, delayMs * attempt));\n        }\n      }\n    }\n    \n    ctx.error = lastError;\n    ctx.skipRemaining = true;\n  };\n}\n\n/**\n * Timeout middleware - fails if processing takes too long\n */\nexport function timeoutMiddleware<TInput>(\n  timeoutMs: number\n): PipelineMiddleware<TInput> {\n  return async (ctx, next) => {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(`Pipeline timeout after ${timeoutMs}ms`)), timeoutMs);\n    });\n    \n    try {\n      await Promise.race([next(), timeoutPromise]);\n    } catch (error) {\n      ctx.error = error instanceof Error ? error : new Error(String(error));\n      ctx.skipRemaining = true;\n    }\n  };\n}\n\n// ===================== FACTORY FUNCTIONS =====================\n\n/**\n * Create a new analysis pipeline\n */\nexport function createPipeline<TInput, TState>(\n  adapter: DomainAdapter<TInput, TState>\n): AnalysisPipeline<TInput, TState> {\n  return new AnalysisPipeline(adapter);\n}\n";export{n as default};
