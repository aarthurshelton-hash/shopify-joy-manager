const e="import { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\nimport { SimulationResult } from '@/lib/chess/gameSimulator';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { GamePhase } from '@/contexts/TimelineContext';\n\n/**\n * Session Store - Persists visualization and navigation state across page navigations\n * This enables full \"backtrack restoration\" - clicking back restores exact board state\n */\n\nexport interface CreativeModeTransfer {\n  board: (string | null)[][];\n  whitePalette: Record<PieceType, string>;\n  blackPalette: Record<PieceType, string>;\n  title: string;\n  sourceVisualizationId?: string;\n}\n\nexport interface CapturedTimelineState {\n  currentMove: number;\n  totalMoves?: number;\n  title?: string;\n  lockedPieces: Array<{ pieceType: PieceType; pieceColor: PieceColor }>;\n  compareMode: boolean;\n  darkMode: boolean;\n  showPieces?: boolean;\n  pieceOpacity?: number;\n}\n\n/**\n * Full visualization state for backtrack restoration\n * Captures every aspect of the board's visual configuration\n */\nexport interface FullVisualizationState {\n  // Timeline state\n  currentMove: number;\n  selectedPhase: GamePhase;\n  isPlaying: boolean;\n  \n  // Legend state\n  lockedPieces: Array<{ pieceType: PieceType; pieceColor: PieceColor }>;\n  compareMode: boolean;\n  highlightedPiece: { pieceType: PieceType; pieceColor: PieceColor } | null;\n  \n  // Display modes\n  displayMode: 'art' | 'analysis' | 'minimal';\n  darkMode: boolean;\n  \n  // Territory/heatmap modes\n  showTerritory: boolean;\n  showHeatmaps: boolean;\n  \n  // Show pieces overlay\n  showPieces: boolean;\n  pieceOpacity: number;\n  \n  // Captured timestamp\n  capturedAt: number;\n  \n  // Source identifier (for matching on restore)\n  sourceRoute: string;\n  visualizationId?: string;\n  pgn?: string;\n}\n\ninterface SessionState {\n  // Current visualization context\n  currentSimulation: SimulationResult | null;\n  currentPgn: string;\n  currentGameTitle: string;\n  savedShareId: string | null;\n  \n  // Captured timeline state for exact visual restoration\n  capturedTimelineState: CapturedTimelineState | null;\n  \n  // Full visualization state stack for backtrack restoration\n  visualizationStateStack: FullVisualizationState[];\n  \n  // Creative mode transfer data\n  creativeModeTransfer: CreativeModeTransfer | null;\n  \n  // Navigation history\n  previousRoute: string | null;\n  navigationStack: string[];\n  \n  // Flag to indicate we're returning from order page\n  returningFromOrder: boolean;\n  \n  // Actions\n  setCurrentSimulation: (simulation: SimulationResult | null, pgn?: string, title?: string) => void;\n  setSavedShareId: (shareId: string | null) => void;\n  setCapturedTimelineState: (state: CapturedTimelineState | null) => void;\n  setReturningFromOrder: (returning: boolean) => void;\n  clearSimulation: () => void;\n  \n  // Full visualization state for backtrack\n  pushVisualizationState: (state: FullVisualizationState) => void;\n  popVisualizationState: () => FullVisualizationState | null;\n  peekVisualizationState: () => FullVisualizationState | null;\n  getVisualizationStateForRoute: (route: string) => FullVisualizationState | null;\n  clearVisualizationStateStack: () => void;\n  \n  // Creative mode transfer\n  setCreativeModeTransfer: (data: CreativeModeTransfer | null) => void;\n  clearCreativeModeTransfer: () => void;\n  \n  // Navigation tracking\n  pushRoute: (route: string) => void;\n  popRoute: () => string | null;\n  setPreviousRoute: (route: string | null) => void;\n  \n  // Full reset\n  clearSession: () => void;\n}\n\n// Synchronous storage wrapper that writes immediately\nconst syncSessionStorage = {\n  getItem: (name: string): string | null => {\n    return sessionStorage.getItem(name);\n  },\n  setItem: (name: string, value: string): void => {\n    sessionStorage.setItem(name, value);\n  },\n  removeItem: (name: string): void => {\n    sessionStorage.removeItem(name);\n  },\n};\n\nexport const useSessionStore = create<SessionState>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      currentSimulation: null,\n      currentPgn: '',\n      currentGameTitle: '',\n      savedShareId: null,\n      capturedTimelineState: null,\n      visualizationStateStack: [],\n      creativeModeTransfer: null,\n      previousRoute: null,\n      navigationStack: [],\n      returningFromOrder: false,\n      \n      // Set current visualization\n      setCurrentSimulation: (simulation, pgn = '', title = '') => {\n        // Get existing state BEFORE the set call\n        const existingState = get();\n        \n        // Build the complete data to store FIRST (before set)\n        const dataToStore = {\n          state: {\n            currentSimulation: simulation,\n            currentPgn: pgn,\n            currentGameTitle: title,\n            savedShareId: existingState.savedShareId,\n            capturedTimelineState: existingState.capturedTimelineState,\n            visualizationStateStack: existingState.visualizationStateStack,\n            creativeModeTransfer: existingState.creativeModeTransfer,\n            previousRoute: existingState.previousRoute,\n            navigationStack: existingState.navigationStack,\n            returningFromOrder: existingState.returningFromOrder,\n          },\n          version: 0,\n        };\n        \n        // Write to sessionStorage SYNCHRONOUSLY FIRST\n        sessionStorage.setItem('en-pensent-session', JSON.stringify(dataToStore));\n        \n        // Then update Zustand state (this may be async internally)\n        set({\n          currentSimulation: simulation,\n          currentPgn: pgn,\n          currentGameTitle: title,\n        });\n      },\n      \n      setSavedShareId: (shareId) => set({ savedShareId: shareId }),\n      \n      setCapturedTimelineState: (state) => set({ capturedTimelineState: state }),\n      \n      setReturningFromOrder: (returning) => set({ returningFromOrder: returning }),\n      \n      clearSimulation: () => set({\n        currentSimulation: null,\n        currentPgn: '',\n        currentGameTitle: '',\n        savedShareId: null,\n        capturedTimelineState: null,\n        returningFromOrder: false,\n      }),\n      \n      // Full visualization state stack management\n      pushVisualizationState: (state) => set((prev) => {\n        // Limit stack size to prevent memory bloat (keep last 10)\n        const newStack = [...prev.visualizationStateStack, state].slice(-10);\n        return { visualizationStateStack: newStack };\n      }),\n      \n      popVisualizationState: () => {\n        const state = get();\n        if (state.visualizationStateStack.length === 0) return null;\n        \n        const newStack = [...state.visualizationStateStack];\n        const popped = newStack.pop() || null;\n        set({ visualizationStateStack: newStack });\n        return popped;\n      },\n      \n      peekVisualizationState: () => {\n        const state = get();\n        if (state.visualizationStateStack.length === 0) return null;\n        return state.visualizationStateStack[state.visualizationStateStack.length - 1];\n      },\n      \n      getVisualizationStateForRoute: (route: string) => {\n        const state = get();\n        // Find the most recent state for this route\n        for (let i = state.visualizationStateStack.length - 1; i >= 0; i--) {\n          if (state.visualizationStateStack[i].sourceRoute === route) {\n            return state.visualizationStateStack[i];\n          }\n        }\n        return null;\n      },\n      \n      clearVisualizationStateStack: () => set({ visualizationStateStack: [] }),\n      \n      // Creative mode transfer\n      setCreativeModeTransfer: (data) => set({ creativeModeTransfer: data }),\n      clearCreativeModeTransfer: () => set({ creativeModeTransfer: null }),\n      \n      // Navigation tracking\n      pushRoute: (route) => set((state) => ({\n        navigationStack: [...state.navigationStack, route],\n        previousRoute: state.navigationStack.length > 0 \n          ? state.navigationStack[state.navigationStack.length - 1] \n          : null,\n      })),\n      \n      popRoute: () => {\n        const state = get();\n        if (state.navigationStack.length === 0) return null;\n        \n        const newStack = [...state.navigationStack];\n        const poppedRoute = newStack.pop() || null;\n        \n        set({\n          navigationStack: newStack,\n          previousRoute: newStack.length > 0 ? newStack[newStack.length - 1] : null,\n        });\n        \n        return poppedRoute;\n      },\n      \n      setPreviousRoute: (route) => set({ previousRoute: route }),\n      \n      clearSession: () => set({\n        currentSimulation: null,\n        currentPgn: '',\n        currentGameTitle: '',\n        savedShareId: null,\n        capturedTimelineState: null,\n        visualizationStateStack: [],\n        creativeModeTransfer: null,\n        previousRoute: null,\n        navigationStack: [],\n        returningFromOrder: false,\n      }),\n    }),\n    {\n      name: 'en-pensent-session',\n      storage: createJSONStorage(() => syncSessionStorage),\n      partialize: (state) => ({\n        // Persist simulation for navigation back to visualization\n        currentSimulation: state.currentSimulation,\n        currentPgn: state.currentPgn,\n        currentGameTitle: state.currentGameTitle,\n        savedShareId: state.savedShareId,\n        capturedTimelineState: state.capturedTimelineState,\n        visualizationStateStack: state.visualizationStateStack,\n        creativeModeTransfer: state.creativeModeTransfer,\n        previousRoute: state.previousRoute,\n        navigationStack: state.navigationStack,\n        returningFromOrder: state.returningFromOrder,\n      }),\n    }\n  )\n);";export{e as default};
