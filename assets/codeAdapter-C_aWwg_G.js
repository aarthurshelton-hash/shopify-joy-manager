const n="/**\n * En Pensent Code - Domain Adapter\n * \n * Implements the DomainAdapter interface for code analysis\n */\n\nimport {\n  DomainAdapter,\n  TemporalSignature,\n  ArchetypeRegistry,\n  ArchetypeDefinition\n} from '../pensent-core/types';\nimport { calculateSignatureSimilarity } from '../pensent-core/patternMatcher';\nimport {\n  CodeCommit,\n  CodeFlowSignature,\n  CodeArchetype,\n  CODE_ARCHETYPE_DEFINITIONS\n} from './types';\nimport { extractCodeFlowSignature } from './codeFlowSignature';\n\n/**\n * Input format for code analysis\n */\nexport interface CodeInput {\n  commits: CodeCommit[];\n  metadata?: {\n    repoName?: string;\n    primaryLanguage?: string;\n    repoUrl?: string;\n  };\n}\n\n/**\n * Code state represents the codebase at a point in time\n */\nexport interface CodeState {\n  commitIndex: number;\n  commit: CodeCommit;\n  cumulativeAdditions: number;\n  cumulativeDeletions: number;\n  activeFiles: Set<string>;\n}\n\n/**\n * Code Domain Adapter for En Pensent\n */\nexport const codeDomainAdapter: DomainAdapter<CodeInput, CodeState> = {\n  domain: 'code',\n  \n  /**\n   * Parse commits into sequence of states\n   */\n  parseInput(input: CodeInput): CodeState[] {\n    const states: CodeState[] = [];\n    let cumulativeAdditions = 0;\n    let cumulativeDeletions = 0;\n    const activeFiles = new Set<string>();\n    \n    // Sort commits by timestamp\n    const sortedCommits = [...input.commits].sort((a, b) => \n      a.timestamp.getTime() - b.timestamp.getTime()\n    );\n    \n    for (let i = 0; i < sortedCommits.length; i++) {\n      const commit = sortedCommits[i];\n      \n      cumulativeAdditions += commit.additions;\n      cumulativeDeletions += commit.deletions;\n      \n      // Track active files\n      for (const file of commit.filesChanged) {\n        if (file.changeType === 'deleted') {\n          activeFiles.delete(file.path);\n        } else {\n          activeFiles.add(file.path);\n        }\n      }\n      \n      states.push({\n        commitIndex: i,\n        commit,\n        cumulativeAdditions,\n        cumulativeDeletions,\n        activeFiles: new Set(activeFiles)\n      });\n    }\n    \n    return states;\n  },\n  \n  /**\n   * Extract signature from states\n   */\n  extractSignature(states: CodeState[]): TemporalSignature {\n    const commits = states.map(s => s.commit);\n    return extractCodeFlowSignature(commits);\n  },\n  \n  /**\n   * Get archetype registry for code domain\n   */\n  getArchetypeRegistry(): ArchetypeRegistry {\n    const archetypes: Record<string, ArchetypeDefinition> = {};\n    \n    for (const [id, def] of Object.entries(CODE_ARCHETYPE_DEFINITIONS)) {\n      archetypes[id] = {\n        id,\n        name: def.name,\n        description: def.description,\n        successRate: def.successRate,\n        predictedOutcome: def.predictedOutcome === 'success' ? 'primary_wins' : \n                         def.predictedOutcome === 'failure' ? 'secondary_wins' : 'uncertain',\n        confidence: def.confidence,\n        keywords: def.keywords,\n        relatedArchetypes: def.relatedArchetypes\n      };\n    }\n    \n    return {\n      domain: 'code',\n      version: '1.0.0',\n      archetypes\n    };\n  },\n  \n  /**\n   * Classify signature into archetype\n   */\n  classifyArchetype(signature: TemporalSignature): string {\n    // The archetype is already determined during signature extraction\n    return signature.archetype;\n  },\n  \n  /**\n   * Calculate similarity between two code signatures\n   */\n  calculateSimilarity(a: TemporalSignature, b: TemporalSignature): number {\n    return calculateSignatureSimilarity(a, b);\n  },\n  \n  /**\n   * Render state for display\n   */\n  renderState(state: CodeState): string {\n    const { commit } = state;\n    return `[${commit.id.substring(0, 7)}] ${commit.message} (+${commit.additions}/-${commit.deletions})`;\n  }\n};\n\n/**\n * Create a code analysis engine\n */\nexport function createCodeAnalysisEngine() {\n  return {\n    /**\n     * Analyze a repository's commit history\n     */\n    analyzeRepository(commits: CodeCommit[], metadata?: CodeInput['metadata']): CodeFlowSignature {\n      const input: CodeInput = { commits, metadata };\n      const states = codeDomainAdapter.parseInput(input);\n      return codeDomainAdapter.extractSignature(states) as CodeFlowSignature;\n    },\n    \n    /**\n     * Get archetype definition\n     */\n    getArchetypeDefinition(archetype: CodeArchetype) {\n      return CODE_ARCHETYPE_DEFINITIONS[archetype];\n    },\n    \n    /**\n     * Compare two repository signatures\n     */\n    compareSignatures(a: CodeFlowSignature, b: CodeFlowSignature): number {\n      return codeDomainAdapter.calculateSimilarity(a, b);\n    },\n    \n    /**\n     * Get recommendations for current state\n     */\n    getRecommendations(signature: CodeFlowSignature): string[] {\n      const archetype = signature.archetype;\n      const definition = CODE_ARCHETYPE_DEFINITIONS[archetype];\n      \n      const recommendations: string[] = [...definition.recommendations];\n      \n      // Add warning-specific recommendations\n      for (const warning of definition.warningSignals) {\n        // Check if warning applies based on signature\n        if (signature.temporalFlow.testCoverageTrend === 'declining' && \n            warning.toLowerCase().includes('test')) {\n          recommendations.push('⚠️ ' + warning);\n        }\n        if (signature.codeMetrics.bugIndicatorCount > signature.codeMetrics.featureIndicatorCount &&\n            warning.toLowerCase().includes('bug')) {\n          recommendations.push('⚠️ ' + warning);\n        }\n      }\n      \n      return recommendations;\n    },\n    \n    /**\n     * Predict project outcome\n     */\n    predictOutcome(signature: CodeFlowSignature): {\n      outcome: 'success' | 'failure' | 'uncertain';\n      confidence: number;\n      reasoning: string;\n    } {\n      const archetype = signature.archetype;\n      const definition = CODE_ARCHETYPE_DEFINITIONS[archetype];\n      \n      let confidence = definition.confidence;\n      \n      // Adjust confidence based on signature characteristics\n      if (signature.temporalFlow.testCoverageTrend === 'improving') {\n        confidence = Math.min(1, confidence + 0.1);\n      } else if (signature.temporalFlow.testCoverageTrend === 'declining') {\n        confidence = Math.max(0, confidence - 0.1);\n      }\n      \n      if (signature.codeMetrics.bugIndicatorCount > signature.codeMetrics.featureIndicatorCount * 2) {\n        confidence = Math.max(0, confidence - 0.15);\n      }\n      \n      return {\n        outcome: definition.predictedOutcome,\n        confidence,\n        reasoning: `Project follows \"${definition.name}\" pattern with ${Math.round(definition.successRate * 100)}% historical success rate. ${definition.description}`\n      };\n    }\n  };\n}\n";export{n as default};
