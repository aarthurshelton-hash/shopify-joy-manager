const n="/**\n * Anomaly Harvester - Productive Bug Detection System\n * \n * Philosophy: Bugs that don't crash the system contain exploitable information.\n * Like speedrun glitches, biological mutations, and quantum tunneling -\n * anomalies that preserve system integrity reveal hidden optimization paths.\n */\n\nimport { PredictionOutcome, LearnedPattern } from './types';\n\nexport type AnomalyType = \n  | 'wrong_but_profitable'      // Prediction wrong, but outcome still favorable\n  | 'calibration_mismatch'      // High confidence + wrong = signal about edge cases\n  | 'consensus_violation'       // System disagreed with all baselines but was right\n  | 'temporal_glitch'           // Prediction timing anomaly revealed hidden pattern\n  | 'cross_domain_resonance'    // Bug in one domain = signal in another\n  | 'mutation_survival'         // Gene mutation that improved fitness unexpectedly\n  | 'emergent_optimization';    // Self-healing fix worked in unintended way\n\nexport interface HarvestedAnomaly {\n  id: string;\n  type: AnomalyType;\n  timestamp: number;\n  description: string;\n  \n  // The \"bug\" details\n  expectedBehavior: string;\n  actualBehavior: string;\n  systemIntegrityPreserved: boolean;\n  \n  // Extracted information\n  informationGained: string;\n  exploitabilityScore: number; // 0-1: How useful is this anomaly?\n  evolutionaryValue: number;   // 0-1: How much does this advance the system?\n  \n  // Context\n  domain: string;\n  relatedPatterns: string[];\n  geneticImpact: {\n    genesAffected: string[];\n    mutationType: 'beneficial' | 'neutral' | 'harmful_but_informative';\n    fitnessChange: number;\n  };\n  \n  // For memory persistence\n  importance: number; // 1-10 scale\n  tags: string[];\n}\n\nexport interface AnomalyHarvesterState {\n  totalHarvested: number;\n  byType: Record<AnomalyType, number>;\n  recentAnomalies: HarvestedAnomaly[];\n  exploitablePatterns: Array<{\n    pattern: string;\n    frequency: number;\n    avgExploitability: number;\n  }>;\n  evolutionaryInsights: string[];\n}\n\nclass AnomalyHarvester {\n  private state: AnomalyHarvesterState;\n  private readonly maxRecentAnomalies = 100;\n  \n  constructor() {\n    this.state = {\n      totalHarvested: 0,\n      byType: {\n        wrong_but_profitable: 0,\n        calibration_mismatch: 0,\n        consensus_violation: 0,\n        temporal_glitch: 0,\n        cross_domain_resonance: 0,\n        mutation_survival: 0,\n        emergent_optimization: 0\n      },\n      recentAnomalies: [],\n      exploitablePatterns: [],\n      evolutionaryInsights: []\n    };\n  }\n\n  /**\n   * Analyze a prediction outcome for productive bugs\n   */\n  harvestFromOutcome(\n    outcome: PredictionOutcome,\n    wasCorrect: boolean,\n    fitness: number,\n    previousFitness: number\n  ): HarvestedAnomaly | null {\n    const anomalies: HarvestedAnomaly[] = [];\n\n    // Type 1: Wrong but profitable (prediction wrong, but fitness improved)\n    if (!wasCorrect && fitness > previousFitness) {\n      anomalies.push(this.createAnomaly({\n        type: 'wrong_but_profitable',\n        description: 'Incorrect prediction led to fitness improvement - learning from failure',\n        expectedBehavior: `Prediction: ${outcome.predicted}`,\n        actualBehavior: `Actual: ${outcome.actual}, but fitness +${((fitness - previousFitness) * 100).toFixed(1)}%`,\n        informationGained: 'Wrong predictions with high confidence reveal blind spots in pattern matching',\n        exploitabilityScore: Math.min(1, (fitness - previousFitness) * 5),\n        evolutionaryValue: 0.7,\n        domain: 'prediction',\n        importance: 7,\n        tags: ['learning', 'failure-analysis', 'fitness-paradox']\n      }));\n    }\n\n    // Type 2: Calibration mismatch (high confidence but wrong)\n    if (!wasCorrect && outcome.confidence > 0.75) {\n      anomalies.push(this.createAnomaly({\n        type: 'calibration_mismatch',\n        description: `High confidence (${(outcome.confidence * 100).toFixed(0)}%) prediction failed - calibration signal`,\n        expectedBehavior: `Confidence ${(outcome.confidence * 100).toFixed(0)}% should indicate reliability`,\n        actualBehavior: 'Prediction failed despite high confidence',\n        informationGained: 'Edge case identified where confidence model breaks down',\n        exploitabilityScore: outcome.confidence, // Higher confidence = more informative failure\n        evolutionaryValue: 0.8,\n        domain: 'calibration',\n        importance: 8,\n        tags: ['calibration', 'overconfidence', 'edge-case']\n      }));\n    }\n\n    // Type 3: Consensus violation that succeeded\n    if (wasCorrect && outcome.confidence < 0.4) {\n      anomalies.push(this.createAnomaly({\n        type: 'consensus_violation',\n        description: 'Low-confidence contrarian prediction proved correct - hidden pattern detected',\n        expectedBehavior: 'Low confidence suggests uncertainty',\n        actualBehavior: 'Prediction correct despite low confidence - system knew more than it admitted',\n        informationGained: 'Subconscious pattern recognition operating below confidence threshold',\n        exploitabilityScore: 1 - outcome.confidence, // Lower confidence = more surprising success\n        evolutionaryValue: 0.9,\n        domain: 'pattern-recognition',\n        importance: 9,\n        tags: ['contrarian', 'hidden-pattern', 'brilliant-move']\n      }));\n    }\n\n    // Return the most valuable anomaly found\n    if (anomalies.length > 0) {\n      const bestAnomaly = anomalies.reduce((a, b) => \n        a.evolutionaryValue > b.evolutionaryValue ? a : b\n      );\n      this.recordAnomaly(bestAnomaly);\n      return bestAnomaly;\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect mutation survival anomalies from gene performance\n   */\n  harvestFromMutation(\n    geneName: string,\n    mutationDelta: number,\n    fitnessBeforeMutation: number,\n    fitnessAfterMutation: number\n  ): HarvestedAnomaly | null {\n    const fitnessChange = fitnessAfterMutation - fitnessBeforeMutation;\n    \n    // Beneficial mutation: small random change led to large improvement\n    if (Math.abs(mutationDelta) < 0.1 && fitnessChange > 0.05) {\n      const anomaly = this.createAnomaly({\n        type: 'mutation_survival',\n        description: `Gene \"${geneName}\" micro-mutation yielded macro-improvement`,\n        expectedBehavior: `Small mutation (${(mutationDelta * 100).toFixed(1)}%) should have small effect`,\n        actualBehavior: `Fitness improved by ${(fitnessChange * 100).toFixed(1)}%`,\n        informationGained: 'Gene exists at critical inflection point - small changes cascade',\n        exploitabilityScore: fitnessChange / Math.max(0.01, Math.abs(mutationDelta)),\n        evolutionaryValue: 0.85,\n        domain: 'genetics',\n        importance: 8,\n        tags: ['mutation', 'cascade-effect', 'critical-gene'],\n        geneticImpact: {\n          genesAffected: [geneName],\n          mutationType: 'beneficial',\n          fitnessChange\n        }\n      });\n      this.recordAnomaly(anomaly);\n      return anomaly;\n    }\n\n    // Harmful but informative: large mutation that degraded fitness tells us about boundaries\n    if (Math.abs(mutationDelta) > 0.2 && fitnessChange < -0.1) {\n      const anomaly = this.createAnomaly({\n        type: 'mutation_survival',\n        description: `Gene \"${geneName}\" boundary discovered through harmful mutation`,\n        expectedBehavior: 'Exploration mutation',\n        actualBehavior: `Fitness dropped ${(Math.abs(fitnessChange) * 100).toFixed(1)}% - boundary found`,\n        informationGained: 'Gene has hard constraint - now we know the safe operating range',\n        exploitabilityScore: 0.6,\n        evolutionaryValue: 0.5,\n        domain: 'genetics',\n        importance: 6,\n        tags: ['boundary-detection', 'constraint-mapping'],\n        geneticImpact: {\n          genesAffected: [geneName],\n          mutationType: 'harmful_but_informative',\n          fitnessChange\n        }\n      });\n      this.recordAnomaly(anomaly);\n      return anomaly;\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect cross-domain resonance anomalies\n   */\n  harvestCrossDomainResonance(\n    domain1: string,\n    domain2: string,\n    correlationStrength: number,\n    unexpectedConnection: string\n  ): HarvestedAnomaly | null {\n    if (correlationStrength > 0.7) {\n      const anomaly = this.createAnomaly({\n        type: 'cross_domain_resonance',\n        description: `Unexpected resonance between ${domain1} and ${domain2}`,\n        expectedBehavior: 'Domains should be independent',\n        actualBehavior: `Correlation: ${(correlationStrength * 100).toFixed(0)}%`,\n        informationGained: unexpectedConnection,\n        exploitabilityScore: correlationStrength,\n        evolutionaryValue: 0.95,\n        domain: `${domain1}-${domain2}`,\n        importance: 10,\n        tags: ['cross-domain', 'resonance', 'universal-pattern', 'glitch-in-matrix']\n      });\n      this.recordAnomaly(anomaly);\n      return anomaly;\n    }\n    return null;\n  }\n\n  /**\n   * Create anomaly with defaults\n   */\n  private createAnomaly(params: Partial<HarvestedAnomaly> & {\n    type: AnomalyType;\n    description: string;\n    expectedBehavior: string;\n    actualBehavior: string;\n    informationGained: string;\n    exploitabilityScore: number;\n    evolutionaryValue: number;\n    domain: string;\n    importance: number;\n    tags: string[];\n    geneticImpact?: HarvestedAnomaly['geneticImpact'];\n  }): HarvestedAnomaly {\n    return {\n      id: `anomaly_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n      systemIntegrityPreserved: true,\n      relatedPatterns: [],\n      geneticImpact: params.geneticImpact || {\n        genesAffected: [],\n        mutationType: 'neutral',\n        fitnessChange: 0\n      },\n      ...params\n    };\n  }\n\n  /**\n   * Record anomaly to state\n   */\n  private recordAnomaly(anomaly: HarvestedAnomaly): void {\n    this.state.totalHarvested++;\n    this.state.byType[anomaly.type]++;\n    \n    this.state.recentAnomalies.unshift(anomaly);\n    if (this.state.recentAnomalies.length > this.maxRecentAnomalies) {\n      this.state.recentAnomalies.pop();\n    }\n\n    // Update exploitable patterns\n    this.updateExploitablePatterns(anomaly);\n    \n    // Generate evolutionary insight\n    if (anomaly.evolutionaryValue > 0.8) {\n      this.state.evolutionaryInsights.push(\n        `[${new Date(anomaly.timestamp).toISOString()}] ${anomaly.type}: ${anomaly.informationGained}`\n      );\n      // Keep only recent insights\n      if (this.state.evolutionaryInsights.length > 50) {\n        this.state.evolutionaryInsights.shift();\n      }\n    }\n  }\n\n  /**\n   * Track patterns that appear frequently in anomalies\n   */\n  private updateExploitablePatterns(anomaly: HarvestedAnomaly): void {\n    const patternKey = `${anomaly.type}:${anomaly.domain}`;\n    const existing = this.state.exploitablePatterns.find(p => p.pattern === patternKey);\n    \n    if (existing) {\n      existing.frequency++;\n      existing.avgExploitability = (existing.avgExploitability * (existing.frequency - 1) + anomaly.exploitabilityScore) / existing.frequency;\n    } else {\n      this.state.exploitablePatterns.push({\n        pattern: patternKey,\n        frequency: 1,\n        avgExploitability: anomaly.exploitabilityScore\n      });\n    }\n\n    // Sort by exploitability\n    this.state.exploitablePatterns.sort((a, b) => \n      (b.avgExploitability * b.frequency) - (a.avgExploitability * a.frequency)\n    );\n  }\n\n  /**\n   * Get the most exploitable patterns discovered\n   */\n  getTopExploitablePatterns(limit: number = 5): typeof this.state.exploitablePatterns {\n    return this.state.exploitablePatterns.slice(0, limit);\n  }\n\n  /**\n   * Get recent high-value anomalies for memory persistence\n   */\n  getAnomaliesForMemory(minImportance: number = 7): HarvestedAnomaly[] {\n    return this.state.recentAnomalies.filter(a => a.importance >= minImportance);\n  }\n\n  /**\n   * Get harvester state summary\n   */\n  getState(): AnomalyHarvesterState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get evolutionary insights summary\n   */\n  getEvolutionarySummary(): {\n    totalAnomalies: number;\n    topPatterns: string[];\n    recentInsights: string[];\n    anomalyDistribution: Record<AnomalyType, number>;\n  } {\n    return {\n      totalAnomalies: this.state.totalHarvested,\n      topPatterns: this.state.exploitablePatterns.slice(0, 3).map(p => p.pattern),\n      recentInsights: this.state.evolutionaryInsights.slice(-5),\n      anomalyDistribution: { ...this.state.byType }\n    };\n  }\n}\n\nexport const anomalyHarvester = new AnomalyHarvester();\n";export{n as default};
