const n="/**\n * Lichess Cloud Evaluation API (via Edge Function)\n * \n * Uses Lichess's cloud evaluation service which runs Stockfish 17 NNUE.\n * Proxied through Edge Function to avoid CORS issues in production.\n * \n * API: https://lichess.org/api#tag/Analysis/operation/apiCloudEval\n * \n * Rate limits: \n * - Anonymous: 20 requests/minute\n * - With token: 100 requests/minute\n */\n\nimport { Chess } from 'chess.js';\n\nexport interface CloudEvaluation {\n  fen: string;\n  knodes: number;\n  depth: number;\n  pvs: Array<{\n    moves: string;\n    cp?: number;\n    mate?: number;\n  }>;\n}\n\nexport interface PositionEvaluation {\n  fen: string;\n  bestMove: string;\n  bestMoveSan: string;\n  evaluation: number; // Centipawns\n  isMate: boolean;\n  mateIn?: number;\n  depth: number;\n  pv: string[];\n  winProbability: number;\n}\n\n// Rate limiting state (local tracking) - v6.80-PATIENT\n// PHILOSOPHY: Quality > Speed. WAIT for rate limits, never skip.\nlet rateLimitResetTime = 0;\nlet lastRequestTime = 0;\nconst MIN_REQUEST_INTERVAL = 5000; // 5s between requests (~12/min - bulletproof headroom)\n\n// In-memory cache for evaluated positions\nconst positionCache = new Map<string, PositionEvaluation>();\nconst CACHE_MAX_SIZE = 500;\n\nexport function getRateLimitStatus(): { isLimited: boolean; resetInMs: number } {\n  const now = Date.now();\n  if (rateLimitResetTime > now) {\n    return { isLimited: true, resetInMs: rateLimitResetTime - now };\n  }\n  return { isLimited: false, resetInMs: 0 };\n}\n\n/**\n * v6.80-PATIENT: Wait for rate limit to clear before proceeding\n * Returns true when ready to proceed, false if timed out waiting\n */\nexport async function waitForRateLimit(maxWaitMs: number = 120000): Promise<boolean> {\n  const status = getRateLimitStatus();\n  if (!status.isLimited) return true;\n  \n  const waitTime = Math.min(status.resetInMs + 2000, maxWaitMs); // Extra 2s buffer\n  console.log(`[v6.80-PATIENT] ⏳ Rate limited - waiting ${Math.ceil(waitTime/1000)}s for API to recover...`);\n  \n  await new Promise(r => setTimeout(r, waitTime));\n  \n  // Double-check after waiting\n  const recheckStatus = getRateLimitStatus();\n  if (recheckStatus.isLimited) {\n    console.warn(`[v6.80-PATIENT] Still rate limited after wait, remaining: ${Math.ceil(recheckStatus.resetInMs/1000)}s`);\n    return false;\n  }\n  \n  console.log(`[v6.80-PATIENT] ✅ Rate limit cleared, resuming...`);\n  return true;\n}\n\n/**\n * Throttle requests to stay under rate limit\n */\nasync function throttleRequest(): Promise<void> {\n  const now = Date.now();\n  const timeSinceLastRequest = now - lastRequestTime;\n  \n  if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {\n    const waitTime = MIN_REQUEST_INTERVAL - timeSinceLastRequest;\n    await new Promise(resolve => setTimeout(resolve, waitTime));\n  }\n  \n  lastRequestTime = Date.now();\n}\n\n/**\n * Get cached evaluation if available\n */\nexport function getCachedEvaluation(fen: string): PositionEvaluation | null {\n  return positionCache.get(fen) || null;\n}\n\n/**\n * Cache an evaluation result\n */\nfunction cacheEvaluation(fen: string, evaluation: PositionEvaluation): void {\n  // Evict oldest entries if cache is full\n  if (positionCache.size >= CACHE_MAX_SIZE) {\n    const firstKey = positionCache.keys().next().value;\n    if (firstKey) positionCache.delete(firstKey);\n  }\n  positionCache.set(fen, evaluation);\n}\n\n/**\n * Clear the position cache\n */\nexport function clearEvaluationCache(): void {\n  positionCache.clear();\n}\n\n// Edge function endpoint\nconst getEdgeFunctionUrl = () => {\n  const url = import.meta.env.VITE_SUPABASE_URL;\n  return `${url}/functions/v1/lichess-cloud-eval`;\n};\n\nconst getHeaders = () => {\n  const key = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;\n  return {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${key}`,\n    'apikey': key\n  };\n};\n\n/**\n * Convert centipawns to win probability (Lichess formula)\n */\nfunction cpToWinProbability(cp: number): number {\n  const K = 0.00368208;\n  return 50 + 50 * (2 / (1 + Math.exp(-K * cp)) - 1);\n}\n\n/**\n * Convert UCI move to SAN\n */\nfunction uciToSan(fen: string, uci: string): string {\n  try {\n    const chess = new Chess(fen);\n    const from = uci.slice(0, 2);\n    const to = uci.slice(2, 4);\n    const promotion = uci.length > 4 ? uci.slice(4) : undefined;\n    \n    const move = chess.move({ from, to, promotion });\n    return move ? move.san : uci;\n  } catch {\n    return uci;\n  }\n}\n\n/**\n * Evaluate a position using Lichess Cloud Eval (Stockfish 17) via Edge Function\n * Includes throttling and caching for rate limit management\n */\n/**\n * v6.80-PATIENT: Evaluate position with patient rate limit handling\n * @param waitForLimit - If true (default), WAIT for rate limits to clear instead of returning null\n */\nexport async function evaluatePosition(\n  fen: string, \n  multiPv: number = 1, \n  skipCache: boolean = false,\n  waitForLimit: boolean = true\n): Promise<PositionEvaluation | null> {\n  // Check cache first\n  if (!skipCache) {\n    const cached = getCachedEvaluation(fen);\n    if (cached) {\n      console.log('[LichessCloud] Cache hit for position');\n      return cached;\n    }\n  }\n  \n  // v6.80-PATIENT: Wait for rate limit instead of returning null\n  const limitStatus = getRateLimitStatus();\n  if (limitStatus.isLimited) {\n    if (waitForLimit) {\n      console.log(`[v6.80-PATIENT] Rate limited - waiting patiently...`);\n      const ready = await waitForRateLimit();\n      if (!ready) {\n        console.warn(`[v6.80-PATIENT] Rate limit wait timed out`);\n        return null;\n      }\n    } else {\n      console.warn(`[LichessCloud] Rate limited, ${Math.ceil(limitStatus.resetInMs / 1000)}s remaining`);\n      return null;\n    }\n  }\n  \n  try {\n    // Throttle to stay under rate limit\n    await throttleRequest();\n    \n    const response = await fetch(getEdgeFunctionUrl(), {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({ fen, multiPv })\n    });\n    \n    if (response.status === 429) {\n      const data = await response.json();\n      const resetMs = data.resetInMs || 60000; // Default 60s if not provided\n      rateLimitResetTime = Date.now() + resetMs;\n      console.warn(`[v6.80-PATIENT] Received 429, reset in ${Math.ceil(resetMs / 1000)}s`);\n      \n      // v6.80-PATIENT: WAIT and RETRY instead of returning null\n      if (waitForLimit) {\n        console.log(`[v6.80-PATIENT] ⏳ Waiting for rate limit to clear, then retrying...`);\n        const ready = await waitForRateLimit();\n        if (ready) {\n          // Recursive retry after waiting\n          return evaluatePosition(fen, multiPv, skipCache, false); // Don't wait again to prevent infinite loop\n        }\n      }\n      return null;\n    }\n    \n    if (!response.ok) {\n      console.error('[LichessCloud] API error:', response.status);\n      return null;\n    }\n    \n    const data = await response.json();\n    \n    if (data.notFound) {\n      console.log('[LichessCloud] Position not in database:', fen.substring(0, 40));\n      return null;\n    }\n    \n    if (!data.pvs || data.pvs.length === 0) {\n      return null;\n    }\n    \n    const mainLine = data.pvs[0];\n    const moves = mainLine.moves.split(' ');\n    const bestMoveUci = moves[0];\n    \n    const isMate = mainLine.mate !== undefined;\n    const evaluation = isMate ? (mainLine.mate! > 0 ? 10000 : -10000) : (mainLine.cp || 0);\n    \n    const result: PositionEvaluation = {\n      fen: data.fen,\n      bestMove: bestMoveUci,\n      bestMoveSan: uciToSan(fen, bestMoveUci),\n      evaluation,\n      isMate,\n      mateIn: mainLine.mate,\n      depth: data.depth,\n      pv: moves,\n      winProbability: cpToWinProbability(evaluation),\n    };\n    \n    // Cache the result\n    cacheEvaluation(fen, result);\n    \n    return result;\n  } catch (error) {\n    console.error('[LichessCloud] Evaluation error:', error);\n    return null;\n  }\n}\n\n/**\n * Batch evaluate multiple positions\n * Returns evaluations in order, with null for unavailable positions\n */\nexport async function evaluatePositions(\n  fens: string[],\n  onProgress?: (completed: number, total: number) => void\n): Promise<(PositionEvaluation | null)[]> {\n  const results: (PositionEvaluation | null)[] = [];\n  \n  for (let i = 0; i < fens.length; i++) {\n    const result = await evaluatePosition(fens[i]);\n    results.push(result);\n    \n    if (onProgress) {\n      onProgress(i + 1, fens.length);\n    }\n  }\n  \n  return results;\n}\n\n/**\n * Check if Lichess API is available via Edge Function\n */\nexport async function checkLichessAvailability(): Promise<{ available: boolean; rateLimited: boolean; resetInMs?: number }> {\n  // Check if we're currently rate limited locally\n  const limitStatus = getRateLimitStatus();\n  if (limitStatus.isLimited) {\n    return { available: false, rateLimited: true, resetInMs: limitStatus.resetInMs };\n  }\n  \n  try {\n    const response = await fetch(getEdgeFunctionUrl(), {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({ action: 'check' })\n    });\n    \n    if (!response.ok) {\n      return { available: false, rateLimited: false };\n    }\n    \n    const data = await response.json();\n    \n    if (data.rateLimited && data.resetInMs) {\n      rateLimitResetTime = Date.now() + data.resetInMs;\n    }\n    \n    return { \n      available: data.available, \n      rateLimited: data.rateLimited || false,\n      resetInMs: data.resetInMs \n    };\n  } catch (error) {\n    console.error('[LichessCloud] Availability check error:', error);\n    return { available: false, rateLimited: false };\n  }\n}\n\n/**\n * Get evaluation for a position at a specific move in a game\n */\nexport async function evaluateGamePosition(\n  pgn: string,\n  moveNumber: number\n): Promise<PositionEvaluation | null> {\n  try {\n    const chess = new Chess();\n    chess.loadPgn(pgn);\n    \n    const history = chess.history();\n    \n    // Reset and play up to the specified move\n    chess.reset();\n    \n    const movesToPlay = Math.min(moveNumber, history.length);\n    for (let i = 0; i < movesToPlay; i++) {\n      chess.move(history[i]);\n    }\n    \n    return evaluatePosition(chess.fen());\n  } catch (error) {\n    console.error('[LichessCloud] Game position error:', error);\n    return null;\n  }\n}\n";export{n as default};
