const e="/**\n * En Pensent Core SDK\n * \n * Universal Temporal Pattern Recognition Engine\n * \n * The core paradigm: Sequential events → Visual signatures → Pattern matching → Trajectory prediction\n * \n * This SDK can be applied to any domain with:\n * - Spatial structure (grid, regions, zones)\n * - Chromatic/intensity values (colors, weights, activity levels)\n * - Temporal evolution (sequence of states over time)\n * \n * Domains: Chess, Code, Music, Light, Health, Finance, and beyond\n * \n * v1.2.0 - Added event bus, caching, pipeline/middleware, and batch processing\n */\n\n// Core Types\nexport * from './types';\n\n// Signature Extraction\nexport {\n  generateFingerprint,\n  calculateQuadrantProfile,\n  calculateTemporalFlow,\n  detectCriticalMoments,\n  calculateIntensity,\n  determineDominantForce,\n  determineFlowDirection,\n  extractSignature,\n  hashString\n} from './signatureExtractor';\n\n// Pattern Matching\nexport {\n  quadrantSimilarity,\n  temporalFlowSimilarity,\n  calculateSignatureSimilarity,\n  findSimilarPatterns,\n  calculateOutcomeProbabilities,\n  getMostLikelyOutcome,\n  calculatePatternDiversity,\n  calculateMatchConfidence\n} from './patternMatcher';\n\n// Trajectory Prediction\nexport {\n  generateTrajectoryPrediction,\n  calculateTrajectoryDivergence,\n  assessTrajectorySustainability,\n  DEFAULT_PREDICTION_CONFIG,\n  type PredictionConfig\n} from './trajectoryPredictor';\n\n// Archetype Resolution\nexport {\n  ArchetypeResolver,\n  createArchetypeResolver,\n  classifyUniversalArchetype,\n  calculateArchetypeSimilarity,\n  DEFAULT_MATCH_CRITERIA,\n  type ArchetypeMatchCriteria,\n  type ArchetypeMatchResult\n} from './archetypeResolver';\n\n// Visualization Primitives\nexport {\n  quadrantToRadarData,\n  temporalFlowToChartData,\n  criticalMomentsToTimeline,\n  createIntensityGauge,\n  createConfidenceGauge,\n  signatureToVisualizationData,\n  getColorForValue,\n  getConfidenceColor,\n  getIntensityColor,\n  formatPercentage,\n  formatTrend,\n  formatArchetype,\n  formatFlowDirection,\n  formatDominantForce,\n  createStaggeredDelays,\n  DEFAULT_COLOR_SCALE,\n  DEFAULT_ANIMATION_CONFIG,\n  type TimeSeriesPoint,\n  type RadarChartData,\n  type HeatMapData,\n  type FlowChartData,\n  type GaugeData,\n  type SignatureVisualizationData,\n  type ColorScale,\n  type AnimationConfig\n} from './visualizationPrimitives';\n\n// Event Bus (NEW in v1.2.0)\nexport {\n  PensentEventBus,\n  createEventBus,\n  globalEventBus,\n  type PensentEvent,\n  type PensentEventType,\n  type PensentEventHandler,\n  type PensentEventFilter,\n  type EventSubscription,\n  type SignatureExtractedPayload,\n  type PatternMatchedPayload,\n  type PredictionGeneratedPayload,\n  type BatchProgressPayload,\n  type ErrorPayload\n} from './eventBus';\n\n// Caching (NEW in v1.2.0)\nexport {\n  PensentCache,\n  SignatureCache,\n  MatchCache,\n  PredictionCache,\n  createCache,\n  createCacheBundle,\n  DEFAULT_CACHE_CONFIG,\n  type CacheEntry,\n  type CacheStats,\n  type CacheConfig\n} from './cache';\n\n// Pipeline & Middleware (NEW in v1.2.0)\nexport {\n  AnalysisPipeline,\n  createPipeline,\n  loggingMiddleware,\n  validationMiddleware,\n  cachingMiddleware,\n  retryMiddleware,\n  timeoutMiddleware,\n  type PipelineContext,\n  type PipelineMiddleware,\n  type PipelineStep\n} from './pipeline';\n\n// Batch Processing (NEW in v1.2.0)\nexport {\n  BatchProcessor,\n  StreamProcessor,\n  createBatchProcessor,\n  createStreamProcessor,\n  DEFAULT_BATCH_CONFIG,\n  type BatchInput,\n  type BatchResult,\n  type BatchProgress,\n  type BatchConfig,\n  type BatchAggregation\n} from './batch';\n\n// Version\nexport const PENSENT_CORE_VERSION = '1.2.0';\n\n/**\n * Create a new En Pensent engine for a domain\n */\nexport function createPensentEngine<TInput, TState>(\n  adapter: import('./types').DomainAdapter<TInput, TState>\n) {\n  return {\n    domain: adapter.domain,\n    \n    /**\n     * Extract signature from input\n     */\n    extractSignature(input: TInput) {\n      const states = adapter.parseInput(input);\n      return adapter.extractSignature(states);\n    },\n    \n    /**\n     * Classify signature into archetype\n     */\n    classifyArchetype(signature: import('./types').TemporalSignature) {\n      return adapter.classifyArchetype(signature);\n    },\n    \n    /**\n     * Find similar patterns\n     */\n    findSimilarPatterns(\n      signature: import('./types').TemporalSignature,\n      patterns: { id: string; signature: import('./types').TemporalSignature; outcome: string }[],\n      options?: { minSimilarity?: number; limit?: number }\n    ) {\n      const { findSimilarPatterns } = require('./patternMatcher');\n      return findSimilarPatterns(signature, patterns, {\n        targetSignature: signature,\n        ...options\n      });\n    },\n    \n    /**\n     * Generate trajectory prediction\n     */\n    predictTrajectory(\n      signature: import('./types').TemporalSignature,\n      matches: import('./types').PatternMatch[],\n      currentPosition: number,\n      totalExpectedLength: number\n    ) {\n      const archetypeRegistry = adapter.getArchetypeRegistry();\n      const archetypeDef = archetypeRegistry.archetypes[signature.archetype] ?? null;\n      \n      const { generateTrajectoryPrediction } = require('./trajectoryPredictor');\n      return generateTrajectoryPrediction(\n        signature,\n        matches,\n        archetypeDef,\n        currentPosition,\n        totalExpectedLength\n      );\n    },\n    \n    /**\n     * Get archetype registry\n     */\n    getArchetypes() {\n      return adapter.getArchetypeRegistry();\n    },\n    \n    /**\n     * Calculate similarity between two signatures\n     */\n    calculateSimilarity(a: import('./types').TemporalSignature, b: import('./types').TemporalSignature) {\n      return adapter.calculateSimilarity(a, b);\n    },\n    \n    /**\n     * Create an analysis pipeline with middleware support\n     */\n    createPipeline() {\n      const { createPipeline } = require('./pipeline');\n      return createPipeline(adapter);\n    },\n    \n    /**\n     * Create a batch processor for bulk analysis\n     */\n    createBatchProcessor(config?: import('./batch').BatchConfig) {\n      const { createBatchProcessor } = require('./batch');\n      return createBatchProcessor(adapter, config);\n    },\n    \n    /**\n     * Create a stream processor for real-time analysis\n     */\n    createStreamProcessor(options?: {\n      bufferSize?: number;\n      flushIntervalMs?: number;\n      onFlush?: (results: import('./batch').BatchResult<import('./types').TemporalSignature>[]) => void;\n    }) {\n      const { createStreamProcessor } = require('./batch');\n      return createStreamProcessor(adapter, options);\n    }\n  };\n}\n";export{e as default};
