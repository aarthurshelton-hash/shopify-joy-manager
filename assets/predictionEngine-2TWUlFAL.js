const n="/**\n * En Pensentâ„¢ Finance Domain - Prediction Engine\n * \n * Generates market predictions from temporal signatures.\n */\n\nimport { TemporalSignature } from '../../types/core';\nimport { \n  MarketArchetype, \n  StockPrediction, \n  MARKET_ARCHETYPES,\n  CandleStick \n} from './types';\nimport { extractMarketSignature } from './signatureExtractor';\n\nexport interface PredictionConfig {\n  timeHorizon: '1h' | '4h' | '1d' | '1w';\n  confidenceThreshold: number;\n  riskTolerance: 'conservative' | 'moderate' | 'aggressive';\n}\n\nconst DEFAULT_CONFIG: PredictionConfig = {\n  timeHorizon: '1d',\n  confidenceThreshold: 55,\n  riskTolerance: 'moderate'\n};\n\n/**\n * Generate a prediction from candlestick data\n */\nexport function generatePrediction(\n  symbol: string,\n  candles: CandleStick[],\n  config: Partial<PredictionConfig> = {}\n): StockPrediction {\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\n  const signature = extractMarketSignature(symbol, candles, fullConfig.timeHorizon);\n  const archetype = signature.archetype as MarketArchetype;\n  const archetypeDef = MARKET_ARCHETYPES[archetype];\n  \n  // Calculate prediction based on archetype and signature\n  const prediction = calculatePrediction(signature, archetypeDef, fullConfig);\n  \n  return {\n    symbol,\n    timestamp: Date.now(),\n    archetype,\n    signature: signature.fingerprint,\n    prediction,\n    priceAtPrediction: candles[candles.length - 1]?.close || 0\n  };\n}\n\n/**\n * Calculate prediction details from signature and archetype\n */\nfunction calculatePrediction(\n  signature: TemporalSignature,\n  archetypeDef: typeof MARKET_ARCHETYPES[MarketArchetype],\n  config: PredictionConfig\n): StockPrediction['prediction'] {\n  const { followThrough, signalStrength } = archetypeDef;\n  const { temporalFlow, quadrantProfile, intensity } = signature;\n  \n  // Base direction from archetype probabilities\n  let direction: 'bullish' | 'bearish' | 'neutral';\n  if (followThrough.bullish > followThrough.bearish + 10) {\n    direction = 'bullish';\n  } else if (followThrough.bearish > followThrough.bullish + 10) {\n    direction = 'bearish';\n  } else {\n    direction = 'neutral';\n  }\n  \n  // Confidence calculation\n  const baseConfidence = Math.max(followThrough.bullish, followThrough.bearish);\n  \n  // Adjust for signal strength\n  const strengthMultiplier = {\n    strong: 1.15,\n    moderate: 1.0,\n    weak: 0.8\n  }[signalStrength];\n  \n  // Adjust for signature quality\n  const momentumBonus = Math.abs(temporalFlow.momentum) * 10;\n  const intensityBonus = intensity * 10;\n  const consistencyBonus = quadrantProfile.q4 ? quadrantProfile.q4 * 10 : 0;\n  \n  let confidence = baseConfidence * strengthMultiplier + momentumBonus + intensityBonus + consistencyBonus;\n  \n  // Apply risk tolerance adjustment\n  const riskMultiplier = {\n    conservative: 0.85,\n    moderate: 1.0,\n    aggressive: 1.15\n  }[config.riskTolerance];\n  \n  confidence = Math.min(95, Math.max(25, confidence * riskMultiplier));\n  \n  // Estimate target move based on intensity and volatility\n  const volatility = (signature.domainData?.volatility as number) || 0.02;\n  const baseMove = volatility * 100; // Convert to percentage\n  const targetMove = baseMove * (1 + intensity) * (direction === 'neutral' ? 0.5 : 1);\n  \n  return {\n    direction,\n    confidence: Math.round(confidence),\n    targetMove: Math.round(targetMove * 10) / 10,\n    timeHorizon: config.timeHorizon\n  };\n}\n\n/**\n * Compare prediction to simple moving average baseline\n */\nexport function generateBaselinePrediction(\n  candles: CandleStick[]\n): { direction: 'bullish' | 'bearish' | 'neutral'; confidence: number } {\n  if (candles.length < 20) {\n    return { direction: 'neutral', confidence: 50 };\n  }\n  \n  const sma20 = candles.slice(-20).reduce((a, c) => a + c.close, 0) / 20;\n  const sma5 = candles.slice(-5).reduce((a, c) => a + c.close, 0) / 5;\n  const currentPrice = candles[candles.length - 1].close;\n  \n  // Simple SMA crossover strategy\n  if (sma5 > sma20 && currentPrice > sma5) {\n    return { direction: 'bullish', confidence: 55 };\n  } else if (sma5 < sma20 && currentPrice < sma5) {\n    return { direction: 'bearish', confidence: 55 };\n  }\n  \n  return { direction: 'neutral', confidence: 50 };\n}\n\n/**\n * Calculate accuracy score comparing prediction to outcome\n */\nexport function calculatePredictionAccuracy(\n  prediction: StockPrediction,\n  outcomePrice: number\n): {\n  actualDirection: 'bullish' | 'bearish' | 'neutral';\n  actualMove: number;\n  wasCorrect: boolean;\n  accuracyScore: number;\n} {\n  const { priceAtPrediction, prediction: pred } = prediction;\n  const priceChange = (outcomePrice - priceAtPrediction) / priceAtPrediction;\n  const actualMove = Math.abs(priceChange * 100);\n  \n  let actualDirection: 'bullish' | 'bearish' | 'neutral';\n  if (priceChange > 0.005) {\n    actualDirection = 'bullish';\n  } else if (priceChange < -0.005) {\n    actualDirection = 'bearish';\n  } else {\n    actualDirection = 'neutral';\n  }\n  \n  const wasCorrect = pred.direction === actualDirection || \n    (pred.direction === 'neutral' && actualDirection === 'neutral');\n  \n  // Calculate accuracy based on:\n  // 1. Direction correctness (50%)\n  // 2. Target move accuracy (50%)\n  const directionScore = wasCorrect ? 50 : 0;\n  const moveAccuracy = Math.max(0, 50 - Math.abs(actualMove - pred.targetMove) * 5);\n  const accuracyScore = directionScore + moveAccuracy;\n  \n  return {\n    actualDirection,\n    actualMove: Math.round(actualMove * 10) / 10,\n    wasCorrect,\n    accuracyScore: Math.round(accuracyScore)\n  };\n}\n\n/**\n * Generate multi-timeframe analysis\n */\nexport function generateMultiTimeframePrediction(\n  symbol: string,\n  candles: CandleStick[]\n): {\n  shortTerm: StockPrediction;\n  mediumTerm: StockPrediction;\n  longTerm: StockPrediction;\n  consensus: 'bullish' | 'bearish' | 'neutral' | 'mixed';\n  overallConfidence: number;\n} {\n  const shortTerm = generatePrediction(symbol, candles.slice(-24), { timeHorizon: '1h' });\n  const mediumTerm = generatePrediction(symbol, candles.slice(-96), { timeHorizon: '4h' });\n  const longTerm = generatePrediction(symbol, candles, { timeHorizon: '1d' });\n  \n  // Determine consensus\n  const directions = [\n    shortTerm.prediction.direction,\n    mediumTerm.prediction.direction,\n    longTerm.prediction.direction\n  ];\n  \n  const bullishCount = directions.filter(d => d === 'bullish').length;\n  const bearishCount = directions.filter(d => d === 'bearish').length;\n  \n  let consensus: 'bullish' | 'bearish' | 'neutral' | 'mixed';\n  if (bullishCount >= 2) {\n    consensus = 'bullish';\n  } else if (bearishCount >= 2) {\n    consensus = 'bearish';\n  } else if (bullishCount === 1 && bearishCount === 1) {\n    consensus = 'mixed';\n  } else {\n    consensus = 'neutral';\n  }\n  \n  // Weight confidences (long-term has more weight)\n  const overallConfidence = Math.round(\n    (shortTerm.prediction.confidence * 0.2) +\n    (mediumTerm.prediction.confidence * 0.3) +\n    (longTerm.prediction.confidence * 0.5)\n  );\n  \n  return {\n    shortTerm,\n    mediumTerm,\n    longTerm,\n    consensus,\n    overallConfidence\n  };\n}\n";export{n as default};
