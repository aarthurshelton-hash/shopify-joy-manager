const n="/**\n * Biorhythm Lunar Synchronization\n * \n * Tracks lunar cycles and their correlation with biological rhythms\n * and market behavior. Ancient wisdom meets quantitative analysis.\n */\n\ntype LunarPhase = \n  | 'new_moon'\n  | 'waxing_crescent'\n  | 'first_quarter'\n  | 'waxing_gibbous'\n  | 'full_moon'\n  | 'waning_gibbous'\n  | 'third_quarter'\n  | 'waning_crescent';\n\ninterface LunarState {\n  phase: LunarPhase;\n  illumination: number; // 0-1\n  daysUntilFull: number;\n  daysUntilNew: number;\n  isEclipse: boolean;\n}\n\ninterface BiorhythmCycle {\n  physical: number; // 23-day cycle, -1 to 1\n  emotional: number; // 28-day cycle, -1 to 1\n  intellectual: number; // 33-day cycle, -1 to 1\n  combined: number; // Weighted average\n}\n\ninterface LunarMarketCorrelation {\n  phase: LunarPhase;\n  historicalBias: 'bullish' | 'bearish' | 'neutral';\n  strength: number;\n  sampleSize: number;\n}\n\ninterface BiorhythmLunarState {\n  lunar: LunarState;\n  biorhythm: BiorhythmCycle;\n  phaseCorrelations: LunarMarketCorrelation[];\n  prediction: {\n    direction: 'up' | 'down' | 'neutral';\n    confidence: number;\n    reasoning: string;\n  };\n  syncScore: number; // How aligned lunar and biorhythm cycles are\n}\n\nclass BiorhythmLunarSync {\n  private readonly LUNAR_CYCLE_DAYS = 29.53;\n  private readonly PHYSICAL_CYCLE = 23;\n  private readonly EMOTIONAL_CYCLE = 28;\n  private readonly INTELLECTUAL_CYCLE = 33;\n  \n  private outcomeHistory: Array<{ phase: LunarPhase; direction: string; wasCorrect: boolean }> = [];\n  private phaseStats: Map<LunarPhase, { up: number; down: number; total: number }> = new Map();\n  private readonly regularization = 0.8; // Conservative due to speculative nature\n  \n  constructor() {\n    // Initialize phase stats\n    const phases: LunarPhase[] = [\n      'new_moon', 'waxing_crescent', 'first_quarter', 'waxing_gibbous',\n      'full_moon', 'waning_gibbous', 'third_quarter', 'waning_crescent'\n    ];\n    for (const phase of phases) {\n      this.phaseStats.set(phase, { up: 0, down: 0, total: 0 });\n    }\n  }\n  \n  /**\n   * Calculate current lunar state\n   */\n  getLunarState(date: Date = new Date()): LunarState {\n    // Known new moon reference: January 6, 2000\n    const referenceNewMoon = new Date(2000, 0, 6, 18, 14, 0);\n    const daysSinceReference = (date.getTime() - referenceNewMoon.getTime()) / (1000 * 60 * 60 * 24);\n    \n    const lunarAge = daysSinceReference % this.LUNAR_CYCLE_DAYS;\n    const illumination = (1 - Math.cos((lunarAge / this.LUNAR_CYCLE_DAYS) * 2 * Math.PI)) / 2;\n    \n    const phase = this.getPhaseFromAge(lunarAge);\n    \n    const daysUntilFull = lunarAge < this.LUNAR_CYCLE_DAYS / 2\n      ? (this.LUNAR_CYCLE_DAYS / 2) - lunarAge\n      : this.LUNAR_CYCLE_DAYS - lunarAge + (this.LUNAR_CYCLE_DAYS / 2);\n    \n    const daysUntilNew = lunarAge < 1 ? 1 - lunarAge : this.LUNAR_CYCLE_DAYS - lunarAge;\n    \n    // Simple eclipse approximation (very rough)\n    const isEclipse = (lunarAge < 1.5 || Math.abs(lunarAge - this.LUNAR_CYCLE_DAYS / 2) < 1.5) &&\n                      (date.getMonth() % 6 === 0 || date.getMonth() % 6 === 5);\n    \n    return { phase, illumination, daysUntilFull, daysUntilNew, isEclipse };\n  }\n  \n  /**\n   * Get lunar phase from age in days\n   */\n  private getPhaseFromAge(age: number): LunarPhase {\n    const phaseLength = this.LUNAR_CYCLE_DAYS / 8;\n    const phaseIndex = Math.floor(age / phaseLength) % 8;\n    \n    const phases: LunarPhase[] = [\n      'new_moon', 'waxing_crescent', 'first_quarter', 'waxing_gibbous',\n      'full_moon', 'waning_gibbous', 'third_quarter', 'waning_crescent'\n    ];\n    \n    return phases[phaseIndex];\n  }\n  \n  /**\n   * Calculate biorhythm cycles\n   * Based on birth date or market \"birth\" (reference point)\n   */\n  getBiorhythmCycle(referenceDate: Date = new Date(2009, 0, 3)): BiorhythmCycle {\n    // Default reference: Bitcoin genesis block as a \"market birth\"\n    const now = new Date();\n    const daysSinceBirth = (now.getTime() - referenceDate.getTime()) / (1000 * 60 * 60 * 24);\n    \n    const physical = Math.sin((2 * Math.PI * daysSinceBirth) / this.PHYSICAL_CYCLE);\n    const emotional = Math.sin((2 * Math.PI * daysSinceBirth) / this.EMOTIONAL_CYCLE);\n    const intellectual = Math.sin((2 * Math.PI * daysSinceBirth) / this.INTELLECTUAL_CYCLE);\n    \n    // Markets are more emotional than intellectual\n    const combined = (physical * 0.25 + emotional * 0.45 + intellectual * 0.3);\n    \n    return { physical, emotional, intellectual, combined };\n  }\n  \n  /**\n   * Get historical correlation between lunar phases and market direction\n   */\n  getPhaseCorrelations(): LunarMarketCorrelation[] {\n    const correlations: LunarMarketCorrelation[] = [];\n    \n    for (const [phase, stats] of this.phaseStats) {\n      if (stats.total < 5) {\n        // Not enough data - use historical research (rough approximations)\n        correlations.push(this.getHistoricalBias(phase));\n      } else {\n        const upRatio = stats.up / stats.total;\n        correlations.push({\n          phase,\n          historicalBias: upRatio > 0.55 ? 'bullish' : upRatio < 0.45 ? 'bearish' : 'neutral',\n          strength: Math.abs(upRatio - 0.5) * 2,\n          sampleSize: stats.total,\n        });\n      }\n    }\n    \n    return correlations;\n  }\n  \n  /**\n   * Get historical bias based on published research\n   */\n  private getHistoricalBias(phase: LunarPhase): LunarMarketCorrelation {\n    // Based on various studies (Yuan, Zheng, and Zhu, etc.)\n    const biases: Record<LunarPhase, { bias: 'bullish' | 'bearish' | 'neutral'; strength: number }> = {\n      new_moon: { bias: 'bullish', strength: 0.3 }, // Often marks bottoms\n      waxing_crescent: { bias: 'bullish', strength: 0.2 },\n      first_quarter: { bias: 'neutral', strength: 0.1 },\n      waxing_gibbous: { bias: 'neutral', strength: 0.1 },\n      full_moon: { bias: 'bearish', strength: 0.25 }, // Often marks tops\n      waning_gibbous: { bias: 'bearish', strength: 0.15 },\n      third_quarter: { bias: 'neutral', strength: 0.1 },\n      waning_crescent: { bias: 'neutral', strength: 0.15 },\n    };\n    \n    const { bias, strength } = biases[phase];\n    return { phase, historicalBias: bias, strength: strength * this.regularization, sampleSize: 0 };\n  }\n  \n  /**\n   * Get full biorhythm-lunar synchronized state\n   */\n  getState(): BiorhythmLunarState {\n    const lunar = this.getLunarState();\n    const biorhythm = this.getBiorhythmCycle();\n    const phaseCorrelations = this.getPhaseCorrelations();\n    \n    // Calculate sync score (how aligned cycles are)\n    const lunarNormalized = lunar.illumination * 2 - 1; // Convert 0-1 to -1 to 1\n    const bioNormalized = biorhythm.combined;\n    \n    // When both cycles align (same sign and similar magnitude)\n    const syncScore = 1 - Math.abs(lunarNormalized - bioNormalized) / 2;\n    \n    // Generate prediction\n    const prediction = this.generatePrediction(lunar, biorhythm, phaseCorrelations);\n    \n    return {\n      lunar,\n      biorhythm,\n      phaseCorrelations,\n      prediction: {\n        ...prediction,\n        confidence: prediction.confidence * this.regularization,\n      },\n      syncScore,\n    };\n  }\n  \n  /**\n   * Generate prediction from lunar and biorhythm data\n   */\n  private generatePrediction(\n    lunar: LunarState,\n    biorhythm: BiorhythmCycle,\n    correlations: LunarMarketCorrelation[]\n  ): { direction: 'up' | 'down' | 'neutral'; confidence: number; reasoning: string } {\n    const currentCorrelation = correlations.find(c => c.phase === lunar.phase);\n    \n    let lunarScore = 0;\n    if (currentCorrelation) {\n      if (currentCorrelation.historicalBias === 'bullish') lunarScore = currentCorrelation.strength;\n      else if (currentCorrelation.historicalBias === 'bearish') lunarScore = -currentCorrelation.strength;\n    }\n    \n    // Biorhythm contribution\n    const bioScore = biorhythm.combined * 0.3;\n    \n    // Eclipse effect (high uncertainty)\n    const eclipseModifier = lunar.isEclipse ? 0.5 : 1;\n    \n    const totalScore = (lunarScore + bioScore) * eclipseModifier;\n    const confidence = Math.min(0.6, Math.abs(totalScore) * 0.8); // Cap at 60% - this is speculative\n    \n    let reasoning = `${lunar.phase.replace('_', ' ')} phase`;\n    if (biorhythm.combined > 0.3) reasoning += ', positive biorhythm';\n    else if (biorhythm.combined < -0.3) reasoning += ', negative biorhythm';\n    if (lunar.isEclipse) reasoning += ' (eclipse caution)';\n    \n    if (Math.abs(totalScore) < 0.1) {\n      return { direction: 'neutral', confidence: 0.3, reasoning };\n    }\n    \n    return {\n      direction: totalScore > 0 ? 'up' : 'down',\n      confidence,\n      reasoning,\n    };\n  }\n  \n  /**\n   * Record outcome for learning\n   */\n  recordOutcome(phase: LunarPhase, actualDirection: 'up' | 'down'): void {\n    const stats = this.phaseStats.get(phase);\n    if (stats) {\n      stats.total++;\n      if (actualDirection === 'up') stats.up++;\n      else stats.down++;\n    }\n    \n    this.outcomeHistory.push({\n      phase,\n      direction: actualDirection,\n      wasCorrect: true, // Will be used for prediction accuracy later\n    });\n    \n    if (this.outcomeHistory.length > 1000) {\n      this.outcomeHistory.shift();\n    }\n  }\n  \n  /**\n   * Get accuracy by lunar phase\n   */\n  getAccuracyByPhase(): Record<LunarPhase, number> {\n    const result: Record<LunarPhase, number> = {} as Record<LunarPhase, number>;\n    \n    for (const [phase, stats] of this.phaseStats) {\n      if (stats.total < 5) {\n        result[phase] = 0.5;\n      } else {\n        // Accuracy is how well our bias matches reality\n        const upRatio = stats.up / stats.total;\n        const bias = this.getHistoricalBias(phase);\n        \n        if (bias.historicalBias === 'bullish') {\n          result[phase] = upRatio;\n        } else if (bias.historicalBias === 'bearish') {\n          result[phase] = 1 - upRatio;\n        } else {\n          result[phase] = 1 - Math.abs(upRatio - 0.5) * 2;\n        }\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get confidence modifier\n   */\n  getConfidenceModifier(): number {\n    const state = this.getState();\n    \n    // Higher sync = higher confidence\n    const syncModifier = 0.9 + state.syncScore * 0.2;\n    \n    // Eclipse reduces confidence\n    const eclipseModifier = state.lunar.isEclipse ? 0.7 : 1;\n    \n    return syncModifier * eclipseModifier * this.regularization;\n  }\n}\n\nexport const biorhythmLunarSync = new BiorhythmLunarSync();\nexport type { LunarPhase, LunarState, BiorhythmCycle, BiorhythmLunarState };\n";export{n as default};
