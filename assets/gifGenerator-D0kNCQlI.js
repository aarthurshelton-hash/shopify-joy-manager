const e="import GIF from 'gif.js';\nimport html2canvas from 'html2canvas';\nimport { SimulationResult, SquareData } from './gameSimulator';\n\ninterface GifGeneratorOptions {\n  board: SquareData[][];\n  totalMoves: number;\n  frameDelay?: number; // ms between frames\n  quality?: number; // 1-30, lower is better quality\n  onProgress?: (progress: number) => void;\n}\n\n// Filter board to show only moves up to a certain point\nfunction filterBoardToMove(board: SquareData[][], moveNumber: number): SquareData[][] {\n  return board.map(rank =>\n    rank.map(square => ({\n      ...square,\n      visits: square.visits.filter(visit => visit.moveNumber <= moveNumber)\n    }))\n  );\n}\n\nexport async function generateGameGif(\n  captureElement: HTMLElement,\n  options: GifGeneratorOptions\n): Promise<Blob> {\n  const {\n    board,\n    totalMoves,\n    frameDelay = 150,\n    quality = 10,\n    onProgress\n  } = options;\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      // Capture the first frame to get dimensions\n      const firstCanvas = await html2canvas(captureElement, {\n        scale: 2, // Good quality without being too large\n        useCORS: true,\n        allowTaint: true,\n        logging: false,\n      });\n\n      const gif = new GIF({\n        workers: 2,\n        quality,\n        width: firstCanvas.width,\n        height: firstCanvas.height,\n        workerScript: '/gif.worker.js',\n      });\n\n      // Determine which moves to capture (sample if too many)\n      const maxFrames = 60; // Limit frames for reasonable file size\n      const step = totalMoves > maxFrames ? Math.ceil(totalMoves / maxFrames) : 1;\n      const movesToCapture: number[] = [];\n      \n      for (let i = 1; i <= totalMoves; i += step) {\n        movesToCapture.push(i);\n      }\n      // Always include the final frame\n      if (movesToCapture[movesToCapture.length - 1] !== totalMoves) {\n        movesToCapture.push(totalMoves);\n      }\n\n      // Add starting position (move 0)\n      movesToCapture.unshift(0);\n\n      const totalFrames = movesToCapture.length;\n      let capturedFrames = 0;\n\n      // Capture frames for each move\n      for (const moveNum of movesToCapture) {\n        // We need to trigger a re-render with the filtered board\n        // This is handled by the component that calls this function\n        \n        // Wait for render\n        await new Promise(r => setTimeout(r, 50));\n\n        const canvas = await html2canvas(captureElement, {\n          scale: 2,\n          useCORS: true,\n          allowTaint: true,\n          logging: false,\n        });\n\n        // Add frame - hold first and last frames longer\n        const isFirstOrLast = moveNum === 0 || moveNum === totalMoves;\n        gif.addFrame(canvas, { \n          delay: isFirstOrLast ? frameDelay * 3 : frameDelay,\n          copy: true \n        });\n\n        capturedFrames++;\n        onProgress?.(capturedFrames / totalFrames * 0.8); // 80% for capture\n      }\n\n      gif.on('progress', (p: number) => {\n        onProgress?.(0.8 + p * 0.2); // Last 20% for encoding\n      });\n\n      gif.on('finished', (blob: Blob) => {\n        resolve(blob);\n      });\n\n      gif.render();\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n";export{e as default};
