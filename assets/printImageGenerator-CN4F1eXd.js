const e="import { SimulationResult, SquareData } from './gameSimulator';\nimport { generateQRDataUrl } from '@/lib/qr/generateVisualizationQR';\nimport { PieceType, PieceColor } from './pieceColors';\n\n// Use string-based type for CapturedState to match the store's generic type\ninterface LockedPiece {\n  pieceType: string;\n  pieceColor: string;\n}\n\ninterface LockedSquare {\n  square: string;\n  pieces: LockedPiece[];\n}\n\ninterface CapturedState {\n  currentMove: number;\n  selectedPhase: string;\n  lockedPieces: LockedPiece[];\n  lockedSquares?: LockedSquare[];\n  compareMode: boolean;\n  displayMode: string;\n  darkMode: boolean;\n  showTerritory: boolean;\n  showHeatmaps: boolean;\n  showPieces?: boolean;\n  pieceOpacity?: number;\n  capturedAt: Date;\n}\n\ninterface HighlightState {\n  lockedPieces: { pieceType: PieceType; pieceColor: PieceColor }[];\n  lockedSquares?: { square: string; pieces: { pieceType: PieceType; pieceColor: PieceColor }[] }[];\n  compareMode: boolean;\n}\n\ninterface PrintOptions {\n  darkMode?: boolean;\n  includeQR?: boolean;\n  shareId?: string;\n  capturedState?: CapturedState;\n  withWatermark?: boolean;\n  highlightState?: HighlightState;\n}\n\n/**\n * Filter board data to match a specific move in the timeline\n */\nfunction filterBoardToMove(board: SquareData[][], currentMove: number): SquareData[][] {\n  if (currentMove === Infinity || currentMove <= 0) return board;\n  \n  return board.map(row => \n    row.map(square => ({\n      ...square,\n      visits: square.visits.filter(visit => visit.moveNumber <= currentMove)\n    }))\n  );\n}\n\n/**\n * Generates a clean (no watermark) base64 image from a chess visualization\n * This is used for Printify print orders - identical to the preview\n * Uses the PrintReadyVisualization component for consistent \"trademark look\"\n */\ninterface PrintOptionsExtended extends PrintOptions {\n  pgn?: string; // Explicit PGN override for piece rendering\n}\n\nexport async function generateCleanPrintImage(\n  simulation: SimulationResult,\n  options: PrintOptionsExtended = {}\n): Promise<string> {\n  const { darkMode = false, includeQR = false, shareId, capturedState, withWatermark = false, highlightState: providedHighlightState, pgn: explicitPgn } = options;\n  \n  // Validate simulation data before attempting generation\n  if (!simulation) {\n    console.error('[printImageGenerator] Invalid simulation: null or undefined');\n    throw new Error('Invalid simulation data: simulation is null');\n  }\n  \n  if (!simulation.board || !Array.isArray(simulation.board) || simulation.board.length === 0) {\n    console.error('[printImageGenerator] Invalid simulation board:', simulation.board);\n    throw new Error('Invalid simulation data: board is empty or invalid');\n  }\n  \n  if (!simulation.gameData) {\n    console.error('[printImageGenerator] Invalid simulation gameData:', simulation.gameData);\n    throw new Error('Invalid simulation data: gameData is missing');\n  }\n  \n  console.log('[printImageGenerator] Starting image generation with valid simulation');\n  \n  const html2canvas = (await import('html2canvas')).default;\n  \n  // Create a temporary container for rendering\n  const container = document.createElement('div');\n  container.style.position = 'absolute';\n  container.style.left = '-9999px';\n  container.style.top = '-9999px';\n  document.body.appendChild(container);\n  \n  try {\n    console.log('[printImageGenerator] Creating temporary container');\n    // Import React and ReactDOM for rendering\n    const React = await import('react');\n    const ReactDOM = await import('react-dom/client');\n    const { default: PrintReadyVisualization } = await import('@/components/chess/PrintReadyVisualization');\n    console.log('[printImageGenerator] Dependencies imported successfully');\n    \n    // Apply captured state filtering if available - this ensures the print matches exactly what the user sees\n    const filteredBoard = capturedState && capturedState.currentMove !== Infinity && capturedState.currentMove > 0\n      ? filterBoardToMove(simulation.board, capturedState.currentMove)\n      : simulation.board;\n    console.log(`[printImageGenerator] Board filtered: ${capturedState ? 'yes' : 'no'}, moves: ${capturedState?.currentMove ?? 'all'}`);\n    \n    // Use captured dark mode if available, otherwise fall back to passed option\n    const effectiveDarkMode = capturedState?.darkMode ?? darkMode;\n    console.log(`[printImageGenerator] Dark mode: ${effectiveDarkMode}`);\n    \n    // Generate QR code if needed\n    let qrDataUrl: string | undefined;\n    if (includeQR && shareId) {\n      try {\n        qrDataUrl = await generateQRDataUrl(shareId, 96);\n        console.log('[printImageGenerator] QR code generated successfully');\n      } catch (qrError) {\n        console.warn('Failed to generate QR code for print:', qrError);\n      }\n    }\n    \n    // Create the print content element\n    const printContent = document.createElement('div');\n    container.appendChild(printContent);\n    \n    // Prepare highlight state for rendering - use provided or from captured state\n    // This ensures locked pieces, locked squares, and compare mode are captured exactly as displayed\n    // Map pieceColor from 'white'/'black' strings to 'w'/'b' types if needed\n    const hasLockedPieces = capturedState?.lockedPieces?.length ?? 0;\n    const hasLockedSquares = capturedState?.lockedSquares?.length ?? 0;\n    \n    const highlightState = providedHighlightState || ((hasLockedPieces > 0 || hasLockedSquares > 0) && capturedState ? {\n      lockedPieces: (capturedState.lockedPieces || []).map(p => ({\n        pieceType: p.pieceType as PieceType,\n        pieceColor: (p.pieceColor === 'white' ? 'w' : p.pieceColor === 'black' ? 'b' : p.pieceColor) as PieceColor,\n      })),\n      lockedSquares: (capturedState.lockedSquares || []).map(sq => ({\n        square: sq.square,\n        pieces: sq.pieces.map(p => ({\n          pieceType: p.pieceType as PieceType,\n          pieceColor: (p.pieceColor === 'white' ? 'w' : p.pieceColor === 'black' ? 'b' : p.pieceColor) as PieceColor,\n        })),\n      })),\n      compareMode: capturedState.compareMode,\n    } : undefined);\n    \n    // Prepare pieces state for overlay if captured - include currentMoveNumber for accurate position\n    const piecesState = capturedState?.showPieces ? {\n      showPieces: capturedState.showPieces,\n      pieceOpacity: capturedState.pieceOpacity ?? 0.7,\n      currentMoveNumber: capturedState.currentMove !== Infinity ? capturedState.currentMove : undefined,\n    } : undefined;\n    \n    // Render the unified PrintReadyVisualization component with longer timeout\n    const root = ReactDOM.createRoot(printContent);\n    await new Promise<void>((resolve) => {\n      root.render(\n        React.createElement(PrintReadyVisualization, {\n          board: filteredBoard,\n          gameData: simulation.gameData,\n          size: 440, // High-res for print (400 board + padding)\n          darkMode: effectiveDarkMode,\n          showQR: includeQR && !!qrDataUrl,\n          qrDataUrl,\n          compact: false,\n          highlightState,\n          piecesState,\n          pgn: explicitPgn || simulation.gameData.pgn,\n          withWatermark, // Pass watermark flag to component\n        })\n      );\n      // Give React more time to render - increased from 150ms to 500ms\n      setTimeout(resolve, 500);\n    });\n    \n    // Wait longer for images/fonts to load\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Capture with html2canvas with retry logic\n    let canvas;\n    let retries = 0;\n    const maxRetries = 3;\n    \n    while (retries < maxRetries) {\n      try {\n        canvas = await html2canvas(printContent, {\n          scale: 3, // High resolution for print quality\n          backgroundColor: effectiveDarkMode ? '#0A0A0A' : '#FDFCFB',\n          useCORS: true,\n          allowTaint: true,\n          logging: false,\n          // Add image timeout\n          imageTimeout: 15000,\n        });\n        break; // Success, exit retry loop\n      } catch (captureError) {\n        retries++;\n        console.warn(`[printImageGenerator] html2canvas attempt ${retries} failed:`, captureError);\n        if (retries >= maxRetries) {\n          throw new Error(`html2canvas failed after ${maxRetries} attempts: ${captureError}`);\n        }\n        // Wait before retry\n        await new Promise(resolve => setTimeout(resolve, 500));\n      }\n    }\n    \n    // Convert to base64\n    const base64 = canvas.toDataURL('image/png', 1.0);\n    \n    // Cleanup React root\n    root.unmount();\n    \n    return base64;\n  } finally {\n    // Always cleanup the container\n    document.body.removeChild(container);\n  }\n}\n\n/**\n * Legacy signature for backward compatibility\n */\nexport async function generateCleanPrintImageLegacy(\n  simulation: SimulationResult,\n  darkMode: boolean = false\n): Promise<string> {\n  return generateCleanPrintImage(simulation, { darkMode });\n}\n";export{e as default};
