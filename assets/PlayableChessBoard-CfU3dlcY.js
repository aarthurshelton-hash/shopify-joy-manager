const e="import { useState, useCallback, useMemo, useRef } from 'react';\nimport { Square } from 'chess.js';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { useHapticFeedback } from '@/hooks/useHapticFeedback';\nimport { EnPensentOverlay, MoveHistoryEntry } from './EnPensentOverlay';\nimport { useLegendHighlight, HighlightedPiece } from '@/contexts/LegendHighlightContext';\n\ninterface PlayableChessBoardProps {\n  fen: string;\n  onMove: (from: Square, to: Square, promotion?: string) => Promise<boolean>;\n  getAvailableMoves: (square: Square) => Square[];\n  isMyTurn: boolean;\n  myColor: 'w' | 'b' | null;\n  whitePalette: Record<string, string>;\n  blackPalette: Record<string, string>;\n  movedSquares: Set<string>;\n  disabled?: boolean;\n  onMoveResult?: (result: { isCapture: boolean; isCheck: boolean; isCheckmate: boolean; isCastle: boolean }) => void;\n  // En Pensent mode props\n  enPensentEnabled?: boolean;\n  enPensentOpacity?: number;\n  moveHistory?: MoveHistoryEntry[];\n  // Show pieces overlay (like PrintReady)\n  showPieces?: boolean;\n}\n\nconst PIECE_SYMBOLS: Record<string, string> = {\n  K: '♔', Q: '♕', R: '♖', B: '♗', N: '♘', P: '♙',\n  k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟',\n};\n\nconst parseFen = (fen: string): (string | null)[][] => {\n  const rows = fen.split(' ')[0].split('/');\n  return rows.map(row => {\n    const squares: (string | null)[] = [];\n    for (const char of row) {\n      if (/\\d/.test(char)) {\n        for (let i = 0; i < parseInt(char); i++) squares.push(null);\n      } else {\n        squares.push(char);\n      }\n    }\n    return squares;\n  });\n};\n\nconst squareToIndex = (square: Square): [number, number] => {\n  const col = square.charCodeAt(0) - 97;\n  const row = 8 - parseInt(square[1]);\n  return [row, col];\n};\n\nconst indexToSquare = (row: number, col: number): Square => {\n  return `${String.fromCharCode(97 + col)}${8 - row}` as Square;\n};\n\nexport const PlayableChessBoard = ({\n  fen,\n  onMove,\n  getAvailableMoves,\n  isMyTurn,\n  myColor,\n  whitePalette,\n  blackPalette,\n  movedSquares,\n  disabled = false,\n  onMoveResult,\n  enPensentEnabled = false,\n  enPensentOpacity = 1, // Default to full opacity (solid, not translucent)\n  moveHistory = [],\n  showPieces = true, // Default to showing pieces\n}: PlayableChessBoardProps) => {\n  const [selectedSquare, setSelectedSquare] = useState<Square | null>(null);\n  const [availableMoves, setAvailableMoves] = useState<Square[]>([]);\n  const [touchFeedback, setTouchFeedback] = useState<Square | null>(null);\n  const boardRef = useRef<HTMLDivElement>(null);\n  const { haptics } = useHapticFeedback();\n\n  // Try to use legend highlight context for reverse highlighting\n  let legendContext: ReturnType<typeof useLegendHighlight> | null = null;\n  try {\n    legendContext = useLegendHighlight();\n  } catch {\n    // Context not available\n  }\n\n  const board = useMemo(() => parseFen(fen), [fen]);\n  const flipped = myColor === 'b';\n\n  // Build a map of square -> pieces that visited it (for hover highlighting)\n  const squarePieceMap = useMemo(() => {\n    const map = new Map<string, HighlightedPiece[]>();\n    \n    for (const move of moveHistory) {\n      const existing = map.get(move.square) || [];\n      // Check if this piece is already in the list\n      const alreadyExists = existing.some(\n        p => p.pieceType === move.piece && p.pieceColor === move.color\n      );\n      if (!alreadyExists) {\n        existing.push({ pieceType: move.piece, pieceColor: move.color });\n        map.set(move.square, existing);\n      }\n    }\n    \n    return map;\n  }, [moveHistory]);\n\n  // Get piece color - always return full color (pieces should always be visible)\n  const getPieceDisplayColor = (piece: string): string => {\n    const isWhite = piece === piece.toUpperCase();\n    // Use standard black/white piece colors for clear visibility\n    return isWhite ? '#1a1a1a' : '#f5f5f5';\n  };\n\n  const handleSquareInteraction = useCallback(async (row: number, col: number) => {\n    if (disabled || !isMyTurn) return;\n\n    const square = indexToSquare(flipped ? 7 - row : row, flipped ? 7 - col : col);\n    const piece = board[flipped ? 7 - row : row]?.[flipped ? 7 - col : col];\n\n    // Touch feedback\n    setTouchFeedback(square);\n    setTimeout(() => setTouchFeedback(null), 150);\n\n    // If we have a selected piece and click on an available move\n    if (selectedSquare && availableMoves.includes(square)) {\n      // Check if this is a capture (target square has opponent piece)\n      const targetPiece = board[flipped ? 7 - row : row]?.[flipped ? 7 - col : col];\n      const isCapture = !!targetPiece;\n      \n      // Haptic feedback for the move attempt\n      if (isCapture) {\n        haptics.capture();\n      } else {\n        haptics.move();\n      }\n      \n      const success = await onMove(selectedSquare, square);\n      if (success) {\n        setSelectedSquare(null);\n        setAvailableMoves([]);\n      } else {\n        // Illegal move\n        haptics.error();\n      }\n      return;\n    }\n\n    // If clicking on own piece, select it\n    if (piece) {\n      const isOwnPiece = myColor === 'w' \n        ? piece === piece.toUpperCase() \n        : piece === piece.toLowerCase();\n      \n      if (isOwnPiece) {\n        haptics.select();\n        setSelectedSquare(square);\n        setAvailableMoves(getAvailableMoves(square));\n        return;\n      }\n    }\n\n    // Deselect\n    setSelectedSquare(null);\n    setAvailableMoves([]);\n  }, [board, selectedSquare, availableMoves, isMyTurn, myColor, flipped, disabled, onMove, getAvailableMoves, haptics]);\n\n\n  // Handle square hover for legend highlighting\n  const handleSquareHover = useCallback((square: string) => {\n    if (!legendContext?.setHoveredSquare) return;\n    \n    const pieces = squarePieceMap.get(square);\n    if (pieces && pieces.length > 0) {\n      // For live games, we don't have moveNumbers per square yet, so pass empty array\n      legendContext.setHoveredSquare({ square, pieces, moveNumbers: [] });\n    } else {\n      // Clear hover when moving to a square with no history\n      legendContext.setHoveredSquare(null);\n    }\n  }, [legendContext, squarePieceMap]);\n\n  const handleSquareLeave = useCallback(() => {\n    if (legendContext?.setHoveredSquare) {\n      legendContext.setHoveredSquare(null);\n    }\n  }, [legendContext]);\n\n  // Check if this square should be highlighted based on legend selection\n  const isSquareHighlighted = useCallback((square: string) => {\n    if (!legendContext) return false;\n    \n    const { highlightedPiece, lockedPieces } = legendContext;\n    const piecesToCheck = lockedPieces.length > 0 ? lockedPieces : (highlightedPiece ? [highlightedPiece] : []);\n    \n    if (piecesToCheck.length === 0) return false;\n    \n    // Check if any of the highlighted pieces visited this square\n    for (const move of moveHistory) {\n      for (const piece of piecesToCheck) {\n        if (move.square === square && move.piece === piece.pieceType && move.color === piece.pieceColor) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }, [legendContext, moveHistory]);\n\n  // Check if filtering is active (any piece highlighted in legend)\n  const hasActiveFilter = legendContext && (\n    legendContext.highlightedPiece !== null || \n    legendContext.lockedPieces.length > 0\n  );\n\n  const renderSquare = (row: number, col: number) => {\n    const actualRow = flipped ? 7 - row : row;\n    const actualCol = flipped ? 7 - col : col;\n    const square = indexToSquare(actualRow, actualCol);\n    const piece = board[actualRow]?.[actualCol];\n    const isLight = (row + col) % 2 === 0;\n    const isSelected = selectedSquare === square;\n    const isAvailableMove = availableMoves.includes(square);\n    const hasBeenMoved = movedSquares.has(square);\n    const isTouched = touchFeedback === square;\n    const hasPieceHistory = squarePieceMap.has(square);\n    const isHighlightedByLegend = isSquareHighlighted(square);\n    \n    // Dim squares that don't match when legend filter is active\n    const shouldDimSquare = hasActiveFilter && hasPieceHistory && !isHighlightedByLegend;\n    const shouldHighlightSquare = hasActiveFilter && isHighlightedByLegend;\n\n    return (\n      <motion.div\n        key={square}\n        onClick={() => handleSquareInteraction(row, col)}\n        onMouseEnter={() => handleSquareHover(square)}\n        onMouseLeave={handleSquareLeave}\n        onTouchEnd={(e) => {\n          // Mobile: long-press or double-tap to show legend info\n          if (enPensentEnabled && hasPieceHistory) {\n            e.stopPropagation();\n            handleSquareHover(square);\n            // Clear after a short delay so user can see the legend highlight\n            setTimeout(() => handleSquareLeave(), 2000);\n          }\n        }}\n        onTouchStart={(e) => {\n          // Prevent default to avoid double-tap zoom on mobile\n          e.stopPropagation();\n        }}\n        className={`\n          relative aspect-square cursor-pointer transition-all\n          ${isLight ? 'bg-amber-100' : 'bg-amber-700'}\n          ${isSelected ? 'ring-4 ring-primary ring-inset z-10' : ''}\n          ${isTouched ? 'brightness-125' : ''}\n          ${!isMyTurn || disabled ? 'cursor-default' : ''}\n          ${hasPieceHistory && enPensentEnabled ? 'hover:ring-2 hover:ring-amber-400/50' : ''}\n          ${shouldDimSquare ? 'opacity-30' : ''}\n          ${shouldHighlightSquare ? 'ring-2 ring-sky-400/70 z-5' : ''}\n          touch-manipulation select-none\n        `}\n        style={{\n          // Larger touch target with invisible padding\n          WebkitTapHighlightColor: 'transparent',\n          transition: 'opacity 0.2s ease-out',\n        }}\n        whileTap={isMyTurn && !disabled ? { scale: 0.95 } : {}}\n      >\n        {/* Available move indicator - larger on mobile */}\n        {isAvailableMove && (\n          <motion.div\n            initial={{ scale: 0 }}\n            animate={{ scale: 1 }}\n            className=\"absolute inset-0 flex items-center justify-center z-20\"\n          >\n            {piece ? (\n              <div className=\"absolute inset-1 sm:inset-1.5 rounded-full border-4 sm:border-[5px] border-primary/60\" />\n            ) : (\n              <div className=\"w-1/3 h-1/3 sm:w-[30%] sm:h-[30%] rounded-full bg-primary/50\" />\n            )}\n          </motion.div>\n        )}\n\n        {/* Piece - always visible with standard colors when showPieces is true */}\n        {piece && showPieces && (\n          <motion.div\n            layout\n            initial={{ scale: 0.8, opacity: 0 }}\n            animate={{ scale: 1, opacity: 1 }}\n            className=\"absolute inset-0 flex items-center justify-center z-10\"\n            style={{\n              color: getPieceDisplayColor(piece),\n              textShadow: piece === piece.toUpperCase() \n                ? '0 1px 2px rgba(0,0,0,0.3), 0 0 1px rgba(255,255,255,0.8)'\n                : '0 1px 2px rgba(0,0,0,0.5), 0 0 1px rgba(0,0,0,0.3)',\n            }}\n          >\n            <span className=\"text-[2.5rem] sm:text-4xl md:text-5xl lg:text-6xl select-none drop-shadow-lg leading-none\">\n              {PIECE_SYMBOLS[piece]}\n            </span>\n          </motion.div>\n        )}\n\n        {/* Coordinate labels - hidden on very small screens */}\n        {col === 0 && (\n          <span className=\"absolute top-0.5 left-0.5 sm:left-1 text-[10px] sm:text-xs font-display opacity-50 select-none\">\n            {8 - actualRow}\n          </span>\n        )}\n        {row === 7 && (\n          <span className=\"absolute bottom-0.5 right-0.5 sm:right-1 text-[10px] sm:text-xs font-display opacity-50 select-none\">\n            {String.fromCharCode(97 + actualCol)}\n          </span>\n        )}\n      </motion.div>\n    );\n  };\n\n  return (\n    <div className=\"w-full max-w-lg mx-auto px-1 sm:px-0\">\n      {/* Turn indicator for mobile - shows clearly whose turn */}\n      <div className=\"sm:hidden mb-2 text-center\">\n        <span className={`inline-block px-3 py-1 rounded-full text-xs font-display uppercase tracking-wider ${\n          isMyTurn && !disabled\n            ? 'bg-primary/20 text-primary animate-pulse'\n            : 'bg-muted text-muted-foreground'\n        }`}>\n          {disabled ? 'Game Over' : isMyTurn ? 'Your Turn - Tap to Move' : \"Opponent's Turn\"}\n        </span>\n      </div>\n      \n      <div \n        ref={boardRef}\n        className=\"relative grid grid-cols-8 border-2 sm:border-4 border-amber-900 rounded-lg overflow-hidden shadow-2xl touch-manipulation\"\n        style={{\n          // Prevent any scrolling while interacting with the board\n          touchAction: 'none',\n        }}\n      >\n        {Array.from({ length: 64 }).map((_, i) => {\n          const row = Math.floor(i / 8);\n          const col = i % 8;\n          return renderSquare(row, col);\n        })}\n        \n        {/* En Pensent Visualization Overlay */}\n        <EnPensentOverlay\n          moveHistory={moveHistory}\n          whitePalette={whitePalette}\n          blackPalette={blackPalette}\n          opacity={enPensentOpacity}\n          isEnabled={enPensentEnabled}\n          flipped={flipped}\n        />\n      </div>\n\n      {/* Selected piece indicator for mobile */}\n      {selectedSquare && (\n        <div className=\"sm:hidden mt-2 text-center\">\n          <span className=\"inline-block px-3 py-1 rounded-full bg-primary/20 text-primary text-xs font-display uppercase tracking-wider\">\n            {availableMoves.length} move{availableMoves.length !== 1 ? 's' : ''} available\n          </span>\n        </div>\n      )}\n    </div>\n  );\n};";export{e as default};
