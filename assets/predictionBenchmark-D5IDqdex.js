const e="/**\n * En Pensent™ Prediction Benchmark System\n * \n * v7.56-SMART-FALLBACK: Intelligent fallback handling with quality tiers\n * v7.3-RETRY-ON-FALLBACK: Retries with extended time before accepting fallback\n * \n * THE PARADIGM: We don't just play chess - we predict its future better than pure calculation.\n * \n * This benchmark proves that fusing strategic pattern recognition with tactical analysis\n * creates predictions that surpass Stockfish's raw evaluation.\n * \n * Performance optimizations:\n * - Patterns loaded ONCE before benchmark starts (not per-prediction)\n * - Accuracy stats fetched ONCE and cached (not per-prediction)\n * - skipCloudEval option used to avoid API rate limits\n * - RETRY with extended timeout before accepting fallback\n * - SMART FALLBACK: Use archetype history instead of random guess\n */\n\nimport { Chess } from 'chess.js';\nimport { getStockfishEngine, terminateStockfish } from '../stockfishEngine';\nimport { generateHybridPrediction } from '../hybridPrediction';\nimport { extractColorFlowSignature } from '../colorFlowAnalysis';\nimport { simulateGame } from '../gameSimulator';\nimport { loadLearnedPatterns } from '../patternLearning/persistentPatternLoader';\nimport { updateAccuracyCache } from '../hybridPrediction/confidenceCalculator';\nimport { loadArchetypeStats, getArchetypePrediction } from '../accuracy/archetypeHistoricalRates';\n\ntype ChessCumulativeStats = {\n  totalGames: number;\n  hybridAccuracy: number;\n  stockfishAccuracy: number;\n};\n\nasync function fetchChessCumulativeStatsSafe(): Promise<ChessCumulativeStats> {\n  // Farm workers run this file under Node (tsx). The realtime accuracy hook depends on\n  // browser-only globals like import.meta.env and localStorage.\n  if (typeof window === 'undefined') {\n    return { totalGames: 0, hybridAccuracy: 50, stockfishAccuracy: 50 };\n  }\n\n  try {\n    const mod = (await import('@/hooks/useRealtimeAccuracy')) as any;\n    const stats = (await mod.fetchChessCumulativeStats()) as ChessCumulativeStats;\n    return stats;\n  } catch {\n    return { totalGames: 0, hybridAccuracy: 50, stockfishAccuracy: 50 };\n  }\n}\n\n// v7.56: Fallback quality tiers\nexport type FallbackTier = 'full' | 'partial_sf' | 'partial_hybrid' | 'archetype_fallback' | 'excluded';\n\nexport interface PredictionAttempt {\n  gameId: string;\n  moveNumber: number;\n  fen: string;\n  pgn: string;\n  \n  // Stockfish's prediction (from raw centipawn evaluation)\n  stockfishEval: number;\n  stockfishPrediction: 'white_wins' | 'black_wins' | 'draw';\n  stockfishConfidence: number; // 0-100\n  \n  // Hybrid system prediction\n  hybridPrediction: 'white_wins' | 'black_wins' | 'draw';\n  hybridConfidence: number; // 0-100\n  hybridArchetype: string;\n  \n  // Actual result after game completes\n  actualResult?: 'white_wins' | 'black_wins' | 'draw';\n  \n  // Scoring\n  stockfishCorrect?: boolean;\n  hybridCorrect?: boolean;\n  \n  // v7.3: Track if this was a retry\n  wasRetried?: boolean;\n  \n  // v7.56: Fallback quality tier\n  fallbackTier?: FallbackTier;\n  fallbackSource?: 'archetype_history' | 'default_rates' | 'random';\n}\n\nexport interface BenchmarkResult {\n  totalGames: number;\n  completedGames: number;\n  predictionPoints: PredictionAttempt[];\n  \n  // Win rates (v7.56: excludes 'excluded' tier)\n  stockfishAccuracy: number;\n  hybridAccuracy: number;\n  \n  // Detailed breakdown\n  stockfishWins: number;  // Predictions where SF was right, Hybrid wrong\n  hybridWins: number;     // Predictions where Hybrid was right, SF wrong\n  bothCorrect: number;\n  bothWrong: number;\n  \n  // By archetype\n  archetypePerformance: Record<string, { correct: number; total: number }>;\n  \n  // Statistical significance\n  confidence: number;\n  pValue: number;\n  \n  // Timestamp\n  startedAt: Date;\n  completedAt?: Date;\n  \n  // v7.3: Retry stats\n  totalRetries?: number;\n  \n  // v7.56: Fallback stats\n  fallbackStats?: {\n    full: number;           // Complete predictions\n    partial_sf: number;     // SF failed, Hybrid worked\n    partial_hybrid: number; // Hybrid failed, SF worked\n    archetype_fallback: number; // Used archetype history\n    excluded: number;       // Both failed - not in accuracy metrics\n  };\n}\n\n// v7.3: Helper to detect if result is a fallback\nfunction isFallbackResult<T>(result: T, fallback: T): boolean {\n  if (result === fallback) return true;\n  if (typeof result === 'object' && typeof fallback === 'object') {\n    return JSON.stringify(result) === JSON.stringify(fallback);\n  }\n  return false;\n}\n\n// v7.3: Promise with timeout that RETRIES with extended time on fallback\nasync function withRetryTimeout<T>(\n  promiseFactory: () => Promise<T>,\n  initialMs: number,\n  fallback: T,\n  maxRetries: number = 2,\n  timeoutMultiplier: number = 1.5\n): Promise<{ result: T; wasRetried: boolean }> {\n  let currentTimeout = initialMs;\n  let wasRetried = false;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    const result = await Promise.race([\n      promiseFactory(),\n      new Promise<T>((resolve) => setTimeout(() => resolve(fallback), currentTimeout))\n    ]);\n    \n    // If we got a real result (not fallback), return it\n    if (!isFallbackResult(result, fallback)) {\n      return { result, wasRetried };\n    }\n    \n    // On fallback, retry with more time\n    if (attempt < maxRetries) {\n      wasRetried = true;\n      currentTimeout = Math.round(currentTimeout * timeoutMultiplier);\n      console.log(`[v7.3] Timeout hit, retry ${attempt + 1}/${maxRetries} with ${currentTimeout}ms`);\n      \n      // Reset Stockfish if it might be stuck\n      if (attempt === 1) {\n        try {\n          terminateStockfish();\n          await new Promise(r => setTimeout(r, 500));\n        } catch (e) {\n          console.warn('[v7.3] Engine reset failed:', e);\n        }\n      }\n    }\n  }\n  \n  // All retries exhausted, return fallback\n  console.warn('[v7.3] All retries exhausted, using fallback');\n  return { result: fallback, wasRetried };\n}\n\n// Simple timeout helper (no retry) for non-critical operations\nfunction withTimeout<T>(promise: Promise<T>, ms: number, fallback: T): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((resolve) => setTimeout(() => resolve(fallback), ms))\n  ]);\n}\n\n// Convert Stockfish centipawn evaluation to win probability and prediction\n// v8.1-SYMMETRIC: Fixed asymmetric thresholds causing white bias\nfunction stockfishEvalToPrediction(cp: number): {\n  prediction: 'white_wins' | 'black_wins' | 'draw';\n  confidence: number;\n} {\n  // SYMMETRIC thresholds - identical for both colors\n  const WINNING_THRESHOLD = 150;\n  const ADVANTAGE_THRESHOLD = 50;\n  const SLIGHT_THRESHOLD = 15;\n  \n  // Winning positions - SYMMETRIC\n  if (cp > WINNING_THRESHOLD) {\n    const confidence = Math.min(85, 60 + (cp - WINNING_THRESHOLD) / 8);\n    return { prediction: 'white_wins', confidence };\n  } else if (cp < -WINNING_THRESHOLD) {\n    const confidence = Math.min(85, 60 + (-cp - WINNING_THRESHOLD) / 8);\n    return { prediction: 'black_wins', confidence };\n  }\n  \n  // Advantage positions - SYMMETRIC\n  else if (cp > ADVANTAGE_THRESHOLD) {\n    const advantage = (cp - ADVANTAGE_THRESHOLD) / (WINNING_THRESHOLD - ADVANTAGE_THRESHOLD);\n    const confidence = 45 + advantage * 20;\n    return { prediction: 'white_wins', confidence };\n  } else if (cp < -ADVANTAGE_THRESHOLD) {\n    const advantage = (-cp - ADVANTAGE_THRESHOLD) / (WINNING_THRESHOLD - ADVANTAGE_THRESHOLD);\n    const confidence = 45 + advantage * 20;\n    return { prediction: 'black_wins', confidence };\n  }\n  \n  // Slight advantage - SYMMETRIC\n  else if (cp > SLIGHT_THRESHOLD) {\n    const confidence = 35 + ((cp - SLIGHT_THRESHOLD) / (ADVANTAGE_THRESHOLD - SLIGHT_THRESHOLD)) * 10;\n    return { prediction: 'white_wins', confidence };\n  } else if (cp < -SLIGHT_THRESHOLD) {\n    const confidence = 35 + ((-cp - SLIGHT_THRESHOLD) / (ADVANTAGE_THRESHOLD - SLIGHT_THRESHOLD)) * 10;\n    return { prediction: 'black_wins', confidence };\n  }\n  \n  // Equal position\n  else {\n    const confidence = 30 + (SLIGHT_THRESHOLD - Math.abs(cp)) * 2;\n    return { prediction: 'draw', confidence };\n  }\n}\n\n// Generate a high-quality Stockfish vs Stockfish game\n// v8.2-IMPROVED: Increased timeouts and better error handling\nexport async function generateStockfishGame(\n  gameId: string,\n  depth: number = 18,\n  maxMoves: number = 100,\n  onProgress?: (move: number, pgn: string) => void\n): Promise<{ pgn: string; result: 'white_wins' | 'black_wins' | 'draw'; moveCount: number }> {\n  const chess = new Chess();\n  const engine = getStockfishEngine();\n  \n  // Timeout: 15s for engine ready (increased from 10s)\n  const ready = await withTimeout(engine.waitReady(), 15000, false);\n  if (!ready) {\n    console.warn(`[Benchmark] Stockfish not ready for game ${gameId}, returning short game`);\n    return { pgn: '', result: 'draw', moveCount: 0 };\n  }\n  \n  let moveCount = 0;\n  const MOVE_TIMEOUT = 8000; // 8s per move max (increased from 5s)\n  const GAME_TIMEOUT = 180000; // 3 min total game limit (increased from 2min)\n  const gameStart = Date.now();\n  \n  // Validate depth parameter\n  if (depth < 10 || depth > 25) {\n    console.warn(`[Benchmark] Depth ${depth} outside optimal range (10-25), using 18`);\n    depth = 18;\n  }\n  \n  let consecutiveFailures = 0;\n  const MAX_CONSECUTIVE_FAILURES = 3;\n  \n  while (!chess.isGameOver() && moveCount < maxMoves) {\n    // Check total game timeout\n    if (Date.now() - gameStart > GAME_TIMEOUT) {\n      console.warn(`[Benchmark] Game ${gameId} hit 3-minute limit at move ${moveCount}`);\n      break;\n    }\n    \n    // Analysis with 8s timeout per move\n    const analysis = await withTimeout(\n      engine.analyzePosition(chess.fen(), { depth, nodes: 100000 }),\n      MOVE_TIMEOUT,\n      { bestMove: null, evaluation: { score: 0 } } as any\n    );\n    \n    if (analysis.bestMove) {\n      try {\n        const from = analysis.bestMove.slice(0, 2);\n        const to = analysis.bestMove.slice(2, 4);\n        const promotion = analysis.bestMove.length > 4 ? analysis.bestMove[4] : undefined;\n        \n        chess.move({ from, to, promotion });\n        moveCount++;\n        consecutiveFailures = 0; // Reset on success\n        \n        onProgress?.(moveCount, chess.pgn());\n      } catch (e) {\n        console.warn(`[Benchmark] Move failed in game ${gameId}:`, analysis.bestMove, e);\n        consecutiveFailures++;\n        if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {\n          console.error(`[Benchmark] Too many consecutive failures in game ${gameId}, aborting`);\n          break;\n        }\n      }\n    } else {\n      console.warn(`[Benchmark] No best move returned for game ${gameId} at move ${moveCount}`);\n      consecutiveFailures++;\n      if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {\n        console.error(`[Benchmark] Too many consecutive failures in game ${gameId}, aborting`);\n        break;\n      }\n    }\n  }\n  \n  // Determine result - v8.1-SYMMETRIC: Use consistent threshold\n  let result: 'white_wins' | 'black_wins' | 'draw' = 'draw';\n  if (chess.isCheckmate()) {\n    result = chess.turn() === 'w' ? 'black_wins' : 'white_wins';\n  } else if (chess.isDraw()) {\n    result = 'draw';\n  } else if (moveCount >= maxMoves || Date.now() - gameStart > GAME_TIMEOUT) {\n    // SYMMETRIC timeout evaluation - same threshold as prediction\n    const finalEval = await withTimeout(engine.quickEval(chess.fen()), 5000, 0);\n    const TIMEOUT_THRESHOLD = 150; // Match WINNING_THRESHOLD in stockfishEvalToPrediction\n    if (finalEval > TIMEOUT_THRESHOLD) result = 'white_wins';\n    else if (finalEval < -TIMEOUT_THRESHOLD) result = 'black_wins';\n    else result = 'draw';\n  }\n  \n  console.log(`[Benchmark] Game ${gameId} completed: ${moveCount} moves, result: ${result}`);\n  return { pgn: chess.pgn(), result, moveCount };\n}\n\n// Make a prediction at a specific point in the game\n// v7.56-SMART-FALLBACK: Uses archetype history for intelligent fallbacks\n// v7.3: Uses retry-on-fallback for both Stockfish and Hybrid predictions\nasync function makePredictionAtMove(\n  gameId: string,\n  fullPgn: string,\n  moveNumber: number,\n  depth: number = 18\n): Promise<PredictionAttempt> {\n  const chess = new Chess();\n  chess.loadPgn(fullPgn);\n  \n  // Get history and replay up to moveNumber\n  const history = chess.history({ verbose: true });\n  chess.reset();\n  \n  for (let i = 0; i < Math.min(moveNumber, history.length); i++) {\n    chess.move(history[i].san);\n  }\n  \n  const truncatedPgn = chess.pgn();\n  const fen = chess.fen();\n  \n  // v7.56: Track fallback state\n  let sfFailed = false;\n  let hybridFailed = false;\n  let fallbackTier: FallbackTier = 'full';\n  let fallbackSource: 'archetype_history' | 'default_rates' | 'random' | undefined;\n  \n  // v7.56: Pre-extract Color Flow signature for smart fallback\n  let extractedArchetype: string = 'unknown';\n  let extractedDominantSide: 'white' | 'black' | 'contested' = 'contested';\n  try {\n    const simResult = simulateGame(truncatedPgn);\n    if (simResult.board && simResult.gameData) {\n      const signature = extractColorFlowSignature(simResult.board, simResult.gameData, moveNumber);\n      extractedArchetype = signature.archetype;\n      extractedDominantSide = signature.dominantSide;\n    }\n  } catch (e) {\n    console.warn('[v7.56] Signature extraction failed:', e);\n  }\n  \n  // v7.3: Stockfish evaluation with RETRY on timeout\n  const engine = getStockfishEngine();\n  await withTimeout(engine.waitReady(), 5000, false);\n  \n  const sfFallback = { evaluation: { score: 0 }, bestMove: '', isFallback: true } as any;\n  const { result: analysis, wasRetried: sfRetried } = await withRetryTimeout(\n    () => engine.analyzePosition(fen, { depth, nodes: 100000 }),\n    8000, // 8s initial timeout\n    sfFallback,\n    2, // max 2 retries\n    1.5 // 1.5x timeout on retry (8s -> 12s -> 18s)\n  );\n  \n  // Check if SF actually returned data or fallback\n  sfFailed = analysis.isFallback === true || (analysis.evaluation?.score === 0 && !analysis.bestMove);\n  \n  const stockfishResult = stockfishEvalToPrediction(analysis.evaluation?.score || 0);\n  \n  // v7.56: Hybrid prediction with SMART FALLBACK\n  const hybridFallback = { \n    trajectoryPrediction: { outcomeProbabilities: { whiteWin: 0.33, blackWin: 0.33, draw: 0.34 } },\n    confidence: { overall: 30 },\n    strategicAnalysis: { archetype: 'FALLBACK' },\n    isFallback: true\n  } as any;\n  \n  const { result: hybridResult, wasRetried: hybridRetried } = await withRetryTimeout(\n    () => generateHybridPrediction(truncatedPgn, { \n      depth,\n      precomputedEval: analysis.evaluation?.score || 0,\n      precomputedDepth: analysis.evaluation?.depth || depth,\n      skipCloudEval: true,\n    }),\n    12000, // 12s initial timeout\n    hybridFallback,\n    2, // max 2 retries\n    1.5 // 1.5x timeout on retry (12s -> 18s -> 27s)\n  );\n  \n  // Check if Hybrid actually returned data or fallback\n  hybridFailed = hybridResult.isFallback === true || hybridResult.strategicAnalysis?.archetype === 'FALLBACK';\n  \n  // v7.56: Determine fallback tier and apply smart fallback if needed\n  let hybridPrediction: 'white_wins' | 'black_wins' | 'draw';\n  let hybridConfidence: number;\n  let hybridArchetype: string;\n  \n  if (!hybridFailed) {\n    // Full prediction available\n    fallbackTier = sfFailed ? 'partial_sf' : 'full';\n    const probs = hybridResult.trajectoryPrediction.outcomeProbabilities;\n    hybridPrediction = \n      probs.whiteWin > probs.blackWin && probs.whiteWin > probs.draw ? 'white_wins' :\n      probs.blackWin > probs.draw ? 'black_wins' : 'draw';\n    hybridConfidence = hybridResult.confidence.overall;\n    hybridArchetype = hybridResult.strategicAnalysis.archetype;\n  } else if (!sfFailed && extractedArchetype !== 'unknown') {\n    // Hybrid failed but SF worked AND we have an archetype - use smart fallback\n    fallbackTier = 'archetype_fallback';\n    const archetypePred = getArchetypePrediction(extractedArchetype as any, extractedDominantSide);\n    hybridPrediction = archetypePred.prediction;\n    hybridConfidence = archetypePred.confidence;\n    hybridArchetype = `${extractedArchetype}_fallback`;\n    fallbackSource = archetypePred.source === 'historical' ? 'archetype_history' : 'default_rates';\n    console.log(`[v7.56] Smart fallback for ${gameId}: ${extractedArchetype} -> ${hybridPrediction} (${fallbackSource})`);\n  } else if (sfFailed && hybridFailed) {\n    // Both failed - exclude from metrics\n    fallbackTier = 'excluded';\n    hybridPrediction = 'draw'; // Placeholder\n    hybridConfidence = 0;\n    hybridArchetype = 'EXCLUDED';\n    fallbackSource = 'random';\n    console.warn(`[v7.56] Both SF and Hybrid failed for ${gameId} - excluding from metrics`);\n  } else {\n    // SF failed, hybrid worked\n    fallbackTier = 'partial_hybrid';\n    const probs = hybridResult.trajectoryPrediction.outcomeProbabilities;\n    hybridPrediction = \n      probs.whiteWin > probs.blackWin && probs.whiteWin > probs.draw ? 'white_wins' :\n      probs.blackWin > probs.draw ? 'black_wins' : 'draw';\n    hybridConfidence = hybridResult.confidence.overall;\n    hybridArchetype = hybridResult.strategicAnalysis.archetype;\n  }\n  \n  const wasRetried = sfRetried || hybridRetried;\n  if (wasRetried) {\n    console.log(`[v7.56] Prediction for ${gameId} completed after retry (SF: ${sfRetried}, Hybrid: ${hybridRetried}, Tier: ${fallbackTier})`);\n  }\n    \n  return {\n    gameId,\n    moveNumber,\n    fen,\n    pgn: truncatedPgn,\n    stockfishEval: analysis.evaluation?.score || 0,\n    stockfishPrediction: stockfishResult.prediction,\n    stockfishConfidence: stockfishResult.confidence,\n    hybridPrediction,\n    hybridConfidence,\n    hybridArchetype,\n    wasRetried,\n    fallbackTier,\n    fallbackSource,\n  };\n}\n\n// Run the full benchmark\n// v7.2-BENCHMARK-STREAMLINED: Pre-load all patterns and cache accuracy ONCE before loop\nexport async function runPredictionBenchmark(\n  options: {\n    numGames?: number;\n    predictionMoveNumber?: number;\n    depth?: number;\n    onProgress?: (status: string, progress: number) => void;\n  } = {}\n): Promise<BenchmarkResult> {\n  const {\n    numGames = 10,\n    predictionMoveNumber = 20,\n    depth = 18,\n    onProgress,\n  } = options;\n  \n  // v7.2: PRE-LOAD patterns ONCE before benchmark starts\n  onProgress?.('Loading historical patterns...', 1);\n  try {\n    const { loaded } = await withTimeout(\n      loadLearnedPatterns(),\n      10000, // 10s timeout\n      { loaded: 0, hybridWins: 0, stockfishWins: 0, totalAccuracy: 0 }\n    );\n    console.log(`[Benchmark] Pre-loaded ${loaded} historical patterns`);\n  } catch (e) {\n    console.warn('[Benchmark] Pattern pre-load failed, continuing:', e);\n  }\n  \n  // v7.56: PRE-LOAD archetype stats for smart fallbacks\n  onProgress?.('Loading archetype history...', 1.5);\n  try {\n    const archetypeStats = await withTimeout(loadArchetypeStats(), 5000, new Map());\n    console.log(`[Benchmark] Pre-loaded archetype stats for ${archetypeStats.size} archetypes`);\n  } catch (e) {\n    console.warn('[Benchmark] Archetype stats pre-load failed, continuing:', e);\n  }\n  \n  // v7.2: PRE-CACHE accuracy stats ONCE before benchmark starts\n  onProgress?.('Fetching accuracy stats...', 2);\n  try {\n    const stats = await withTimeout(\n      fetchChessCumulativeStatsSafe(),\n      5000, // 5s timeout\n      { totalGames: 0, hybridAccuracy: 50, stockfishAccuracy: 50 } as any\n    );\n    if (stats.totalGames > 0) {\n      const totalCorrect = Math.round((stats.hybridAccuracy / 100) * stats.totalGames);\n      updateAccuracyCache(stats.totalGames, totalCorrect);\n    }\n    console.log(`[Benchmark] Pre-cached accuracy: ${stats.hybridAccuracy.toFixed(1)}% from ${stats.totalGames} games`);\n  } catch (e) {\n    console.warn('[Benchmark] Accuracy pre-cache failed, continuing:', e);\n  }\n  \n  const result: BenchmarkResult = {\n    totalGames: numGames,\n    completedGames: 0,\n    predictionPoints: [],\n    stockfishAccuracy: 0,\n    hybridAccuracy: 0,\n    stockfishWins: 0,\n    hybridWins: 0,\n    bothCorrect: 0,\n    bothWrong: 0,\n    archetypePerformance: {},\n    confidence: 0,\n    pValue: 1,\n    startedAt: new Date(),\n  };\n  \n  // v8.2-PARALLEL: Process games in parallel batches for faster benchmarks\n  const BATCH_SIZE = 3; // Process 3 games concurrently\n  \n  for (let batchStart = 0; batchStart < numGames; batchStart += BATCH_SIZE) {\n    const batchEnd = Math.min(batchStart + BATCH_SIZE, numGames);\n    const batchIndices = Array.from({ length: batchEnd - batchStart }, (_, i) => batchStart + i);\n    \n    onProgress?.(`Generating games ${batchStart + 1}-${batchEnd}/${numGames}`, (batchStart / numGames) * 100);\n    \n    // Generate games in parallel\n    const gamePromises = batchIndices.map(async (i) => {\n      const gameId = `internal_sfvsf_${i}`;\n      try {\n        const game = await generateStockfishGame(gameId, depth, 100);\n        return { i, gameId, game, error: null };\n      } catch (error) {\n        console.error(`[Benchmark] Failed to generate game ${i}:`, error);\n        return { i, gameId, game: null, error };\n      }\n    });\n    \n    const batchResults = await Promise.all(gamePromises);\n    \n    // Process results sequentially to maintain consistency\n    for (const { i, gameId, game, error } of batchResults) {\n      if (error || !game) {\n        console.error(`[Benchmark] Skipping game ${i} due to generation error`);\n        continue;\n      }\n      \n      if (game.moveCount < predictionMoveNumber) {\n        console.log(`[Benchmark] Game ${i} too short (${game.moveCount} moves), skipping`);\n        continue;\n      }\n      \n      onProgress?.(`Analyzing game ${i + 1}/${numGames}`, ((i + 0.5) / numGames) * 100);\n      \n      try {\n        // Make predictions at the specified move\n        const prediction = await makePredictionAtMove(gameId, game.pgn, predictionMoveNumber, depth);\n        prediction.actualResult = game.result;\n        \n        // Score predictions\n        prediction.stockfishCorrect = prediction.stockfishPrediction === game.result;\n        prediction.hybridCorrect = prediction.hybridPrediction === game.result;\n        \n        result.predictionPoints.push(prediction);\n        result.completedGames++;\n        \n        // Update archetype performance\n        if (!result.archetypePerformance[prediction.hybridArchetype]) {\n          result.archetypePerformance[prediction.hybridArchetype] = { correct: 0, total: 0 };\n        }\n        result.archetypePerformance[prediction.hybridArchetype].total++;\n        if (prediction.hybridCorrect) {\n          result.archetypePerformance[prediction.hybridArchetype].correct++;\n        }\n        \n        // Update comparison counts\n        if (prediction.stockfishCorrect && prediction.hybridCorrect) {\n          result.bothCorrect++;\n        } else if (!prediction.stockfishCorrect && !prediction.hybridCorrect) {\n          result.bothWrong++;\n        } else if (prediction.hybridCorrect) {\n          result.hybridWins++;\n        } else {\n          result.stockfishWins++;\n        }\n      } catch (e) {\n        console.error(`[Benchmark] Error analyzing game ${i}:`, e);\n      }\n    }\n  }\n  \n  // v8.1: Calculate fallback stats (for transparency)\n  const fallbackStats = {\n    full: result.predictionPoints.filter(p => p.fallbackTier === 'full').length,\n    partial_sf: result.predictionPoints.filter(p => p.fallbackTier === 'partial_sf').length,\n    partial_hybrid: result.predictionPoints.filter(p => p.fallbackTier === 'partial_hybrid').length,\n    archetype_fallback: result.predictionPoints.filter(p => p.fallbackTier === 'archetype_fallback').length,\n    excluded: result.predictionPoints.filter(p => p.fallbackTier === 'excluded').length,\n  };\n  result.fallbackStats = fallbackStats;\n  \n  console.log(`[v7.56] Fallback stats: ${JSON.stringify(fallbackStats)}`);\n  \n  // v8.1-FIXED: Calculate final statistics INCLUDING ALL predictions with actual results\n  // Previously excluded 'excluded' tier which skewed accuracy metrics\n  const predictionsWithResults = result.predictionPoints.filter(p => p.actualResult);\n  const totalCount = predictionsWithResults.length;\n  \n  // Count ALL predictions with results (don't exclude based on fallback tier)\n  const sfCorrect = predictionsWithResults.filter(p => p.stockfishCorrect).length;\n  const hybridCorrect = predictionsWithResults.filter(p => p.hybridCorrect).length;\n  \n  result.stockfishAccuracy = totalCount > 0 ? (sfCorrect / totalCount) * 100 : 0;\n  result.hybridAccuracy = totalCount > 0 ? (hybridCorrect / totalCount) * 100 : 0;\n  \n  // Statistical significance (binomial test approximation)\n  // v8.2-IMPROVED: Added confidence intervals and better statistical reporting\n  if (totalCount > 0) {\n    const diff = Math.abs(hybridCorrect - sfCorrect);\n    const n = totalCount;\n    const variance = n * 0.5 * 0.5; // Under null hypothesis\n    const zScore = diff / Math.sqrt(variance);\n    result.pValue = 2 * (1 - normalCdf(zScore));\n    result.confidence = 100 * (1 - result.pValue);\n    \n    // Calculate 95% confidence intervals using Wilson score interval\n    const wilsonInterval = (successes: number, trials: number, z: number = 1.96) => {\n      if (trials === 0) return { lower: 0, upper: 0 };\n      const p = successes / trials;\n      const denominator = 1 + (z * z) / trials;\n      const centre = (p + (z * z) / (2 * trials)) / denominator;\n      const halfWidth = z * Math.sqrt((p * (1 - p) + (z * z) / (4 * trials)) / trials) / denominator;\n      return {\n        lower: Math.max(0, centre - halfWidth) * 100,\n        upper: Math.min(1, centre + halfWidth) * 100\n      };\n    };\n    \n    const sfCI = wilsonInterval(sfCorrect, totalCount);\n    const hybridCI = wilsonInterval(hybridCorrect, totalCount);\n    \n    console.log(`[v8.2] Statistical Analysis:`);\n    console.log(`[v8.2]   Sample size: ${totalCount} games`);\n    console.log(`[v8.2]   Stockfish: ${sfCorrect}/${totalCount} = ${result.stockfishAccuracy.toFixed(1)}% [95% CI: ${sfCI.lower.toFixed(1)}% - ${sfCI.upper.toFixed(1)}%]`);\n    console.log(`[v8.2]   Hybrid: ${hybridCorrect}/${totalCount} = ${result.hybridAccuracy.toFixed(1)}% [95% CI: ${hybridCI.lower.toFixed(1)}% - ${hybridCI.upper.toFixed(1)}%]`);\n    console.log(`[v8.2]   Difference: ${(result.hybridAccuracy - result.stockfishAccuracy).toFixed(1)} percentage points`);\n    console.log(`[v8.2]   p-value: ${result.pValue.toFixed(4)} (${result.pValue < 0.05 ? 'significant at α=0.05' : 'not significant'})`);\n  }\n  \n  result.completedAt = new Date();\n  \n  // Log summary with corrected counts\n  console.log(`[v8.1] Analyzed ${totalCount} predictions total`);\n  if (fallbackStats.excluded > 0) {\n    console.log(`[v8.1] Included ${fallbackStats.excluded} previously excluded predictions`);\n  }\n  console.log(`[v8.1] Stockfish: ${sfCorrect}/${totalCount} (${result.stockfishAccuracy.toFixed(1)}%)`);\n  console.log(`[v8.1] Hybrid: ${hybridCorrect}/${totalCount} (${result.hybridAccuracy.toFixed(1)}%)`);\n  if (fallbackStats.archetype_fallback > 0) {\n    console.log(`[v8.1] Used archetype-based smart fallback for ${fallbackStats.archetype_fallback} predictions`);\n  }\n  \n  return result;\n}\n\n// Normal CDF approximation for p-value calculation\nfunction normalCdf(z: number): number {\n  const a1 = 0.254829592;\n  const a2 = -0.284496736;\n  const a3 = 1.421413741;\n  const a4 = -1.453152027;\n  const a5 = 1.061405429;\n  const p = 0.3275911;\n  \n  const sign = z < 0 ? -1 : 1;\n  z = Math.abs(z) / Math.sqrt(2);\n  \n  const t = 1 / (1 + p * z);\n  const y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);\n  \n  return 0.5 * (1 + sign * y);\n}\n\n// Quick benchmark with pre-existing games\n// v7.2-BENCHMARK-STREAMLINED: Pre-load patterns and cache accuracy\nexport async function runQuickBenchmark(\n  pgnGames: { pgn: string; result: 'white_wins' | 'black_wins' | 'draw' }[],\n  predictionMoveNumber: number = 20,\n  depth: number = 18,\n  onProgress?: (status: string, progress: number) => void\n): Promise<BenchmarkResult> {\n  // v7.2: PRE-LOAD patterns and accuracy stats ONCE\n  onProgress?.('Loading historical patterns...', 1);\n  try {\n    await withTimeout(loadLearnedPatterns(), 10000, { loaded: 0 } as any);\n    const stats = await withTimeout(fetchChessCumulativeStatsSafe(), 5000, { totalGames: 0, hybridAccuracy: 50 } as any);\n    if (stats.totalGames > 0) {\n      const totalCorrect = Math.round((stats.hybridAccuracy / 100) * stats.totalGames);\n      updateAccuracyCache(stats.totalGames, totalCorrect);\n    }\n  } catch (e) {\n    console.warn('[QuickBenchmark] Pre-load failed, continuing:', e);\n  }\n  \n  const result: BenchmarkResult = {\n    totalGames: pgnGames.length,\n    completedGames: 0,\n    predictionPoints: [],\n    stockfishAccuracy: 0,\n    hybridAccuracy: 0,\n    stockfishWins: 0,\n    hybridWins: 0,\n    bothCorrect: 0,\n    bothWrong: 0,\n    archetypePerformance: {},\n    confidence: 0,\n    pValue: 1,\n    startedAt: new Date(),\n  };\n  \n  for (let i = 0; i < pgnGames.length; i++) {\n    const game = pgnGames[i];\n    const gameId = `quick-${i}`;\n    \n    onProgress?.(`Analyzing game ${i + 1}/${pgnGames.length}`, (i / pgnGames.length) * 100);\n    \n    try {\n      const prediction = await makePredictionAtMove(gameId, game.pgn, predictionMoveNumber, depth);\n      prediction.actualResult = game.result;\n      prediction.stockfishCorrect = prediction.stockfishPrediction === game.result;\n      prediction.hybridCorrect = prediction.hybridPrediction === game.result;\n      \n      result.predictionPoints.push(prediction);\n      result.completedGames++;\n      \n      // Update counts (same as above)\n      if (!result.archetypePerformance[prediction.hybridArchetype]) {\n        result.archetypePerformance[prediction.hybridArchetype] = { correct: 0, total: 0 };\n      }\n      result.archetypePerformance[prediction.hybridArchetype].total++;\n      if (prediction.hybridCorrect) {\n        result.archetypePerformance[prediction.hybridArchetype].correct++;\n      }\n      \n      if (prediction.stockfishCorrect && prediction.hybridCorrect) {\n        result.bothCorrect++;\n      } else if (!prediction.stockfishCorrect && !prediction.hybridCorrect) {\n        result.bothWrong++;\n      } else if (prediction.hybridCorrect) {\n        result.hybridWins++;\n      } else {\n        result.stockfishWins++;\n      }\n      \n    } catch (e) {\n      console.error(`Error in game ${i}:`, e);\n    }\n  }\n  \n  // Calculate stats\n  const sfCorrect = result.predictionPoints.filter(p => p.stockfishCorrect).length;\n  const hybridCorrect = result.predictionPoints.filter(p => p.hybridCorrect).length;\n  \n  result.stockfishAccuracy = result.completedGames > 0 ? (sfCorrect / result.completedGames) * 100 : 0;\n  result.hybridAccuracy = result.completedGames > 0 ? (hybridCorrect / result.completedGames) * 100 : 0;\n  \n  if (result.completedGames > 0) {\n    const diff = Math.abs(hybridCorrect - sfCorrect);\n    const n = result.completedGames;\n    const variance = n * 0.5 * 0.5;\n    const zScore = diff / Math.sqrt(variance);\n    result.pValue = 2 * (1 - normalCdf(zScore));\n    result.confidence = 100 * (1 - result.pValue);\n  }\n  \n  result.completedAt = new Date();\n  \n  return result;\n}\n\nexport default runPredictionBenchmark;\n";export{e as default};
