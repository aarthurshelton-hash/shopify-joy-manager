const e="import { useEffect, useCallback, useRef } from 'react';\nimport { useLocation } from 'react-router-dom';\nimport { useSessionStore, FullVisualizationState } from '@/stores/sessionStore';\nimport { useVisualizationStateStore } from '@/stores/visualizationStateStore';\nimport { GamePhase } from '@/contexts/TimelineContext';\nimport { PieceType, PieceColor } from '@/lib/chess/pieceColors';\n\ninterface PiecesState {\n  showPieces: boolean;\n  pieceOpacity: number;\n}\n\ninterface CaptureConfig {\n  visualizationId?: string;\n  pgn?: string;\n  piecesState?: PiecesState;\n}\n\n/**\n * Hook to capture and restore full visualization state on navigation\n * Enables \"backtrack restoration\" - clicking back restores exact board state\n */\nexport function useVisualizationStateCapture(config?: CaptureConfig) {\n  const location = useLocation();\n  const pushVisualizationState = useSessionStore(s => s.pushVisualizationState);\n  const getVisualizationStateForRoute = useSessionStore(s => s.getVisualizationStateForRoute);\n  const peekVisualizationState = useSessionStore(s => s.peekVisualizationState);\n  \n  const {\n    currentMove,\n    selectedPhase,\n    lockedPieces,\n    compareMode,\n    displayMode,\n    darkMode,\n    showTerritory,\n    showHeatmaps,\n    setCurrentMove,\n    setSelectedPhase,\n    setLockedPieces,\n    setCompareMode,\n    setDisplayMode,\n    setDarkMode,\n    setShowTerritory,\n    setShowHeatmaps,\n  } = useVisualizationStateStore();\n  \n  const hasRestoredRef = useRef(false);\n  const currentRouteRef = useRef(location.pathname);\n  \n  // Capture current state before navigation\n  const captureState = useCallback((): FullVisualizationState => {\n    return {\n      currentMove,\n      selectedPhase: selectedPhase as GamePhase,\n      isPlaying: false,\n      lockedPieces: lockedPieces.map(p => ({\n        pieceType: p.pieceType as PieceType,\n        pieceColor: p.pieceColor as PieceColor,\n      })),\n      compareMode,\n      highlightedPiece: null,\n      displayMode,\n      darkMode,\n      showTerritory,\n      showHeatmaps,\n      showPieces: config?.piecesState?.showPieces ?? false,\n      pieceOpacity: config?.piecesState?.pieceOpacity ?? 0.7,\n      capturedAt: Date.now(),\n      sourceRoute: location.pathname,\n      visualizationId: config?.visualizationId,\n      pgn: config?.pgn,\n    };\n  }, [\n    currentMove,\n    selectedPhase,\n    lockedPieces,\n    compareMode,\n    displayMode,\n    darkMode,\n    showTerritory,\n    showHeatmaps,\n    config?.piecesState,\n    config?.visualizationId,\n    config?.pgn,\n    location.pathname,\n  ]);\n  \n  // Save state when navigating away\n  const saveStateBeforeNavigation = useCallback(() => {\n    const state = captureState();\n    pushVisualizationState(state);\n  }, [captureState, pushVisualizationState]);\n  \n  // Restore state from session on mount (for back navigation)\n  useEffect(() => {\n    if (hasRestoredRef.current) return;\n    \n    // Check if we have a saved state for this route\n    const savedState = getVisualizationStateForRoute(location.pathname);\n    \n    if (savedState) {\n      // Restore all state\n      setCurrentMove(savedState.currentMove);\n      setSelectedPhase(savedState.selectedPhase);\n      setLockedPieces(savedState.lockedPieces);\n      setCompareMode(savedState.compareMode);\n      setDisplayMode(savedState.displayMode);\n      setDarkMode(savedState.darkMode);\n      setShowTerritory(savedState.showTerritory);\n      setShowHeatmaps(savedState.showHeatmaps);\n      \n      hasRestoredRef.current = true;\n    }\n  }, [\n    location.pathname,\n    getVisualizationStateForRoute,\n    setCurrentMove,\n    setSelectedPhase,\n    setLockedPieces,\n    setCompareMode,\n    setDisplayMode,\n    setDarkMode,\n    setShowTerritory,\n    setShowHeatmaps,\n  ]);\n  \n  // Track route changes and save state when leaving visualization pages\n  useEffect(() => {\n    const handleBeforeUnload = () => {\n      saveStateBeforeNavigation();\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    \n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      // Save state when component unmounts (navigation away)\n      if (currentRouteRef.current !== location.pathname) {\n        saveStateBeforeNavigation();\n      }\n    };\n  }, [saveStateBeforeNavigation, location.pathname]);\n  \n  // Update route ref\n  useEffect(() => {\n    currentRouteRef.current = location.pathname;\n  }, [location.pathname]);\n  \n  return {\n    captureState,\n    saveStateBeforeNavigation,\n    getCurrentSavedState: () => peekVisualizationState(),\n    getSavedStateForRoute: getVisualizationStateForRoute,\n  };\n}\n\n/**\n * Hook to get initial state from session or URL for visualization pages\n */\nexport function useInitialVisualizationState() {\n  const location = useLocation();\n  const getVisualizationStateForRoute = useSessionStore(s => s.getVisualizationStateForRoute);\n  \n  // Get saved state for current route\n  const savedState = getVisualizationStateForRoute(location.pathname);\n  \n  return {\n    hasSavedState: !!savedState,\n    savedState,\n    initialMove: savedState?.currentMove ?? Infinity,\n    initialPhase: savedState?.selectedPhase ?? 'all',\n    initialLockedPieces: savedState?.lockedPieces ?? [],\n    initialCompareMode: savedState?.compareMode ?? false,\n    initialDisplayMode: savedState?.displayMode ?? 'art',\n    initialDarkMode: savedState?.darkMode ?? false,\n    initialShowTerritory: savedState?.showTerritory ?? false,\n    initialShowHeatmaps: savedState?.showHeatmaps ?? false,\n    initialShowPieces: savedState?.showPieces ?? false,\n    initialPieceOpacity: savedState?.pieceOpacity ?? 0.7,\n  };\n}\n";export{e as default};
