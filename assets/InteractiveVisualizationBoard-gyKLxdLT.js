const e="import React, { useCallback, useMemo, useState } from 'react';\nimport { Chess, Square, Move } from 'chess.js';\nimport { SquareData, SquareVisit } from '@/lib/chess/gameSimulator';\nimport { boardColors, getPieceColor, PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { useLegendHighlight, HighlightedPiece, HoveredSquareInfo, AnnotationType, PieceMoveArrow } from '@/contexts/LegendHighlightContext';\n\ninterface InteractiveVisualizationBoardProps {\n  board: SquareData[][];\n  size?: number;\n  showPieces?: boolean;\n  pieceOpacity?: number;\n  pgn?: string;\n  currentMoveNumber?: number;\n  onFollowPieceActivated?: (moveNumber: number) => void;\n}\n\n// Track individual pieces with unique IDs for animation\ninterface TrackedPiece {\n  id: string; // Unique ID like \"w-Q-d1\" (color-type-startSquare)\n  type: string;\n  color: 'w' | 'b';\n  square: string;\n  x: number;\n  y: number;\n}\n\n// Unicode chess piece characters\nconst PIECE_SYMBOLS: Record<string, string> = {\n  'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',\n  'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟',\n};\n\n// Get the current color for a visit using the active palette\nfunction getVisitColor(visit: SquareVisit): string {\n  return getPieceColor(visit.piece, visit.color);\n}\n\n// Check if a visit matches any of the highlighted pieces\nfunction visitMatchesAnyHighlight(visit: SquareVisit, highlights: HighlightedPiece[]): boolean {\n  if (highlights.length === 0) return true;\n  return highlights.some(h => visit.piece === h.pieceType && visit.color === h.pieceColor);\n}\n\n// Check which highlight index a visit matches (for compare mode coloring)\nfunction getMatchingHighlightIndex(visit: SquareVisit, highlights: HighlightedPiece[]): number {\n  return highlights.findIndex(h => visit.piece === h.pieceType && visit.color === h.pieceColor);\n}\n\n// Renders nested squares for a single board square as SVG rects\nconst renderNestedSquares = (\n  visits: SquareVisit[],\n  x: number,\n  y: number,\n  squareSize: number,\n  baseColor: string,\n  highlightedPieces: HighlightedPiece[],\n  compareMode: boolean,\n  isHoveredSquare: boolean,\n  isHighlightedFromLegend: boolean\n): React.ReactNode[] => {\n  const elements: React.ReactNode[] = [];\n  const padding = squareSize * 0.08;\n  \n  const hasHighlight = highlightedPieces.length > 0;\n  \n  // Determine if this square has any matching visits\n  const matchingVisits = hasHighlight \n    ? visits.filter(v => visitMatchesAnyHighlight(v, highlightedPieces))\n    : visits;\n  \n  const hasMatchingVisit = matchingVisits.length > 0;\n  \n  // In compare mode, check which pieces are present\n  const piece1Present = highlightedPieces.length > 0 && visits.some(\n    v => v.piece === highlightedPieces[0].pieceType && v.color === highlightedPieces[0].pieceColor\n  );\n  const piece2Present = highlightedPieces.length > 1 && visits.some(\n    v => v.piece === highlightedPieces[1].pieceType && v.color === highlightedPieces[1].pieceColor\n  );\n  const isOverlap = piece1Present && piece2Present;\n  \n  // Base dimming when highlight is active but this square doesn't match\n  const shouldDim = hasHighlight && !hasMatchingVisit && !isHoveredSquare;\n  \n  // Draw base square\n  elements.push(\n    <rect\n      key={`base-${x}-${y}`}\n      x={x}\n      y={y}\n      width={squareSize}\n      height={squareSize}\n      fill={baseColor}\n      style={{\n        opacity: shouldDim ? 0.3 : 1,\n        transition: 'opacity 0.2s ease-out',\n      }}\n    />\n  );\n  \n  if (visits.length === 0) {\n    return elements;\n  }\n  \n  // Get unique colors in order of first appearance\n  const uniqueColors: { color: string; matches: boolean; highlightIndex: number }[] = [];\n  for (const visit of visits) {\n    const color = getVisitColor(visit);\n    const highlightIndex = getMatchingHighlightIndex(visit, highlightedPieces);\n    const matches = !hasHighlight || highlightIndex !== -1;\n    const existingIndex = uniqueColors.findIndex(uc => uc.color === color);\n    if (existingIndex === -1) {\n      uniqueColors.push({ color, matches, highlightIndex });\n    } else if (matches) {\n      uniqueColors[existingIndex].matches = true;\n      if (highlightIndex !== -1) {\n        uniqueColors[existingIndex].highlightIndex = highlightIndex;\n      }\n    }\n  }\n  \n  // Calculate sizes for nested squares\n  const maxNesting = Math.min(uniqueColors.length, 6);\n  const layers: { color: string; layerSize: number; matches: boolean; highlightIndex: number }[] = [];\n  \n  let currentSize = squareSize - padding * 2;\n  const sizeReduction = (currentSize * 0.7) / maxNesting;\n  \n  for (let i = 0; i < maxNesting; i++) {\n    layers.push({\n      color: uniqueColors[i].color,\n      layerSize: currentSize,\n      matches: uniqueColors[i].matches,\n      highlightIndex: uniqueColors[i].highlightIndex,\n    });\n    currentSize -= sizeReduction;\n    if (currentSize < squareSize * 0.1) break;\n  }\n  \n  // Draw layers from outside in (largest first)\n  for (let i = 0; i < layers.length; i++) {\n    const layer = layers[i];\n    const offset = (squareSize - layer.layerSize) / 2;\n    \n    // Determine opacity based on highlight state\n    let opacity = 1;\n    if (hasHighlight && !isHoveredSquare) {\n      opacity = layer.matches ? 1 : 0.15;\n    }\n    \n    elements.push(\n      <rect\n        key={`layer-${x}-${y}-${i}`}\n        x={x + offset}\n        y={y + offset}\n        width={layer.layerSize}\n        height={layer.layerSize}\n        fill={layer.color}\n        style={{\n          opacity,\n          transition: 'opacity 0.2s ease-out',\n        }}\n      />\n    );\n  }\n  \n  // Add visual effects for highlighted squares\n  if ((hasHighlight && hasMatchingVisit) || isHoveredSquare) {\n    const glowSize = squareSize * 0.02;\n    \n    if (isHoveredSquare) {\n      // Square is being hovered - show amber glow\n      elements.push(\n        <rect\n          key={`glow-hover-${x}-${y}`}\n          x={x + glowSize}\n          y={y + glowSize}\n          width={squareSize - glowSize * 2}\n          height={squareSize - glowSize * 2}\n          fill=\"none\"\n          stroke=\"rgba(251, 191, 36, 0.8)\"\n          strokeWidth={glowSize * 2}\n          style={{ transition: 'all 0.2s ease-out' }}\n        />\n      );\n    } else if (compareMode && highlightedPieces.length === 2) {\n      // In compare mode, show different effects based on overlap\n      if (isOverlap) {\n        // Overlap: purple glow\n        elements.push(\n          <rect\n            key={`glow-overlap-${x}-${y}`}\n            x={x + glowSize}\n            y={y + glowSize}\n            width={squareSize - glowSize * 2}\n            height={squareSize - glowSize * 2}\n            fill=\"none\"\n            stroke=\"rgba(168, 85, 247, 0.8)\"\n            strokeWidth={glowSize * 2}\n            style={{ transition: 'all 0.2s ease-out' }}\n          />\n        );\n      } else if (piece1Present) {\n        // Only piece 1: sky blue glow\n        elements.push(\n          <rect\n            key={`glow-p1-${x}-${y}`}\n            x={x + glowSize}\n            y={y + glowSize}\n            width={squareSize - glowSize * 2}\n            height={squareSize - glowSize * 2}\n            fill=\"none\"\n            stroke=\"rgba(56, 189, 248, 0.6)\"\n            strokeWidth={glowSize * 1.5}\n            style={{ transition: 'all 0.2s ease-out' }}\n          />\n        );\n      } else if (piece2Present) {\n        // Only piece 2: rose glow\n        elements.push(\n          <rect\n            key={`glow-p2-${x}-${y}`}\n            x={x + glowSize}\n            y={y + glowSize}\n            width={squareSize - glowSize * 2}\n            height={squareSize - glowSize * 2}\n            fill=\"none\"\n            stroke=\"rgba(251, 113, 133, 0.6)\"\n            strokeWidth={glowSize * 1.5}\n            style={{ transition: 'all 0.2s ease-out' }}\n          />\n        );\n      }\n    } else if (isHighlightedFromLegend) {\n      // Single selection mode from legend: white glow\n      elements.push(\n        <rect\n          key={`glow-${x}-${y}`}\n          x={x + glowSize}\n          y={y + glowSize}\n          width={squareSize - glowSize * 2}\n          height={squareSize - glowSize * 2}\n          fill=\"none\"\n          stroke=\"rgba(255,255,255,0.6)\"\n          strokeWidth={glowSize}\n          style={{ transition: 'all 0.2s ease-out' }}\n        />\n      );\n    }\n  }\n  \n  return elements;\n};\n\nconst InteractiveVisualizationBoard: React.FC<InteractiveVisualizationBoardProps> = ({\n  board,\n  size = 500,\n  showPieces = false,\n  pieceOpacity = 0.7,\n  pgn,\n  currentMoveNumber,\n  onFollowPieceActivated,\n}) => {\n  const [hoveredSquareLocal, setHoveredSquareLocal] = useState<string | null>(null);\n  const [hoveredPieceSquare, setHoveredPieceSquare] = useState<string | null>(null);\n  \n  // Use the context hook directly - it will throw if not in provider, but that's expected\n  const context = useLegendHighlight();\n  \n  // Extract values from context\n  const lockedPieces = context.lockedPieces;\n  const lockedSquares = context.lockedSquares;\n  const highlightedPiece = context.highlightedPiece;\n  const compareMode = context.compareMode;\n  const setHoveredSquare = context.setHoveredSquare;\n  const setHighlightedAnnotations = context.setHighlightedAnnotations;\n  const hoveredAnnotation = context.hoveredAnnotation;\n  const hoveredSquareFromContext = context.hoveredSquare;\n  const toggleLockedPiece = context.toggleLockedPiece;\n  const toggleLockedSquare = context.toggleLockedSquare;\n  const pieceArrows = context.pieceArrows;\n  const setFollowPieceData = context.setFollowPieceData;\n  const setPieceArrows = context.setPieceArrows;\n  const hoveredMove = context.hoveredMove; // For timeline key moment hover\n\n  // Build highlighted pieces array from context state\n  const highlightedPieces = useMemo(() => {\n    // If a move is being hovered from timeline, highlight that piece\n    if (hoveredMove?.piece) {\n      return [hoveredMove.piece];\n    }\n    // If annotation is hovered, use its associated pieces\n    if (hoveredAnnotation?.associatedPieces && hoveredAnnotation.associatedPieces.length > 0) {\n      return hoveredAnnotation.associatedPieces;\n    }\n    // Combine locked pieces and hover highlight\n    if (lockedPieces.length > 0) {\n      return lockedPieces;\n    }\n    if (highlightedPiece) {\n      return [highlightedPiece];\n    }\n    return [];\n  }, [lockedPieces, highlightedPiece, hoveredAnnotation, hoveredMove]);\n  \n  const squareSize = size / 8;\n  const borderWidth = size * 0.02;\n  const totalSize = size + borderWidth * 2;\n\n  // Helper to try multiple PGN parsing strategies\n  const parsePgn = useCallback((rawPgn: string): { success: boolean; moves: Move[] } => {\n    const chess = new Chess();\n    \n    // Strategy 1: Try loading full PGN as-is\n    try {\n      chess.loadPgn(rawPgn);\n      const moves = chess.history({ verbose: true }) as Move[];\n      if (moves.length > 0) {\n        return { success: true, moves };\n      }\n    } catch {}\n    \n    // Strategy 2: Remove headers and try again\n    chess.reset();\n    const withoutHeaders = rawPgn.replace(/\\[.*?\\]\\s*/g, '').trim();\n    if (withoutHeaders) {\n      try {\n        chess.loadPgn(withoutHeaders);\n        const moves = chess.history({ verbose: true }) as Move[];\n        if (moves.length > 0) {\n          return { success: true, moves };\n        }\n      } catch {}\n    }\n    \n    // Strategy 3: Parse moves manually (e.g., \"1. e4 e5 2. Nf3 Nc6\")\n    chess.reset();\n    const moveTextMatch = rawPgn.match(/(\\d+\\.\\s*\\S+(?:\\s+\\S+)?)/g);\n    if (moveTextMatch) {\n      try {\n        for (const moveGroup of moveTextMatch) {\n          // Extract just the moves without move numbers\n          const individualMoves = moveGroup.replace(/\\d+\\.\\s*/, '').trim().split(/\\s+/);\n          for (const m of individualMoves) {\n            if (m && m !== '*' && !m.match(/^[012/-]+$/)) {\n              chess.move(m);\n            }\n          }\n        }\n        const parsedMoves = chess.history({ verbose: true }) as Move[];\n        if (parsedMoves.length > 0) {\n          return { success: true, moves: parsedMoves };\n        }\n      } catch {}\n    }\n    \n    return { success: false, moves: [] };\n  }, []);\n\n  // Calculate tracked pieces with unique IDs for animation\n  const trackedPieces = useMemo((): TrackedPiece[] => {\n    // Early return if pieces shouldn't be shown\n    if (!showPieces) {\n      console.log('[InteractiveVisualizationBoard] showPieces is false, skipping piece rendering');\n      return [];\n    }\n    \n    // Validate PGN is a non-empty string\n    if (!pgn || typeof pgn !== 'string') {\n      console.warn('[InteractiveVisualizationBoard] No PGN for pieces - pgn is:', typeof pgn, 'value:', pgn);\n      return [];\n    }\n    \n    const trimmedPgn = pgn.trim();\n    if (trimmedPgn === '' || trimmedPgn.length < 2) {\n      console.warn('[InteractiveVisualizationBoard] Empty or too short PGN for pieces, length:', trimmedPgn.length);\n      return [];\n    }\n    \n    console.log('[InteractiveVisualizationBoard] Parsing PGN for pieces, length:', trimmedPgn.length, 'currentMove:', currentMoveNumber);\n    \n    try {\n      // Use robust PGN parser\n      const { success, moves: allMovesVerbose } = parsePgn(trimmedPgn);\n      \n      if (!success || allMovesVerbose.length === 0) {\n        console.warn('[InteractiveVisualizationBoard] PGN parsing failed or no moves found');\n        return [];\n      }\n      \n      console.log('[InteractiveVisualizationBoard] Parsed', allMovesVerbose.length, 'moves successfully');\n      \n      // Track piece origins - each piece gets a unique ID based on starting square\n      const pieceOrigins = new Map<string, string>(); // current square -> origin ID\n      \n      // Initialize with starting position\n      const startChess = new Chess();\n      for (let rank = 0; rank < 8; rank++) {\n        for (let file = 0; file < 8; file++) {\n          const square = `${String.fromCharCode(97 + file)}${rank + 1}` as Square;\n          const piece = startChess.get(square);\n          if (piece) {\n            const originId = `${piece.color}-${piece.type.toUpperCase()}-${square}`;\n            pieceOrigins.set(square, originId);\n          }\n        }\n      }\n      \n      // Replay moves to track piece movements\n      const chess = new Chess();\n      const moveCount = currentMoveNumber !== undefined ? currentMoveNumber : allMovesVerbose.length;\n      \n      for (let i = 0; i < Math.min(moveCount, allMovesVerbose.length); i++) {\n        const move = allMovesVerbose[i];\n        const originId = pieceOrigins.get(move.from);\n        \n        // Handle captures - remove captured piece\n        if (move.captured) {\n          pieceOrigins.delete(move.to);\n        }\n        \n        // Move piece to new square\n        if (originId) {\n          pieceOrigins.delete(move.from);\n          pieceOrigins.set(move.to, originId);\n        }\n        \n        // Handle castling - move the rook too\n        if (move.flags.includes('k')) { // Kingside\n          const rookFrom = move.color === 'w' ? 'h1' : 'h8';\n          const rookTo = move.color === 'w' ? 'f1' : 'f8';\n          const rookId = pieceOrigins.get(rookFrom);\n          if (rookId) {\n            pieceOrigins.delete(rookFrom);\n            pieceOrigins.set(rookTo, rookId);\n          }\n        } else if (move.flags.includes('q')) { // Queenside\n          const rookFrom = move.color === 'w' ? 'a1' : 'a8';\n          const rookTo = move.color === 'w' ? 'd1' : 'd8';\n          const rookId = pieceOrigins.get(rookFrom);\n          if (rookId) {\n            pieceOrigins.delete(rookFrom);\n            pieceOrigins.set(rookTo, rookId);\n          }\n        }\n        \n        // Handle promotion - update the piece type in the ID\n        if (move.promotion) {\n          const newId = `${move.color}-${move.promotion.toUpperCase()}-${move.from}-promoted`;\n          pieceOrigins.set(move.to, newId);\n        }\n        \n        chess.move(allMovesVerbose[i].san);\n      }\n      \n      // Build tracked pieces array\n      const pieces: TrackedPiece[] = [];\n      const boardState = chess.board();\n      \n      for (let rowIndex = 0; rowIndex < 8; rowIndex++) {\n        const rank = 7 - rowIndex;\n        for (let file = 0; file < 8; file++) {\n          const piece = boardState[rowIndex]?.[file];\n          if (piece) {\n            const square = `${String.fromCharCode(97 + file)}${rank + 1}`;\n            const originId = pieceOrigins.get(square) || `${piece.color}-${piece.type.toUpperCase()}-${square}`;\n            const x = borderWidth + file * squareSize + squareSize / 2;\n            const y = borderWidth + rowIndex * squareSize + squareSize / 2;\n            \n            pieces.push({\n              id: originId,\n              type: piece.type,\n              color: piece.color,\n              square,\n              x,\n              y,\n            });\n          }\n        }\n      }\n      \n      return pieces;\n    } catch (e) {\n      console.error('Error parsing PGN for pieces:', e);\n      return [];\n    }\n  }, [showPieces, pgn, currentMoveNumber, borderWidth, squareSize]);\n  \n  // Calculate piece move arrows from PGN\n  const calculatePieceArrows = useCallback((pieceType: string, pieceColor: 'w' | 'b'): PieceMoveArrow[] => {\n    if (!pgn) return [];\n    \n    try {\n      const chess = new Chess();\n      chess.loadPgn(pgn);\n      const allMoves = chess.history({ verbose: true });\n      \n      const arrows: PieceMoveArrow[] = [];\n      const normalizedType = pieceType.toLowerCase();\n      \n      allMoves.forEach((move, index) => {\n        // Match piece type (pawns are '' in move.piece)\n        const moveType = move.piece;\n        const isPawn = normalizedType === 'p' && moveType === 'p';\n        const isOtherPiece = moveType === normalizedType;\n        \n        if ((isPawn || isOtherPiece) && move.color === pieceColor) {\n          arrows.push({\n            from: move.from,\n            to: move.to,\n            moveNumber: index + 1,\n            pieceType: pieceType.toUpperCase() as PieceType,\n            pieceColor: pieceColor as PieceColor,\n            isCapture: !!move.captured,\n          });\n        }\n      });\n      \n      return arrows;\n    } catch (e) {\n      console.error('Error calculating piece arrows:', e);\n      return [];\n    }\n  }, [pgn]);\n\n  // Handle piece click to highlight all squares it visited and activate follow mode\n  const handlePieceClick = useCallback((pieceType: string, pieceColor: 'w' | 'b') => {\n    const highlightPiece: HighlightedPiece = {\n      pieceType: pieceType.toUpperCase() as PieceType,\n      pieceColor: pieceColor as PieceColor,\n    };\n    \n    // Calculate arrows for this piece\n    const arrows = calculatePieceArrows(pieceType, pieceColor);\n    setPieceArrows(arrows);\n    \n    // Set up follow piece mode\n    if (arrows.length > 0) {\n      const moveNumbers = arrows.map(a => a.moveNumber);\n      setFollowPieceData({\n        piece: highlightPiece,\n        moveNumbers,\n        currentIndex: 0,\n      });\n      \n      // Notify parent to jump to first move of this piece\n      if (onFollowPieceActivated) {\n        onFollowPieceActivated(moveNumbers[0]);\n      }\n    }\n    \n    toggleLockedPiece(highlightPiece);\n  }, [toggleLockedPiece, calculatePieceArrows, setPieceArrows, setFollowPieceData, onFollowPieceActivated]);\n\n  // Handle piece hover\n  const handlePieceHover = useCallback((square: string, pieceType: string, pieceColor: 'w' | 'b') => {\n    setHoveredPieceSquare(square);\n  }, []);\n\n  const handlePieceLeave = useCallback(() => {\n    setHoveredPieceSquare(null);\n  }, []);\n\n  // Get unique pieces that visited a square\n  const getPiecesForSquare = useCallback((square: SquareData): HighlightedPiece[] => {\n    const pieces: HighlightedPiece[] = [];\n    const seen = new Set<string>();\n    \n    for (const visit of square.visits) {\n      const key = `${visit.color}-${visit.piece}`;\n      if (!seen.has(key)) {\n        seen.add(key);\n        pieces.push({ pieceType: visit.piece, pieceColor: visit.color });\n      }\n    }\n    \n    return pieces;\n  }, []);\n\n  // Get all move numbers associated with a square's visits\n  const getMoveNumbersForSquare = useCallback((square: SquareData): number[] => {\n    const moveNumbers: number[] = [];\n    for (const visit of square.visits) {\n      if (!moveNumbers.includes(visit.moveNumber)) {\n        moveNumbers.push(visit.moveNumber);\n      }\n    }\n    return moveNumbers.sort((a, b) => a - b);\n  }, []);\n\n  const handleSquareHover = useCallback((rank: number, file: number) => {\n    const square = board[rank][file];\n    const squareName = `${String.fromCharCode(97 + file)}${rank + 1}`;\n    setHoveredSquareLocal(squareName);\n    \n    const pieces = getPiecesForSquare(square);\n    const moveNumbers = getMoveNumbersForSquare(square);\n    \n    // Update the context with hovered square info\n    setHoveredSquare({ square: squareName, pieces, moveNumbers });\n    \n    // Update annotation highlighting based on pieces on this square\n    if (pieces.length > 0) {\n      const annotations: AnnotationType[] = [];\n      if (pieces.some(p => p.pieceColor === 'w')) annotations.push('white-player');\n      if (pieces.some(p => p.pieceColor === 'b')) annotations.push('black-player');\n      setHighlightedAnnotations(annotations);\n    } else {\n      setHighlightedAnnotations([]);\n    }\n  }, [board, setHoveredSquare, setHighlightedAnnotations, getPiecesForSquare, getMoveNumbersForSquare]);\n\n  const handleSquareLeave = useCallback(() => {\n    setHoveredSquareLocal(null);\n    setHoveredSquare(null);\n    setHighlightedAnnotations([]);\n  }, [setHoveredSquare, setHighlightedAnnotations]);\n\n  // Handle square click to toggle lock\n  const handleSquareClick = useCallback((rank: number, file: number) => {\n    const square = board[rank][file];\n    const squareName = `${String.fromCharCode(97 + file)}${rank + 1}`;\n    const pieces = getPiecesForSquare(square);\n    \n    if (pieces.length > 0) {\n      toggleLockedSquare(squareName, pieces);\n    }\n  }, [board, getPiecesForSquare, toggleLockedSquare]);\n  \n  // Determine effective highlighting pieces - include pieces from hovered/locked squares\n  const effectiveHighlightPieces = useMemo(() => {\n    // If we have locked pieces or legend hover, use those\n    if (highlightedPieces.length > 0) return highlightedPieces;\n    // If there are locked squares, use the pieces from those squares\n    if (lockedSquares.length > 0) {\n      const piecesFromLockedSquares: HighlightedPiece[] = [];\n      for (const ls of lockedSquares) {\n        for (const p of ls.pieces) {\n          if (!piecesFromLockedSquares.some(ep => ep.pieceType === p.pieceType && ep.pieceColor === p.pieceColor)) {\n            piecesFromLockedSquares.push(p);\n          }\n        }\n      }\n      return piecesFromLockedSquares;\n    }\n    // If a square is being hovered, use the pieces from that square to highlight all their visited squares\n    if (hoveredSquareFromContext?.pieces && hoveredSquareFromContext.pieces.length > 0) {\n      return hoveredSquareFromContext.pieces;\n    }\n    return [];\n  }, [highlightedPieces, lockedSquares, hoveredSquareFromContext]);\n  \n  // Memoize board rendering for performance\n  const boardElements = useMemo(() => {\n    return [...Array(8)].map((_, rowIndex) => {\n      const rank = 7 - rowIndex; // Flip to show rank 8 at top\n      return [...Array(8)].map((_, file) => {\n        const square = board[rank][file];\n        const baseColor = square.isLight ? boardColors.light : boardColors.dark;\n        const x = borderWidth + file * squareSize;\n        const y = borderWidth + rowIndex * squareSize;\n        const squareName = `${String.fromCharCode(97 + file)}${rank + 1}`;\n        const isHovered = hoveredSquareLocal === squareName;\n        \n        // Check if this square is locked\n        const isLockedSquare = lockedSquares.some(ls => ls.square === squareName);\n        \n        // Check if this is the target square from a hovered move (timeline key moment)\n        const isTargetSquareFromHoveredMove = hoveredMove?.targetSquare === squareName;\n        \n        // Check if this square has any of the effective highlighted pieces\n        const isHighlightedFromLegend = effectiveHighlightPieces.length > 0 && square.visits.some(\n          v => effectiveHighlightPieces.some(h => h.pieceType === v.piece && h.pieceColor === v.color)\n        );\n        \n        return renderNestedSquares(\n          square.visits,\n          x,\n          y,\n          squareSize,\n          baseColor,\n          effectiveHighlightPieces,\n          compareMode,\n          isHovered || isTargetSquareFromHoveredMove || isLockedSquare,\n          isHighlightedFromLegend\n        );\n      });\n    });\n  }, [board, borderWidth, squareSize, effectiveHighlightPieces, compareMode, hoveredSquareLocal, lockedSquares, hoveredAnnotation, hoveredMove]);\n\n  // Create invisible interaction layer for hover detection and click locking\n  const interactionSquares = useMemo(() => {\n    return [...Array(8)].map((_, rowIndex) => {\n      const rank = 7 - rowIndex;\n      return [...Array(8)].map((_, file) => {\n        const x = borderWidth + file * squareSize;\n        const y = borderWidth + rowIndex * squareSize;\n        const square = board[rank][file];\n        const hasVisits = square.visits.length > 0;\n        const squareName = `${String.fromCharCode(97 + file)}${rank + 1}`;\n        const isLocked = lockedSquares.some(ls => ls.square === squareName);\n        \n        return (\n          <rect\n            key={`interact-${rank}-${file}`}\n            x={x}\n            y={y}\n            width={squareSize}\n            height={squareSize}\n            fill=\"transparent\"\n            style={{ cursor: hasVisits ? 'pointer' : 'default' }}\n            onMouseEnter={() => handleSquareHover(rank, file)}\n            onMouseLeave={handleSquareLeave}\n            onClick={() => hasVisits && handleSquareClick(rank, file)}\n            onTouchStart={(e) => {\n              if (hasVisits) {\n                e.stopPropagation();\n                handleSquareHover(rank, file);\n                // Auto-clear after 2 seconds for mobile (unless locked)\n                if (!isLocked) {\n                  setTimeout(handleSquareLeave, 2000);\n                }\n              }\n            }}\n          />\n        );\n      });\n    });\n  }, [board, borderWidth, squareSize, lockedSquares, handleSquareHover, handleSquareLeave, handleSquareClick]);\n  \n  // Render chess pieces layer with animations\n  const pieceElements = useMemo(() => {\n    if (!showPieces || trackedPieces.length === 0) return null;\n    \n    const elements: React.ReactNode[] = [];\n    const fontSize = squareSize * 0.75;\n    \n    for (const piece of trackedPieces) {\n      const pieceKey = piece.color === 'w' \n        ? piece.type.toUpperCase() \n        : piece.type.toLowerCase();\n      const symbol = PIECE_SYMBOLS[pieceKey];\n      \n      if (!symbol) continue;\n      \n      // Check if this piece type is currently highlighted\n      const isHighlighted = highlightedPieces.some(\n        h => h.pieceType === piece.type.toUpperCase() && h.pieceColor === piece.color\n      );\n      const isHovered = hoveredPieceSquare === piece.square;\n      \n      elements.push(\n        <g \n          key={piece.id}\n          style={{\n            transform: `translate(${piece.x}px, ${piece.y}px)`,\n            transition: 'transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)',\n          }}\n        >\n          <text\n            x={0}\n            y={0}\n            textAnchor=\"middle\"\n            dominantBaseline=\"central\"\n            fontSize={fontSize}\n            fill={piece.color === 'w' ? '#ffffff' : '#1a1a1a'}\n            stroke={piece.color === 'w' ? '#1a1a1a' : '#ffffff'}\n            strokeWidth={fontSize * 0.03}\n            style={{ \n              opacity: pieceOpacity,\n              transition: 'opacity 0.2s ease-out, filter 0.2s ease-out',\n              cursor: 'pointer',\n              filter: isHighlighted \n                ? `drop-shadow(0 0 ${fontSize * 0.15}px rgba(251, 191, 36, 0.8)) drop-shadow(0 ${fontSize * 0.02}px ${fontSize * 0.04}px rgba(0,0,0,0.3))`\n                : isHovered\n                ? `drop-shadow(0 0 ${fontSize * 0.1}px rgba(255, 255, 255, 0.6)) drop-shadow(0 ${fontSize * 0.02}px ${fontSize * 0.04}px rgba(0,0,0,0.3))`\n                : `drop-shadow(0 ${fontSize * 0.02}px ${fontSize * 0.04}px rgba(0,0,0,0.3))`,\n              pointerEvents: 'none', // We use invisible rects for interaction\n            }}\n          >\n            {symbol}\n          </text>\n          {/* Invisible interaction area for piece */}\n          <rect\n            x={-squareSize * 0.4}\n            y={-squareSize * 0.4}\n            width={squareSize * 0.8}\n            height={squareSize * 0.8}\n            fill=\"transparent\"\n            style={{ cursor: 'pointer' }}\n            onClick={(e) => {\n              e.stopPropagation();\n              handlePieceClick(piece.type, piece.color);\n            }}\n            onMouseEnter={() => handlePieceHover(piece.square, piece.type, piece.color)}\n            onMouseLeave={handlePieceLeave}\n          />\n        </g>\n      );\n    }\n    \n    return elements;\n  }, [showPieces, trackedPieces, squareSize, pieceOpacity, highlightedPieces, hoveredPieceSquare, handlePieceClick, handlePieceHover, handlePieceLeave]);\n  \n  // Helper to convert square notation to coordinates\n  const squareToCoords = useCallback((square: string): { x: number; y: number } => {\n    const file = square.charCodeAt(0) - 97; // 'a' = 0\n    const rank = parseInt(square[1]) - 1;   // '1' = 0\n    const rowIndex = 7 - rank;\n    return {\n      x: borderWidth + file * squareSize + squareSize / 2,\n      y: borderWidth + rowIndex * squareSize + squareSize / 2,\n    };\n  }, [borderWidth, squareSize]);\n\n  // Render move arrows\n  const arrowElements = useMemo(() => {\n    if (pieceArrows.length === 0) return null;\n    \n    const arrows: React.ReactNode[] = [];\n    const arrowWidth = squareSize * 0.08;\n    const headLength = squareSize * 0.2;\n    const headWidth = squareSize * 0.15;\n    \n    // Create arrow marker definition\n    const markerId = 'arrowhead';\n    \n    pieceArrows.forEach((arrow, idx) => {\n      const from = squareToCoords(arrow.from);\n      const to = squareToCoords(arrow.to);\n      \n      // Calculate arrow direction\n      const dx = to.x - from.x;\n      const dy = to.y - from.y;\n      const length = Math.sqrt(dx * dx + dy * dy);\n      \n      if (length === 0) return;\n      \n      // Normalize direction\n      const nx = dx / length;\n      const ny = dy / length;\n      \n      // Shorten arrow to not overlap with piece center\n      const shortenStart = squareSize * 0.15;\n      const shortenEnd = squareSize * 0.25;\n      \n      const startX = from.x + nx * shortenStart;\n      const startY = from.y + ny * shortenStart;\n      const endX = to.x - nx * shortenEnd;\n      const endY = to.y - ny * shortenEnd;\n      \n      // Calculate arrowhead points\n      const headBaseX = endX - nx * headLength;\n      const headBaseY = endY - ny * headLength;\n      const perpX = -ny * headWidth;\n      const perpY = nx * headWidth;\n      \n      // Color based on capture status and opacity based on move number\n      const baseOpacity = 0.5 + (idx / pieceArrows.length) * 0.4;\n      const color = arrow.isCapture ? 'rgba(239, 68, 68, 0.8)' : 'rgba(251, 191, 36, 0.8)';\n      \n      arrows.push(\n        <g key={`arrow-${idx}`} style={{ opacity: baseOpacity }}>\n          {/* Arrow line */}\n          <line\n            x1={startX}\n            y1={startY}\n            x2={headBaseX}\n            y2={headBaseY}\n            stroke={color}\n            strokeWidth={arrowWidth}\n            strokeLinecap=\"round\"\n          />\n          {/* Arrow head */}\n          <polygon\n            points={`${endX},${endY} ${headBaseX + perpX},${headBaseY + perpY} ${headBaseX - perpX},${headBaseY - perpY}`}\n            fill={color}\n          />\n          {/* Move number indicator */}\n          <circle\n            cx={startX}\n            cy={startY}\n            r={squareSize * 0.1}\n            fill=\"rgba(0,0,0,0.7)\"\n            stroke={color}\n            strokeWidth={1}\n          />\n          <text\n            x={startX}\n            y={startY}\n            textAnchor=\"middle\"\n            dominantBaseline=\"central\"\n            fontSize={squareSize * 0.12}\n            fill=\"white\"\n            fontWeight=\"bold\"\n          >\n            {arrow.moveNumber}\n          </text>\n        </g>\n      );\n    });\n    \n    return arrows;\n  }, [pieceArrows, squareSize, squareToCoords]);\n  \n  return (\n    <svg\n      width={totalSize}\n      height={totalSize}\n      viewBox={`0 0 ${totalSize} ${totalSize}`}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      style={{ display: 'block' }}\n    >\n      {/* Border */}\n      <rect\n        x={0}\n        y={0}\n        width={totalSize}\n        height={totalSize}\n        fill={boardColors.border}\n      />\n      \n      {/* Board squares */}\n      {boardElements}\n      \n      {/* Move arrows layer */}\n      {arrowElements}\n      \n      {/* Chess pieces overlay */}\n      {pieceElements}\n      \n      {/* Invisible interaction layer */}\n      {interactionSquares}\n    </svg>\n  );\n};\n\nexport default InteractiveVisualizationBoard;\n";export{e as default};
