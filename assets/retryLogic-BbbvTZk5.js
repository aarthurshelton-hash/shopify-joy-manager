const n="/**\n * API Retry Logic with Exponential Backoff\n * \n * Provides resilient API calls with automatic retry for transient failures.\n * Implements exponential backoff with jitter to prevent thundering herd.\n * \n * @module retryLogic\n * @example\n * ```typescript\n * const data = await withRetry(\n *   () => fetch('/api/data').then(r => r.json()),\n *   { maxRetries: 5, baseDelayMs: 500 }\n * );\n * ```\n */\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n  retryableStatuses: number[];\n}\n\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelayMs: 1000,\n  maxDelayMs: 10000,\n  retryableStatuses: [408, 429, 500, 502, 503, 504],\n};\n\n/**\n * Calculate delay with exponential backoff and jitter\n */\nfunction calculateDelay(attempt: number, config: RetryConfig): number {\n  const exponentialDelay = config.baseDelayMs * Math.pow(2, attempt);\n  const jitter = Math.random() * 1000;\n  return Math.min(exponentialDelay + jitter, config.maxDelayMs);\n}\n\n/**\n * Sleep for specified milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Check if error is retryable\n */\nfunction isRetryableError(error: unknown, config: RetryConfig): boolean {\n  if (error instanceof Response) {\n    return config.retryableStatuses.includes(error.status);\n  }\n  \n  if (error instanceof Error) {\n    // Network errors are retryable\n    const networkErrors = ['fetch', 'network', 'timeout', 'abort'];\n    return networkErrors.some(e => error.message.toLowerCase().includes(e));\n  }\n  \n  return false;\n}\n\n/**\n * Execute function with retry logic\n * \n * @template T Return type of the function\n * @param {() => Promise<T>} fn Function to execute\n * @param {Partial<RetryConfig>} [config] Retry configuration\n * @returns {Promise<T>} Result of the function\n * @throws {Error} After all retries are exhausted\n * \n * @example\n * ```typescript\n * const data = await withRetry(\n *   () => fetch('/api/data').then(r => r.json()),\n *   { maxRetries: 5, baseDelayMs: 500 }\n * );\n * ```\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  config: Partial<RetryConfig> = {}\n): Promise<T> {\n  const fullConfig = { ...DEFAULT_RETRY_CONFIG, ...config };\n  let lastError: unknown;\n  \n  for (let attempt = 0; attempt <= fullConfig.maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n      \n      // Don't retry on last attempt\n      if (attempt === fullConfig.maxRetries) {\n        break;\n      }\n      \n      // Check if error is retryable\n      if (!isRetryableError(error, fullConfig)) {\n        throw error;\n      }\n      \n      // Calculate and wait for delay\n      const delay = calculateDelay(attempt, fullConfig);\n      console.log(`[Retry] Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);\n      await sleep(delay);\n    }\n  }\n  \n  throw lastError;\n}\n\n/**\n * Fetch with automatic retry\n * \n * @param {string | Request | URL} input Fetch input\n * @param {RequestInit} [init] Fetch options\n * @param {Partial<RetryConfig>} [retryConfig] Retry configuration\n * @returns {Promise<Response>} Fetch response\n * \n * @example\n * ```typescript\n * const response = await fetchWithRetry('/api/data', {\n *   method: 'POST',\n *   body: JSON.stringify({ id: 1 })\n * });\n * ```\n */\nexport async function fetchWithRetry(\n  input: string | Request | URL,\n  init?: RequestInit,\n  retryConfig?: Partial<RetryConfig>\n): Promise<Response> {\n  return withRetry(async () => {\n    const response = await fetch(input, init);\n    \n    // Throw on error status to trigger retry\n    if (!response.ok) {\n      throw response;\n    }\n    \n    return response;\n  }, retryConfig);\n}\n\n/**\n * Supabase RPC with retry\n * \n * @template T Return type\n * @param {Function} rpcFn Supabase RPC function\n * @param {Partial<RetryConfig>} [retryConfig] Retry configuration\n * @returns {Promise<T>} RPC result\n */\nexport async function supabaseRpcWithRetry<T>(\n  rpcFn: () => Promise<{ data: T | null; error: Error | null }>,\n  retryConfig?: Partial<RetryConfig>\n): Promise<T> {\n  return withRetry(async () => {\n    const { data, error } = await rpcFn();\n    \n    if (error) {\n      throw error;\n    }\n    \n    if (data === null) {\n      throw new Error('No data returned from RPC');\n    }\n    \n    return data;\n  }, retryConfig);\n}\n";export{n as default};
