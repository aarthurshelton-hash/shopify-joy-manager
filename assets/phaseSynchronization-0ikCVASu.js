const e="/**\n * Phase Synchronization Detector\n * Identifies when biological, cosmic, and market cycles enter phase-lock\n * Like pendulums on a shared platform, independent cycles can synchronize\n */\n\nimport { DomainType } from '../types';\n\n// Cycle Definition\nexport interface CycleDefinition {\n  name: string;\n  domain: DomainType | 'geological' | 'linguistic';\n  periodMs: number;         // Cycle period in milliseconds\n  currentPhase: number;     // 0-1 (0 = start, 0.5 = mid, 1 = end/restart)\n  amplitude: number;        // Strength of the cycle\n  lastPeakAt?: number;      // Timestamp of last peak\n  lastTroughAt?: number;    // Timestamp of last trough\n}\n\n// Phase Lock Event\nexport interface PhaseLockEvent {\n  id: string;\n  timestamp: number;\n  synchronizedCycles: string[];   // Names of cycles that synchronized\n  lockStrength: number;           // 0-1 how strongly locked\n  commonPhase: number;            // The phase they're locked at\n  predictedDuration: number;      // How long lock expected to last (ms)\n  marketImplication: 'strong_trend' | 'reversal_imminent' | 'volatility_expansion' | 'consolidation';\n  resolved?: {\n    actualDuration: number;\n    wasCorrect: boolean;\n  };\n}\n\n// Phase Coherence Calculation Result\nexport interface PhaseCoherence {\n  overallCoherence: number;       // 0-1 average phase alignment\n  dominantPhase: number;          // The phase most cycles are near\n  cycleCount: number;             // Number of cycles analyzed\n  synchronizedPairs: [string, string, number][]; // [cycle1, cycle2, correlation]\n  isSignificant: boolean;         // Whether coherence exceeds random chance\n}\n\n// Known Natural Cycles\nexport const KNOWN_CYCLES: Record<string, CycleDefinition> = {\n  // Cosmic Cycles\n  lunar: {\n    name: 'Lunar Cycle',\n    domain: 'bio',\n    periodMs: 29.5 * 24 * 60 * 60 * 1000, // ~29.5 days\n    currentPhase: 0,\n    amplitude: 0.7\n  },\n  solar_rotation: {\n    name: 'Solar Rotation',\n    domain: 'satellite',\n    periodMs: 27 * 24 * 60 * 60 * 1000, // ~27 days\n    currentPhase: 0,\n    amplitude: 0.5\n  },\n  mercury_synodic: {\n    name: 'Mercury Synodic',\n    domain: 'satellite',\n    periodMs: 116 * 24 * 60 * 60 * 1000, // ~116 days\n    currentPhase: 0,\n    amplitude: 0.4\n  },\n  \n  // Biological Cycles\n  circadian: {\n    name: 'Circadian Rhythm',\n    domain: 'bio',\n    periodMs: 24 * 60 * 60 * 1000, // 24 hours\n    currentPhase: 0,\n    amplitude: 0.9\n  },\n  ultradian: {\n    name: 'Ultradian (90min)',\n    domain: 'bio',\n    periodMs: 90 * 60 * 1000, // 90 minutes\n    currentPhase: 0,\n    amplitude: 0.6\n  },\n  weekly: {\n    name: 'Weekly Rhythm',\n    domain: 'bio',\n    periodMs: 7 * 24 * 60 * 60 * 1000, // 7 days\n    currentPhase: 0,\n    amplitude: 0.5\n  },\n  \n  // Market Cycles\n  options_expiry: {\n    name: 'Options Expiry',\n    domain: 'market',\n    periodMs: 30 * 24 * 60 * 60 * 1000, // ~monthly\n    currentPhase: 0,\n    amplitude: 0.8\n  },\n  quarterly: {\n    name: 'Quarterly Cycle',\n    domain: 'market',\n    periodMs: 91 * 24 * 60 * 60 * 1000, // ~91 days\n    currentPhase: 0,\n    amplitude: 0.7\n  },\n  \n  // Geological\n  tidal: {\n    name: 'Tidal Cycle',\n    domain: 'geological',\n    periodMs: 12.42 * 60 * 60 * 1000, // ~12.42 hours\n    currentPhase: 0,\n    amplitude: 0.4\n  }\n};\n\n// Calculate phase from timestamp\nexport function calculatePhase(\n  timestamp: number,\n  periodMs: number,\n  epochOffset: number = 0\n): number {\n  const elapsed = timestamp - epochOffset;\n  return (elapsed % periodMs) / periodMs;\n}\n\n// Calculate phase difference between two cycles\nexport function phaseDifference(phase1: number, phase2: number): number {\n  const diff = Math.abs(phase1 - phase2);\n  return Math.min(diff, 1 - diff); // Circular distance\n}\n\n// Check if two phases are synchronized\nexport function arePhasesSynchronized(\n  phase1: number,\n  phase2: number,\n  tolerance: number = 0.1\n): boolean {\n  return phaseDifference(phase1, phase2) <= tolerance;\n}\n\n// Phase Synchronization Detector Class\nexport class PhaseSynchronizationDetector {\n  private cycles: Map<string, CycleDefinition> = new Map();\n  private events: PhaseLockEvent[] = [];\n  private epochReference: number;\n\n  constructor(epochReference?: number) {\n    // Use January 1, 2000 as default epoch\n    this.epochReference = epochReference || new Date('2000-01-01T00:00:00Z').getTime();\n    \n    // Initialize with known cycles\n    Object.entries(KNOWN_CYCLES).forEach(([key, cycle]) => {\n      this.cycles.set(key, { ...cycle });\n    });\n  }\n\n  // Update all cycle phases to current time\n  updateCyclePhases(timestamp: number = Date.now()): void {\n    for (const [key, cycle] of this.cycles) {\n      cycle.currentPhase = calculatePhase(timestamp, cycle.periodMs, this.epochReference);\n    }\n  }\n\n  // Add a custom cycle\n  addCycle(key: string, cycle: CycleDefinition): void {\n    this.cycles.set(key, cycle);\n  }\n\n  // Analyze current phase coherence\n  analyzePhaseCoherence(): PhaseCoherence {\n    this.updateCyclePhases();\n    \n    const cycleArray = Array.from(this.cycles.entries());\n    const phases = cycleArray.map(([_, c]) => c.currentPhase);\n    \n    // Calculate pairwise synchronization\n    const synchronizedPairs: [string, string, number][] = [];\n    \n    for (let i = 0; i < cycleArray.length; i++) {\n      for (let j = i + 1; j < cycleArray.length; j++) {\n        const [name1, cycle1] = cycleArray[i];\n        const [name2, cycle2] = cycleArray[j];\n        \n        const diff = phaseDifference(cycle1.currentPhase, cycle2.currentPhase);\n        const correlation = 1 - diff * 2; // Convert to correlation-like score\n        \n        if (correlation > 0.6) {\n          synchronizedPairs.push([name1, name2, correlation]);\n        }\n      }\n    }\n    \n    // Calculate overall coherence (Kuramoto order parameter approximation)\n    const sumCos = phases.reduce((sum, p) => sum + Math.cos(2 * Math.PI * p), 0);\n    const sumSin = phases.reduce((sum, p) => sum + Math.sin(2 * Math.PI * p), 0);\n    const overallCoherence = Math.sqrt(sumCos * sumCos + sumSin * sumSin) / phases.length;\n    \n    // Dominant phase (average angular position)\n    const dominantPhase = (Math.atan2(sumSin, sumCos) / (2 * Math.PI) + 1) % 1;\n    \n    // Is this level of coherence significant?\n    // Random phases would have coherence ~0.2-0.3, significant would be >0.5\n    const isSignificant = overallCoherence > 0.5;\n    \n    return {\n      overallCoherence,\n      dominantPhase,\n      cycleCount: phases.length,\n      synchronizedPairs,\n      isSignificant\n    };\n  }\n\n  // Detect phase lock event\n  detectPhaseLock(): PhaseLockEvent | null {\n    const coherence = this.analyzePhaseCoherence();\n    \n    if (!coherence.isSignificant) return null;\n    \n    // Find which cycles are most synchronized\n    const syncedCycleNames = new Set<string>();\n    coherence.synchronizedPairs.forEach(([c1, c2, _]) => {\n      syncedCycleNames.add(c1);\n      syncedCycleNames.add(c2);\n    });\n    \n    if (syncedCycleNames.size < 3) return null; // Need at least 3 cycles\n    \n    // Determine market implication based on phase and cycles involved\n    let marketImplication: PhaseLockEvent['marketImplication'];\n    \n    if (coherence.dominantPhase < 0.25 || coherence.dominantPhase > 0.75) {\n      marketImplication = 'reversal_imminent';\n    } else if (coherence.dominantPhase > 0.4 && coherence.dominantPhase < 0.6) {\n      marketImplication = 'strong_trend';\n    } else if (coherence.overallCoherence > 0.7) {\n      marketImplication = 'volatility_expansion';\n    } else {\n      marketImplication = 'consolidation';\n    }\n    \n    // Estimate duration based on shortest synchronized cycle\n    const syncedCycles = Array.from(syncedCycleNames)\n      .map(name => this.cycles.get(name))\n      .filter(Boolean) as CycleDefinition[];\n    \n    const shortestPeriod = Math.min(...syncedCycles.map(c => c.periodMs));\n    const predictedDuration = shortestPeriod * 0.2; // ~20% of shortest cycle\n    \n    const event: PhaseLockEvent = {\n      id: `plock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n      synchronizedCycles: Array.from(syncedCycleNames),\n      lockStrength: coherence.overallCoherence,\n      commonPhase: coherence.dominantPhase,\n      predictedDuration,\n      marketImplication\n    };\n    \n    this.events.push(event);\n    return event;\n  }\n\n  // Get prediction based on current synchronization\n  getSynchronizationPrediction(): {\n    confidence: number;\n    direction: 'bullish' | 'bearish' | 'neutral';\n    reasoning: string;\n    synchronizedCycles: string[];\n  } {\n    const coherence = this.analyzePhaseCoherence();\n    \n    if (!coherence.isSignificant) {\n      return {\n        confidence: 0.3,\n        direction: 'neutral',\n        reasoning: 'Cycles are desynchronized - no clear directional bias',\n        synchronizedCycles: []\n      };\n    }\n    \n    // Phase position determines direction tendency\n    // 0-0.25: Recovery/early bull\n    // 0.25-0.5: Bull run\n    // 0.5-0.75: Topping/early bear\n    // 0.75-1.0: Bear market/bottoming\n    \n    let direction: 'bullish' | 'bearish' | 'neutral';\n    let reasoning: string;\n    \n    if (coherence.dominantPhase < 0.25) {\n      direction = 'bullish';\n      reasoning = 'Synchronized cycles in early expansion phase';\n    } else if (coherence.dominantPhase < 0.5) {\n      direction = 'bullish';\n      reasoning = 'Synchronized cycles in mid-cycle growth phase';\n    } else if (coherence.dominantPhase < 0.75) {\n      direction = 'bearish';\n      reasoning = 'Synchronized cycles in late cycle/distribution phase';\n    } else {\n      direction = 'neutral';\n      reasoning = 'Synchronized cycles near inflection point - reversal likely';\n    }\n    \n    // Confidence based on coherence strength\n    const confidence = 0.4 + (coherence.overallCoherence * 0.5);\n    \n    const syncedNames = coherence.synchronizedPairs.flatMap(([c1, c2]) => [c1, c2]);\n    const uniqueNames = [...new Set(syncedNames)];\n    \n    return {\n      confidence: Math.min(0.9, confidence),\n      direction,\n      reasoning,\n      synchronizedCycles: uniqueNames\n    };\n  }\n\n  // Resolve a phase lock event\n  resolvePhaseLockEvent(eventId: string, actualDuration: number, wasCorrect: boolean): void {\n    const event = this.events.find(e => e.id === eventId);\n    if (event) {\n      event.resolved = { actualDuration, wasCorrect };\n    }\n  }\n\n  // Get synchronization strength score for engine integration\n  getSynchronizationScore(): number {\n    const coherence = this.analyzePhaseCoherence();\n    return coherence.overallCoherence;\n  }\n\n  // Get recent phase lock events\n  getRecentEvents(limit: number = 10): PhaseLockEvent[] {\n    return [...this.events]\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  // Calculate accuracy of phase lock predictions\n  getAccuracyStats(): {\n    totalEvents: number;\n    resolvedEvents: number;\n    correctPredictions: number;\n    accuracy: number;\n  } {\n    const resolved = this.events.filter(e => e.resolved);\n    const correct = resolved.filter(e => e.resolved?.wasCorrect);\n    \n    return {\n      totalEvents: this.events.length,\n      resolvedEvents: resolved.length,\n      correctPredictions: correct.length,\n      accuracy: resolved.length > 0 ? correct.length / resolved.length : 0\n    };\n  }\n\n  // Export for persistence\n  exportState(): { cycles: [string, CycleDefinition][]; events: PhaseLockEvent[] } {\n    return {\n      cycles: Array.from(this.cycles.entries()),\n      events: [...this.events]\n    };\n  }\n\n  // Import from persistence\n  importState(state: { cycles: [string, CycleDefinition][]; events: PhaseLockEvent[] }): void {\n    this.cycles = new Map(state.cycles);\n    this.events = state.events;\n  }\n}\n\n// Singleton instance\nexport const phaseSynchronizationDetector = new PhaseSynchronizationDetector();\n\nexport default phaseSynchronizationDetector;\n";export{e as default};
