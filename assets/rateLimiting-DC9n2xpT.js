const n="/**\n * API Rate Limiting for Trading Operations\n * \n * Implements strict rate limiting for trading endpoints to prevent\n * abuse and ensure system stability.\n */\n\ninterface RateLimitEntry {\n  count: number;\n  windowStart: number;\n  lastRequest: number;\n}\n\ninterface RateLimitConfig {\n  maxRequests: number;\n  windowMs: number;\n  blockDurationMs?: number;\n}\n\n/**\n * Rate limiter configurations for different endpoint types\n */\nexport const RATE_LIMITS = {\n  // Trading operations - very strict\n  TRADING: {\n    maxRequests: 10,      // 10 requests\n    windowMs: 60000,      // per minute\n    blockDurationMs: 300000, // 5 min block if exceeded\n  } as RateLimitConfig,\n  \n  // Market data - moderate\n  MARKET_DATA: {\n    maxRequests: 60,      // 60 requests\n    windowMs: 60000,      // per minute\n  } as RateLimitConfig,\n  \n  // Account info - lenient\n  ACCOUNT: {\n    maxRequests: 30,      // 30 requests\n    windowMs: 60000,      // per minute\n  } as RateLimitConfig,\n  \n  // Order placement - extremely strict\n  ORDER_PLACE: {\n    maxRequests: 5,       // 5 orders\n    windowMs: 60000,      // per minute\n    blockDurationMs: 600000, // 10 min block if exceeded\n  } as RateLimitConfig,\n} as const;\n\n/**\n * In-memory rate limit store (per-session)\n * For production, consider Redis or similar\n */\nclass RateLimitStore {\n  private store = new Map<string, RateLimitEntry>();\n  private blockedClients = new Map<string, number>();\n  \n  /**\n   * Check if client is currently blocked\n   */\n  isBlocked(clientId: string): { blocked: boolean; remainingMs?: number } {\n    const blockedUntil = this.blockedClients.get(clientId);\n    if (blockedUntil && Date.now() < blockedUntil) {\n      return { \n        blocked: true, \n        remainingMs: blockedUntil - Date.now() \n      };\n    }\n    \n    if (blockedUntil) {\n      this.blockedClients.delete(clientId);\n    }\n    \n    return { blocked: false };\n  }\n  \n  /**\n   * Record a request and check rate limit\n   */\n  recordRequest(clientId: string, config: RateLimitConfig): { \n    allowed: boolean; \n    remaining: number;\n    resetTime: number;\n    blocked?: boolean;\n    blockDurationMs?: number;\n  } {\n    // Check if client is blocked\n    const blockStatus = this.isBlocked(clientId);\n    if (blockStatus.blocked) {\n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: Date.now() + (blockStatus.remainingMs || 0),\n        blocked: true,\n        blockDurationMs: blockStatus.remainingMs,\n      };\n    }\n    \n    const now = Date.now();\n    const entry = this.store.get(clientId);\n    \n    // Reset window if expired\n    if (!entry || now - entry.windowStart > config.windowMs) {\n      this.store.set(clientId, {\n        count: 1,\n        windowStart: now,\n        lastRequest: now,\n      });\n      \n      return {\n        allowed: true,\n        remaining: config.maxRequests - 1,\n        resetTime: now + config.windowMs,\n      };\n    }\n    \n    // Check if limit exceeded\n    if (entry.count >= config.maxRequests) {\n      // Block client if configured\n      if (config.blockDurationMs) {\n        this.blockedClients.set(clientId, now + config.blockDurationMs);\n      }\n      \n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: entry.windowStart + config.windowMs,\n        blocked: true,\n        blockDurationMs: config.blockDurationMs,\n      };\n    }\n    \n    // Increment counter\n    entry.count++;\n    entry.lastRequest = now;\n    \n    return {\n      allowed: true,\n      remaining: config.maxRequests - entry.count,\n      resetTime: entry.windowStart + config.windowMs,\n    };\n  }\n  \n  /**\n   * Clean up old entries (call periodically)\n   */\n  cleanup(): void {\n    const now = Date.now();\n    const maxAge = 3600000; // 1 hour\n    \n    for (const [key, entry] of this.store.entries()) {\n      if (now - entry.windowStart > maxAge) {\n        this.store.delete(key);\n      }\n    }\n    \n    for (const [key, blockedUntil] of this.blockedClients.entries()) {\n      if (now > blockedUntil) {\n        this.blockedClients.delete(key);\n      }\n    }\n  }\n}\n\n// Global rate limit store instance\nconst rateLimitStore = new RateLimitStore();\n\n/**\n * Rate limit check result\n */\nexport interface RateLimitResult {\n  allowed: boolean;\n  limit: number;\n  remaining: number;\n  resetTime: number;\n  blocked?: boolean;\n  blockDurationMs?: number;\n  retryAfter?: number;\n}\n\n/**\n * Check rate limit for a client\n */\nexport function checkRateLimit(\n  clientId: string, \n  endpointType: keyof typeof RATE_LIMITS\n): RateLimitResult {\n  const config = RATE_LIMITS[endpointType];\n  const result = rateLimitStore.recordRequest(clientId, config);\n  \n  return {\n    limit: config.maxRequests,\n    ...result,\n    retryAfter: result.blocked && result.blockDurationMs \n      ? Math.ceil(result.blockDurationMs / 1000) \n      : undefined,\n  };\n}\n\n/**\n * Middleware-style rate limit checker\n * Returns null if allowed, or error response if blocked\n */\nexport function rateLimitMiddleware(\n  clientId: string,\n  endpointType: keyof typeof RATE_LIMITS\n): { error: string; status: number; headers: Record<string, string> } | null {\n  const result = checkRateLimit(clientId, endpointType);\n  \n  if (!result.allowed) {\n    const headers: Record<string, string> = {\n      'X-RateLimit-Limit': String(result.limit),\n      'X-RateLimit-Remaining': '0',\n      'X-RateLimit-Reset': String(Math.ceil(result.resetTime / 1000)),\n    };\n    \n    if (result.retryAfter) {\n      headers['Retry-After'] = String(result.retryAfter);\n    }\n    \n    return {\n      error: result.blocked \n        ? `Rate limit exceeded. You are temporarily blocked for ${Math.ceil((result.blockDurationMs || 0) / 1000)} seconds.`\n        : 'Rate limit exceeded. Please try again later.',\n      status: 429,\n      headers,\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Get rate limit headers for successful requests\n */\nexport function getRateLimitHeaders(\n  clientId: string,\n  endpointType: keyof typeof RATE_LIMITS\n): Record<string, string> {\n  const config = RATE_LIMITS[endpointType];\n  const result = rateLimitStore.recordRequest(clientId, config);\n  \n  return {\n    'X-RateLimit-Limit': String(config.maxRequests),\n    'X-RateLimit-Remaining': String(result.remaining),\n    'X-RateLimit-Reset': String(Math.ceil(result.resetTime / 1000)),\n  };\n}\n\n/**\n * Generate client ID from request\n */\nexport function generateClientId(userId: string, endpoint: string): string {\n  return `${userId}:${endpoint}`;\n}\n\n// Periodic cleanup\nsetInterval(() => rateLimitStore.cleanup(), 300000); // Every 5 minutes\n";export{n as default};
