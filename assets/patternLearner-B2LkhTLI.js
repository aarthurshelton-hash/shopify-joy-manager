const n="/**\n * Pattern Learner - Discovers and manages learned patterns\n */\n\nimport { LearnedPattern, PatternCondition, PredictionOutcome } from './types';\n\nconst MAX_PATTERNS = 100;\n\nexport function createPatternId(conditions: { correlationStrength: number; volatility: number; momentum: number }): string {\n  const c = Math.round(conditions.correlationStrength * 10);\n  const v = Math.round(conditions.volatility * 10);\n  const m = Math.round(conditions.momentum * 10);\n  return `C${c}V${v}M${m}`;\n}\n\nexport function generatePatternName(conditions: { correlationStrength: number; volatility: number; momentum: number }): string {\n  const corrDesc = conditions.correlationStrength > 0.7 ? 'High-Corr' : \n                   conditions.correlationStrength > 0.4 ? 'Mid-Corr' : 'Low-Corr';\n  const volDesc = conditions.volatility > 0.7 ? 'High-Vol' : \n                  conditions.volatility > 0.4 ? 'Mid-Vol' : 'Low-Vol';\n  const momDesc = conditions.momentum > 0.3 ? 'Bullish-Mom' : \n                  conditions.momentum < -0.3 ? 'Bearish-Mom' : 'Neutral-Mom';\n  \n  return `${corrDesc} ${volDesc} ${momDesc}`;\n}\n\nexport function extractConditions(conditions: { correlationStrength: number; volatility: number; momentum: number }): PatternCondition[] {\n  return [\n    { market: 'cross', indicator: 'correlation_shift', operator: 'between', value: [conditions.correlationStrength - 0.1, conditions.correlationStrength + 0.1] },\n    { market: 'cross', indicator: 'volatility', operator: 'between', value: [conditions.volatility - 0.1, conditions.volatility + 0.1] },\n    { market: 'cross', indicator: 'price_change', operator: conditions.momentum > 0 ? '>' : '<', value: 0 }\n  ];\n}\n\nexport function learnFromOutcome(\n  patternLibrary: LearnedPattern[],\n  prediction: PredictionOutcome,\n  wasCorrect: boolean,\n  decayRate: number\n): LearnedPattern[] {\n  const patternId = createPatternId(prediction.marketConditions);\n  const existingIndex = patternLibrary.findIndex(p => p.id === patternId);\n  \n  const newLibrary = [...patternLibrary];\n  \n  if (existingIndex !== -1) {\n    const existing = { ...newLibrary[existingIndex] };\n    existing.occurrences++;\n    existing.successRate = \n      (existing.successRate * (existing.occurrences - 1) + (wasCorrect ? 1 : 0)) \n      / existing.occurrences;\n    existing.lastSeen = Date.now();\n    existing.confidence = Math.min(0.95, \n      existing.successRate * Math.min(1, existing.occurrences / 50)\n    );\n    newLibrary[existingIndex] = existing;\n  } else if (patternLibrary.length < MAX_PATTERNS) {\n    newLibrary.push({\n      id: patternId,\n      name: generatePatternName(prediction.marketConditions),\n      conditions: extractConditions(prediction.marketConditions),\n      predictedOutcome: prediction.predicted === 'up' ? 'bullish' : \n                        prediction.predicted === 'down' ? 'bearish' : 'neutral',\n      confidence: 0.5,\n      occurrences: 1,\n      successRate: wasCorrect ? 1 : 0,\n      discoveredAt: Date.now(),\n      lastSeen: Date.now()\n    });\n  }\n  \n  // Decay and filter old patterns\n  return newLibrary\n    .map(p => ({ ...p, confidence: p.confidence * decayRate }))\n    .filter(p => p.confidence > 0.1 || Date.now() - p.lastSeen < 3600000);\n}\n\nexport function getBestPatterns(patternLibrary: LearnedPattern[], limit: number = 5): LearnedPattern[] {\n  return [...patternLibrary]\n    .filter(p => p.occurrences >= 5)\n    .sort((a, b) => b.successRate * b.confidence - a.successRate * a.confidence)\n    .slice(0, limit);\n}\n";export{n as default};
