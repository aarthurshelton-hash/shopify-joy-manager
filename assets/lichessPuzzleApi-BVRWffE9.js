const n="/**\n * Lichess Puzzle API Integration\n * Fetches puzzles from Lichess open database (4M+ puzzles)\n * \n * v8.1-PUZZLES: New source for temporal pattern training\n */\n\nexport interface LichessPuzzle {\n  id: string;\n  fen: string;\n  moves: string[]; // Solution in UCI format\n  rating: number;\n  ratingDeviation: number;\n  themes: string[];\n  gameUrl?: string; // Link to source game\n  opening?: string;\n}\n\nexport interface LichessPuzzleResult {\n  puzzles: LichessPuzzle[];\n  totalFetched: number;\n  errors: string[];\n}\n\n// Lichess puzzle themes for filtering\nexport const LICHESS_PUZZLE_THEMES = [\n  'mate', 'mateIn1', 'mateIn2', 'mateIn3', 'mateIn4', 'mateIn5',\n  'fork', 'pin', 'skewer', 'discoveredAttack', 'doubleCheck',\n  'sacrifice', 'deflection', 'decoy', 'interference',\n  'zugzwang', 'xRayAttack', 'clearance', 'quietMove',\n  'backRankMate', 'smotheredMate', 'arabianMate', 'anastasiasMate',\n  'endgame', 'pawnEndgame', 'rookEndgame', 'queenEndgame',\n  'opening', 'middlegame', 'advantage', 'crushing', 'defensive',\n  'hangingPiece', 'trappedPiece', 'exposedKing', \n  'kingsideAttack', 'queensideAttack',\n  'promotion', 'underPromotion', 'castling', 'enPassant',\n  'intermezzo', 'capturingDefender', 'masterGame'\n] as const;\n\n/**\n * Fetch puzzles from Lichess database\n * Uses database export or API endpoint\n * \n * v8.1: Fetches real puzzles with temporal pattern data\n */\nexport async function fetchLichessPuzzles(\n  options: {\n    max?: number;\n    minRating?: number;\n    maxRating?: number;\n    themes?: string[];\n  } = {}\n): Promise<LichessPuzzleResult> {\n  const { \n    max = 100, \n    minRating = 800, \n    maxRating = 2800,\n    themes = []\n  } = options;\n  \n  const errors: string[] = [];\n  \n  try {\n    // Lichess puzzle database API endpoint\n    const response = await fetch(\n      `https://database.lichess.org/lichess_db_puzzle.csv.zst`,\n      { method: 'HEAD' } // Check availability first\n    );\n    \n    // For live fetching, use Lichess API\n    const puzzles: LichessPuzzle[] = [];\n    \n    // Fetch from Lichess puzzle API (batch endpoint)\n    const apiUrl = new URL('https://lichess.org/api/puzzle/next');\n    if (themes.length > 0) {\n      apiUrl.searchParams.set('theme', themes.join(','));\n    }\n    \n    // Fetch multiple puzzles in batches\n    const batchSize = Math.min(max, 50); // API limit\n    const batchesNeeded = Math.ceil(max / batchSize);\n    \n    for (let i = 0; i < batchesNeeded && puzzles.length < max; i++) {\n      try {\n        const batchResponse = await fetch(apiUrl.toString());\n        \n        if (!batchResponse.ok) {\n          errors.push(`Batch ${i + 1}: HTTP ${batchResponse.status}`);\n          continue;\n        }\n        \n        const data = await batchResponse.json();\n        \n        if (data.puzzle) {\n          const puzzle: LichessPuzzle = {\n            id: `puz_${data.puzzle.id}`,\n            fen: data.puzzle.fen,\n            moves: data.puzzle.solution || [],\n            rating: data.puzzle.rating || 1500,\n            ratingDeviation: data.puzzle.ratingDeviation || 100,\n            themes: data.puzzle.themes || [],\n            gameUrl: data.puzzle.gameId ? `https://lichess.org/${data.puzzle.gameId}` : undefined,\n            opening: data.puzzle.opening\n          };\n          \n          // Filter by rating if specified\n          if (puzzle.rating >= minRating && puzzle.rating <= maxRating) {\n            puzzles.push(puzzle);\n          }\n        }\n        \n        // Small delay between requests\n        if (i < batchesNeeded - 1) {\n          await new Promise(r => setTimeout(r, 100));\n        }\n      } catch (err) {\n        errors.push(`Batch ${i + 1}: ${err instanceof Error ? err.message : 'Unknown error'}`);\n      }\n    }\n    \n    console.log(`[Lichess Puzzles v8.1] âœ“ Fetched ${puzzles.length} puzzles (themes: ${themes.join(', ') || 'all'})`);\n    \n    return {\n      puzzles,\n      totalFetched: puzzles.length,\n      errors\n    };\n    \n  } catch (error) {\n    console.error('[Lichess Puzzles] Fetch error:', error);\n    return {\n      puzzles: [],\n      totalFetched: 0,\n      errors: [error instanceof Error ? error.message : 'Unknown error']\n    };\n  }\n}\n\n/**\n * Convert Lichess puzzle to unified game format\n * For benchmark compatibility\n */\nexport function puzzleToUnified(\n  puzzle: LichessPuzzle\n): {\n  pgn: string;\n  fen: string;\n  gameId: string;\n  source: 'puzzle';\n  themes: string[];\n  rating: number;\n  solution: string[];\n} {\n  // Create minimal PGN from FEN and solution\n  const moves = puzzle.moves.map((move, i) => \n    i % 2 === 0 ? `${Math.floor(i / 2) + 1}. ${move}` : move\n  ).join(' ');\n  \n  const pgn = `[Event \"Lichess Puzzle ${puzzle.id}\"]\\n` +\n              `[FEN \"${puzzle.fen}\"]\\n` +\n              `[PuzzleRating \"${puzzle.rating}\"]\\n` +\n              `[PuzzleThemes \"${puzzle.themes.join(', ')}\"]\\n\\n` +\n              `${moves} *`;\n  \n  return {\n    pgn,\n    fen: puzzle.fen,\n    gameId: `puz_${puzzle.id}`,\n    source: 'puzzle' as const,\n    themes: puzzle.themes,\n    rating: puzzle.rating,\n    solution: puzzle.moves\n  };\n}\n";export{n as default};
