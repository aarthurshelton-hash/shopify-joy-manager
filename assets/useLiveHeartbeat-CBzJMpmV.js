const n="/**\n * Live Heartbeat Hook\n * Provides auto-refreshing, always-on analysis state\n * Pulses like a heartbeat to keep analysis fresh\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\nexport interface HeartbeatConfig {\n  /** Interval in milliseconds between heartbeats (default: 30000 = 30s) */\n  interval?: number;\n  /** Auto-start on mount (default: true) */\n  autoStart?: boolean;\n  /** Callback when heartbeat triggers */\n  onPulse?: () => void | Promise<void>;\n  /** Enable/disable heartbeat (default: true) */\n  enabled?: boolean;\n}\n\nexport interface HeartbeatState {\n  isAlive: boolean;\n  lastPulse: Date | null;\n  pulseCount: number;\n  isProcessing: boolean;\n  nextPulseIn: number; // seconds until next pulse\n}\n\nexport function useLiveHeartbeat(config: HeartbeatConfig = {}) {\n  const {\n    interval = 30000,\n    autoStart = true,\n    onPulse,\n    enabled = true\n  } = config;\n\n  const [state, setState] = useState<HeartbeatState>({\n    isAlive: false,\n    lastPulse: null,\n    pulseCount: 0,\n    isProcessing: false,\n    nextPulseIn: Math.floor(interval / 1000)\n  });\n\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const countdownRef = useRef<NodeJS.Timeout | null>(null);\n  const onPulseRef = useRef(onPulse);\n\n  // Keep callback ref up to date\n  useEffect(() => {\n    onPulseRef.current = onPulse;\n  }, [onPulse]);\n\n  const pulse = useCallback(async () => {\n    if (!enabled) return;\n    \n    setState(prev => ({ ...prev, isProcessing: true }));\n    \n    try {\n      if (onPulseRef.current) {\n        await onPulseRef.current();\n      }\n    } catch (error) {\n      console.error('[Heartbeat] Pulse error:', error);\n    } finally {\n      setState(prev => ({\n        ...prev,\n        isAlive: true,\n        lastPulse: new Date(),\n        pulseCount: prev.pulseCount + 1,\n        isProcessing: false,\n        nextPulseIn: Math.floor(interval / 1000)\n      }));\n    }\n  }, [enabled, interval]);\n\n  const start = useCallback(() => {\n    if (intervalRef.current) return;\n\n    // Initial pulse\n    pulse();\n\n    // Set up recurring pulse\n    intervalRef.current = setInterval(pulse, interval);\n\n    // Set up countdown timer\n    countdownRef.current = setInterval(() => {\n      setState(prev => ({\n        ...prev,\n        nextPulseIn: Math.max(0, prev.nextPulseIn - 1)\n      }));\n    }, 1000);\n\n    setState(prev => ({ ...prev, isAlive: true }));\n  }, [pulse, interval]);\n\n  const stop = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n    if (countdownRef.current) {\n      clearInterval(countdownRef.current);\n      countdownRef.current = null;\n    }\n    setState(prev => ({ ...prev, isAlive: false }));\n  }, []);\n\n  const restart = useCallback(() => {\n    stop();\n    setTimeout(start, 100);\n  }, [stop, start]);\n\n  // Auto-start on mount\n  useEffect(() => {\n    if (autoStart && enabled) {\n      start();\n    }\n\n    return () => {\n      stop();\n    };\n  }, [autoStart, enabled, start, stop]);\n\n  // Handle enabled changes\n  useEffect(() => {\n    if (!enabled && intervalRef.current) {\n      stop();\n    } else if (enabled && autoStart && !intervalRef.current) {\n      start();\n    }\n  }, [enabled, autoStart, start, stop]);\n\n  return {\n    ...state,\n    pulse,\n    start,\n    stop,\n    restart\n  };\n}\n\n/**\n * Format time until next pulse\n */\nexport function formatNextPulse(seconds: number): string {\n  if (seconds <= 0) return 'now';\n  if (seconds < 60) return `${seconds}s`;\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins}m ${secs}s`;\n}\n";export{n as default};
