const n="/**\n * En Pensent Core SDK - Sustainability Assessor\n * \n * Assesses trajectory sustainability and risk levels\n */\n\nimport { TemporalSignature, PatternMatch } from '../types';\n\nexport interface SustainabilityAssessment {\n  sustainable: boolean;\n  reason: string;\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\n/**\n * Predict if current trajectory is sustainable\n */\nexport function assessTrajectorySustainability(\n  signature: TemporalSignature\n): SustainabilityAssessment {\n  const { temporalFlow, intensity, criticalMoments } = signature;\n  \n  // Check for high intensity with acceleration (burnout risk)\n  if (temporalFlow.trend === 'accelerating' && intensity > 0.8) {\n    return {\n      sustainable: false,\n      reason: 'High intensity with accelerating trend may lead to burnout',\n      riskLevel: 'high'\n    };\n  }\n  \n  // Check for declining trend with negative momentum\n  if (temporalFlow.trend === 'declining' && temporalFlow.momentum < -0.5) {\n    return {\n      sustainable: false,\n      reason: 'Declining trend with negative momentum indicates loss of direction',\n      riskLevel: 'high'\n    };\n  }\n  \n  // Check for too many critical moments (instability)\n  if (criticalMoments.filter(m => m.severity > 0.7).length > 3) {\n    return {\n      sustainable: false,\n      reason: 'Too many critical moments indicate instability',\n      riskLevel: 'medium'\n    };\n  }\n  \n  // Volatile but potentially stabilizing\n  if (temporalFlow.trend === 'volatile') {\n    return {\n      sustainable: true,\n      reason: 'Volatile but may stabilize',\n      riskLevel: 'medium'\n    };\n  }\n  \n  return {\n    sustainable: true,\n    reason: 'Current trajectory appears sustainable',\n    riskLevel: 'low'\n  };\n}\n\n/**\n * Calculate trajectory divergence (how much current path differs from historical patterns)\n */\nexport function calculateTrajectoryDivergence(\n  currentSignature: TemporalSignature,\n  matches: PatternMatch[]\n): number {\n  if (matches.length === 0) return 1; // Maximum divergence if no matches\n  \n  // Calculate average signature of matches\n  const avgIntensity = matches.reduce((sum, m) => sum + m.signature.intensity, 0) / matches.length;\n  const avgMomentum = matches.reduce((sum, m) => sum + m.signature.temporalFlow.momentum, 0) / matches.length;\n  \n  // Calculate divergence from average\n  const intensityDivergence = Math.abs(currentSignature.intensity - avgIntensity);\n  const momentumDivergence = Math.abs(currentSignature.temporalFlow.momentum - avgMomentum) / 2;\n  \n  return (intensityDivergence + momentumDivergence) / 2;\n}\n";export{n as default};
