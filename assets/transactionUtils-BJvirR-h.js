const n="/**\n * Database Transaction Utilities\n * \n * Provides safe transaction handling with automatic rollback\n * for heavy business load scenarios\n */\n\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface TransactionOptions {\n  maxRetries?: number;\n  retryDelayMs?: number;\n  timeoutMs?: number;\n}\n\nconst DEFAULT_OPTIONS: TransactionOptions = {\n  maxRetries: 3,\n  retryDelayMs: 1000,\n  timeoutMs: 30000,\n};\n\n/**\n * Execute operations within a database transaction\n * Automatically handles rollback on failure\n */\nexport async function withTransaction<T>(\n  operations: (client: typeof supabase) => Promise<T>,\n  options: TransactionOptions = {}\n): Promise<{ success: boolean; result?: T; error?: string }> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  \n  for (let attempt = 1; attempt <= opts.maxRetries!; attempt++) {\n    try {\n      // Start transaction\n      const { error: beginError } = await supabase.rpc('begin_transaction');\n      if (beginError) throw beginError;\n      \n      try {\n        // Execute operations\n        const result = await operations(supabase);\n        \n        // Commit transaction\n        const { error: commitError } = await supabase.rpc('commit_transaction');\n        if (commitError) throw commitError;\n        \n        return { success: true, result };\n      } catch (error) {\n        // Rollback on error\n        await supabase.rpc('rollback_transaction').catch(() => {});\n        throw error;\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      \n      // Check if retryable\n      const isRetryable = \n        message.includes('deadlock') ||\n        message.includes('lock timeout') ||\n        message.includes('connection') ||\n        message.includes('network');\n      \n      if (isRetryable && attempt < opts.maxRetries!) {\n        console.log(`[Transaction] Retry ${attempt}/${opts.maxRetries} after error: ${message}`);\n        await delay(opts.retryDelayMs! * attempt);\n        continue;\n      }\n      \n      return { success: false, error: message };\n    }\n  }\n  \n  return { success: false, error: 'Max retries exceeded' };\n}\n\n/**\n * Safe update with optimistic locking\n * Prevents lost updates in concurrent scenarios\n */\nexport async function safeUpdateWithLock<T>(\n  table: string,\n  id: string,\n  updates: Record<string, unknown>,\n  versionField: string = 'version'\n): Promise<{ success: boolean; data?: T; error?: string }> {\n  try {\n    // Get current version\n    const { data: current, error: fetchError } = await supabase\n      .from(table)\n      .select(`*, ${versionField}`)\n      .eq('id', id)\n      .single();\n    \n    if (fetchError) throw fetchError;\n    if (!current) return { success: false, error: 'Record not found' };\n    \n    const currentVersion = (current as Record<string, unknown>)[versionField] as number || 0;\n    \n    // Attempt update with version check\n    const { data, error } = await supabase\n      .from(table)\n      .update({\n        ...updates,\n        [versionField]: currentVersion + 1,\n      })\n      .eq('id', id)\n      .eq(versionField, currentVersion)\n      .select()\n      .single();\n    \n    if (error) {\n      if (error.code === 'PGRST116') {\n        return { success: false, error: 'Record was modified by another user' };\n      }\n      throw error;\n    }\n    \n    return { success: true, data: data as T };\n  } catch (error) {\n    return { \n      success: false, \n      error: error instanceof Error ? error.message : 'Update failed' \n    };\n  }\n}\n\n/**\n * Batch insert with chunking\n * Prevents oversized requests for large datasets\n */\nexport async function batchInsert<T>(\n  table: string,\n  records: T[],\n  chunkSize: number = 100\n): Promise<{ success: boolean; inserted: number; error?: string }> {\n  let inserted = 0;\n  \n  try {\n    for (let i = 0; i < records.length; i += chunkSize) {\n      const chunk = records.slice(i, i + chunkSize);\n      \n      const { error } = await supabase\n        .from(table)\n        .insert(chunk);\n      \n      if (error) throw error;\n      inserted += chunk.length;\n    }\n    \n    return { success: true, inserted };\n  } catch (error) {\n    return { \n      success: false, \n      inserted,\n      error: error instanceof Error ? error.message : 'Batch insert failed'\n    };\n  }\n}\n\n/**\n * Delay utility\n */\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute with timeout\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number\n): Promise<{ success: boolean; result?: T; error?: string }> {\n  try {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error('Operation timed out')), timeoutMs);\n    });\n    \n    const result = await Promise.race([promise, timeoutPromise]);\n    return { success: true, result };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Operation failed'\n    };\n  }\n}\n\n/**\n * Safe RPC call with retry\n */\nexport async function safeRpc<T>(\n  rpcName: string,\n  params: Record<string, unknown>,\n  maxRetries: number = 3\n): Promise<{ success: boolean; data?: T; error?: string }> {\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const { data, error } = await supabase.rpc(rpcName, params);\n      \n      if (error) throw error;\n      \n      return { success: true, data: data as T };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      \n      if (attempt < maxRetries) {\n        console.log(`[RPC ${rpcName}] Retry ${attempt}/${maxRetries}`);\n        await delay(1000 * attempt);\n        continue;\n      }\n      \n      return { success: false, error: message };\n    }\n  }\n  \n  return { success: false, error: 'Max retries exceeded' };\n}\n";export{n as default};
