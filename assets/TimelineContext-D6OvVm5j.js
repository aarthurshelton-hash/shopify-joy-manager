const e="import React, { createContext, useContext, useState, useCallback, useRef, useEffect, ReactNode } from 'react';\n\nexport type GamePhase = 'all' | 'opening' | 'middlegame' | 'endgame';\n\ninterface PhaseRange {\n  start: number;\n  end: number;\n}\n\ninterface TimelineContextValue {\n  currentMove: number;\n  maxMoves: number;\n  isPlaying: boolean;\n  playbackSpeed: number;\n  selectedPhase: GamePhase;\n  phaseRanges: Record<GamePhase, PhaseRange>;\n  setCurrentMove: (move: number) => void;\n  setMaxMoves: (max: number) => void;\n  play: () => void;\n  pause: () => void;\n  togglePlayback: () => void;\n  setPlaybackSpeed: (speed: number) => void;\n  reset: () => void;\n  stepForward: () => void;\n  stepBackward: () => void;\n  setSelectedPhase: (phase: GamePhase) => void;\n}\n\nconst TimelineContext = createContext<TimelineContextValue | undefined>(undefined);\n\n// Calculate game phase ranges based on total moves\n// Opening: first ~20% of moves (typically first 10-15 moves per side = 20-30 half-moves)\n// Middlegame: ~20% to ~70% of moves\n// Endgame: last ~30% of moves\nfunction calculatePhaseRanges(totalMoves: number): Record<GamePhase, PhaseRange> {\n  const openingEnd = Math.min(Math.floor(totalMoves * 0.2), 30); // Max 30 half-moves for opening\n  const endgameStart = Math.max(Math.floor(totalMoves * 0.7), openingEnd + 1);\n  \n  return {\n    all: { start: 0, end: totalMoves },\n    opening: { start: 0, end: openingEnd },\n    middlegame: { start: openingEnd + 1, end: endgameStart - 1 },\n    endgame: { start: endgameStart, end: totalMoves },\n  };\n}\n\ninterface TimelineProviderProps {\n  children: ReactNode;\n  initialMove?: number;\n  initialPhase?: GamePhase;\n}\n\nexport function TimelineProvider({ children, initialMove, initialPhase }: TimelineProviderProps) {\n  const [currentMove, setCurrentMoveState] = useState<number>(initialMove ?? Infinity); // Infinity means \"show all\"\n  const [maxMoves, setMaxMovesState] = useState<number>(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(500); // ms per move\n  const [selectedPhase, setSelectedPhaseState] = useState<GamePhase>(initialPhase ?? 'all');\n  const [phaseRanges, setPhaseRanges] = useState<Record<GamePhase, PhaseRange>>(\n    calculatePhaseRanges(0)\n  );\n  const animationRef = useRef<number | null>(null);\n  const lastUpdateRef = useRef<number>(0);\n\n  const setMaxMoves = useCallback((max: number) => {\n    setMaxMovesState(max);\n    setPhaseRanges(calculatePhaseRanges(max));\n  }, []);\n\n  const setCurrentMove = useCallback((move: number) => {\n    setCurrentMoveState(move);\n  }, []);\n\n  const setSelectedPhase = useCallback((phase: GamePhase) => {\n    setSelectedPhaseState(phase);\n    setIsPlaying(false);\n    // When selecting a phase, reset to show all moves in that phase\n    setCurrentMoveState(Infinity);\n  }, []);\n\n  const play = useCallback(() => {\n    setIsPlaying(true);\n    const range = phaseRanges[selectedPhase];\n    // If at end, restart from beginning of phase\n    setCurrentMoveState(prev => {\n      if (prev >= range.end || prev === Infinity) {\n        return range.start;\n      }\n      return Math.max(prev, range.start);\n    });\n  }, [phaseRanges, selectedPhase]);\n\n  const pause = useCallback(() => {\n    setIsPlaying(false);\n  }, []);\n\n  const togglePlayback = useCallback(() => {\n    setIsPlaying(prev => {\n      if (!prev) {\n        const range = phaseRanges[selectedPhase];\n        // Starting playback - reset if at end of phase\n        setCurrentMoveState(current => {\n          if (current >= range.end || current === Infinity) {\n            return range.start;\n          }\n          return Math.max(current, range.start);\n        });\n      }\n      return !prev;\n    });\n  }, [phaseRanges, selectedPhase]);\n\n  const reset = useCallback(() => {\n    setIsPlaying(false);\n    setCurrentMoveState(Infinity);\n  }, []);\n\n  const stepForward = useCallback(() => {\n    const range = phaseRanges[selectedPhase];\n    setCurrentMoveState(prev => {\n      if (prev === Infinity) return range.end;\n      return Math.min(prev + 1, range.end);\n    });\n  }, [phaseRanges, selectedPhase]);\n\n  const stepBackward = useCallback(() => {\n    const range = phaseRanges[selectedPhase];\n    setCurrentMoveState(prev => {\n      if (prev === Infinity) return range.end - 1;\n      if (prev <= range.start) return range.start;\n      return prev - 1;\n    });\n  }, [phaseRanges, selectedPhase]);\n\n  // Animation loop\n  useEffect(() => {\n    if (!isPlaying) {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = null;\n      }\n      return;\n    }\n\n    const range = phaseRanges[selectedPhase];\n\n    const animate = (timestamp: number) => {\n      if (timestamp - lastUpdateRef.current >= playbackSpeed) {\n        lastUpdateRef.current = timestamp;\n        \n        setCurrentMoveState(prev => {\n          const next = prev === Infinity ? range.start + 1 : prev + 1;\n          if (next > range.end) {\n            setIsPlaying(false);\n            return range.end;\n          }\n          return next;\n        });\n      }\n      \n      animationRef.current = requestAnimationFrame(animate);\n    };\n\n    lastUpdateRef.current = performance.now();\n    animationRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [isPlaying, playbackSpeed, phaseRanges, selectedPhase]);\n\n  return (\n    <TimelineContext.Provider value={{\n      currentMove,\n      maxMoves,\n      isPlaying,\n      playbackSpeed,\n      selectedPhase,\n      phaseRanges,\n      setCurrentMove,\n      setMaxMoves,\n      play,\n      pause,\n      togglePlayback,\n      setPlaybackSpeed,\n      reset,\n      stepForward,\n      stepBackward,\n      setSelectedPhase,\n    }}>\n      {children}\n    </TimelineContext.Provider>\n  );\n}\n\nexport function useTimeline() {\n  const context = useContext(TimelineContext);\n  if (context === undefined) {\n    throw new Error('useTimeline must be used within a TimelineProvider');\n  }\n  return context;\n}\n\n// Helper hook to get filtered board based on timeline and phase\nexport function useTimelineBoard(fullBoard: any[][] | undefined, totalMoves: number) {\n  const { currentMove, setMaxMoves, selectedPhase, phaseRanges } = useTimeline();\n  \n  // Update max moves when total changes\n  useEffect(() => {\n    setMaxMoves(totalMoves);\n  }, [totalMoves, setMaxMoves]);\n\n  // If no board, return undefined\n  if (!fullBoard) {\n    return fullBoard;\n  }\n\n  const range = phaseRanges[selectedPhase];\n  \n  // Filter visits based on phase and current move\n  return fullBoard.map(rank => \n    rank.map(square => ({\n      ...square,\n      visits: square.visits.filter((visit: any) => {\n        const moveNum = visit.moveNumber;\n        // Always filter by phase range\n        if (moveNum < range.start || moveNum > range.end) {\n          return false;\n        }\n        // If showing all moves in phase, include all in range\n        if (currentMove === Infinity) {\n          return true;\n        }\n        // Otherwise filter by current move\n        return moveNum <= currentMove;\n      })\n    }))\n  );\n}\n";export{e as default};
