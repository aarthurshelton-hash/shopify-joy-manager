const e="/**\n * En Pensent Code - Signature Extraction\n * \n * Extract Code Flow Signatures from commit histories\n */\n\nimport {\n  CodeCommit,\n  CodeFileChange,\n  CodeFlowSignature,\n  CodeQuadrantProfile,\n  CodeTemporalFlow,\n  CodeMetrics,\n  CodeArchetype,\n  FileCategory,\n  CommitType,\n  COMMIT_TYPE_KEYWORDS,\n  FILE_CATEGORY_MAP,\n  CODE_ARCHETYPE_DEFINITIONS\n} from './types';\nimport {\n  generateFingerprint,\n  calculateTemporalFlow,\n  detectCriticalMoments,\n  determineDominantForce,\n  determineFlowDirection\n} from '../pensent-core/signatureExtractor';\nimport { CriticalMoment } from '../pensent-core/types';\n\n/**\n * Extract a Code Flow Signature from a sequence of commits\n */\nexport function extractCodeFlowSignature(commits: CodeCommit[]): CodeFlowSignature {\n  if (commits.length === 0) {\n    return createEmptyCodeSignature();\n  }\n  \n  // Sort commits by timestamp\n  const sortedCommits = [...commits].sort((a, b) => \n    a.timestamp.getTime() - b.timestamp.getTime()\n  );\n  \n  // Calculate metrics\n  const codeMetrics = calculateCodeMetrics(sortedCommits);\n  \n  // Calculate quadrant profile (activity by code region)\n  const quadrantProfile = calculateCodeQuadrantProfile(sortedCommits);\n  \n  // Calculate temporal flow\n  const temporalFlow = calculateCodeTemporalFlow(sortedCommits, codeMetrics);\n  \n  // Detect critical moments\n  const criticalMoments = detectCodeCriticalMoments(sortedCommits);\n  \n  // Classify archetype\n  const archetype = classifyCodeArchetype(quadrantProfile, temporalFlow, codeMetrics);\n  \n  // Calculate intensity\n  const intensity = calculateCodeIntensity(codeMetrics, temporalFlow);\n  \n  // Determine dominant force (frontend vs backend focus)\n  const dominantForce = determineDominantForce(\n    quadrantProfile.q1 + (quadrantProfile.custom?.frontend ?? 0),\n    quadrantProfile.q2 + (quadrantProfile.custom?.backend ?? 0),\n    0.1\n  );\n  \n  // Determine flow direction\n  const flowDirection = determineFlowDirection(quadrantProfile);\n  \n  // Generate fingerprint\n  const fingerprint = generateFingerprint(\n    quadrantProfile,\n    temporalFlow,\n    archetype,\n    intensity\n  );\n  \n  // Date range\n  const dateRange = {\n    start: sortedCommits[0].timestamp,\n    end: sortedCommits[sortedCommits.length - 1].timestamp\n  };\n  \n  // Unique authors\n  const uniqueAuthors = new Set(sortedCommits.map(c => c.author)).size;\n  \n  return {\n    fingerprint,\n    archetype,\n    dominantForce,\n    flowDirection,\n    intensity,\n    quadrantProfile,\n    temporalFlow,\n    criticalMoments,\n    codeMetrics,\n    domainData: {\n      domain: 'code',\n      totalCommits: sortedCommits.length,\n      totalAuthors: uniqueAuthors,\n      dateRange\n    }\n  };\n}\n\n/**\n * Create an empty code signature\n */\nfunction createEmptyCodeSignature(): CodeFlowSignature {\n  return {\n    fingerprint: 'EP-00000000',\n    archetype: 'stability_plateau',\n    dominantForce: 'balanced',\n    flowDirection: 'chaotic',\n    intensity: 0,\n    quadrantProfile: {\n      q1: 0.25, q2: 0.25, q3: 0.25, q4: 0.25,\n      custom: { frontend: 0, backend: 0, tests: 0, config: 0, docs: 0, types: 0, utils: 0 }\n    },\n    temporalFlow: {\n      opening: 0, middle: 0, ending: 0,\n      trend: 'stable', momentum: 0,\n      velocityTrend: 'stable',\n      bugToFeatureRatio: 0,\n      refactorRatio: 0,\n      testCoverageTrend: 'stable'\n    },\n    criticalMoments: [],\n    codeMetrics: {\n      avgCommitSize: 0,\n      commitFrequency: 0,\n      churnRate: 0,\n      contributorCount: 0,\n      fileConcentration: 0,\n      bugIndicatorCount: 0,\n      refactorIndicatorCount: 0,\n      featureIndicatorCount: 0\n    },\n    domainData: {\n      domain: 'code',\n      totalCommits: 0,\n      totalAuthors: 0,\n      dateRange: { start: new Date(), end: new Date() }\n    }\n  };\n}\n\n/**\n * Calculate code metrics from commits\n */\nfunction calculateCodeMetrics(commits: CodeCommit[]): CodeMetrics {\n  if (commits.length === 0) {\n    return {\n      avgCommitSize: 0,\n      commitFrequency: 0,\n      churnRate: 0,\n      contributorCount: 0,\n      fileConcentration: 0,\n      bugIndicatorCount: 0,\n      refactorIndicatorCount: 0,\n      featureIndicatorCount: 0\n    };\n  }\n  \n  // Calculate average commit size\n  const totalLines = commits.reduce((sum, c) => sum + c.additions + c.deletions, 0);\n  const avgCommitSize = totalLines / commits.length;\n  \n  // Calculate commit frequency (commits per day)\n  const firstCommit = commits[0].timestamp.getTime();\n  const lastCommit = commits[commits.length - 1].timestamp.getTime();\n  const daySpan = Math.max(1, (lastCommit - firstCommit) / (1000 * 60 * 60 * 24));\n  const commitFrequency = commits.length / daySpan;\n  \n  // Calculate churn rate\n  const totalAdditions = commits.reduce((sum, c) => sum + c.additions, 0);\n  const totalDeletions = commits.reduce((sum, c) => sum + c.deletions, 0);\n  const churnRate = totalLines > 0 ? totalDeletions / totalLines : 0;\n  \n  // Count unique contributors\n  const contributorCount = new Set(commits.map(c => c.author)).size;\n  \n  // Calculate file concentration\n  const fileChangeCounts: Record<string, number> = {};\n  for (const commit of commits) {\n    for (const file of commit.filesChanged) {\n      fileChangeCounts[file.path] = (fileChangeCounts[file.path] ?? 0) + 1;\n    }\n  }\n  const totalFileChanges = Object.values(fileChangeCounts).reduce((a, b) => a + b, 0);\n  const topFileChanges = Object.values(fileChangeCounts).sort((a, b) => b - a).slice(0, 10);\n  const topFileSum = topFileChanges.reduce((a, b) => a + b, 0);\n  const fileConcentration = totalFileChanges > 0 ? topFileSum / totalFileChanges : 0;\n  \n  // Count commit type indicators\n  let bugIndicatorCount = 0;\n  let refactorIndicatorCount = 0;\n  let featureIndicatorCount = 0;\n  \n  for (const commit of commits) {\n    const messageLower = commit.message.toLowerCase();\n    \n    if (COMMIT_TYPE_KEYWORDS.bugfix.some(kw => messageLower.includes(kw))) {\n      bugIndicatorCount++;\n    }\n    if (COMMIT_TYPE_KEYWORDS.refactor.some(kw => messageLower.includes(kw))) {\n      refactorIndicatorCount++;\n    }\n    if (COMMIT_TYPE_KEYWORDS.feature.some(kw => messageLower.includes(kw))) {\n      featureIndicatorCount++;\n    }\n  }\n  \n  return {\n    avgCommitSize,\n    commitFrequency,\n    churnRate,\n    contributorCount,\n    fileConcentration,\n    bugIndicatorCount,\n    refactorIndicatorCount,\n    featureIndicatorCount\n  };\n}\n\n/**\n * Calculate code quadrant profile from commits\n */\nfunction calculateCodeQuadrantProfile(commits: CodeCommit[]): CodeQuadrantProfile {\n  const categoryWeights: Record<FileCategory, number> = {\n    frontend: 0,\n    backend: 0,\n    tests: 0,\n    config: 0,\n    docs: 0,\n    types: 0,\n    utils: 0,\n    assets: 0,\n    unknown: 0\n  };\n  \n  let totalWeight = 0;\n  \n  for (const commit of commits) {\n    for (const file of commit.filesChanged) {\n      const category = categorizeFile(file.path);\n      const weight = file.additions + file.deletions;\n      categoryWeights[category] += weight;\n      totalWeight += weight;\n    }\n  }\n  \n  if (totalWeight === 0) {\n    totalWeight = 1; // Prevent division by zero\n  }\n  \n  // Normalize weights\n  for (const category of Object.keys(categoryWeights) as FileCategory[]) {\n    categoryWeights[category] /= totalWeight;\n  }\n  \n  // Map to quadrants\n  // Q1 = Frontend (UI focus)\n  // Q2 = Backend (Server focus)\n  // Q3 = Tests (Quality focus)\n  // Q4 = Config + Docs (Infrastructure focus)\n  \n  return {\n    q1: categoryWeights.frontend + categoryWeights.assets * 0.5,\n    q2: categoryWeights.backend + categoryWeights.types * 0.5,\n    q3: categoryWeights.tests,\n    q4: categoryWeights.config + categoryWeights.docs,\n    center: categoryWeights.utils + categoryWeights.types * 0.5 + categoryWeights.assets * 0.5,\n    custom: {\n      frontend: categoryWeights.frontend,\n      backend: categoryWeights.backend,\n      tests: categoryWeights.tests,\n      config: categoryWeights.config,\n      docs: categoryWeights.docs,\n      types: categoryWeights.types,\n      utils: categoryWeights.utils\n    }\n  };\n}\n\n/**\n * Categorize a file by its path and extension\n */\nfunction categorizeFile(path: string): FileCategory {\n  const pathLower = path.toLowerCase();\n  \n  // Check for test files first (can be .ts, .tsx, etc.)\n  if (pathLower.includes('.test.') || pathLower.includes('.spec.') || \n      pathLower.includes('__tests__') || pathLower.includes('/test/') ||\n      pathLower.includes('.cy.')) {\n    return 'tests';\n  }\n  \n  // Check for docs\n  if (pathLower.includes('/docs/') || pathLower.includes('readme') ||\n      pathLower.endsWith('.md') || pathLower.endsWith('.mdx')) {\n    return 'docs';\n  }\n  \n  // Check for config\n  if (pathLower.includes('config') || pathLower.includes('.env') ||\n      pathLower.endsWith('.json') || pathLower.endsWith('.yaml') ||\n      pathLower.endsWith('.yml') || pathLower.endsWith('.toml') ||\n      pathLower.includes('dockerfile') || pathLower.includes('docker-compose')) {\n    return 'config';\n  }\n  \n  // Check for frontend paths\n  if (pathLower.includes('/components/') || pathLower.includes('/pages/') ||\n      pathLower.includes('/views/') || pathLower.includes('/ui/') ||\n      pathLower.includes('/styles/') || pathLower.includes('/css/') ||\n      pathLower.endsWith('.css') || pathLower.endsWith('.scss') ||\n      pathLower.endsWith('.tsx') || pathLower.endsWith('.jsx') ||\n      pathLower.endsWith('.vue') || pathLower.endsWith('.svelte')) {\n    return 'frontend';\n  }\n  \n  // Check for backend paths\n  if (pathLower.includes('/api/') || pathLower.includes('/server/') ||\n      pathLower.includes('/backend/') || pathLower.includes('/functions/') ||\n      pathLower.includes('/routes/') || pathLower.includes('/controllers/') ||\n      pathLower.includes('/models/') || pathLower.includes('/services/') ||\n      pathLower.endsWith('.sql') || pathLower.endsWith('.py') ||\n      pathLower.endsWith('.go') || pathLower.endsWith('.rs') ||\n      pathLower.endsWith('.java') || pathLower.endsWith('.rb')) {\n    return 'backend';\n  }\n  \n  // Check for types\n  if (pathLower.includes('/types/') || pathLower.endsWith('.d.ts') ||\n      pathLower.includes('/interfaces/')) {\n    return 'types';\n  }\n  \n  // Check for utils\n  if (pathLower.includes('/utils/') || pathLower.includes('/helpers/') ||\n      pathLower.includes('/lib/') || pathLower.includes('/shared/')) {\n    return 'utils';\n  }\n  \n  // Check for assets\n  if (pathLower.includes('/assets/') || pathLower.includes('/images/') ||\n      pathLower.includes('/public/') || pathLower.includes('/static/') ||\n      pathLower.match(/\\.(png|jpg|jpeg|gif|svg|ico|webp|mp4|mp3|wav)$/)) {\n    return 'assets';\n  }\n  \n  // Default based on extension\n  const ext = '.' + pathLower.split('.').pop();\n  return FILE_CATEGORY_MAP[ext] ?? 'unknown';\n}\n\n/**\n * Calculate code temporal flow\n */\nfunction calculateCodeTemporalFlow(\n  commits: CodeCommit[],\n  metrics: CodeMetrics\n): CodeTemporalFlow {\n  // Calculate activity levels per commit\n  const activityLevels = commits.map(c => \n    Math.min(1, (c.additions + c.deletions) / 500) // Normalize to 0-1\n  );\n  \n  // Use core temporal flow calculation\n  const baseFlow = calculateTemporalFlow(activityLevels);\n  \n  // Calculate velocity trend\n  const halfIndex = Math.floor(commits.length / 2);\n  const firstHalf = commits.slice(0, halfIndex);\n  const secondHalf = commits.slice(halfIndex);\n  \n  const firstHalfAvg = firstHalf.length > 0 \n    ? firstHalf.reduce((sum, c) => sum + c.additions + c.deletions, 0) / firstHalf.length \n    : 0;\n  const secondHalfAvg = secondHalf.length > 0 \n    ? secondHalf.reduce((sum, c) => sum + c.additions + c.deletions, 0) / secondHalf.length \n    : 0;\n  \n  let velocityTrend: 'accelerating' | 'stable' | 'declining';\n  if (secondHalfAvg > firstHalfAvg * 1.2) {\n    velocityTrend = 'accelerating';\n  } else if (secondHalfAvg < firstHalfAvg * 0.8) {\n    velocityTrend = 'declining';\n  } else {\n    velocityTrend = 'stable';\n  }\n  \n  // Calculate bug to feature ratio\n  const bugToFeatureRatio = metrics.featureIndicatorCount > 0 \n    ? metrics.bugIndicatorCount / metrics.featureIndicatorCount \n    : metrics.bugIndicatorCount;\n  \n  // Calculate refactor ratio\n  const totalIndicators = metrics.bugIndicatorCount + metrics.refactorIndicatorCount + metrics.featureIndicatorCount;\n  const refactorRatio = totalIndicators > 0 \n    ? metrics.refactorIndicatorCount / totalIndicators \n    : 0;\n  \n  // Determine test coverage trend (based on test file activity)\n  const testCommitCount = commits.filter(c => \n    c.filesChanged.some(f => categorizeFile(f.path) === 'tests')\n  ).length;\n  const testRatio = commits.length > 0 ? testCommitCount / commits.length : 0;\n  \n  let testCoverageTrend: 'improving' | 'stable' | 'declining';\n  if (testRatio > 0.3) {\n    testCoverageTrend = 'improving';\n  } else if (testRatio < 0.1) {\n    testCoverageTrend = 'declining';\n  } else {\n    testCoverageTrend = 'stable';\n  }\n  \n  return {\n    ...baseFlow,\n    velocityTrend,\n    bugToFeatureRatio,\n    refactorRatio,\n    testCoverageTrend\n  };\n}\n\n/**\n * Detect critical moments in code evolution\n */\nfunction detectCodeCriticalMoments(commits: CodeCommit[]): CriticalMoment[] {\n  const moments: CriticalMoment[] = [];\n  \n  if (commits.length < 3) return moments;\n  \n  // Calculate change magnitudes\n  const magnitudes = commits.map(c => c.additions + c.deletions);\n  const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;\n  \n  for (let i = 0; i < commits.length; i++) {\n    const commit = commits[i];\n    const magnitude = magnitudes[i];\n    \n    // Large commits (> 3x average)\n    if (magnitude > avgMagnitude * 3) {\n      moments.push({\n        index: i,\n        type: 'major_change',\n        severity: Math.min(1, magnitude / (avgMagnitude * 5)),\n        description: `Major change: ${commit.message.substring(0, 50)}...`,\n        metadata: { commitId: commit.id, filesChanged: commit.filesChanged.length }\n      });\n    }\n    \n    // Hotfix/emergency commits\n    const messageLower = commit.message.toLowerCase();\n    if (messageLower.includes('hotfix') || messageLower.includes('emergency') || \n        messageLower.includes('critical') || messageLower.includes('urgent')) {\n      moments.push({\n        index: i,\n        type: 'emergency',\n        severity: 0.9,\n        description: `Emergency: ${commit.message.substring(0, 50)}...`,\n        metadata: { commitId: commit.id }\n      });\n    }\n    \n    // Revert commits\n    if (messageLower.includes('revert')) {\n      moments.push({\n        index: i,\n        type: 'revert',\n        severity: 0.7,\n        description: `Revert: ${commit.message.substring(0, 50)}...`,\n        metadata: { commitId: commit.id }\n      });\n    }\n    \n    // Breaking changes\n    if (messageLower.includes('breaking') || messageLower.includes('migration required')) {\n      moments.push({\n        index: i,\n        type: 'breaking_change',\n        severity: 0.85,\n        description: `Breaking change: ${commit.message.substring(0, 50)}...`,\n        metadata: { commitId: commit.id }\n      });\n    }\n  }\n  \n  // Sort by index and limit\n  moments.sort((a, b) => a.index - b.index);\n  return moments.slice(0, 10);\n}\n\n/**\n * Classify code archetype from signature components\n */\nfunction classifyCodeArchetype(\n  quadrantProfile: CodeQuadrantProfile,\n  temporalFlow: CodeTemporalFlow,\n  metrics: CodeMetrics\n): CodeArchetype {\n  // Score each archetype\n  const scores: Record<CodeArchetype, number> = {\n    rapid_growth: 0,\n    refactor_cycle: 0,\n    tech_debt_spiral: 0,\n    stability_plateau: 0,\n    feature_burst: 0,\n    death_march: 0,\n    test_driven: 0,\n    documentation_push: 0,\n    infrastructure_shift: 0,\n    bug_hunting: 0,\n    greenfield: 0,\n    legacy_rescue: 0\n  };\n  \n  // Rapid growth indicators\n  if (temporalFlow.velocityTrend === 'accelerating') scores.rapid_growth += 2;\n  if (metrics.featureIndicatorCount > metrics.bugIndicatorCount * 2) scores.rapid_growth += 2;\n  if (metrics.avgCommitSize > 100) scores.rapid_growth += 1;\n  \n  // Refactor cycle indicators\n  const refactorRatio = metrics.refactorIndicatorCount / Math.max(1, metrics.bugIndicatorCount + metrics.refactorIndicatorCount + metrics.featureIndicatorCount);\n  if (refactorRatio > 0.3) scores.refactor_cycle += 3;\n  if (metrics.churnRate > 0.4) scores.refactor_cycle += 1;\n  \n  // Tech debt spiral indicators\n  if (temporalFlow.bugToFeatureRatio > 1) scores.tech_debt_spiral += 2;\n  if (temporalFlow.testCoverageTrend === 'declining') scores.tech_debt_spiral += 2;\n  if (metrics.churnRate > 0.6) scores.tech_debt_spiral += 1;\n  \n  // Stability plateau indicators\n  if (temporalFlow.trend === 'stable' && metrics.avgCommitSize < 50) scores.stability_plateau += 3;\n  if (temporalFlow.velocityTrend === 'stable') scores.stability_plateau += 1;\n  \n  // Feature burst indicators\n  if (metrics.featureIndicatorCount > metrics.refactorIndicatorCount * 2) scores.feature_burst += 2;\n  if (temporalFlow.momentum > 0.5) scores.feature_burst += 1;\n  \n  // Death march indicators\n  if (temporalFlow.velocityTrend === 'accelerating' && temporalFlow.bugToFeatureRatio > 0.5) scores.death_march += 2;\n  if (metrics.commitFrequency > 10) scores.death_march += 1; // Very high commit frequency\n  \n  // Test driven indicators\n  if (quadrantProfile.q3 > 0.25) scores.test_driven += 3;\n  if (temporalFlow.testCoverageTrend === 'improving') scores.test_driven += 2;\n  \n  // Documentation push indicators\n  if ((quadrantProfile.custom?.docs ?? 0) > 0.15) scores.documentation_push += 3;\n  \n  // Infrastructure shift indicators\n  if (quadrantProfile.q4 > 0.3) scores.infrastructure_shift += 3;\n  \n  // Bug hunting indicators\n  if (temporalFlow.bugToFeatureRatio > 2) scores.bug_hunting += 3;\n  if (metrics.bugIndicatorCount > metrics.featureIndicatorCount) scores.bug_hunting += 1;\n  \n  // Greenfield indicators\n  if (metrics.churnRate < 0.1) scores.greenfield += 2;\n  if (quadrantProfile.custom?.config ?? 0 > 0.2) scores.greenfield += 1;\n  \n  // Legacy rescue indicators\n  if (metrics.churnRate > 0.5 && refactorRatio > 0.2) scores.legacy_rescue += 2;\n  \n  // Find highest scoring archetype\n  let maxScore = 0;\n  let bestArchetype: CodeArchetype = 'stability_plateau';\n  \n  for (const [archetype, score] of Object.entries(scores) as [CodeArchetype, number][]) {\n    if (score > maxScore) {\n      maxScore = score;\n      bestArchetype = archetype;\n    }\n  }\n  \n  return bestArchetype;\n}\n\n/**\n * Calculate code intensity\n */\nfunction calculateCodeIntensity(\n  metrics: CodeMetrics,\n  temporalFlow: CodeTemporalFlow\n): number {\n  // Factors contributing to intensity\n  const commitSizeIntensity = Math.min(1, metrics.avgCommitSize / 200);\n  const frequencyIntensity = Math.min(1, metrics.commitFrequency / 5);\n  const churnIntensity = metrics.churnRate;\n  const momentumIntensity = (temporalFlow.momentum + 1) / 2; // Normalize from -1..1 to 0..1\n  \n  // Weighted average\n  return (\n    commitSizeIntensity * 0.25 +\n    frequencyIntensity * 0.25 +\n    churnIntensity * 0.25 +\n    momentumIntensity * 0.25\n  );\n}\n\n/**\n * Classify commit type from message\n */\nexport function classifyCommitType(message: string): CommitType {\n  const messageLower = message.toLowerCase();\n  \n  for (const [type, keywords] of Object.entries(COMMIT_TYPE_KEYWORDS) as [CommitType, string[]][]) {\n    if (keywords.some(kw => messageLower.includes(kw))) {\n      return type;\n    }\n  }\n  \n  return 'unknown';\n}\n";export{e as default};
