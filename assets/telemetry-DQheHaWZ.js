const e="/**\n * Unified Telemetry Hub\n * \n * Central aggregation point for all real-time data across:\n * - Code analysis events\n * - Universal adapter signals\n * - Evolution system broadcasts\n * - Live codebase metrics\n * - Market/chess cross-domain events\n * \n * Provides reactive streams for frontend visualizations\n */\n\nimport { subscribeToEvolution, type EvolutionEvent } from '@/hooks/useUnifiedEvolution';\nimport { subscribeToAdapterEvolution } from '@/lib/pensent-core/domains/universal/adapters';\nimport { codebaseSyncManager } from '@/hooks/useCodebaseSync';\nimport { supabase } from '@/integrations/supabase/client';\n\n// Telemetry event types\ntype TelemetryEvent =\n  | { type: 'code_analysis'; data: CodeTelemetryData }\n  | { type: 'adapter_signal'; data: AdapterTelemetryData }\n  | { type: 'evolution_event'; data: EvolutionTelemetryData }\n  | { type: 'codebase_sync'; data: CodebaseTelemetryData }\n  | { type: 'cross_domain_resonance'; data: ResonanceTelemetryData }\n  | { type: 'issue_detected'; data: IssueTelemetryData }\n  | { type: 'heal_applied'; data: HealTelemetryData };\n\ninterface CodeTelemetryData {\n  archetype: string;\n  health: number;\n  patternDensity: number;\n  fileCount: number;\n  linesOfCode: number;\n  issuesDetected: number;\n  timestamp: number;\n}\n\ninterface AdapterTelemetryData {\n  adapterName: string;\n  domain: string;\n  signalCount: number;\n  learningRate: number;\n  resonanceScore: number;\n  isActive: boolean;\n  timestamp: number;\n}\n\ninterface EvolutionTelemetryData {\n  eventType: string;\n  source: string;\n  data: Record<string, unknown>;\n  timestamp: number;\n}\n\ninterface CodebaseTelemetryData {\n  version: number;\n  fileCount: number;\n  totalLines: number;\n  checksum: string;\n  syncStatus: 'synced' | 'stale' | 'syncing';\n  timestamp: number;\n}\n\ninterface ResonanceTelemetryData {\n  adapter1: string;\n  adapter2: string;\n  resonanceScore: number;\n  sharedPatterns: string[];\n  timestamp: number;\n}\n\ninterface IssueTelemetryData {\n  id: string;\n  type: string;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  file: string;\n  title: string;\n  timestamp: number;\n}\n\ninterface HealTelemetryData {\n  issueId: string;\n  file: string;\n  action: string;\n  success: boolean;\n  timestamp: number;\n}\n\n// Telemetry state container\ninterface UnifiedTelemetryState {\n  code: CodeTelemetryData | null;\n  adapters: Map<string, AdapterTelemetryData>;\n  resonances: ResonanceTelemetryData[];\n  issues: IssueTelemetryData[];\n  heals: HealTelemetryData[];\n  evolution: EvolutionTelemetryData[];\n  codebase: CodebaseTelemetryData | null;\n  lastUpdate: number;\n}\n\nconst telemetryState: UnifiedTelemetryState = {\n  code: null,\n  adapters: new Map(),\n  resonances: [],\n  issues: [],\n  heals: [],\n  evolution: [],\n  codebase: null,\n  lastUpdate: Date.now()\n};\n\n// Event listeners\ntype TelemetryListener = (state: UnifiedTelemetryState) => void;\nconst listeners = new Set<TelemetryListener>();\n\n// Subscribe to telemetry updates\nexport function subscribeToTelemetry(listener: TelemetryListener): () => void {\n  listeners.add(listener);\n  // Immediately emit current state\n  listener({ ...telemetryState, adapters: new Map(telemetryState.adapters) });\n  return () => listeners.delete(listener);\n}\n\n// Emit state update to all listeners\nfunction emitTelemetryUpdate() {\n  const state = { ...telemetryState, adapters: new Map(telemetryState.adapters) };\n  listeners.forEach(listener => listener(state));\n}\n\n// Record telemetry event\nfunction recordEvent(event: TelemetryEvent) {\n  telemetryState.lastUpdate = Date.now();\n\n  switch (event.type) {\n    case 'code_analysis':\n      telemetryState.code = event.data;\n      break;\n    case 'adapter_signal':\n      telemetryState.adapters.set(event.data.adapterName, event.data);\n      break;\n    case 'cross_domain_resonance':\n      // Keep only last 20 resonances\n      telemetryState.resonances = [event.data, ...telemetryState.resonances].slice(0, 20);\n      break;\n    case 'issue_detected':\n      telemetryState.issues = [event.data, ...telemetryState.issues].slice(0, 50);\n      break;\n    case 'heal_applied':\n      telemetryState.heals = [event.data, ...telemetryState.heals].slice(0, 20);\n      break;\n    case 'evolution_event':\n      telemetryState.evolution = [event.data, ...telemetryState.evolution].slice(0, 100);\n      break;\n    case 'codebase_sync':\n      telemetryState.codebase = event.data;\n      break;\n  }\n\n  emitTelemetryUpdate();\n\n  // Persist to Supabase for historical analysis\n  persistTelemetryEvent(event).catch(console.error);\n}\n\n// Persist telemetry to database\nasync function persistTelemetryEvent(event: TelemetryEvent) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    await supabase.from('telemetry_events' as any).insert({\n      event_type: event.type,\n      event_data: event.data,\n      timestamp: new Date().toISOString()\n    });\n  } catch (err) {\n    // Silent fail - telemetry shouldn't break the app\n    console.warn('[Telemetry] Failed to persist:', err);\n  }\n}\n\n// Initialize all data stream connections\nexport function initializeTelemetryHub(): () => void {\n  const unsubscribers: Array<() => void> = [];\n\n  // 1. Subscribe to evolution events\n  unsubscribers.push(\n    subscribeToEvolution((event: EvolutionEvent) => {\n      recordEvent({\n        type: 'evolution_event',\n        data: {\n          eventType: event.type,\n          source: event.source,\n          data: event.data,\n          timestamp: Date.now()\n        }\n      });\n\n      // Also record as codebase event if code-related\n      if (event.source === 'code') {\n        recordEvent({\n          type: 'code_analysis',\n          data: {\n            archetype: (event.data.archetype as string) || 'unknown',\n            health: (event.data.health as number) || 0,\n            patternDensity: (event.data.patternDensity as number) || 0,\n            fileCount: (event.data.fileCount as number) || 0,\n            linesOfCode: (event.data.linesOfCode as number) || 0,\n            issuesDetected: (event.data.issuesDetected as number) || 0,\n            timestamp: Date.now()\n          }\n        });\n      }\n    })\n  );\n\n  // 2. Subscribe to adapter evolution\n  unsubscribers.push(\n    subscribeToAdapterEvolution((event) => {\n      recordEvent({\n        type: 'evolution_event',\n        data: {\n          eventType: event.type,\n          source: 'adapter',\n          data: event,\n          timestamp: Date.now()\n        }\n      });\n\n      if (event.type === 'resonance_detected' && event.resonance) {\n        recordEvent({\n          type: 'cross_domain_resonance',\n          data: {\n            adapter1: event.resonance.adapter1,\n            adapter2: event.resonance.adapter2,\n            resonanceScore: event.resonance.score,\n            sharedPatterns: [],\n            timestamp: Date.now()\n          }\n        });\n      }\n    })\n  );\n\n  // 3. Set up codebase sync monitoring\n  const syncInterval = setInterval(() => {\n    const version = codebaseSyncManager.getVersion();\n    recordEvent({\n      type: 'codebase_sync',\n      data: {\n        version,\n        fileCount: 0, // Would need actual file count\n        totalLines: 0,\n        checksum: '',\n        syncStatus: 'synced',\n        timestamp: Date.now()\n      }\n    });\n  }, 30000); // Every 30 seconds\n\n  unsubscribers.push(() => clearInterval(syncInterval));\n\n  console.log('[TelemetryHub] All data streams connected');\n\n  // Return cleanup function\n  return () => {\n    unsubscribers.forEach(unsub => unsub());\n    clearInterval(syncInterval);\n    console.log('[TelemetryHub] All data streams disconnected');\n  };\n}\n\n// Manual event recording (for components to use)\nexport function recordCodeAnalysis(data: CodeTelemetryData) {\n  recordEvent({ type: 'code_analysis', data });\n}\n\nexport function recordAdapterSignal(data: AdapterTelemetryData) {\n  recordEvent({ type: 'adapter_signal', data });\n}\n\nexport function recordIssueDetected(data: IssueTelemetryData) {\n  recordEvent({ type: 'issue_detected', data });\n}\n\nexport function recordHealApplied(data: HealTelemetryData) {\n  recordEvent({ type: 'heal_applied', data });\n}\n\n// Get current telemetry state (for non-reactive access)\nexport function getTelemetryState(): Readonly<UnifiedTelemetryState> {\n  return {\n    ...telemetryState,\n    adapters: new Map(telemetryState.adapters)\n  };\n}\n\n// Export types\nexport type {\n  TelemetryEvent,\n  UnifiedTelemetryState,\n  CodeTelemetryData,\n  AdapterTelemetryData,\n  ResonanceTelemetryData,\n  IssueTelemetryData,\n  HealTelemetryData\n};\n";export{e as default};
