const n="/**\n * Universal Adapter Monitor Hook\n * \n * Consumes adapter registry state from global state and provides\n * reactive access to all 55 domain adapters' metrics.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  universalAdapterRegistry, \n  subscribeToAdapterEvolution,\n  AdapterRegistry, \n  CrossDomainResonance,\n  type UnifiedMarketData\n} from '@/lib/pensent-core/domains/universal/adapters';\n\nexport interface AdapterMetrics {\n  name: string;\n  domain: string;\n  isActive: boolean;\n  signalCount: number;\n  learningRate: number;\n  lastUpdate: number;\n  healthScore: number;\n}\n\nexport interface ResonanceMetrics {\n  adapter1: string;\n  adapter2: string;\n  resonanceScore: number;\n  sharedPatterns: string[];\n  lastSynced: number;\n}\n\nexport interface UniversalMonitorState {\n  adapters: AdapterMetrics[];\n  resonances: ResonanceMetrics[];\n  evolutionCycle: number;\n  totalSignals: number;\n  activeCount: number;\n  lastUpdate: number;\n}\n\nexport interface DomainSummary {\n  domain: string;\n  adapterCount: number;\n  totalSignals: number;\n  avgLearningRate: number;\n  healthScore: number;\n}\n\n// Domain color mapping for visualization\nexport const DOMAIN_COLORS: Record<string, string> = {\n  temporal: '#8b5cf6',      // violet\n  soul: '#ec4899',          // pink\n  bio: '#22c55e',           // green\n  quantum: '#06b6d4',       // cyan\n  photonic: '#f59e0b',      // amber\n  market: '#10b981',        // emerald\n  network: '#6366f1',       // indigo\n  security: '#ef4444',      // red\n  chess: '#f97316',       // orange\n  code: '#3b82f6',        // blue\n  climate: '#14b8a6',       // teal\n  light: '#eab308',       // yellow\n  audio: '#a855f7',       // purple\n  realization: '#f43f5e',   // rose\n  atomic: '#0ea5e9',      // sky\n  biologyDeep: '#84cc16',   // lime\n  default: '#6b7280'        // gray\n};\n\nexport function useUniversalAdapterMonitor(pollInterval: number = 5000) {\n  const [state, setState] = useState<UniversalMonitorState>({\n    adapters: [],\n    resonances: [],\n    evolutionCycle: 0,\n    totalSignals: 0,\n    activeCount: 0,\n    lastUpdate: Date.now()\n  });\n\n  const [domainSummaries, setDomainSummaries] = useState<DomainSummary[]>([]);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Extract state from global registry\n  const refreshState = useCallback(() => {\n    const globalObj = globalThis as Record<string, unknown>;\n    const adapterState = globalObj.EN_PENSENT_ADAPTER_STATE as {\n      cycle: number;\n      timestamp: number;\n      adapters: Array<{\n        name: string;\n        domain: string;\n        isActive: boolean;\n        signalCount: number;\n        learningRate: number;\n      }>;\n      resonances: Array<{\n        adapter1: string;\n        adapter2: string;\n        resonanceScore: number;\n        sharedPatterns: string[];\n        lastSynced: number;\n      }>;\n    } | undefined;\n\n    if (adapterState) {\n      const adapters: AdapterMetrics[] = adapterState.adapters.map(a => ({\n        ...a,\n        lastUpdate: adapterState.timestamp,\n        healthScore: calculateHealthScore(a)\n      }));\n\n      const totalSignals = adapters.reduce((sum, a) => sum + a.signalCount, 0);\n      const activeCount = adapters.filter(a => a.isActive).length;\n\n      setState({\n        adapters,\n        resonances: adapterState.resonances,\n        evolutionCycle: adapterState.cycle,\n        totalSignals,\n        activeCount,\n        lastUpdate: adapterState.timestamp\n      });\n\n      // Calculate domain summaries\n      const domainMap = new Map<string, DomainSummary>();\n      adapters.forEach(adapter => {\n        const existing = domainMap.get(adapter.domain);\n        if (existing) {\n          existing.adapterCount++;\n          existing.totalSignals += adapter.signalCount;\n          existing.avgLearningRate = (existing.avgLearningRate * (existing.adapterCount - 1) + adapter.learningRate) / existing.adapterCount;\n          existing.healthScore = (existing.healthScore * (existing.adapterCount - 1) + adapter.healthScore) / existing.adapterCount;\n        } else {\n          domainMap.set(adapter.domain, {\n            domain: adapter.domain,\n            adapterCount: 1,\n            totalSignals: adapter.signalCount,\n            avgLearningRate: adapter.learningRate,\n            healthScore: adapter.healthScore\n          });\n        }\n      });\n\n      setDomainSummaries(Array.from(domainMap.values()));\n    }\n  }, []);\n\n  // Get top resonating pairs\n  const getTopResonances = useCallback((limit: number = 10): ResonanceMetrics[] => {\n    return state.resonances\n      .sort((a, b) => b.resonanceScore - a.resonanceScore)\n      .slice(0, limit);\n  }, [state.resonances]);\n\n  // Get adapters by domain\n  const getAdaptersByDomain = useCallback((domain: string): AdapterMetrics[] => {\n    return state.adapters.filter(a => a.domain === domain);\n  }, [state.adapters]);\n\n  // Get health score for specific adapter\n  const getAdapterHealth = useCallback((name: string): number => {\n    const adapter = state.adapters.find(a => a.name === name);\n    return adapter?.healthScore || 0;\n  }, [state.adapters]);\n\n  // Trigger manual sync\n  const triggerSync = useCallback(async () => {\n    await universalAdapterRegistry.initializeAll();\n    refreshState();\n  }, [refreshState]);\n\n  // Increment signal for an adapter\n  const incrementSignal = useCallback((adapterName: string) => {\n    universalAdapterRegistry.incrementSignalCount(adapterName);\n    refreshState();\n  }, [refreshState]);\n\n  // Start polling\n  useEffect(() => {\n    refreshState();\n    intervalRef.current = setInterval(refreshState, pollInterval);\n    \n    // Subscribe to adapter evolution events\n    const unsubscribe = subscribeToAdapterEvolution((event) => {\n      console.log('[UniversalAdapterMonitor] Evolution event:', event.type);\n      refreshState();\n    });\n    \n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n      unsubscribe();\n    };\n  }, [pollInterval, refreshState]);\n\n  return {\n    ...state,\n    domainSummaries,\n    topResonances: getTopResonances(),\n    getAdaptersByDomain,\n    getAdapterHealth,\n    refreshState,\n    triggerSync,\n    incrementSignal\n  };\n}\n\n// Calculate health score based on adapter metrics\nfunction calculateHealthScore(adapter: {\n  isActive: boolean;\n  signalCount: number;\n  learningRate: number;\n}): number {\n  if (!adapter.isActive) return 0;\n  \n  const activityScore = Math.min(30, adapter.signalCount / 100);\n  const learningScore = adapter.learningRate * 100;\n  const baseScore = 50;\n  \n  return Math.min(100, baseScore + activityScore + learningScore);\n}\n\n// Get color for domain\nexport function getDomainColor(domain: string): string {\n  return DOMAIN_COLORS[domain] || DOMAIN_COLORS.default;\n}\n";export{n as default};
