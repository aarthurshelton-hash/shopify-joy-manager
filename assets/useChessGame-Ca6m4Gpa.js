const e="import { useState, useEffect, useCallback, useRef } from 'react';\nimport { Chess, Square, Move } from 'chess.js';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useAuth } from '@/hooks/useAuth';\nimport { toast } from 'sonner';\nimport { calculateGameRatingChanges } from '@/lib/chess/eloCalculator';\nimport { getDrawToastMessage } from '@/lib/chess/drawReasons';\nimport { useChessSounds } from '@/hooks/useChessSounds';\nimport { useSoundStore } from '@/stores/soundStore';\n\nexport type TimeControl = 'bullet_1' | 'blitz_5' | 'rapid_15' | 'untimed';\nexport type GameStatus = 'waiting' | 'active' | 'completed' | 'abandoned';\nexport type GameResult = 'white_wins' | 'black_wins' | 'draw' | 'abandoned';\n\nexport interface ChessGameState {\n  id: string;\n  whitePlayerId: string | null;\n  blackPlayerId: string | null;\n  status: GameStatus;\n  result: GameResult | null;\n  pgn: string;\n  currentFen: string;\n  moveCount: number;\n  timeControl: TimeControl;\n  whiteTimeRemaining: number | null;\n  blackTimeRemaining: number | null;\n  whitePalette: Record<string, string> | null;\n  blackPalette: Record<string, string> | null;\n  challengeCode: string | null;\n  winnerId: string | null;\n  createdAt: string;\n  startedAt: string | null;\n}\n\nexport interface UseChessGameReturn {\n  game: Chess;\n  gameState: ChessGameState | null;\n  isMyTurn: boolean;\n  myColor: 'w' | 'b' | null;\n  isLoading: boolean;\n  error: string | null;\n  makeMove: (from: Square, to: Square, promotion?: string) => Promise<boolean>;\n  createGame: (timeControl: TimeControl, isPublic: boolean, palette: Record<string, string>) => Promise<string | null>;\n  joinGame: (gameId: string, palette: Record<string, string>) => Promise<boolean>;\n  joinByCode: (code: string, palette: Record<string, string>) => Promise<boolean>;\n  resignGame: () => Promise<void>;\n  offerDraw: () => Promise<void>;\n  loadGame: (gameId: string) => Promise<void>;\n  getAvailableMoves: (square: Square) => Square[];\n  movedSquares: Set<string>; // Track which squares have been moved to (for visualization fill-in)\n}\n\nconst TIME_CONTROL_SECONDS: Record<TimeControl, number> = {\n  bullet_1: 60,\n  blitz_5: 300,\n  rapid_15: 900,\n  untimed: 0,\n};\n\nexport const useChessGame = (): UseChessGameReturn => {\n  const { user } = useAuth();\n  const [game, setGame] = useState<Chess>(new Chess());\n  const [gameState, setGameState] = useState<ChessGameState | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [movedSquares, setMovedSquares] = useState<Set<string>>(new Set());\n  \n  // Sound effects - read from global store\n  const { enabled: soundEnabled, volume: soundVolume } = useSoundStore();\n  const { playSound } = useChessSounds(soundEnabled, soundVolume);\n  const previousFenRef = useRef<string>('');\n\n  const myColor: 'w' | 'b' | null = gameState\n    ? gameState.whitePlayerId === user?.id\n      ? 'w'\n      : gameState.blackPlayerId === user?.id\n      ? 'b'\n      : null\n    : null;\n\n  const isMyTurn = gameState?.status === 'active' && game.turn() === myColor;\n\n  // Subscribe to real-time game updates\n  useEffect(() => {\n    if (!gameState?.id) return;\n\n    const channel = supabase\n      .channel(`game-${gameState.id}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'UPDATE',\n          schema: 'public',\n          table: 'chess_games',\n          filter: `id=eq.${gameState.id}`,\n        },\n        (payload) => {\n          const updated = payload.new as any;\n          \n          // Check for game completion and play appropriate sound\n          if (updated.status === 'completed' && gameState.status !== 'completed') {\n            if (updated.result === 'draw') {\n              playSound('draw');\n            } else if (updated.winner_id === user?.id) {\n              playSound('victory');\n            } else {\n              playSound('defeat');\n            }\n          }\n          \n          setGameState(prev => prev ? {\n            ...prev,\n            status: updated.status,\n            result: updated.result,\n            pgn: updated.pgn,\n            currentFen: updated.current_fen,\n            moveCount: updated.move_count,\n            whiteTimeRemaining: updated.white_time_remaining,\n            blackTimeRemaining: updated.black_time_remaining,\n            winnerId: updated.winner_id,\n            blackPlayerId: updated.black_player_id,\n            startedAt: updated.started_at,\n          } : null);\n\n          // Update chess.js game state\n          if (updated.current_fen) {\n            const newGame = new Chess(updated.current_fen);\n            setGame(newGame);\n          }\n        }\n      )\n      .subscribe();\n\n    // Subscribe to moves\n    const movesChannel = supabase\n      .channel(`moves-${gameState.id}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'chess_moves',\n          filter: `game_id=eq.${gameState.id}`,\n        },\n        (payload) => {\n          const move = payload.new as any;\n          // Track moved squares for visualization\n          const uci = move.move_uci;\n          if (uci && uci.length >= 4) {\n            const to = uci.substring(2, 4);\n            setMovedSquares(prev => new Set([...prev, to]));\n          }\n          \n          // Play sound for opponent's move\n          if (move.player_id !== user?.id) {\n            const san = move.move_san;\n            if (san.includes('#')) {\n              playSound('checkmate');\n            } else if (san.includes('+')) {\n              playSound('check');\n            } else if (san.includes('x')) {\n              playSound('capture');\n            } else if (san === 'O-O' || san === 'O-O-O') {\n              playSound('castle');\n            } else {\n              playSound('move');\n            }\n          }\n        }\n      )\n      .subscribe();\n\n    return () => {\n      supabase.removeChannel(channel);\n      supabase.removeChannel(movesChannel);\n    };\n  }, [gameState?.id, gameState?.status, user?.id, playSound]);\n\n  const loadGame = useCallback(async (gameId: string) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data, error: fetchError } = await supabase\n        .from('chess_games')\n        .select('*')\n        .eq('id', gameId)\n        .maybeSingle();\n\n      if (fetchError) throw fetchError;\n      if (!data) throw new Error('Game not found');\n\n      setGameState({\n        id: data.id,\n        whitePlayerId: data.white_player_id,\n        blackPlayerId: data.black_player_id,\n        status: data.status as GameStatus,\n        result: data.result as GameResult | null,\n        pgn: data.pgn || '',\n        currentFen: data.current_fen,\n        moveCount: data.move_count || 0,\n        timeControl: data.time_control as TimeControl,\n        whiteTimeRemaining: data.white_time_remaining,\n        blackTimeRemaining: data.black_time_remaining,\n        whitePalette: data.white_palette as Record<string, string> | null,\n        blackPalette: data.black_palette as Record<string, string> | null,\n        challengeCode: data.challenge_code,\n        winnerId: data.winner_id,\n        createdAt: data.created_at,\n        startedAt: data.started_at,\n      });\n\n      const newGame = new Chess(data.current_fen);\n      setGame(newGame);\n\n      // Load existing moves to track moved squares\n      const { data: moves } = await supabase\n        .from('chess_moves')\n        .select('move_uci')\n        .eq('game_id', gameId)\n        .order('move_number', { ascending: true });\n\n      if (moves) {\n        const squares = new Set<string>();\n        moves.forEach(m => {\n          if (m.move_uci && m.move_uci.length >= 4) {\n            squares.add(m.move_uci.substring(2, 4));\n          }\n        });\n        setMovedSquares(squares);\n      }\n    } catch (e) {\n      setError(e instanceof Error ? e.message : 'Failed to load game');\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const createGame = useCallback(async (\n    timeControl: TimeControl,\n    isPublic: boolean,\n    palette: Record<string, string>\n  ): Promise<string | null> => {\n    if (!user) {\n      toast.error('Please sign in to create a game');\n      return null;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const initialTime = TIME_CONTROL_SECONDS[timeControl] || null;\n      \n      // Generate challenge code\n      const { data: codeResult } = await supabase.rpc('generate_challenge_code');\n      \n      const { data, error: createError } = await supabase\n        .from('chess_games')\n        .insert({\n          white_player_id: user.id,\n          status: 'waiting',\n          time_control: timeControl,\n          white_time_remaining: initialTime,\n          black_time_remaining: initialTime,\n          white_palette: palette,\n          is_public: isPublic,\n          challenge_code: codeResult,\n        })\n        .select()\n        .single();\n\n      if (createError) throw createError;\n\n      toast.success(isPublic ? 'Game created! Waiting for opponent...' : `Challenge code: ${codeResult}`);\n      await loadGame(data.id);\n      return data.id;\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : 'Failed to create game';\n      setError(msg);\n      toast.error(msg);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [user, loadGame]);\n\n  const joinGame = useCallback(async (gameId: string, palette: Record<string, string>): Promise<boolean> => {\n    if (!user) {\n      toast.error('Please sign in to join a game');\n      return false;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data: gameData, error: fetchError } = await supabase\n        .from('chess_games')\n        .select('*')\n        .eq('id', gameId)\n        .maybeSingle();\n\n      if (fetchError) throw fetchError;\n      if (!gameData) throw new Error('Game not found');\n      if (gameData.status !== 'waiting') throw new Error('Game already started');\n      if (gameData.white_player_id === user.id) throw new Error('Cannot join your own game');\n\n      const { error: updateError } = await supabase\n        .from('chess_games')\n        .update({\n          black_player_id: user.id,\n          black_palette: palette,\n          status: 'active',\n          started_at: new Date().toISOString(),\n          last_move_at: new Date().toISOString(),\n        })\n        .eq('id', gameId);\n\n      if (updateError) throw updateError;\n\n      playSound('gameStart');\n      toast.success('Joined game! You are playing as Black.');\n      await loadGame(gameId);\n      return true;\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : 'Failed to join game';\n      setError(msg);\n      toast.error(msg);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [user, loadGame, playSound]);\n\n  const joinByCode = useCallback(async (code: string, palette: Record<string, string>): Promise<boolean> => {\n    if (!user) {\n      toast.error('Please sign in to join a game');\n      return false;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data: gameData, error: fetchError } = await supabase\n        .from('chess_games')\n        .select('id')\n        .eq('challenge_code', code.toUpperCase())\n        .eq('status', 'waiting')\n        .maybeSingle();\n\n      if (fetchError) throw fetchError;\n      if (!gameData) throw new Error('Invalid or expired challenge code');\n\n      return await joinGame(gameData.id, palette);\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : 'Failed to join by code';\n      setError(msg);\n      toast.error(msg);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [user, joinGame]);\n\n  const makeMove = useCallback(async (from: Square, to: Square, promotion?: string): Promise<boolean> => {\n    if (!gameState || !user || !isMyTurn) return false;\n\n    try {\n      // Make move locally first\n      const move = game.move({ from, to, promotion });\n      if (!move) {\n        playSound('illegal');\n        return false;\n      }\n\n      // Play appropriate sound for the move\n      if (game.isCheckmate()) {\n        playSound('checkmate');\n      } else if (game.isCheck()) {\n        playSound('check');\n      } else if (move.captured) {\n        playSound('capture');\n      } else if (move.san === 'O-O' || move.san === 'O-O-O') {\n        playSound('castle');\n      } else {\n        playSound('move');\n      }\n\n      setGame(new Chess(game.fen()));\n      setMovedSquares(prev => new Set([...prev, to]));\n\n      // Update game state in database\n      const newPgn = game.pgn();\n      const newFen = game.fen();\n      \n      let result: GameResult | null = null;\n      let winnerId: string | null = null;\n      let status: GameStatus = 'active';\n\n      if (game.isGameOver()) {\n        status = 'completed';\n        if (game.isCheckmate()) {\n          result = game.turn() === 'w' ? 'black_wins' : 'white_wins';\n          winnerId = game.turn() === 'w' ? gameState.blackPlayerId : gameState.whitePlayerId;\n        } else {\n          result = 'draw';\n        }\n      }\n\n      // Insert move\n      await supabase.from('chess_moves').insert({\n        game_id: gameState.id,\n        player_id: user.id,\n        move_number: gameState.moveCount + 1,\n        move_san: move.san,\n        move_uci: from + to + (promotion || ''),\n        fen_after: newFen,\n      });\n\n      // Update game\n      await supabase\n        .from('chess_games')\n        .update({\n          pgn: newPgn,\n          current_fen: newFen,\n          move_count: gameState.moveCount + 1,\n          last_move_at: new Date().toISOString(),\n          status,\n          result,\n          winner_id: winnerId,\n          completed_at: status === 'completed' ? new Date().toISOString() : null,\n        })\n        .eq('id', gameState.id);\n\n      if (status === 'completed' && result) {\n        // Update ELO ratings\n        await updateEloRatings(gameState.whitePlayerId, gameState.blackPlayerId, result);\n        \n        // Play game end sounds\n        if (result === 'draw') {\n          playSound('draw');\n        } else if (winnerId === user?.id) {\n          playSound('victory');\n        } else {\n          playSound('defeat');\n        }\n        \n        if (result === 'white_wins') {\n          toast.success(myColor === 'w' ? 'You won!' : 'White wins!');\n        } else if (result === 'black_wins') {\n          toast.success(myColor === 'b' ? 'You won!' : 'Black wins!');\n        } else {\n          toast.info(getDrawToastMessage(game));\n        }\n      }\n\n      return true;\n    } catch (e) {\n      console.error('Move error:', e);\n      return false;\n    }\n  }, [game, gameState, user, isMyTurn, myColor, playSound]);\n\n  // Update ELO ratings for both players after a game completes\n  const updateEloRatings = useCallback(async (\n    whitePlayerId: string | null,\n    blackPlayerId: string | null,\n    result: GameResult\n  ) => {\n    if (!whitePlayerId || !blackPlayerId || result === 'abandoned') return;\n    \n    try {\n      // Fetch current ratings for both players\n      const { data: profiles } = await supabase\n        .from('profiles')\n        .select('user_id, elo_rating')\n        .in('user_id', [whitePlayerId, blackPlayerId]);\n      \n      if (!profiles || profiles.length !== 2) return;\n      \n      const whiteProfile = profiles.find(p => p.user_id === whitePlayerId);\n      const blackProfile = profiles.find(p => p.user_id === blackPlayerId);\n      \n      if (!whiteProfile || !blackProfile) return;\n      \n      const whiteRating = whiteProfile.elo_rating || 1200;\n      const blackRating = blackProfile.elo_rating || 1200;\n      \n      // Calculate new ratings\n      const ratingResult = result === 'draw' ? 'draw' : result;\n      const changes = calculateGameRatingChanges(whiteRating, blackRating, ratingResult);\n      \n      // Update both players' ratings\n      await Promise.all([\n        supabase\n          .from('profiles')\n          .update({ elo_rating: changes.white.newRating })\n          .eq('user_id', whitePlayerId),\n        supabase\n          .from('profiles')\n          .update({ elo_rating: changes.black.newRating })\n          .eq('user_id', blackPlayerId)\n      ]);\n      \n      // Show rating change to current user\n      if (user?.id === whitePlayerId) {\n        const change = changes.white.change;\n        toast.info(`Rating: ${changes.white.newRating} (${change >= 0 ? '+' : ''}${change})`);\n      } else if (user?.id === blackPlayerId) {\n        const change = changes.black.change;\n        toast.info(`Rating: ${changes.black.newRating} (${change >= 0 ? '+' : ''}${change})`);\n      }\n    } catch (error) {\n      console.error('Failed to update ELO ratings:', error);\n    }\n  }, [user]);\n\n  const resignGame = useCallback(async () => {\n    if (!gameState || !user || !myColor) return;\n\n    const result: GameResult = myColor === 'w' ? 'black_wins' : 'white_wins';\n    const winnerId = myColor === 'w' ? gameState.blackPlayerId : gameState.whitePlayerId;\n\n    await supabase\n      .from('chess_games')\n      .update({\n        status: 'completed',\n        result,\n        winner_id: winnerId,\n        completed_at: new Date().toISOString(),\n      })\n      .eq('id', gameState.id);\n\n    // Update ELO ratings\n    await updateEloRatings(gameState.whitePlayerId, gameState.blackPlayerId, result);\n\n    toast.info('You resigned');\n  }, [gameState, user, myColor, updateEloRatings]);\n\n  const offerDraw = useCallback(async () => {\n    toast.info('Draw offer sent (opponent auto-accepts in this version)');\n    \n    if (!gameState) return;\n    \n    await supabase\n      .from('chess_games')\n      .update({\n        status: 'completed',\n        result: 'draw',\n        completed_at: new Date().toISOString(),\n      })\n      .eq('id', gameState.id);\n\n    // Update ELO ratings\n    await updateEloRatings(gameState.whitePlayerId, gameState.blackPlayerId, 'draw');\n  }, [gameState, updateEloRatings]);\n\n  const getAvailableMoves = useCallback((square: Square): Square[] => {\n    const moves = game.moves({ square, verbose: true });\n    return moves.map(m => m.to as Square);\n  }, [game]);\n\n  return {\n    game,\n    gameState,\n    isMyTurn,\n    myColor,\n    isLoading,\n    error,\n    makeMove,\n    createGame,\n    joinGame,\n    joinByCode,\n    resignGame,\n    offerDraw,\n    loadGame,\n    getAvailableMoves,\n    movedSquares,\n  };\n};\n";export{e as default};
