const n="/**\n * Fused Recommendation Generator\n * \n * Combines tactical and strategic analysis into unified recommendations\n */\n\nimport { Chess } from 'chess.js';\nimport { ColorFlowSignature } from '../colorFlowAnalysis';\nimport { TacticalInsight, StrategicInsight, FusedRecommendation } from './types';\n\n/**\n * Fuse tactical and strategic recommendations\n */\nexport function fuseRecommendations(\n  tactical: TacticalInsight,\n  strategic: StrategicInsight,\n  signature: ColorFlowSignature,\n  chess: Chess\n): FusedRecommendation {\n  const reasoning: string[] = [];\n  \n  // Start with tactical best move\n  const move = tactical.bestMove;\n  \n  // Add tactical reasoning\n  reasoning.push(`Stockfish recommends ${move} (eval: ${(tactical.evaluation / 100).toFixed(2)})`);\n  \n  // Add strategic context\n  reasoning.push(`This aligns with the ${strategic.archetypeName} pattern`);\n  \n  // Check trajectory alignment\n  let trajectoryAlignment: string;\n  if (signature.flowDirection === 'kingside' && move.includes('h') || move.includes('g')) {\n    trajectoryAlignment = 'Perfectly aligned - continues kingside pressure';\n  } else if (signature.flowDirection === 'queenside' && (move.includes('a') || move.includes('b') || move.includes('c'))) {\n    trajectoryAlignment = 'Perfectly aligned - continues queenside expansion';\n  } else if (signature.flowDirection === 'central' && (move.includes('d') || move.includes('e'))) {\n    trajectoryAlignment = 'Perfectly aligned - reinforces central control';\n  } else {\n    trajectoryAlignment = 'Tactically optimal, may shift strategic trajectory';\n  }\n  \n  // Tradeoff analysis\n  let tradeoff: string;\n  if (Math.abs(tactical.evaluation) > 200) {\n    tradeoff = 'Short-term tactics dominate - position is already decided';\n  } else if (signature.temporalFlow.volatility > 60) {\n    tradeoff = 'High-intensity position - tactical precision critical';\n  } else {\n    tradeoff = 'Balanced position - strategic considerations matter equally';\n  }\n  \n  // Confidence based on alignment\n  const alignmentBonus = trajectoryAlignment.includes('Perfectly') ? 15 : 0;\n  const moveConfidence = Math.min(95, 60 + alignmentBonus + (signature.intensity / 4));\n  \n  return {\n    move,\n    reasoning,\n    trajectoryAlignment,\n    tradeoffAnalysis: tradeoff,\n    moveConfidence,\n  };\n}\n";export{n as default};
