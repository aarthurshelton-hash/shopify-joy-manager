const e="import { useState, useCallback, useRef } from 'react';\nimport { toast } from 'sonner';\nimport { SimulationResult, SquareData, GameData } from '@/lib/chess/gameSimulator';\nimport { recordVisionInteraction } from '@/lib/visualizations/visionScoring';\nimport { watermarkBase64Image } from '@/lib/chess/invisibleWatermark';\nimport { checkRateLimit, getAnonymousIdentifier, RATE_LIMITS } from '@/lib/rateLimit';\n\ninterface ExportState {\n  isExportingHD: boolean;\n  isExportingGIF: boolean;\n  gifProgress: number;\n}\n\ninterface UseVisualizationExportOptions {\n  isPremium: boolean;\n  visualizationId?: string | null;\n  userId?: string | null;\n  onUnauthorized?: () => void;\n  onUpgradeRequired?: () => void;\n}\n\ninterface TrademarkExportOptions {\n  board: SquareData[][];\n  gameData: GameData;\n  title: string;\n  darkMode?: boolean;\n  showQR?: boolean;\n  shareId?: string;\n  currentMoveNumber?: number;\n  highlightState?: {\n    lockedPieces: Array<{ pieceType: string; pieceColor: string }>;\n    lockedSquares?: Array<{ square: string; pieces: Array<{ pieceType: string; pieceColor: string }> }>;\n    compareMode: boolean;\n  };\n  piecesState?: {\n    showPieces: boolean;\n    pieceOpacity: number;\n  };\n  pgn?: string; // Explicit PGN for piece position calculation\n}\n\n/**\n * Hook for handling HD download and GIF export functionality\n */\nexport function useVisualizationExport(options: UseVisualizationExportOptions) {\n  const { isPremium, visualizationId, userId, onUnauthorized, onUpgradeRequired } = options;\n  \n  const [state, setState] = useState<ExportState>({\n    isExportingHD: false,\n    isExportingGIF: false,\n    gifProgress: 0,\n  });\n  \n  const boardRef = useRef<HTMLDivElement>(null);\n\n  /**\n   * Download HD image of the visualization\n   */\n  const downloadHD = useCallback(async (\n    captureElement: HTMLElement,\n    title: string,\n    darkMode: boolean = false\n  ): Promise<boolean> => {\n    if (!isPremium) {\n      onUpgradeRequired?.();\n      return false;\n    }\n\n    setState(prev => ({ ...prev, isExportingHD: true }));\n    \n    try {\n      const html2canvas = (await import('html2canvas')).default;\n      \n      // Capture with high resolution\n      const canvas = await html2canvas(captureElement, {\n        scale: 5, // 5x for print-quality resolution\n        useCORS: true,\n        allowTaint: true,\n        logging: false,\n        backgroundColor: darkMode ? '#0A0A0A' : '#FDFCFB',\n        // Ensure SVGs render correctly\n        onclone: (clonedDoc) => {\n          // Force any fonts to load\n          const svgs = clonedDoc.querySelectorAll('svg');\n          svgs.forEach(svg => {\n            svg.style.overflow = 'visible';\n          });\n        },\n      });\n      \n      // Convert to base64 first for watermarking\n      let base64Image = canvas.toDataURL('image/png', 1.0);\n      \n      // Apply invisible watermark with ownership data\n      if (visualizationId && userId) {\n        try {\n          base64Image = await watermarkBase64Image(base64Image, {\n            visualizationId,\n            userId,\n            timestamp: Date.now(),\n          });\n        } catch (wmError) {\n          console.warn('Failed to apply watermark:', wmError);\n          // Continue without watermark\n        }\n      }\n      \n      // Convert base64 to blob for download\n      const response = await fetch(base64Image);\n      const blob = await response.blob();\n      \n      // Create download link with better reliability\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `${title.replace(/\\s+/g, '-').toLowerCase()}-hd.png`;\n      \n      // Ensure link is properly appended and clicked\n      document.body.appendChild(link);\n      \n      // Use setTimeout to ensure DOM is ready before click\n      setTimeout(() => {\n        link.click();\n        \n        // Cleanup after a short delay to ensure download starts\n        setTimeout(() => {\n          if (link.parentNode) {\n            document.body.removeChild(link);\n          }\n          URL.revokeObjectURL(url);\n        }, 100);\n      }, 0);\n      \n      // Record the download interaction\n      if (visualizationId) {\n        recordVisionInteraction(visualizationId, 'download_hd');\n      }\n      \n      toast.success('HD image downloaded!', {\n        description: 'Your visualization has been saved to your device.',\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('HD export failed:', error);\n      toast.error('Download failed', {\n        description: 'Please try again or use a different browser.',\n      });\n      return false;\n    } finally {\n      setState(prev => ({ ...prev, isExportingHD: false }));\n    }\n  }, [isPremium, visualizationId, onUpgradeRequired]);\n\n  /**\n   * Download HD image with the \"trademark look\" - proper PrintReadyVisualization rendering\n   * This ensures the export matches the print product exactly\n   */\n  const downloadTrademarkHD = useCallback(async (\n    exportOptions: TrademarkExportOptions\n  ): Promise<boolean> => {\n    if (!isPremium) {\n      onUpgradeRequired?.();\n      return false;\n    }\n\n    // Check rate limit for downloads\n    const identifier = getAnonymousIdentifier();\n    const rateLimitResult = await checkRateLimit(identifier, 'download', RATE_LIMITS.download.maxRequests, RATE_LIMITS.download.windowSeconds);\n    if (!rateLimitResult.allowed) {\n      toast.error(`Too many downloads. Please wait ${rateLimitResult.retry_after} seconds.`);\n      return false;\n    }\n\n    setState(prev => ({ ...prev, isExportingHD: true }));\n    \n    try {\n      // Use the print image generator which renders PrintReadyVisualization\n      const { generateCleanPrintImage } = await import('@/lib/chess/printImageGenerator');\n      \n      // Create a simulation result from the board data\n      const simulation: SimulationResult = {\n        board: exportOptions.board,\n        gameData: exportOptions.gameData,\n        totalMoves: exportOptions.gameData.moves?.length || 0,\n      };\n      \n      // Build captured state for print generator\n      const capturedState = {\n        currentMove: exportOptions.currentMoveNumber ?? Infinity,\n        selectedPhase: 'all' as const,\n        lockedPieces: exportOptions.highlightState?.lockedPieces || [],\n        compareMode: exportOptions.highlightState?.compareMode || false,\n        displayMode: 'art' as const,\n        darkMode: exportOptions.darkMode || false,\n        showTerritory: false,\n        showHeatmaps: false,\n        showPieces: exportOptions.piecesState?.showPieces || false,\n        pieceOpacity: exportOptions.piecesState?.pieceOpacity || 0.7,\n        capturedAt: new Date(),\n      };\n      \n      let base64Image = await generateCleanPrintImage(simulation, {\n        darkMode: exportOptions.darkMode || false,\n        includeQR: exportOptions.showQR || false,\n        shareId: exportOptions.shareId,\n        capturedState,\n        highlightState: exportOptions.highlightState ? {\n          lockedPieces: exportOptions.highlightState.lockedPieces.map(p => ({\n            pieceType: p.pieceType as 'k' | 'q' | 'r' | 'b' | 'n' | 'p',\n            // Map 'white'/'black' to 'w'/'b' if needed\n            pieceColor: (p.pieceColor === 'white' ? 'w' : p.pieceColor === 'black' ? 'b' : p.pieceColor) as 'w' | 'b',\n          })),\n          compareMode: exportOptions.highlightState.compareMode,\n        } : undefined,\n        pgn: exportOptions.pgn || exportOptions.gameData.pgn, // Pass explicit PGN for pieces\n      });\n      \n      // Apply invisible watermark with ownership data\n      if (visualizationId && userId) {\n        try {\n          base64Image = await watermarkBase64Image(base64Image, {\n            visualizationId,\n            userId,\n            timestamp: Date.now(),\n            shareId: exportOptions.shareId,\n          });\n        } catch (wmError) {\n          console.warn('Failed to apply watermark:', wmError);\n          // Continue without watermark\n        }\n      }\n      \n      // Convert base64 to blob for download\n      const response = await fetch(base64Image);\n      const blob = await response.blob();\n      \n      // Create download link with better reliability\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `${exportOptions.title.replace(/\\s+/g, '-').toLowerCase()}-hd.png`;\n      \n      // Ensure link is properly appended and clicked\n      document.body.appendChild(link);\n      \n      // Use setTimeout to ensure DOM is ready before click\n      setTimeout(() => {\n        link.click();\n        \n        // Cleanup after a short delay to ensure download starts\n        setTimeout(() => {\n          if (link.parentNode) {\n            document.body.removeChild(link);\n          }\n          URL.revokeObjectURL(url);\n        }, 100);\n      }, 0);\n      \n      // Record the download interaction\n      if (visualizationId) {\n        recordVisionInteraction(visualizationId, 'download_hd');\n      }\n      \n      toast.success('HD image downloaded!', {\n        description: 'Your trademark visualization has been saved.',\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('Trademark HD export failed:', error);\n      toast.error('Download failed', {\n        description: 'Please try again or use a different browser.',\n      });\n      return false;\n    } finally {\n      setState(prev => ({ ...prev, isExportingHD: false }));\n    }\n  }, [isPremium, visualizationId, onUpgradeRequired]);\n\n  /**\n   * Generate animated GIF of the game progression - frame-by-frame capture\n   * Each frame represents a move state from the timeline\n   */\n  const downloadGIF = useCallback(async (\n    simulation: SimulationResult,\n    captureElement: HTMLElement,\n    title: string,\n    onProgressUpdate?: (progress: number) => void,\n    piecesState?: { showPieces: boolean; pieceOpacity: number }\n  ): Promise<boolean> => {\n    if (!isPremium) {\n      onUpgradeRequired?.();\n      return false;\n    }\n\n    // Check rate limit for downloads\n    const identifier = getAnonymousIdentifier();\n    const rateLimitResult = await checkRateLimit(identifier, 'download', RATE_LIMITS.download.maxRequests, RATE_LIMITS.download.windowSeconds);\n    if (!rateLimitResult.allowed) {\n      toast.error(`Too many downloads. Please wait ${rateLimitResult.retry_after} seconds.`);\n      return false;\n    }\n\n    // Validate simulation data before starting\n    if (!simulation || !simulation.board || simulation.totalMoves === undefined) {\n      toast.error('Invalid visualization data', {\n        description: 'Cannot generate GIF from current visualization.',\n      });\n      return false;\n    }\n\n    if (simulation.totalMoves === 0) {\n      toast.error('No moves to animate', {\n        description: 'This visualization has no moves to create a GIF from.',\n      });\n      return false;\n    }\n\n    setState(prev => ({ ...prev, isExportingGIF: true, gifProgress: 0 }));\n    \n    try {\n      // Import the frame-by-frame GIF generator\n      const { generateAnimatedGif } = await import('@/lib/chess/gifFrameRenderer');\n      \n      // Show progress toast\n      const toastId = 'gif-export';\n      toast.loading('Generating animated GIF...', { id: toastId, duration: Infinity });\n      \n      const updateProgress = (progress: number, message: string) => {\n        setState(prev => ({ ...prev, gifProgress: progress }));\n        onProgressUpdate?.(progress);\n        toast.loading(`${message} (${Math.round(progress * 100)}%)`, { id: toastId });\n      };\n      \n      // Generate the GIF with frame-by-frame capture\n      const blob = await generateAnimatedGif({\n        simulation,\n        size: 400,\n        darkMode: false,\n        showCoordinates: true,\n        frameDelay: 150,\n        quality: 10,\n        maxFrames: 60,\n        onProgress: updateProgress,\n        showPieces: piecesState?.showPieces || false,\n        pieceOpacity: piecesState?.pieceOpacity || 0.7,\n      });\n      \n      // Validate blob was created\n      if (!blob || blob.size === 0) {\n        throw new Error('Generated GIF is empty');\n      }\n      \n      // Download the GIF\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `${title.replace(/\\s+/g, '-').toLowerCase()}.gif`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n      \n      // Record the download interaction\n      if (visualizationId) {\n        recordVisionInteraction(visualizationId, 'download_gif');\n      }\n      \n      toast.dismiss(toastId);\n      toast.success('Animated GIF downloaded!', {\n        description: `${simulation.totalMoves} moves captured (${(blob.size / 1024).toFixed(0)}KB)`,\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('GIF export failed:', error);\n      toast.dismiss('gif-export');\n      \n      // Provide more specific error messages\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      let description = 'Please try again or use HD download instead.';\n      \n      if (errorMessage.includes('worker')) {\n        description = 'GIF encoder failed to initialize. Try refreshing the page.';\n      } else if (errorMessage.includes('timeout')) {\n        description = 'GIF generation took too long. Try with a shorter game.';\n      } else if (errorMessage.includes('frame')) {\n        description = 'Failed to capture visualization frames.';\n      }\n      \n      toast.error('GIF generation failed', { description });\n      return false;\n    } finally {\n      setState(prev => ({ ...prev, isExportingGIF: false, gifProgress: 0 }));\n    }\n  }, [isPremium, visualizationId, onUpgradeRequired]);\n\n  return {\n    ...state,\n    boardRef,\n    downloadHD,\n    downloadTrademarkHD,\n    downloadGIF,\n  };\n}\n";export{e as default};
