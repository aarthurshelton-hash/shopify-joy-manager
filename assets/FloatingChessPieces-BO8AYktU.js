const e="import React, { useState, useEffect, useMemo } from 'react';\n\nconst chessPieces = ['♔', '♕', '♖', '♗', '♘', '♙', '♚', '♛', '♜', '♝', '♞', '♟'];\n\n// Trail colors for variety\nconst trailColors = {\n  gold: [\n    'rgba(212, 175, 55,', // Classic gold\n    'rgba(255, 215, 0,',  // Bright gold\n    'rgba(218, 165, 32,', // Goldenrod\n    'rgba(184, 134, 11,', // Dark gold\n  ],\n  silver: [\n    'rgba(192, 192, 192,', // Silver\n    'rgba(169, 169, 169,', // Dark silver\n    'rgba(211, 211, 211,', // Light silver\n    'rgba(220, 220, 220,', // Gainsboro\n  ]\n};\n\ninterface TrailPoint {\n  x: number;\n  y: number;\n  opacity: number;\n  colorIdx: number;\n}\n\ninterface AnimatedPiece {\n  id: number;\n  piece: string;\n  x: number;\n  y: number;\n  depth: number; // 0-1, higher = closer/larger/faster\n  size: number;\n  color: 'gold' | 'silver';\n  trails: TrailPoint[];\n  phase: number;\n  speed: number;\n}\n\nconst FloatingChessPieces: React.FC = () => {\n  // Reduce piece count on mobile for better performance\n  const [isMobile, setIsMobile] = useState(() => \n    typeof window !== 'undefined' && window.innerWidth < 768\n  );\n  \n  useEffect(() => {\n    const checkMobile = () => setIsMobile(window.innerWidth < 768);\n    window.addEventListener('resize', checkMobile, { passive: true });\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n  \n  const pieceCount = isMobile ? 6 : 12; // Fewer pieces on mobile\n  \n  const initialPieces = useMemo<AnimatedPiece[]>(() => \n    Array.from({ length: pieceCount }, (_, i) => {\n      const depth = Math.random(); // 0 = far, 1 = close\n      return {\n        id: i,\n        piece: chessPieces[Math.floor(Math.random() * chessPieces.length)],\n        x: Math.random() * 120 - 10,\n        y: 15 + Math.random() * 70,\n        depth,\n        size: isMobile ? 12 + depth * 16 : 14 + depth * 22, // Smaller on mobile\n        color: Math.random() > 0.5 ? 'gold' : 'silver',\n        trails: [],\n        phase: Math.random() * Math.PI * 2,\n        speed: isMobile ? 0.06 + depth * 0.12 : 0.08 + depth * 0.18, // Slower on mobile\n      };\n    }), [pieceCount, isMobile]\n  );\n\n  const [pieces, setPieces] = useState(initialPieces);\n  \n  // Reset pieces when mobile state changes\n  useEffect(() => {\n    setPieces(initialPieces);\n  }, [initialPieces]);\n\n  useEffect(() => {\n    let frameId: number;\n    let lastTime = 0;\n    const targetInterval = 80; // ~12fps for smooth, low-CPU animation\n    \n    const animate = (time: number) => {\n      if (time - lastTime >= targetInterval) {\n        lastTime = time;\n        \n        setPieces(prev => prev.map(piece => {\n          const newPhase = piece.phase + 0.015 * (0.5 + piece.depth);\n          const wave = Math.sin(newPhase) * (0.15 + piece.depth * 0.1);\n          const vertWave = Math.cos(newPhase * 0.5) * 0.04;\n          \n          let newX = piece.x + piece.speed + wave;\n          let newY = piece.y + vertWave;\n          \n          // Wrap horizontally\n          if (newX > 115) newX = -15;\n          \n          // Clamp vertical\n          newY = Math.max(12, Math.min(88, newY));\n          \n          // Add trail with random color variation\n          const newTrails: TrailPoint[] = [\n            { \n              x: piece.x, \n              y: piece.y, \n              opacity: 0.15 + piece.depth * 0.05,\n              colorIdx: Math.floor(Math.random() * 4)\n            },\n            ...piece.trails.map(t => ({ ...t, opacity: t.opacity * 0.78 }))\n          ].filter(t => t.opacity > 0.01).slice(0, 5);\n          \n          return { ...piece, x: newX, y: newY, phase: newPhase, trails: newTrails };\n        }));\n      }\n      frameId = requestAnimationFrame(animate);\n    };\n    \n    frameId = requestAnimationFrame(animate);\n    return () => cancelAnimationFrame(frameId);\n  }, []);\n\n  return (\n    <div className=\"absolute inset-0 overflow-hidden pointer-events-none\">\n      {pieces.map((piece) => {\n        const colors = trailColors[piece.color];\n        const baseOpacity = 0.12 + piece.depth * 0.12;\n        \n        return (\n          <React.Fragment key={piece.id}>\n            {/* Color trails */}\n            {piece.trails.map((trail, idx) => (\n              <span\n                key={`t-${piece.id}-${idx}`}\n                style={{\n                  position: 'absolute',\n                  left: `${trail.x}%`,\n                  top: `${trail.y}%`,\n                  fontSize: piece.size,\n                  color: `${colors[trail.colorIdx]}${trail.opacity * 0.4})`,\n                  textShadow: `0 0 ${6 + piece.depth * 8}px ${colors[trail.colorIdx]}${trail.opacity * 0.25})`,\n                  transform: 'translate(-50%, -50%)',\n                  filter: `blur(${1.2 - trail.opacity * 3}px)`,\n                  zIndex: Math.floor(piece.depth * 10),\n                }}\n              >\n                {piece.piece}\n              </span>\n            ))}\n            \n            {/* Main piece - using GPU-accelerated transform */}\n            <span\n              style={{\n                position: 'absolute',\n                left: `${piece.x}%`,\n                top: `${piece.y}%`,\n                fontSize: piece.size,\n                color: `${colors[0]}${baseOpacity})`,\n                textShadow: `0 0 ${10 + piece.depth * 10}px ${colors[0]}${baseOpacity * 0.6})`,\n                transform: 'translate3d(-50%, -50%, 0)',\n                filter: `drop-shadow(0 0 ${4 + piece.depth * 6}px ${colors[0]}0.3))`,\n                zIndex: Math.floor(piece.depth * 10) + 1,\n                willChange: 'left, top',\n                backfaceVisibility: 'hidden',\n              }}\n            >\n              {piece.piece}\n            </span>\n          </React.Fragment>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default FloatingChessPieces;\n";export{e as default};
