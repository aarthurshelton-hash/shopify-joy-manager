const n="/**\n * Biological/Health Domain Adapter\n * Converts biological rhythms to En Pensent temporal signatures\n * \n * Biological systems exhibit universal patterns that reflect\n * the same temporal dynamics found in markets and nature.\n * This adapter extracts temporal patterns from:\n * - Heart rate variability (HRV)\n * - Circadian rhythms\n * - Hormonal cycles\n * - Neural oscillations\n */\n\nimport type { DomainAdapter, UniversalSignal, DomainSignature } from '../types';\n\ninterface BioData {\n  heartRate: number; // BPM\n  hrvMs: number; // Heart rate variability in ms\n  cortisol: number; // 0-1 normalized stress hormone\n  melatonin: number; // 0-1 normalized sleep hormone\n  brainwaveHz: number; // Dominant brainwave frequency\n  timestamp: number;\n}\n\ntype BrainwaveState = 'delta' | 'theta' | 'alpha' | 'beta' | 'gamma';\n\nclass BioDomainAdapter implements DomainAdapter<BioData> {\n  domain = 'bio' as const;\n  name = 'Biological Rhythm Analyzer';\n  isActive = false;\n  lastUpdate = 0;\n  \n  private signalBuffer: UniversalSignal[] = [];\n  private readonly BUFFER_SIZE = 1000;\n  \n  // Brainwave frequency ranges\n  private readonly BRAINWAVES: Record<BrainwaveState, { min: number; max: number }> = {\n    delta: { min: 0.5, max: 4 },   // Deep sleep\n    theta: { min: 4, max: 8 },     // Meditation, drowsy\n    alpha: { min: 8, max: 13 },    // Relaxed, calm\n    beta: { min: 13, max: 30 },    // Alert, focused\n    gamma: { min: 30, max: 100 },  // Peak performance\n  };\n\n  async initialize(): Promise<void> {\n    this.isActive = true;\n    this.lastUpdate = Date.now();\n    console.log('[BioAdapter] Initialized - Biological pattern recognition active');\n  }\n\n  processRawData(data: BioData): UniversalSignal {\n    const { heartRate, hrvMs, cortisol, melatonin, brainwaveHz, timestamp } = data;\n    \n    // Heart rate as base frequency (normalized)\n    const frequency = heartRate / 60; // Hz\n    \n    // HRV indicates system health/adaptability\n    const intensity = Math.min(hrvMs / 100, 1);\n    \n    // Stress-relaxation balance affects phase\n    const stressBalance = cortisol - melatonin;\n    const phase = (stressBalance + 1) * Math.PI;\n    \n    // Extract harmonics from bio signals\n    const harmonics = this.extractHarmonics(heartRate, hrvMs, cortisol, melatonin, brainwaveHz);\n    \n    const signal: UniversalSignal = {\n      domain: 'bio',\n      timestamp,\n      intensity,\n      frequency,\n      phase,\n      harmonics,\n      rawData: [heartRate, hrvMs, cortisol, melatonin, brainwaveHz],\n    };\n    \n    this.signalBuffer.push(signal);\n    if (this.signalBuffer.length > this.BUFFER_SIZE) {\n      this.signalBuffer.shift();\n    }\n    \n    this.lastUpdate = timestamp;\n    return signal;\n  }\n\n  extractSignature(signals: UniversalSignal[]): DomainSignature {\n    if (signals.length === 0) {\n      return this.getDefaultSignature();\n    }\n\n    const recentSignals = signals.slice(-100);\n    \n    // Calculate quadrant profile from biological state\n    const quadrantProfile = this.calculateQuadrantFromBio(recentSignals);\n    \n    // Temporal flow from circadian patterns\n    const temporalFlow = this.calculateTemporalFlow(recentSignals);\n    \n    // Calculate advanced metrics\n    const avgIntensity = recentSignals.reduce((sum, s) => sum + s.intensity, 0) / recentSignals.length;\n    const hrvVariance = this.calculateVariance(recentSignals.map(s => s.rawData[1]));\n    const dominantFreq = this.findDominantFrequency(recentSignals);\n    const harmonicRes = this.calculateHarmonicResonance(recentSignals);\n    const coherence = this.calculateHeartBrainCoherence(recentSignals);\n    \n    return {\n      domain: 'bio',\n      quadrantProfile,\n      temporalFlow,\n      intensity: avgIntensity,\n      momentum: this.calculateMomentum(recentSignals),\n      volatility: Math.sqrt(hrvVariance) / 50, // Normalize HRV variance\n      dominantFrequency: dominantFreq,\n      harmonicResonance: harmonicRes,\n      phaseAlignment: coherence,\n      extractedAt: Date.now(),\n    };\n  }\n\n  private extractHarmonics(hr: number, hrv: number, cortisol: number, melatonin: number, brainwave: number): number[] {\n    const hrNorm = hr / 100;\n    const hrvNorm = Math.min(hrv / 100, 1);\n    const brainNorm = brainwave / 50;\n    \n    return [\n      hrNorm,\n      hrvNorm,\n      cortisol,\n      melatonin,\n      brainNorm,\n      Math.sin(hrNorm * Math.PI) * hrvNorm,\n      Math.cos(brainNorm * Math.PI) * cortisol,\n      (1 - cortisol) * melatonin,\n    ];\n  }\n\n  private getBrainwaveState(hz: number): BrainwaveState {\n    if (hz < this.BRAINWAVES.delta.max) return 'delta';\n    if (hz < this.BRAINWAVES.theta.max) return 'theta';\n    if (hz < this.BRAINWAVES.alpha.max) return 'alpha';\n    if (hz < this.BRAINWAVES.beta.max) return 'beta';\n    return 'gamma';\n  }\n\n  private calculateQuadrantFromBio(signals: UniversalSignal[]): DomainSignature['quadrantProfile'] {\n    // Map biological state to quadrants\n    // High heart rate = aggressive (fight response)\n    // High HRV = defensive (adaptability)\n    // High cortisol = tactical (stress response)\n    // High brainwave coherence = strategic (peak performance)\n    \n    const avgHR = signals.reduce((sum, s) => sum + s.rawData[0], 0) / signals.length;\n    const avgHRV = signals.reduce((sum, s) => sum + s.rawData[1], 0) / signals.length;\n    const avgCortisol = signals.reduce((sum, s) => sum + s.rawData[2], 0) / signals.length;\n    const avgBrainwave = signals.reduce((sum, s) => sum + s.rawData[4], 0) / signals.length;\n    \n    // Normalize\n    const hrScore = Math.min((avgHR - 60) / 60, 1); // 60-120 BPM range\n    const hrvScore = Math.min(avgHRV / 80, 1);\n    const stressScore = avgCortisol;\n    const focusScore = Math.min(avgBrainwave / 30, 1); // Higher beta/gamma = focus\n    \n    const total = hrScore + hrvScore + stressScore + focusScore || 1;\n    \n    return {\n      aggressive: hrScore / total,\n      defensive: hrvScore / total,\n      tactical: stressScore / total,\n      strategic: focusScore / total,\n    };\n  }\n\n  private calculateTemporalFlow(signals: UniversalSignal[]): DomainSignature['temporalFlow'] {\n    const len = signals.length;\n    const third = Math.floor(len / 3);\n    \n    const earlyHRV = signals.slice(0, third).reduce((sum, s) => sum + s.rawData[1], 0) / third || 0;\n    const midHRV = signals.slice(third, 2 * third).reduce((sum, s) => sum + s.rawData[1], 0) / third || 0;\n    const lateHRV = signals.slice(2 * third).reduce((sum, s) => sum + s.rawData[1], 0) / third || 0;\n    \n    const total = earlyHRV + midHRV + lateHRV || 1;\n    \n    return {\n      early: earlyHRV / total,\n      mid: midHRV / total,\n      late: lateHRV / total,\n    };\n  }\n\n  private calculateVariance(values: number[]): number {\n    if (values.length === 0) return 0;\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n  }\n\n  private calculateHeartBrainCoherence(signals: UniversalSignal[]): number {\n    // Measure correlation between heart rate and brainwave patterns\n    if (signals.length < 10) return 0.5;\n    \n    const hrValues = signals.map(s => s.rawData[0]);\n    const brainValues = signals.map(s => s.rawData[4]);\n    \n    const hrMean = hrValues.reduce((a, b) => a + b, 0) / hrValues.length;\n    const brainMean = brainValues.reduce((a, b) => a + b, 0) / brainValues.length;\n    \n    let numerator = 0;\n    let hrDenom = 0;\n    let brainDenom = 0;\n    \n    for (let i = 0; i < signals.length; i++) {\n      const hrDiff = hrValues[i] - hrMean;\n      const brainDiff = brainValues[i] - brainMean;\n      numerator += hrDiff * brainDiff;\n      hrDenom += hrDiff * hrDiff;\n      brainDenom += brainDiff * brainDiff;\n    }\n    \n    const denom = Math.sqrt(hrDenom * brainDenom);\n    const correlation = denom > 0 ? numerator / denom : 0;\n    \n    return (correlation + 1) / 2; // Normalize to 0-1\n  }\n\n  private findDominantFrequency(signals: UniversalSignal[]): number {\n    const freqBuckets = new Map<number, number>();\n    \n    signals.forEach(s => {\n      const bucket = Math.round(s.frequency * 10) / 10;\n      freqBuckets.set(bucket, (freqBuckets.get(bucket) || 0) + s.intensity);\n    });\n    \n    let maxBucket = 1;\n    let maxValue = 0;\n    freqBuckets.forEach((value, bucket) => {\n      if (value > maxValue) {\n        maxValue = value;\n        maxBucket = bucket;\n      }\n    });\n    \n    return maxBucket;\n  }\n\n  private calculateHarmonicResonance(signals: UniversalSignal[]): number {\n    if (signals.length < 2) return 0;\n    \n    let resonanceSum = 0;\n    for (let i = 1; i < signals.length; i++) {\n      const h1 = signals[i].harmonics;\n      const h2 = signals[i - 1].harmonics;\n      \n      let dotProduct = 0;\n      let mag1 = 0;\n      let mag2 = 0;\n      \n      for (let j = 0; j < h1.length; j++) {\n        dotProduct += h1[j] * h2[j];\n        mag1 += h1[j] * h1[j];\n        mag2 += h2[j] * h2[j];\n      }\n      \n      const denom = Math.sqrt(mag1) * Math.sqrt(mag2);\n      const cosineSim = denom > 0 ? dotProduct / denom : 0;\n      resonanceSum += (cosineSim + 1) / 2;\n    }\n    \n    return resonanceSum / (signals.length - 1);\n  }\n\n  private calculateMomentum(signals: UniversalSignal[]): number {\n    if (signals.length < 10) return 0;\n    \n    const recent = signals.slice(-10);\n    const older = signals.slice(-20, -10);\n    \n    const recentAvg = recent.reduce((sum, s) => sum + s.intensity, 0) / recent.length;\n    const olderAvg = older.length > 0 \n      ? older.reduce((sum, s) => sum + s.intensity, 0) / older.length \n      : recentAvg;\n    \n    return (recentAvg - olderAvg) / (olderAvg || 1);\n  }\n\n  private getDefaultSignature(): DomainSignature {\n    return {\n      domain: 'bio',\n      quadrantProfile: { aggressive: 0.25, defensive: 0.25, tactical: 0.25, strategic: 0.25 },\n      temporalFlow: { early: 0.33, mid: 0.34, late: 0.33 },\n      intensity: 0.5,\n      momentum: 0,\n      volatility: 0,\n      dominantFrequency: 1.2,\n      harmonicResonance: 0.5,\n      phaseAlignment: 0.5,\n      extractedAt: Date.now(),\n    };\n  }\n\n  // Generate bio signal correlated with market stress\n  generateMarketCorrelatedSignal(marketVolatility: number, marketDirection: number): BioData {\n    // Market volatility increases stress response\n    const baseHR = 70;\n    const heartRate = baseHR + (marketVolatility * 40); // Higher volatility = higher HR\n    \n    // HRV decreases under stress\n    const hrvMs = 80 - (marketVolatility * 60);\n    \n    // Cortisol rises with market uncertainty\n    const cortisol = 0.3 + (marketVolatility * 0.6);\n    \n    // Melatonin inversely related to stress\n    const melatonin = Math.max(0.1, 0.7 - (marketVolatility * 0.5));\n    \n    // Brainwave shifts with market direction\n    // Positive market = alpha/beta (calm focus)\n    // Negative market = beta/gamma (stress/hyper-focus)\n    const brainwaveHz = 12 + (marketVolatility * 20) + (marketDirection < 0 ? 5 : -3);\n    \n    return {\n      heartRate: Math.max(50, Math.min(150, heartRate)),\n      hrvMs: Math.max(10, Math.min(100, hrvMs)),\n      cortisol: Math.max(0, Math.min(1, cortisol)),\n      melatonin: Math.max(0, Math.min(1, melatonin)),\n      brainwaveHz: Math.max(0.5, Math.min(50, brainwaveHz)),\n      timestamp: Date.now(),\n    };\n  }\n}\n\nexport const bioAdapter = new BioDomainAdapter();\nexport type { BioData };\n";export{n as default};
