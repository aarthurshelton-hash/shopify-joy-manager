const e="import React, { useMemo } from 'react';\nimport { SquareData, SquareVisit } from '@/lib/chess/gameSimulator';\nimport { boardColors, getPieceColor, PieceType, PieceColor } from '@/lib/chess/pieceColors';\nimport { useLegendHighlight, HighlightedPiece, HoveredMoveInfo } from '@/contexts/LegendHighlightContext';\nimport { useEnPensentPatterns } from '@/hooks/useEnPensentPatterns';\nimport { TemporalSignature } from '@/lib/pensent-core/types/core';\n\ninterface ChessBoardVisualizationProps {\n  board: SquareData[][];\n  size?: number;\n  overrideHighlightedPieces?: HighlightedPiece[];\n  overrideCompareMode?: boolean;\n  signature?: TemporalSignature | null;\n}\n\nfunction getVisitColor(visit: SquareVisit): string {\n  return getPieceColor(visit.piece, visit.color);\n}\n\nfunction visitMatchesAnyHighlight(visit: SquareVisit, highlights: HighlightedPiece[]): boolean {\n  if (highlights.length === 0) return true;\n  return highlights.some(h => visit.piece === h.pieceType && visit.color === h.pieceColor);\n}\n\nfunction getMatchingHighlightIndex(visit: SquareVisit, highlights: HighlightedPiece[]): number {\n  return highlights.findIndex(h => visit.piece === h.pieceType && visit.color === h.pieceColor);\n}\n\nfunction getQuadrantForSquare(file: number, rank: number): 'q1' | 'q2' | 'q3' | 'q4' {\n  if (file < 4) return rank >= 4 ? 'q1' : 'q3';\n  return rank >= 4 ? 'q2' : 'q4';\n}\n\nconst renderNestedSquares = (\n  visits: SquareVisit[],\n  x: number,\n  y: number,\n  squareSize: number,\n  baseColor: string,\n  highlightedPieces: HighlightedPiece[],\n  compareMode: boolean,\n  hoveredMove: HoveredMoveInfo | null,\n  squareName: string,\n  enPensentGlow?: { color: string; intensity: number }\n): React.ReactNode[] => {\n  const elements: React.ReactNode[] = [];\n  const padding = squareSize * 0.08;\n  \n  const hasHighlight = highlightedPieces.length > 0;\n  const isHoveredMoveTarget = hoveredMove?.targetSquare === squareName;\n  const hoveredMoveMatchingVisits = hoveredMove \n    ? visits.filter(v => v.piece === hoveredMove.piece.pieceType && v.color === hoveredMove.piece.pieceColor)\n    : [];\n  const hasHoveredMoveVisit = hoveredMoveMatchingVisits.length > 0;\n  const matchingVisits = hasHighlight \n    ? visits.filter(v => visitMatchesAnyHighlight(v, highlightedPieces))\n    : visits;\n  const hasMatchingVisit = matchingVisits.length > 0;\n  \n  const piece1Present = highlightedPieces.length > 0 && visits.some(\n    v => v.piece === highlightedPieces[0].pieceType && v.color === highlightedPieces[0].pieceColor\n  );\n  const piece2Present = highlightedPieces.length > 1 && visits.some(\n    v => v.piece === highlightedPieces[1].pieceType && v.color === highlightedPieces[1].pieceColor\n  );\n  const isOverlap = piece1Present && piece2Present;\n  \n  const shouldDim = (hasHighlight && !hasMatchingVisit) || (hoveredMove && !hasHoveredMoveVisit && !isHoveredMoveTarget);\n  \n  // En Pensent quadrant glow effect\n  if (enPensentGlow && enPensentGlow.intensity > 0.1) {\n    elements.push(\n      <rect\n        key={`pensent-glow-${x}-${y}`}\n        x={x}\n        y={y}\n        width={squareSize}\n        height={squareSize}\n        fill={enPensentGlow.color}\n        opacity={enPensentGlow.intensity * 0.1}\n        style={{ transition: 'opacity 0.3s ease-out' }}\n      />\n    );\n  }\n  \n  elements.push(\n    <rect\n      key={`base-${x}-${y}`}\n      x={x}\n      y={y}\n      width={squareSize}\n      height={squareSize}\n      fill={baseColor}\n      style={{\n        opacity: shouldDim ? 0.3 : 1,\n        transition: 'opacity 0.2s ease-out',\n      }}\n    />\n  );\n  \n  if (visits.length === 0) return elements;\n  \n  const uniqueColors: { color: string; matches: boolean; highlightIndex: number }[] = [];\n  for (const visit of visits) {\n    const color = getVisitColor(visit);\n    const highlightIndex = getMatchingHighlightIndex(visit, highlightedPieces);\n    const matches = !hasHighlight || highlightIndex !== -1;\n    const existingIndex = uniqueColors.findIndex(uc => uc.color === color);\n    if (existingIndex === -1) {\n      uniqueColors.push({ color, matches, highlightIndex });\n    } else if (matches) {\n      uniqueColors[existingIndex].matches = true;\n      if (highlightIndex !== -1) uniqueColors[existingIndex].highlightIndex = highlightIndex;\n    }\n  }\n  \n  const maxNesting = Math.min(uniqueColors.length, 6);\n  const layers: { color: string; layerSize: number; matches: boolean; highlightIndex: number }[] = [];\n  \n  let currentSize = squareSize - padding * 2;\n  const sizeReduction = (currentSize * 0.7) / maxNesting;\n  \n  for (let i = 0; i < maxNesting; i++) {\n    layers.push({\n      color: uniqueColors[i].color,\n      layerSize: currentSize,\n      matches: uniqueColors[i].matches,\n      highlightIndex: uniqueColors[i].highlightIndex,\n    });\n    currentSize -= sizeReduction;\n    if (currentSize < squareSize * 0.1) break;\n  }\n  \n  for (let i = 0; i < layers.length; i++) {\n    const layer = layers[i];\n    const offset = (squareSize - layer.layerSize) / 2;\n    const opacity = hasHighlight ? (layer.matches ? 1 : 0.15) : 1;\n    \n    elements.push(\n      <rect\n        key={`layer-${x}-${y}-${i}`}\n        x={x + offset}\n        y={y + offset}\n        width={layer.layerSize}\n        height={layer.layerSize}\n        fill={layer.color}\n        style={{ opacity, transition: 'opacity 0.2s ease-out' }}\n      />\n    );\n  }\n  \n  // Highlight effects (existing logic preserved)\n  if (hasHighlight && hasMatchingVisit) {\n    const glowSize = squareSize * 0.02;\n    if (compareMode && highlightedPieces.length === 2) {\n      if (isOverlap) {\n        elements.push(<rect key={`glow-overlap-${x}-${y}`} x={x + glowSize} y={y + glowSize} width={squareSize - glowSize * 2} height={squareSize - glowSize * 2} fill=\"none\" stroke=\"rgba(168, 85, 247, 0.8)\" strokeWidth={glowSize * 2} />);\n      } else if (piece1Present) {\n        elements.push(<rect key={`glow-p1-${x}-${y}`} x={x + glowSize} y={y + glowSize} width={squareSize - glowSize * 2} height={squareSize - glowSize * 2} fill=\"none\" stroke=\"rgba(56, 189, 248, 0.6)\" strokeWidth={glowSize * 1.5} />);\n      } else if (piece2Present) {\n        elements.push(<rect key={`glow-p2-${x}-${y}`} x={x + glowSize} y={y + glowSize} width={squareSize - glowSize * 2} height={squareSize - glowSize * 2} fill=\"none\" stroke=\"rgba(251, 113, 133, 0.6)\" strokeWidth={glowSize * 1.5} />);\n      }\n    } else {\n      elements.push(<rect key={`glow-${x}-${y}`} x={x + glowSize} y={y + glowSize} width={squareSize - glowSize * 2} height={squareSize - glowSize * 2} fill=\"none\" stroke=\"rgba(255,255,255,0.6)\" strokeWidth={glowSize} />);\n    }\n  }\n  \n  if (hoveredMove && (isHoveredMoveTarget || hasHoveredMoveVisit)) {\n    const glowSize = squareSize * 0.025;\n    if (isHoveredMoveTarget) {\n      elements.push(<rect key={`glow-move-target-${x}-${y}`} x={x + glowSize} y={y + glowSize} width={squareSize - glowSize * 2} height={squareSize - glowSize * 2} fill=\"none\" stroke=\"rgba(251, 191, 36, 0.9)\" strokeWidth={glowSize * 2} />);\n    } else {\n      elements.push(<rect key={`glow-move-piece-${x}-${y}`} x={x + glowSize} y={y + glowSize} width={squareSize - glowSize * 2} height={squareSize - glowSize * 2} fill=\"none\" stroke=\"rgba(251, 191, 36, 0.4)\" strokeWidth={glowSize} />);\n    }\n  }\n  \n  return elements;\n};\n\nconst ChessBoardVisualization: React.FC<ChessBoardVisualizationProps> = ({\n  board,\n  size = 500,\n  overrideHighlightedPieces,\n  overrideCompareMode,\n  signature\n}) => {\n  const pattern = useEnPensentPatterns(signature);\n  \n  // Try to get context - this is safe as hooks are always called\n  let contextData: { highlightedPiece: HighlightedPiece | null; lockedPieces: HighlightedPiece[]; compareMode: boolean; hoveredMove: HoveredMoveInfo | null } | null = null;\n  try {\n    contextData = useLegendHighlight();\n  } catch { /* Context not available */ }\n  \n  const highlightedPieces: HighlightedPiece[] = overrideHighlightedPieces || \n    (contextData?.lockedPieces.length ? contextData.lockedPieces : \n     contextData?.highlightedPiece ? [contextData.highlightedPiece] : []);\n  const compareMode = overrideCompareMode ?? contextData?.compareMode ?? false;\n  const hoveredMove = contextData?.hoveredMove ?? null;\n  const squareSize = size / 8;\n  const borderWidth = size * 0.02;\n  const totalSize = size + borderWidth * 2;\n  \n  const getSquareName = (file: number, rank: number): string => {\n    const files = 'abcdefgh';\n    return `${files[file]}${rank + 1}`;\n  };\n  \n  const boardElements = useMemo(() => {\n    return [...Array(8)].map((_, rowIndex) => {\n      const rank = 7 - rowIndex;\n      return [...Array(8)].map((_, file) => {\n        const square = board[rank][file];\n        const baseColor = square.isLight ? boardColors.light : boardColors.dark;\n        const x = borderWidth + file * squareSize;\n        const y = borderWidth + rowIndex * squareSize;\n        const squareName = getSquareName(file, rank);\n        \n        // En Pensent quadrant-based glow\n        const quadrant = getQuadrantForSquare(file, rank);\n        const quadrantIntensity = signature ? (pattern.quadrantWeights[quadrant] || 0) : 0;\n        const enPensentGlow = signature ? {\n          color: pattern.dominantColor,\n          intensity: quadrantIntensity * pattern.intensity\n        } : undefined;\n        \n        return renderNestedSquares(\n          square.visits,\n          x, y,\n          squareSize,\n          baseColor,\n          highlightedPieces,\n          compareMode,\n          hoveredMove,\n          squareName,\n          enPensentGlow\n        );\n      });\n    });\n  }, [board, borderWidth, squareSize, highlightedPieces, compareMode, hoveredMove, signature, pattern]);\n  \n  return (\n    <svg\n      width={totalSize}\n      height={totalSize}\n      viewBox={`0 0 ${totalSize} ${totalSize}`}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      style={{ display: 'block' }}\n    >\n      {/* Border with En Pensent accent */}\n      <rect\n        x={0}\n        y={0}\n        width={totalSize}\n        height={totalSize}\n        fill={signature ? pattern.dominantColor : boardColors.border}\n        opacity={signature ? 0.9 : 1}\n      />\n      \n      {/* Inner border */}\n      <rect\n        x={borderWidth * 0.5}\n        y={borderWidth * 0.5}\n        width={totalSize - borderWidth}\n        height={totalSize - borderWidth}\n        fill={boardColors.border}\n      />\n      \n      {boardElements}\n      \n      {/* En Pensent archetype watermark */}\n      {signature && (\n        <text\n          x={totalSize - borderWidth}\n          y={totalSize - 4}\n          textAnchor=\"end\"\n          fontSize={8}\n          fill={pattern.dominantColor}\n          opacity={0.3}\n          fontFamily=\"monospace\"\n        >\n          {pattern.archetype}\n        </text>\n      )}\n    </svg>\n  );\n};\n\nexport default ChessBoardVisualization;\n";export{e as default};
