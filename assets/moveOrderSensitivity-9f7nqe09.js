const e="/**\n * Move Order Sensitivity - v7.53-ACCURACY\n * \n * Analyzes move sequences for cascade effects (Grotthuss-style).\n * The order of moves matters as much as the moves themselves.\n */\n\nexport interface MoveSequence {\n  moves: string[];\n  timestamps?: number[];\n  evaluations?: number[];\n}\n\nexport interface SequencePattern {\n  id: string;\n  name: string;\n  signature: string[];  // Move type sequence\n  predictiveValue: number;\n  typicalOutcome: 'white_advantage' | 'black_advantage' | 'dynamic_equality';\n}\n\n/**\n * Common strategic sequences that predict outcomes\n */\nexport const STRATEGIC_SEQUENCES: SequencePattern[] = [\n  {\n    id: 'cascade_attack',\n    name: 'Cascade Attack',\n    signature: ['check', 'capture', 'threat', 'capture'],\n    predictiveValue: 0.85,\n    typicalOutcome: 'white_advantage',\n  },\n  {\n    id: 'prophylactic_chain',\n    name: 'Prophylactic Chain',\n    signature: ['quiet', 'quiet', 'quiet', 'threat'],\n    predictiveValue: 0.75,\n    typicalOutcome: 'dynamic_equality',\n  },\n  {\n    id: 'pawn_storm',\n    name: 'Pawn Storm Cascade',\n    signature: ['pawn', 'pawn', 'pawn', 'piece'],\n    predictiveValue: 0.7,\n    typicalOutcome: 'white_advantage',\n  },\n  {\n    id: 'exchange_sequence',\n    name: 'Simplification Cascade',\n    signature: ['capture', 'capture', 'capture', 'quiet'],\n    predictiveValue: 0.65,\n    typicalOutcome: 'dynamic_equality',\n  },\n  {\n    id: 'pressure_buildup',\n    name: 'Pressure Buildup',\n    signature: ['piece', 'piece', 'threat', 'threat'],\n    predictiveValue: 0.8,\n    typicalOutcome: 'white_advantage',\n  },\n];\n\n/**\n * Classify a move into a type for sequence analysis\n */\nexport function classifyMove(move: string, isCapture: boolean, isCheck: boolean): string {\n  if (isCheck) return 'check';\n  if (isCapture) return 'capture';\n  \n  // Pawn moves\n  if (move.match(/^[a-h]/)) return 'pawn';\n  \n  // Check for threat indicators (simplified)\n  if (move.includes('+') || move.includes('#')) return 'threat';\n  \n  // Piece development\n  if (move.match(/^[NBRQK]/)) return 'piece';\n  \n  return 'quiet';\n}\n\n/**\n * Extract move type sequence from a list of moves\n */\nexport function extractMoveTypeSequence(\n  moves: string[],\n  captureFlags: boolean[],\n  checkFlags: boolean[]\n): string[] {\n  return moves.map((move, i) => \n    classifyMove(move, captureFlags[i] || false, checkFlags[i] || false)\n  );\n}\n\n/**\n * Calculate similarity between two sequences\n */\nexport function sequenceSimilarity(seq1: string[], seq2: string[]): number {\n  const minLen = Math.min(seq1.length, seq2.length);\n  if (minLen === 0) return 0;\n  \n  let matches = 0;\n  for (let i = 0; i < minLen; i++) {\n    if (seq1[i] === seq2[i]) matches++;\n  }\n  \n  return matches / minLen;\n}\n\n/**\n * Find matching strategic sequences\n */\nexport function findMatchingSequences(\n  moveSequence: string[],\n  windowSize: number = 4\n): { pattern: SequencePattern; similarity: number; position: number }[] {\n  const matches: { pattern: SequencePattern; similarity: number; position: number }[] = [];\n  \n  // Slide window through the move sequence\n  for (let i = 0; i <= moveSequence.length - windowSize; i++) {\n    const window = moveSequence.slice(i, i + windowSize);\n    \n    for (const pattern of STRATEGIC_SEQUENCES) {\n      const similarity = sequenceSimilarity(window, pattern.signature);\n      if (similarity >= 0.5) {\n        matches.push({ pattern, similarity, position: i });\n      }\n    }\n  }\n  \n  // Sort by similarity\n  return matches.sort((a, b) => b.similarity - a.similarity);\n}\n\n/**\n * Calculate momentum from move sequence\n * Captures vs quiet moves ratio indicates attacking intent\n */\nexport function calculateSequenceMomentum(moveTypes: string[]): number {\n  if (moveTypes.length === 0) return 0;\n  \n  const weights: Record<string, number> = {\n    check: 1.0,\n    capture: 0.7,\n    threat: 0.6,\n    pawn: 0.3,\n    piece: 0.2,\n    quiet: -0.1,\n  };\n  \n  let momentum = 0;\n  let decayFactor = 1;\n  \n  // Recent moves weighted more heavily\n  for (let i = moveTypes.length - 1; i >= 0; i--) {\n    const moveType = moveTypes[i];\n    momentum += (weights[moveType] || 0) * decayFactor;\n    decayFactor *= 0.85; // Decay for older moves\n  }\n  \n  // Normalize to -1 to 1\n  return Math.max(-1, Math.min(1, momentum / moveTypes.length));\n}\n\n/**\n * Detect cascade patterns (Grotthuss-style propagation)\n */\nexport function detectCascade(\n  evaluations: number[],\n  threshold: number = 50\n): { hasCascade: boolean; direction: 'positive' | 'negative' | 'none'; magnitude: number } {\n  if (evaluations.length < 3) {\n    return { hasCascade: false, direction: 'none', magnitude: 0 };\n  }\n  \n  // Calculate consecutive changes\n  const changes: number[] = [];\n  for (let i = 1; i < evaluations.length; i++) {\n    changes.push(evaluations[i] - evaluations[i - 1]);\n  }\n  \n  // Look for consistent direction with increasing magnitude\n  let positiveStreak = 0;\n  let negativeStreak = 0;\n  let maxMagnitude = 0;\n  \n  for (const change of changes) {\n    if (change > threshold) {\n      positiveStreak++;\n      negativeStreak = 0;\n      maxMagnitude = Math.max(maxMagnitude, change);\n    } else if (change < -threshold) {\n      negativeStreak++;\n      positiveStreak = 0;\n      maxMagnitude = Math.max(maxMagnitude, Math.abs(change));\n    } else {\n      positiveStreak = 0;\n      negativeStreak = 0;\n    }\n  }\n  \n  if (positiveStreak >= 2) {\n    return { hasCascade: true, direction: 'positive', magnitude: maxMagnitude };\n  }\n  if (negativeStreak >= 2) {\n    return { hasCascade: true, direction: 'negative', magnitude: maxMagnitude };\n  }\n  \n  return { hasCascade: false, direction: 'none', magnitude: 0 };\n}\n";export{e as default};
